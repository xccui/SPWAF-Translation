<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.1.5_3_10490" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>"INSERT INTO Temperatures (sensor, temp) VALUES (?, ?)") updateStmt = conn.prepareStatement(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045248Z" creationid="xccui" creationdate="20190714T045248Z">
        <seg>"INSERT INTO Temperatures (sensor, temp) VALUES (?, ?)") updateStmt = conn.prepareStatement(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"INSERT INTO example.sensors(sensorId, temperature) VALUES (?, ?);")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210821Z" creationid="xccui" creationdate="20190711T210821Z">
        <seg>"INSERT INTO example.sensors(sensorId, temperature) VALUES (?, ?);")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"UPDATE Temperatures SET temp = ?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045251Z" creationid="xccui" creationdate="20190714T045251Z">
        <seg>"UPDATE Temperatures SET temp = ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"WriteAheadSink", new SocketWriteAheadSink)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064237Z" creationid="xccui" creationdate="20190715T064237Z">
        <seg>"WriteAheadSink", new SocketWriteAheadSink)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"flink-version":"1.7.1", "flink-commit":"89eafb4"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T042114Z" creationid="xccui" creationdate="20190729T042114Z">
        <seg>"flink-version":"1.7.1", "flink-commit":"89eafb4"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"maxTemperature", key, Types.STRING,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041618Z" creationid="xccui" creationdate="20190707T041618Z">
        <seg>"maxTemperature", key, Types.STRING,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"operation":{"location":"file:///savepoints/savepoint-e99cdb-34410597dec0"}}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T193633Z" creationid="xccui" creationdate="20190729T193633Z">
        <seg>"operation":{"location":"file:///savepoints/savepoint-e99cdb-34410597dec0"}}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"path/to/jarFile.jar") // JAR file to ship to the JobManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045648Z" creationid="xccui" creationdate="20190612T045648Z">
        <seg>"path/to/jarFile.jar") // 需要传输到JobManager的JAR包</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"taskmanagers":2, "slots-total":8, "slots-available":6, "jobs-running":1, "jobs-finished":2, "jobs-cancelled":1, "jobs-failed":0,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T042110Z" creationid="xccui" creationdate="20190729T042110Z">
        <seg>"taskmanagers":2, "slots-total":8, "slots-available":6, "jobs-running":1, "jobs-finished":2, "jobs-cancelled":1, "jobs-failed":0,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"thresholds", classOf[String], classOf[Double])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041352Z" creationid="xccui" creationdate="20190702T041352Z">
        <seg>"thresholds", classOf[String], classOf[Double])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"topic",</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T144756Z" creationid="xingcan" creationdate="20190709T144756Z">
        <seg>"topic",</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Binary metadata file of a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T020604Z" creationid="xccui" creationdate="20190726T020604Z">
        <seg># 某一保存点的二进制元数据文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Checkpointed operator states</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T021251Z" creationid="xccui" creationdate="20190726T021251Z">
        <seg># 存储的算子状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Isolates Flink from other frameworks using the ZooKeeper cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T205022Z" creationid="xccui" creationdate="20190720T204951Z">
        <seg># 将Flink和其他使用ZooKeeper集群的框架进行隔离。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Isolates multiple Flink clusters from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T051004Z" creationid="xccui" creationdate="20190721T051004Z">
        <seg># 将多个Flink集群相互隔离。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Must be less or equal to the configured maximum number of attempts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052916Z" creationid="xccui" creationdate="20190721T052916Z">
        <seg># 该值必须小于或等于配置的最大尝试次数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Path of a particular savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T020544Z" creationid="xccui" creationdate="20190726T020508Z">
        <seg># 某一具体保存点的路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># RECOMMENDED: set the base path for all Flink clusters in ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T205006Z" creationid="xccui" creationdate="20190720T204920Z">
        <seg># 建议参数：在ZooKeeper中为全部Flink集群设置基础路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># RECOMMENDED: set the path for the Flink cluster in ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T050950Z" creationid="xccui" creationdate="20190721T050950Z">
        <seg># 建议参数：在ZooKeeper中为Flink集群设置路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># REQUIRED: enable HA mode via ZooKeeper high-availability: zookeeper</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T203841Z" creationid="xccui" creationdate="20190720T203841Z">
        <seg># 必填参数：通过ZooKeeper开启HA模式 high-availability: zookeeper</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># REQUIRED: provide a list of all ZooKeeper servers of the quorum high-availability.zookeeper.quorum: address1:2181[,...],addressX:2181</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T204357Z" creationid="xccui" creationdate="20190720T204348Z">
        <seg># 必填参数：提供ZooKeeper Quorum的服务器列表 high-availability.zookeeper.quorum: address1:2181[,...],addressX:2181</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># REQUIRED: set storage location for job metadata in remote storage high-availability.storageDir: hdfs:///flink/recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T204512Z" creationid="xccui" creationdate="20190720T204512Z">
        <seg># 必填参数：设置作业元数据的远程存储位置 high-availability.storageDir: hdfs:///flink/recovery</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Restart an application at most 3 times (+ the initial start).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052826Z" creationid="xccui" creationdate="20190721T052826Z">
        <seg># 应用最多重启3次（包括首次启动）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Savepoint root path</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T020445Z" creationid="xccui" creationdate="20190726T020445Z">
        <seg># 保存点根路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># The cluster id is required to look up the metadata of a failed cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T051140Z" creationid="xccui" creationdate="20190721T051109Z">
        <seg># 集群ID是查找故障集群元数据的必要信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#OnTimerContext, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032607Z" creationid="xccui" creationdate="20190622T032607Z">
        <seg>#OnTimerContext, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/flink run \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040000Z" creationid="xccui" creationdate="20190329T040000Z">
        <seg>$ ./bin/flink run \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/start-cluster.sh</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045745Z" creationid="xccui" creationdate="20190329T045745Z">
        <seg>$ ./bin/start-cluster.sh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/start-cluster.sh Starting cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123207Z" creationid="xccui" creationdate="20190605T123146Z">
        <seg>$ ./bin/start-cluster.sh Starting cluster.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/stop-cluster.sh</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041911Z" creationid="xccui" creationdate="20190329T041911Z">
        <seg>$ ./bin/stop-cluster.sh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ cd flink-1.7.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025034Z" creationid="xccui" creationdate="20190329T025034Z">
        <seg>$ cd flink-1.7.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ tail -f ./log/flink-&lt;user&gt;-taskexecutor-&lt;n&gt;-&lt;hostname&gt;.out</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041713Z" creationid="xccui" creationdate="20190329T041713Z">
        <seg>$ tail -f ./log/flink-&lt;user&gt;-taskexecutor-&lt;n&gt;-&lt;hostname&gt;.out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ tar xvfz flink-1.7.1-bin-scala_2.12.tgz</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024954Z" creationid="xccui" creationdate="20190329T024954Z">
        <seg>$ tar xvfz flink-1.7.1-bin-scala_2.12.tgz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ wget https://streaming-with-flink.github.io/\ examples/download/examples-scala.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123520Z" creationid="xccui" creationdate="20190605T123520Z">
        <seg>$ wget https://streaming-with-flink.github.io/\ examples/download/examples-scala.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ wget https://streaming-with-flink.github.io/examples/download/examples-scala.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035706Z" creationid="xccui" creationdate="20190329T035706Z">
        <seg>$ wget https://streaming-with-flink.github.io/examples/download/examples-scala.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>${FLINK_IMAGE_NAME}: The name of the job-specific image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T044035Z" creationid="xccui" creationdate="20190730T044035Z">
        <seg>${FLINK_IMAGE_NAME}：特定作业镜像的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>${FLINK_JOB_PARALLELISM}: The degree of parallelism for the job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T035554Z" creationid="xccui" creationdate="20190730T035554Z">
        <seg>${FLINK_JOB_PARALLELISM}：作业的并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>${FLINK_JOB}: The main class of the job to start.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T044105Z" creationid="xccui" creationdate="20190730T044105Z">
        <seg>${FLINK_JOB}：用于启动作业的主类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>("Sarah", 23))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T071033Z" creationid="xccui" creationdate="20190616T071033Z">
        <seg>("Sarah", 23))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>("sensor_2", 10 * 1000L), // forward sensor_2 for 10 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T014254Z" creationid="xccui" creationdate="20190622T031629Z">
        <seg>("sensor_2", 10 * 1000L), // sensor_2转发10秒</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>("sensor_7", 60 * 1000L)) // forward sensor_7 for 1 minute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T014248Z" creationid="xccui" creationdate="20190622T031639Z">
        <seg>("sensor_7", 60 * 1000L)) // sensor_7转发1分钟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(List((r.id, r.temperature, tempDiff)), Some(r.temperature))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023256Z" creationid="xccui" creationdate="20190701T023256Z">
        <seg>(List((r.id, r.temperature, tempDiff)), Some(r.temperature))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(List.empty, Some(in.temperature))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023138Z" creationid="xccui" creationdate="20190701T023138Z">
        <seg>(List.empty, Some(in.temperature))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(List.empty, Some(r.temperature))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023336Z" creationid="xccui" creationdate="20190701T023336Z">
        <seg>(List.empty, Some(r.temperature))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(List.fill(mod)(new java.lang.Long(div + 1)) ++</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062849Z" creationid="xccui" creationdate="20190701T062849Z">
        <seg>(List.fill(mod)(new java.lang.Long(div + 1)) ++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See “Defining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T031713Z" creationid="xccui" creationdate="20190729T031713Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See “Modifying the State of an Operator”.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T054644Z" creationid="xccui" creationdate="20190727T054644Z">
        <seg>（见"修改算子的状态"一节。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(TumblingEventTimeWindows.of(size)) or for window.(TumblingProcessing TimeWindows.of(size)) depending on the configured time characteristic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T051459Z" creationid="xccui" creationdate="20190623T051459Z">
        <seg>具体调用那个方法取决于配置的时间特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(enabled by default) and limit the size of state (5 MB by default):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022635Z" creationid="xccui" creationdate="20190801T022615Z">
        <seg>可以通过接收参数来决定是否开启异步检查点（默认开启）及限制状态大小（默认5MB）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(enabled by default):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022826Z" creationid="xccui" creationdate="20190801T022826Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(for (i &lt;- 0 until numSensors) yield "sensor_" + (i + 1))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040221Z" creationid="xccui" creationdate="20190707T040221Z">
        <seg>(for (i &lt;- 0 until numSensors) yield "sensor_" + (i + 1))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(fs.&lt;scheme&gt;.limit.timeout) and how long to wait until an idle connection is closed (fs.&lt;scheme&gt;.limit.stream-timeout).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T050647Z" creationid="xccui" creationdate="20190722T050647Z">
        <seg>超时参数可用来控制连接请求失败前的等待时间（fs.&lt;schema&gt;.limit.timeout）以及空闲连接关闭的等待时间（fs.&lt;scheme&gt;.limit.stream-timeout）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(more on this in “Checkpoints, Savepoints, and State Recovery” on page 58), RocksDBStateBackend is a good choice for applications with very large state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T024258Z" creationid="xccui" creationdate="20190704T024258Z">
        <seg>所以对于状态非常大的应用是一个很好的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(r1: (String, Double, Double), r2: (String, Double, Double)) =&gt; { (r1._1, r1._2.min(r2._2), r1._3.max(r2._3))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043611Z" creationid="xccui" creationdate="20190625T043611Z">
        <seg>(r1: (String, Double, Double), r2: (String, Double, Double)) =&gt; { (r1._1, r1._2.min(r2._2), r1._3.max(r2._3))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(temporary inconsistencies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170412Z" creationid="xccui" creationdate="20190708T170207Z">
        <seg>（故障恢复过程中会有临时性不一致）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031643Z" creationid="xccui" creationdate="20190622T031643Z">
        <seg>)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154515Z" creationid="xingcan" creationdate="20190801T154515Z">
        <seg>))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210053Z" creationid="xccui" creationdate="20190711T210053Z">
        <seg>);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* first results and updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T033955Z" creationid="xccui" creationdate="20190629T033913Z">
        <seg>* 会区分首次结果和后续更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* monotonically increases for 1 second (in processing time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071249Z" creationid="xccui" creationdate="20190621T071249Z">
        <seg>* 则发出警告。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* re-directs them to a side output */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155826Z" creationid="xingcan" creationdate="20190628T155754Z">
        <seg>* 并将其重定向到副输出的ProcessFunction */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* to the target directory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042003Z" creationid="xccui" creationdate="20190716T042003Z">
        <seg>* 来提交事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* with a temperature below 32F.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T203306Z" creationid="xccui" creationdate="20190622T023641Z">
        <seg>* 向副输出发送冻结警报。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041304Z" creationid="xccui" creationdate="20190716T041304Z">
        <seg>* 临时文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071254Z" creationid="xccui" creationdate="20190621T071254Z">
        <seg>*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*/ override def preCommit(transaction: String): Unit = { transactionWriter.flush()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041857Z" creationid="xccui" creationdate="20190716T041857Z">
        <seg>*/ override def preCommit(transaction: String): Unit = { transactionWriter.flush()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>------------------ Running/Restarting Jobs ------------------- 17.10.2018 21:13:14 : bc0b2ad61ecd4a615d92ce25390f61ad :</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033025Z" creationid="xccui" creationdate="20190726T033025Z">
        <seg>------------------ Running/Restarting Jobs ------------------- 17.10.2018 21:13:14 : bc0b2ad61ecd4a615d92ce25390f61ad :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--------------------------------------------------------------</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033034Z" creationid="xccui" creationdate="20190726T033034Z">
        <seg>--------------------------------------------------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--from-archive &lt;path-to-Flink-1.7.1-archive&gt; \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034507Z" creationid="xccui" creationdate="20190730T034507Z">
        <seg>--from-archive &lt;path-to-Flink-1.7.1-archive&gt; \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--image-name flink-book-apps</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034514Z" creationid="xccui" creationdate="20190730T034514Z">
        <seg>--image-name flink-book-apps</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--job-jar &lt;path-to-example-apps-JAR-file&gt; \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034511Z" creationid="xccui" creationdate="20190730T034511Z">
        <seg>--job-jar &lt;path-to-example-apps-JAR-file&gt; \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--link flink-jobmanager:jobmanager \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T032513Z" creationid="xccui" creationdate="20190718T032513Z">
        <seg>--link flink-jobmanager:jobmanager \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-1L</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034527Z" creationid="xccui" creationdate="20190713T034527Z">
        <seg>-1L</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DarchetypeArtifactId=flink-quickstart-scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004831Z" creationid="xccui" creationdate="20190612T004831Z">
        <seg>-DarchetypeArtifactId=flink-quickstart-scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DarchetypeGroupId=org.apache.flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004826Z" creationid="xccui" creationdate="20190612T004826Z">
        <seg>-DarchetypeGroupId=org.apache.flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DarchetypeVersion=1.7.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004835Z" creationid="xccui" creationdate="20190612T004835Z">
        <seg>-DarchetypeVersion=1.7.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DartifactId=flink-scala-project</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004842Z" creationid="xccui" creationdate="20190612T004842Z">
        <seg>-DartifactId=flink-scala-project</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DgroupId=org.apache.flink.quickstart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004839Z" creationid="xccui" creationdate="20190612T004839Z">
        <seg>-DgroupId=org.apache.flink.quickstart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Dhadoop.version=2.6.1-cdh5.0.0</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025254Z" creationid="xccui" creationdate="20190722T025254Z">
        <seg>-Dhadoop.version=2.6.1-cdh5.0.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DinteractiveMode=false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004854Z" creationid="xccui" creationdate="20190612T004854Z">
        <seg>-DinteractiveMode=false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Dpackage=org.apache.flink.quickstart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004850Z" creationid="xccui" creationdate="20190612T004850Z">
        <seg>-Dpackage=org.apache.flink.quickstart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Dversion=0.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004846Z" creationid="xccui" creationdate="20190612T004846Z">
        <seg>-Dversion=0.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-X POST http://localhost:8081/v1/jobs/e99cdb41b422631c8ee2218caa6af1cc/savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T181405Z" creationid="xccui" creationdate="20190729T181405Z">
        <seg>-X POST http://localhost:8081/v1/jobs/e99cdb41b422631c8ee2218caa6af1cc/savepoints</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-X POST http://localhost:8081/v1/savepoint-disposal</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200903Z" creationid="xccui" creationdate="20190729T200903Z">
        <seg>-X POST http://localhost:8081/v1/savepoint-disposal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-c io.github.streamingwithflink.chapter1.AverageSensorReadings \ examples-scala.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040003Z" creationid="xccui" creationdate="20190329T040003Z">
        <seg>-c io.github.streamingwithflink.chapter1.AverageSensorReadings \ examples-scala.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-e JOB_MANAGER_RPC_ADDRESS=jobmanager \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T032424Z" creationid="xccui" creationdate="20190718T032424Z">
        <seg>-e JOB_MANAGER_RPC_ADDRESS=jobmanager \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-e JOB_MANAGER_RPC_ADDRESS=jobmanager flink:1.7 taskmanager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T032516Z" creationid="xccui" creationdate="20190718T032516Z">
        <seg>-e JOB_MANAGER_RPC_ADDRESS=jobmanager flink:1.7 taskmanager</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-m flag:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T032201Z" creationid="xccui" creationdate="20190726T032201Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-p 8081:8081 flink:1.7 jobmanager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T032427Z" creationid="xccui" creationdate="20190718T032427Z">
        <seg>-p 8081:8081 flink:1.7 jobmanager</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T064032Z" creationid="xccui" creationdate="20190301T040155Z">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink cancel -s [savepointPath] &lt;jobId&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T183437Z" creationid="xccui" creationdate="20190726T183437Z">
        <seg>./bin/flink cancel -s [savepointPath] &lt;jobId&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink cancel -s \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T184651Z" creationid="xccui" creationdate="20190726T184651Z">
        <seg>./bin/flink cancel -s \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink cancel &lt;jobId&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T183310Z" creationid="xccui" creationdate="20190726T183310Z">
        <seg>./bin/flink cancel &lt;jobId&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink list -r Waiting for response...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033021Z" creationid="xccui" creationdate="20190726T033021Z">
        <seg>./bin/flink list -r Waiting for response...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink modify &lt;jobId&gt; -p &lt;newParallelism&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190728T044520Z" creationid="xccui" creationdate="20190728T044520Z">
        <seg>./bin/flink modify &lt;jobId&gt; -p &lt;newParallelism&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink modify bc0b2ad61ecd4a615d92ce25390f61ad -p 16 Modify job bc0b2ad61ecd4a615d92ce25390f61ad.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190728T071911Z" creationid="xccui" creationdate="20190728T071911Z">
        <seg>./bin/flink modify bc0b2ad61ecd4a615d92ce25390f61ad -p 16 Modify job bc0b2ad61ecd4a615d92ce25390f61ad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink run -c my.app.MainClass ~/myApp.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T031653Z" creationid="xccui" creationdate="20190726T031653Z">
        <seg>./bin/flink run -c my.app.MainClass ~/myApp.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink run -d ~/myApp.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T030909Z" creationid="xccui" creationdate="20190726T030909Z">
        <seg>./bin/flink run -d ~/myApp.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink run -m myMasterHost:9876 ~/myApp.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T032205Z" creationid="xccui" creationdate="20190726T032205Z">
        <seg>./bin/flink run -m myMasterHost:9876 ~/myApp.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink run -m yarn-cluster ./path/to/job.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T012236Z" creationid="xccui" creationdate="20190719T012236Z">
        <seg>./bin/flink run -m yarn-cluster ./path/to/job.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink run -p 16 ~/myApp.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T031153Z" creationid="xccui" creationdate="20190726T031153Z">
        <seg>./bin/flink run -p 16 ~/myApp.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink run -s &lt;savepointPath&gt; [options] &lt;jobJar&gt; [arguments]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T040216Z" creationid="xccui" creationdate="20190727T040216Z">
        <seg>./bin/flink run -s &lt;savepointPath&gt; [options] &lt;jobJar&gt; [arguments]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink run ~/myApp.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T025246Z" creationid="xccui" creationdate="20190726T025246Z">
        <seg>./bin/flink run ~/myApp.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink run ~/myApp.jar my-arg1 my-arg2 my-arg3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T030417Z" creationid="xccui" creationdate="20190726T030417Z">
        <seg>./bin/flink run ~/myApp.jar my-arg1 my-arg2 my-arg3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink savepoint -d &lt;savepointPath&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035128Z" creationid="xccui" creationdate="20190726T035128Z">
        <seg>./bin/flink savepoint -d &lt;savepointPath&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink savepoint -d \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035201Z" creationid="xccui" creationdate="20190726T035201Z">
        <seg>./bin/flink savepoint -d \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink savepoint &lt;jobId&gt; [savepointPath]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033255Z" creationid="xccui" creationdate="20190726T033255Z">
        <seg>./bin/flink savepoint &lt;jobId&gt; [savepointPath]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./bin/flink savepoint bc0b2ad61ecd4a615d92ce25390f61ad \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033842Z" creationid="xccui" creationdate="20190726T033842Z">
        <seg>./bin/flink savepoint bc0b2ad61ecd4a615d92ce25390f61ad \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./build.sh \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034504Z" creationid="xccui" creationdate="20190730T034504Z">
        <seg>./build.sh \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>./flink-container/kubernetes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T043821Z" creationid="xccui" creationdate="20190730T043821Z">
        <seg>./flink-container/kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.&lt;t0/&gt; &lt;t1/&gt;ix 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035437Z" creationid="xccui" creationdate="20190418T035437Z">
        <seg>.&lt;t0/&gt; &lt;t1/&gt;ix 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.PROCESS_CONTINUOUSLY,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185028Z" creationid="xccui" creationdate="20190710T185028Z">
        <seg>.PROCESS_CONTINUOUSLY,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.addGroup("MyMetrics")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T050218Z" creationid="xccui" creationdate="20190804T050218Z">
        <seg>.addGroup("MyMetrics")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.addSource(new SensorSource)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042142Z" creationid="xccui" creationdate="20190612T042142Z">
        <seg>.addSource(new SensorSource)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.aggregate(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040348Z" creationid="xccui" creationdate="20190625T040348Z">
        <seg>.aggregate(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.aggregate(new AvgTempFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005454Z" creationid="xccui" creationdate="20190624T005454Z">
        <seg>.aggregate(new AvgTempFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.allowedLateness(Time.seconds(5))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165249Z" creationid="xingcan" creationdate="20190628T165249Z">
        <seg>.allowedLateness(Time.seconds(5))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.apply(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040149Z" creationid="xccui" creationdate="20190628T040149Z">
        <seg>.apply(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.apply(new TemperatureAverager)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042735Z" creationid="xccui" creationdate="20190612T042735Z">
        <seg>.apply(new TemperatureAverager)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.asQueryableState("maxTemperature")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062320Z" creationid="xccui" creationdate="20190706T062320Z">
        <seg>.asQueryableState("maxTemperature")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.assignAscendingTimestamps(e =&gt; e.timestamp)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052008Z" creationid="xccui" creationdate="20190620T052008Z">
        <seg>.assignAscendingTimestamps(e =&gt; e.timestamp)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.assignTimestampsAndWatermarks(new MyAssigner())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044656Z" creationid="xccui" creationdate="20190620T044656Z">
        <seg>.assignTimestampsAndWatermarks(new MyAssigner())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.assignTimestampsAndWatermarks(new SensorTimeAssigner)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042218Z" creationid="xccui" creationdate="20190612T042218Z">
        <seg>.assignTimestampsAndWatermarks(new SensorTimeAssigner)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.between(&lt;lower-bound&gt;, &lt;upper-bound&gt;) // bounds with respect to input1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025903Z" creationid="xccui" creationdate="20190628T025903Z">
        <seg>.between(&lt;lower-bound&gt;, &lt;upper-bound&gt;) // 相对于input1的上下界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.broadcast(broadcastStateDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024340Z" creationid="xccui" creationdate="20190702T024340Z">
        <seg>.broadcast(broadcastStateDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.build()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205926Z" creationid="xccui" creationdate="20190710T205926Z">
        <seg>.build()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.connect(broadcastThresholds)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024509Z" creationid="xccui" creationdate="20190702T024509Z">
        <seg>.connect(broadcastThresholds)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.connect(filterSwitches)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031704Z" creationid="xccui" creationdate="20190622T031704Z">
        <seg>.connect(filterSwitches)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.connect(second.broadcast())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T051829Z" creationid="xccui" creationdate="20190615T051829Z">
        <seg>.connect(second.broadcast())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.connect(two)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050150Z" creationid="xccui" creationdate="20190615T050150Z">
        <seg>.connect(two)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.connect(two.keyBy(0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050438Z" creationid="xccui" creationdate="20190615T050438Z">
        <seg>.connect(two.keyBy(0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.counter("droppedElements")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015239Z" creationid="xccui" creationdate="20190803T015239Z">
        <seg>.counter("droppedElements")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.counter("myCounter")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T050224Z" creationid="xccui" creationdate="20190804T050224Z">
        <seg>.counter("myCounter")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.createSerializer(new ExecutionConfig),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064325Z" creationid="xccui" creationdate="20190715T064325Z">
        <seg>.createSerializer(new ExecutionConfig),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.equalTo(...)   // specify key attributes for input2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040016Z" creationid="xccui" creationdate="20190628T040016Z">
        <seg>.equalTo(...)   // 为input2指定键值属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.filter( r =&gt; r.temperature &gt;= 25 )</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053216Z" creationid="xccui" creationdate="20190613T053216Z">
        <seg>.filter( r =&gt; r.temperature &gt;= 25 )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.filter(new Filter1())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203603Z" creationid="xccui" creationdate="20190730T203603Z">
        <seg>.filter(new Filter1())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.filter(new Filter2())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203635Z" creationid="xccui" creationdate="20190730T203635Z">
        <seg>.filter(new Filter2())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.flatMap(id =&gt; id.split(" "))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005229Z" creationid="xccui" creationdate="20190613T005229Z">
        <seg>.flatMap(id =&gt; id.split(" "))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.flatMap(new TemperatureAlertFunction(1.1))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024139Z" creationid="xccui" creationdate="20190703T024139Z">
        <seg>.flatMap(new TemperatureAlertFunction(1.1))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.flatMap(new TemperatureAlertFunction(1.7))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062430Z" creationid="xccui" creationdate="20190630T062430Z">
        <seg>.flatMap(new TemperatureAlertFunction(1.7))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.flatMapWithState[(String, Double, Double), Double] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023019Z" creationid="xccui" creationdate="20190701T023019Z">
        <seg>.flatMapWithState[(String, Double, Double), Double] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.forBulkFormat(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T024511Z" creationid="xccui" creationdate="20190711T024511Z">
        <seg>.forBulkFormat(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.forRowFormat(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205915Z" creationid="xccui" creationdate="20190710T205915Z">
        <seg>.forRowFormat(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041410Z" creationid="xccui" creationdate="20190716T041410Z">
        <seg>.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.fromCollection(Seq(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031609Z" creationid="xccui" creationdate="20190622T031609Z">
        <seg>.fromCollection(Seq(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getConnection( "jdbc:derby:memory:flinkExample", new Properties())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211038Z" creationid="xccui" creationdate="20190716T211038Z">
        <seg>.getConnection( "jdbc:derby:memory:flinkExample", new Properties())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getIndexOfThisSubtask</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052356Z" creationid="xccui" creationdate="20190701T052356Z">
        <seg>.getIndexOfThisSubtask</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getKvState[String, ValueState[(String, Double)], (String, Double)]( JobID.fromHexString(jobId),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041615Z" creationid="xccui" creationdate="20190707T041615Z">
        <seg>.getKvState[String, ValueState[(String, Double)], (String, Double)]( JobID.fromHexString(jobId),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getMetricGroup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015235Z" creationid="xccui" creationdate="20190803T015235Z">
        <seg>.getMetricGroup</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getSideOutput(new  OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155646Z" creationid="xingcan" creationdate="20190628T155646Z">
        <seg>.getSideOutput(new  OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getSideOutput(new OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155129Z" creationid="xingcan" creationdate="20190628T155129Z">
        <seg>.getSideOutput(new OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getSideOutput(new OutputTag[String]("freezing-alarms"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022914Z" creationid="xccui" creationdate="20190622T022914Z">
        <seg>.getSideOutput(new OutputTag[String]("freezing-alarms"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getState[Double](lastTempDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T061052Z" creationid="xccui" creationdate="20190706T061052Z">
        <seg>.getState[Double](lastTempDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041334Z" creationid="xccui" creationdate="20190622T041334Z">
        <seg>.keyBy(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062236Z" creationid="xccui" creationdate="20190614T062236Z">
        <seg>.keyBy(0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(0) // key on first field of the tuple</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T062128Z" creationid="xccui" creationdate="20190614T054452Z">
        <seg>.keyBy(0) // 以元组第一个字段为键值进行分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(0, 0) // key both input streams on first attribute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T062815Z" creationid="xccui" creationdate="20190615T050311Z">
        <seg>.keyBy(0, 0) // 两个数据流都以第一个属性作为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(_._1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002503Z" creationid="xccui" creationdate="20190624T002503Z">
        <seg>.keyBy(_._1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(_.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042408Z" creationid="xccui" creationdate="20190612T042408Z">
        <seg>.keyBy(_.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(_.id, _._1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031732Z" creationid="xccui" creationdate="20190622T031732Z">
        <seg>.keyBy(_.id, _._1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(r =&gt; r.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051709Z" creationid="xccui" creationdate="20190614T051709Z">
        <seg>.keyBy(r =&gt; r.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(…)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025835Z" creationid="xccui" creationdate="20190628T025835Z">
        <seg>.keyBy(…)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map( r =&gt; {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042255Z" creationid="xccui" creationdate="20190612T042255Z">
        <seg>.map( r =&gt; {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(new Map1())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203606Z" creationid="xccui" creationdate="20190730T203606Z">
        <seg>.map(new Map1())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(new Map2()).disableChaining()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203631Z" creationid="xccui" creationdate="20190730T203631Z">
        <seg>.map(new Map2()).disableChaining()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(new Map2()).startNewChain()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T204405Z" creationid="xccui" creationdate="20190730T204405Z">
        <seg>.map(new Map2()).startNewChain()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(new MyMapper).setParallelism(defaultP * 2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061721Z" creationid="xccui" creationdate="20190616T061721Z">
        <seg>.map(new MyMapper).setParallelism(defaultP * 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(r =&gt; (r.id, r.temperature))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002456Z" creationid="xccui" creationdate="20190624T002456Z">
        <seg>.map(r =&gt; (r.id, r.temperature))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(r =&gt; (r.id, r.temperature, r.temperature))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043556Z" creationid="xccui" creationdate="20190625T043556Z">
        <seg>.map(r =&gt; (r.id, r.temperature, r.temperature))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(t -&gt; new Person(t.f0, t.f1))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062217Z" creationid="xccui" creationdate="20190617T062217Z">
        <seg>.map(t -&gt; new Person(t.f0, t.f1))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.max(1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062222Z" creationid="xccui" creationdate="20190706T062222Z">
        <seg>.max(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.mkString("\t| ") println(header)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040225Z" creationid="xccui" creationdate="20190707T040225Z">
        <seg>.mkString("\t| ") println(header)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.orderedWait( readings,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201724Z" creationid="xccui" creationdate="20190716T201724Z">
        <seg>.orderedWait( readings,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.print()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022917Z" creationid="xccui" creationdate="20190622T022917Z">
        <seg>.print()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.print().setParallelism(2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T015337Z" creationid="xccui" creationdate="20190617T015337Z">
        <seg>.print().setParallelism(2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061520Z" creationid="xccui" creationdate="20190623T061520Z">
        <seg>.process(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(ProcessJoinFunction) // process pairs of matched events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025916Z" creationid="xccui" creationdate="20190628T025916Z">
        <seg>.process(ProcessJoinFunction) // 处理匹配的事件对</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new CountFunction())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155052Z" creationid="xingcan" creationdate="20190628T155052Z">
        <seg>.process(new CountFunction())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new FreezingMonitor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022815Z" creationid="xccui" creationdate="20190622T022815Z">
        <seg>.process(new FreezingMonitor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new HighAndLowTempProcessFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030647Z" creationid="xccui" creationdate="20190625T030647Z">
        <seg>.process(new HighAndLowTempProcessFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new LateReadingsFilter)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155624Z" creationid="xingcan" creationdate="20190628T155624Z">
        <seg>.process(new LateReadingsFilter)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new ReadingFilter)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031750Z" creationid="xccui" creationdate="20190622T031750Z">
        <seg>.process(new ReadingFilter)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new TempIncreaseAlertFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071117Z" creationid="xccui" creationdate="20190621T071117Z">
        <seg>.process(new TempIncreaseAlertFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new TemperatureAverager)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T045129Z" creationid="xccui" creationdate="20190623T045129Z">
        <seg>.process(new TemperatureAverager)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new UpdatableTemperatureAlertFunction())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024512Z" creationid="xccui" creationdate="20190702T024512Z">
        <seg>.process(new UpdatableTemperatureAlertFunction())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new UpdatingWindowCountFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165340Z" creationid="xingcan" creationdate="20190628T165340Z">
        <seg>.process(new UpdatingWindowCountFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.reduce(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040338Z" creationid="xccui" creationdate="20190625T040338Z">
        <seg>.reduce(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002511Z" creationid="xccui" creationdate="20190624T002511Z">
        <seg>.reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.reduce((x, y) =&gt; (x._1, x._2 ::: y._2))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062241Z" creationid="xccui" creationdate="20190614T062241Z">
        <seg>.reduce((x, y) =&gt; (x._1, x._2 ::: y._2))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.reduce/aggregate/process(...) // specify the window function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041358Z" creationid="xccui" creationdate="20190622T041358Z">
        <seg>.reduce/aggregate/process(...) // 指定窗口函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.returns(Types.POJO(Person.class));</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062253Z" creationid="xccui" creationdate="20190617T062253Z">
        <seg>.returns(Types.POJO(Person.class));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.setHost("localhost")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210814Z" creationid="xccui" creationdate="20190711T210814Z">
        <seg>.setHost("localhost")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.setMaxParallelism(1024)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025203Z" creationid="xccui" creationdate="20190703T025203Z">
        <seg>.setMaxParallelism(1024)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.setParallelism(1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024036Z" creationid="xccui" creationdate="20190714T024036Z">
        <seg>.setParallelism(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.setParallelism(2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015403Z" creationid="xccui" creationdate="20190731T015403Z">
        <seg>.setParallelism(2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.setParallelism(4)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015245Z" creationid="xccui" creationdate="20190731T015245Z">
        <seg>.setParallelism(4)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.setQuery(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210817Z" creationid="xccui" creationdate="20190711T210817Z">
        <seg>.setQuery(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.sideOutputLateData(new OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154958Z" creationid="xingcan" creationdate="20190628T154958Z">
        <seg>.sideOutputLateData(new OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.slotSharingGroup("blue")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015419Z" creationid="xccui" creationdate="20190731T015419Z">
        <seg>.slotSharingGroup("blue")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.slotSharingGroup("green")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015241Z" creationid="xccui" creationdate="20190731T015241Z">
        <seg>.slotSharingGroup("green")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.slotSharingGroup("yellow")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015327Z" creationid="xccui" creationdate="20190731T015327Z">
        <seg>.slotSharingGroup("yellow")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.split(t =&gt; if (t._1 &gt; 1000) Seq("large") else Seq("small"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064105Z" creationid="xccui" creationdate="20190615T064105Z">
        <seg>.split(t =&gt; if (t._1 &gt; 1000) Seq("large") else Seq("small"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.sum(1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054503Z" creationid="xccui" creationdate="20190614T054503Z">
        <seg>.sum(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040334Z" creationid="xccui" creationdate="20190625T040334Z">
        <seg>.timeWindow(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.hours(1), Time(minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060213Z" creationid="xccui" creationdate="20190623T060213Z">
        <seg>.timeWindow(Time.hours(1), Time(minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.seconds(1))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T053729Z" creationid="xccui" creationdate="20190623T053729Z">
        <seg>.timeWindow(Time.seconds(1))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.seconds(10))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154936Z" creationid="xingcan" creationdate="20190628T154936Z">
        <seg>.timeWindow(Time.seconds(10))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.seconds(15))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002507Z" creationid="xccui" creationdate="20190624T002507Z">
        <seg>.timeWindow(Time.seconds(15))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.seconds(5))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042713Z" creationid="xccui" creationdate="20190612T042713Z">
        <seg>.timeWindow(Time.seconds(5))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.uid("TempAlert")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024132Z" creationid="xccui" creationdate="20190703T024132Z">
        <seg>.uid("TempAlert")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.union(tokyoStream, rioStream)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064856Z" creationid="xccui" creationdate="20190614T064856Z">
        <seg>.union(tokyoStream, rioStream)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.where(...)  // specify key attributes for input1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040006Z" creationid="xccui" creationdate="20190628T040006Z">
        <seg>.where(...)  // 为input1指定键值属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041337Z" creationid="xccui" creationdate="20190622T041337Z">
        <seg>.window(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(...) // specify the WindowAssigner [.trigger(...)] // optional: specify a Trigger [.evictor(...)] // optional: specify an Evictor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040210Z" creationid="xccui" creationdate="20190628T040145Z">
        <seg>.window(...) // 指定WindowAssigner [.trigger(...)] // 选择性地指定Trigger [.evictor(...)] // 选择性地指定Evictor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(EventTimeSessionWindows.withGap(Time.minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061515Z" creationid="xccui" creationdate="20190623T061515Z">
        <seg>.window(EventTimeSessionWindows.withGap(Time.minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(ProcessingTimeSessionWindows.withGap(Time.minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061554Z" creationid="xccui" creationdate="20190623T061554Z">
        <seg>.window(ProcessingTimeSessionWindows.withGap(Time.minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(SlidingEventTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060110Z" creationid="xccui" creationdate="20190623T060110Z">
        <seg>.window(SlidingEventTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(SlidingProcessingTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060140Z" creationid="xccui" creationdate="20190623T060140Z">
        <seg>.window(SlidingProcessingTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(TumblingEventTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054538Z" creationid="xccui" creationdate="20190623T054538Z">
        <seg>.window(TumblingEventTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(TumblingEventTimeWindows.of(Time.seconds(1)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T045125Z" creationid="xccui" creationdate="20190623T045125Z">
        <seg>.window(TumblingEventTimeWindows.of(Time.seconds(1)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(TumblingProcessingTimeWindows.of(Time.seconds(1)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T050101Z" creationid="xccui" creationdate="20190623T050101Z">
        <seg>.window(TumblingProcessingTimeWindows.of(Time.seconds(1)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.windowAll(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041446Z" creationid="xccui" creationdate="20190622T041446Z">
        <seg>.windowAll(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/**</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030655Z" creationid="xccui" creationdate="20190625T030655Z">
        <seg>/**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** A ProcessFunction that filters out late sensor readings and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155735Z" creationid="xingcan" creationdate="20190628T155735Z">
        <seg>/** 用于过滤出迟到的传感器读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** A counting WindowProcessFunction that distinguishes between</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T033840Z" creationid="xccui" creationdate="20190629T033840Z">
        <seg>/** 用于计数的WindowProcessFunction，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** A custom window that groups events into 30-second tumbling windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042719Z" creationid="xccui" creationdate="20190626T042645Z">
        <seg>/** 将事件按照每30秒滚动窗口进行分组的自定义窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** A trigger that fires early.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200135Z" creationid="xccui" creationdate="20190626T200135Z">
        <seg>/** 可提前触发的触发器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** Aborts a transaction by deleting the transaction file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042203Z" creationid="xccui" creationdate="20190716T042203Z">
        <seg>/** 通过删除事务文件来终止事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** Commit a transaction by moving the precommitted transaction file</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042017Z" creationid="xccui" creationdate="20190716T041935Z">
        <seg>/** 通过将预提交的事务文件移动到目标目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** Creates a temporary file for a transaction into which the records are</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041256Z" creationid="xccui" creationdate="20190716T041256Z">
        <seg>/** 为写入记录的事务创建一个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** Emits a warning if the temperature of a sensor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071241Z" creationid="xccui" creationdate="20190621T071241Z">
        <seg>/** 如果某传感器的温度在1秒（处理时间）内持续增加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** Emits freezing alarms to a side output for readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023624Z" creationid="xccui" creationdate="20190622T023402Z">
        <seg>/** 对于温度低于32F的读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** Flush and close the current transaction file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053111Z" creationid="xccui" creationdate="20190716T041831Z">
        <seg>/** 强制写出文件内容并关闭当前事务文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** Write record into the current transaction file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041550Z" creationid="xccui" creationdate="20190716T041550Z">
        <seg>/** 将记录写入当前事务文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060223Z" creationid="xccui" creationdate="20190616T060223Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// -----</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024040Z" creationid="xccui" creationdate="20190714T024040Z">
        <seg>// -----</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 1 min in ms</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051052Z" creationid="xccui" creationdate="20190620T051052Z">
        <seg>// 1分钟的毫秒数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A context object that is given to Evictor methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202140Z" creationid="xccui" creationdate="20190627T202124Z">
        <seg>// 用于移除器内方法的上下文对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A context object that is given to Trigger methods to allow them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192513Z" creationid="xccui" creationdate="20190626T192513Z">
        <seg>// 用于触发器中方法的上下文对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A context that gives access to the current processing time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041941Z" creationid="xccui" creationdate="20190626T041941Z">
        <seg>// 用于访问当前处理时间的上下文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// An AggregateFunction to compute the average tempeature per sensor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005524Z" creationid="xccui" creationdate="20190624T005518Z">
        <seg>// 用于计算每个传感器平均温度的AggregateFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called for every element that gets added to a window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185959Z" creationid="xccui" creationdate="20190626T185959Z">
        <seg>// 每当有元素添加到窗口中时都会调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called when a processing-time timer fires public abstract TriggerResult onProcessingTime( long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190106Z" creationid="xccui" creationdate="20190626T190106Z">
        <seg>// 在处理时间计时器触发时调用 public abstract TriggerResult onProcessingTime( long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called when an event-time timer fires</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190125Z" creationid="xccui" creationdate="20190626T190125Z">
        <seg>// 在事件时间计时器触发时调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called when several windows have been merged into one window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190218Z" creationid="xccui" creationdate="20190626T190218Z">
        <seg>// 当多个窗口合并为一个窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// CheckpointCommitter that commits checkpoints to the local filesystem</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064308Z" creationid="xccui" creationdate="20190715T064308Z">
        <seg>// 将检查点对应的数据写入本地文件系统的CheckpointCommitter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Clears any state that the trigger might hold for the given window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192245Z" creationid="xccui" creationdate="20190626T192245Z">
        <seg>// 在触发器中清除那些为给定窗口保存的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Connections and prepared statements should be cached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211033Z" creationid="xccui" creationdate="20190716T211033Z">
        <seg>// 你应该对连接和预编译语句进行缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Continue.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200637Z" creationid="xccui" creationdate="20190626T200637Z">
        <seg>// 继续。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Creating a new connection and statement for each record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T210846Z" creationid="xccui" creationdate="20190716T210846Z">
        <seg>// 为每条记录创建一个新的连接及语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// DataStream of Tuple2&lt;String, Integer&gt; for Person(name, age) DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; persons = env.fromElements( Tuple2.of("Adam", 17),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035155Z" creationid="xccui" creationdate="20190617T035155Z">
        <seg>// DataStream of Tuple2&lt;String, Integer&gt; for Person(name, age) DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; persons = env.fromElements( Tuple2.of("Adam", 17),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// DataStream of Tuple2[String, Integer] for Person(name, age) val persons: DataStream[(String, Integer)] = env.fromElements( ("Adam", 17),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041104Z" creationid="xccui" creationdate="20190616T071009Z">
        <seg>// DataStream的类型Tuple2[String, Integer]表示Person(name, age) val persons: DataStream[(String, Integer)] = env.fromElements( ("Adam", 17),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Deletes a processing-time timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192706Z" creationid="xccui" creationdate="20190626T192706Z">
        <seg>// 删除一个处理时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Deletes an event-time timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192717Z" creationid="xccui" creationdate="20190626T192717Z">
        <seg>// 删除一个事件时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Deletes any custom per-window state when the window is purged</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024334Z" creationid="xccui" creationdate="20190624T010617Z">
        <seg>// 在窗口清除时删除自定义的单个窗口状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Emits a record to the side output identified by the OutputTag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010948Z" creationid="xccui" creationdate="20190624T010948Z">
        <seg>// 向OutputTag标识的副输出发送记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Enable externalized checkpoints cpConfig.enableExternalizedCheckpoints( ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T205329Z" creationid="xccui" creationdate="20190731T205329Z">
        <seg>// 启用外化检查点 cpConfig.enableExternalizedCheckpoints( ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Evaluates the window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010513Z" creationid="xccui" creationdate="20190624T010513Z">
        <seg>// 对窗口执行计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Extension of TriggerContext that is given to the Trigger.onMerge() method</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193024Z" creationid="xccui" creationdate="20190626T193024Z">
        <seg>// 用于Trigger.onMerge()方法的TriggerContext扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// IN1: the type of the first input stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042818Z" creationid="xccui" creationdate="20190615T042818Z">
        <seg>// IN1：第一条输入流的类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// IN2: the type of the second input stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042841Z" creationid="xccui" creationdate="20190615T042841Z">
        <seg>// IN2：第二条输入流的类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// IN: the type of the split elements OutputSelector[IN]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061011Z" creationid="xccui" creationdate="20190615T061011Z">
        <seg>// IN：拆分流的元素类型 OutputSelector[IN]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Indicates whether this assigner creates event-time windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041916Z" creationid="xccui" creationdate="20190626T041916Z">
        <seg>// 表明此分配器是否创建基于事件时间的窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// KEY: the type of the key KeySelector[IN, KEY]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051050Z" creationid="xccui" creationdate="20190618T051050Z">
        <seg>// KEY：键值类型 KeySelector[IN, KEY]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Merges per-window state of the trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193052Z" creationid="xccui" creationdate="20190626T193052Z">
        <seg>// 合并触发器中的单个窗口状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Note: This is NOT best practice!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T210952Z" creationid="xccui" creationdate="20190716T210952Z">
        <seg>// 注意：实际应用中不要这么做！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// O: the type of output elements FlatMapFunction[T, O]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T061027Z" creationid="xccui" creationdate="20190613T061027Z">
        <seg>// O：输出元素的类型 FlatMapFunction[T, O]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// O: the type of output elements MapFunction[T, O]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055335Z" creationid="xccui" creationdate="20190613T050340Z">
        <seg>// O：输出元素的类型 MapFunction[T, O]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// OUT: the type of the output elements CoFlatMapFunction[IN1, IN2, OUT]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042914Z" creationid="xccui" creationdate="20190615T042914Z">
        <seg>// OUT：输出元素的类型 CoFlatMapFunction[IN1, IN2, OUT]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// OUT: the type of the output elements CoMapFunction[IN1, IN2, OUT]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042855Z" creationid="xccui" creationdate="20190615T042855Z">
        <seg>// OUT：输出元素的类型 CoMapFunction[IN1, IN2, OUT]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Optionally evicts elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201836Z" creationid="xccui" creationdate="20190627T201836Z">
        <seg>// 选择性地移除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Random JobID used by the CheckpointCommitter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064344Z" creationid="xccui" creationdate="20190715T064344Z">
        <seg>// 用于CheckpointCommitter的随机JobID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Registers a processing-time timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192628Z" creationid="xccui" creationdate="20190626T192628Z">
        <seg>// 注册一个处理时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Registers an event-time timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192648Z" creationid="xccui" creationdate="20190626T192648Z">
        <seg>// 注册一个事件时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Retrieves a state object that is scoped to the window and the key of the trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192922Z" creationid="xccui" creationdate="20190626T192915Z">
        <seg>// 获取一个作用域为触发器键值和当前窗口的状态对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns a collection of windows to which the element is assigned</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041644Z" creationid="xccui" creationdate="20190626T041644Z">
        <seg>// 返回元素分配的目标窗口集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the TypeSerializer for the windows of this WindowAssigner public abstract TypeSerializer&lt;W&gt; getWindowSerializer( ExecutionConfig executionConfig);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041816Z" creationid="xccui" creationdate="20190626T041816Z">
        <seg>// 返回WindowAssigner中窗口的TypeSerializer public abstract TypeSerializer&lt;W&gt; getWindowSerializer( ExecutionConfig executionConfig);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the current event time watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202209Z" creationid="xccui" creationdate="20190627T202209Z">
        <seg>// 返回当前事件时间水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the current event-time watermark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010748Z" creationid="xccui" creationdate="20190624T010748Z">
        <seg>// 返回当前事件时间水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the current processing time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010733Z" creationid="xccui" creationdate="20190624T010733Z">
        <seg>// 返回当前处理时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the current processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202152Z" creationid="xccui" creationdate="20190627T202152Z">
        <seg>// 返回当前处理时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the current watermark time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192614Z" creationid="xccui" creationdate="20190626T192605Z">
        <seg>// 返回当前水位线时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the default Trigger of the WindowAssigner public abstract Trigger&lt;T, W&gt; getDefaultTrigger( StreamExecutionEnvironment env);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041742Z" creationid="xccui" creationdate="20190626T041742Z">
        <seg>// 返回WindowAssigner的默认触发器 public abstract Trigger&lt;T, W&gt; getDefaultTrigger( StreamExecutionEnvironment env);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the metadata of the window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010721Z" creationid="xccui" creationdate="20190624T010721Z">
        <seg>// 返回窗口的元数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns true if this trigger supports merging of trigger state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190151Z" creationid="xccui" creationdate="20190626T190151Z">
        <seg>// 如果触发器支持合并触发器状态则返回true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Scala object that defines the DataStream program in the main() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T052233Z" creationid="xccui" creationdate="20190612T041823Z">
        <seg>// Scala对象，其main()方法中定义了DataStream程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Serializer for records</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064319Z" creationid="xccui" creationdate="20190715T064319Z">
        <seg>// 记录的序列化器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// State accessor for per-key global state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010914Z" creationid="xccui" creationdate="20190624T010914Z">
        <seg>// 用于每个键值全局状态的访问器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// State accessor for per-window state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024341Z" creationid="xccui" creationdate="20190624T010837Z">
        <seg>// 用于单个窗口状态的访问器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// T: the element type ReduceFunction[T]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061908Z" creationid="xccui" creationdate="20190614T061908Z">
        <seg>// T：元素类型 ReduceFunction[T]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// T: the type of elements FilterFunction[T]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053022Z" creationid="xccui" creationdate="20190613T053018Z">
        <seg>// T：元素类型 FilterFunction[T]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// T: the type of input elements</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050329Z" creationid="xccui" creationdate="20190613T050329Z">
        <seg>// T：输入元素的类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The FileInputFormat "hdfs:///path/to/my/data", // The path to read</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185013Z" creationid="xccui" creationdate="20190710T185013Z">
        <seg>// FileInputFormat "hdfs:///path/to/my/data", // 读取路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The accumulator holds the sum of temperatures and an event count.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005549Z" creationid="xccui" creationdate="20190624T005549Z">
        <seg>// 累加器用于保存温度总和及事件数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The context holding window metadata</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010711Z" creationid="xccui" creationdate="20190624T010711Z">
        <seg>// 保存窗口元数据的上下文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The monitoring interval in ms</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185059Z" creationid="xccui" creationdate="20190710T185059Z">
        <seg>// 以毫秒为单位的监控间隔</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The processing mode</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185034Z" creationid="xccui" creationdate="20190710T185034Z">
        <seg>// 处理模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The state to be merged must support merging</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193113Z" creationid="xccui" creationdate="20190626T193107Z">
        <seg>// 目标状态自身需要支持合并</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This method is called when a window is purged</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192344Z" creationid="xccui" creationdate="20190626T192330Z">
        <seg>// 该方法会在清除窗口时调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TypeInformation for Java Tuples TypeInformation&lt;Tuple2&lt;Long, String&gt;&gt; tupleType = Types.TUPLE(Types.LONG, Types.STRING);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053842Z" creationid="xccui" creationdate="20190617T053631Z">
        <seg>// Java元组的TypeInformation TypeInformation&lt;Tuple2&lt;Long, String&gt;&gt; tupleType = Types.TUPLE(Types.LONG, Types.STRING);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TypeInformation for POJOs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053657Z" creationid="xccui" creationdate="20190617T053657Z">
        <seg>// POJO的TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TypeInformation for Scala Tuples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053836Z" creationid="xccui" creationdate="20190617T053836Z">
        <seg>// Scala元组的TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TypeInformation for case classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053913Z" creationid="xccui" creationdate="20190617T053913Z">
        <seg>// 样例类的TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TypeInformation for primitive types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053611Z" creationid="xccui" creationdate="20190617T053611Z">
        <seg>// 原始类型的TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a filter lambda function that checks if tweets contains the word "flink"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055912Z" creationid="xccui" creationdate="20190618T055912Z">
        <seg>// 用于检查是否包含"flink"一词的过滤器lambda函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// add an input element to the accumulator and return the accumulator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T035912Z" creationid="xccui" creationdate="20190624T004439Z">
        <seg>// 向累加器中添加一个输入元素并返回累加器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// add current cnt</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034202Z" creationid="xccui" creationdate="20190713T034202Z">
        <seg>// 添加当前的cnt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// all of Flink's built-in backends are configurable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030007Z" creationid="xccui" creationdate="20190801T030007Z">
        <seg>// 所有Flink内置的状态后端都是可配置的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// allow three checkpoint to be in progress at the same time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T203219Z" creationid="xccui" creationdate="20190731T203219Z">
        <seg>// 允许同时生成三个检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// alternative: connect two keyed streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T205951Z" creationid="xccui" creationdate="20190615T050418Z">
        <seg>// 或者是联结两个已经按键值分好区的数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// and the state of the triggers needs to be merged</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190949Z" creationid="xccui" creationdate="20190626T190949Z">
        <seg>// 且需要合并触发器状态时调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// apply ProcessFunction to monitor temperatures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071114Z" creationid="xccui" creationdate="20190621T071114Z">
        <seg>// 使用KeyedProcessFunction来监测温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// apply a stateful FlatMapFunction on the keyed stream which</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064858Z" creationid="xccui" creationdate="20190630T062142Z">
        <seg>// 在键值分区数据流上应用一个状态化的FlatMapFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// apply filtering CoProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031748Z" creationid="xccui" creationdate="20190622T031748Z">
        <seg>// 应用过滤CoProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// apply result handling callback on the room future</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211946Z" creationid="xccui" creationdate="20190716T211946Z">
        <seg>// 对房间Future对象应用结果处理回调</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// assign record timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054920Z" creationid="xccui" creationdate="20190620T054920Z">
        <seg>// 为记录分配时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// assign timestamps and generate watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044653Z" creationid="xccui" creationdate="20190620T044653Z">
        <seg>// 分配时间戳并生成水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// assign timestamps and watermarks (required for event time)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042213Z" creationid="xccui" creationdate="20190612T042213Z">
        <seg>// 分配时间戳和水位线（事件时间所需)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// assume local setup and TM runs on same machine as client</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035915Z" creationid="xccui" creationdate="20190707T035915Z">
        <seg>// 假设使用本地模式，TM和客户端运行在相同机器上</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// at most 100 concurrent requests</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201812Z" creationid="xccui" creationdate="20190716T201812Z">
        <seg>// 最多100个并发请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// both fields are public public String name; public int age;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044828Z" creationid="xccui" creationdate="20190617T044828Z">
        <seg>// 两个字段都是公有类型 public String name; public int age;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// broadcast second input stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T051818Z" creationid="xccui" creationdate="20190615T051818Z">
        <seg>// 将第二条输入流广播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// broker list</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T145553Z" creationid="xingcan" creationdate="20190709T144752Z">
        <seg>// Kafka Broker列表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// build Flink for a Hadoop version of a distributor mvn clean install -DskipTests -Pvendor-repos \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025251Z" creationid="xccui" creationdate="20190722T025251Z">
        <seg>// 针对某一发行商版本的Hadoop构建Flink mvn clean install -DskipTests -Pvendor-repos \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// build Flink for a specific official Hadoop version mvn clean install -DskipTests -Dhadoop.version=2.6.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025224Z" creationid="xccui" creationdate="20190722T025224Z">
        <seg>// 针对某一特定官方版本的Hadoop构建Flink mvn clean install -DskipTests -Dhadoop.version=2.6.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// caching execution context used to handle the query threads private lazy val cachingPoolExecCtx = ExecutionContext.fromExecutor(Executors.newCachedThreadPool())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T205528Z" creationid="xccui" creationdate="20190716T205528Z">
        <seg>// 缓存用于处理查询线程的执行环境 private lazy val cachingPoolExecCtx = ExecutionContext.fromExecutor(Executors.newCachedThreadPool())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// can be looked up in logs of running job or the web UI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040028Z" creationid="xccui" creationdate="20190707T040028Z">
        <seg>// 可以通过运行作业的日志或Web UI获取</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// check if temperature is high</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162300Z" creationid="xccui" creationdate="20190702T162300Z">
        <seg>//检查温度是否过高</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// check if the file exists to ensure that the commit is idempotent</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042140Z" creationid="xccui" creationdate="20190716T042118Z">
        <seg>// 检查目标文件是否存在以保证提交的幂等性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// check if we have a threshold</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042721Z" creationid="xccui" creationdate="20190702T042721Z">
        <seg>// 检查阈值是否已经存在</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// check if we may forward the reading if (forwardingEnabled.value()) { out.collect(reading)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032301Z" creationid="xccui" creationdate="20190622T032301Z">
        <seg>// 检查是否可以转发读数 if (forwardingEnabled.value()) { out.collect(reading)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// check if we need to emit an alert</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064446Z" creationid="xccui" creationdate="20190630T064446Z">
        <seg>// 检查是否需要发出警报</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// checkpoints have to complete within five minutes, or are discarded</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T032938Z" creationid="xccui" creationdate="20190731T203918Z">
        <seg>// 检查点生成必须在五分钟内完成，否则就会终止执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// clear all state for the key lastTempState.clear() lastTimerState.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210846Z" creationid="xccui" creationdate="20190704T210846Z">
        <seg>// 清除当前键值的所有状态 lastTempState.clear() lastTimerState.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// clear trigger state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T053358Z" creationid="xccui" creationdate="20190626T200942Z">
        <seg>// 清理触发器状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// close resultset, statement, and connection</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211738Z" creationid="xccui" creationdate="20190716T211738Z">
        <seg>// 关闭结果集、语句及连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// close writer and socket writer.close() socket.close()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024903Z" creationid="xccui" creationdate="20190714T024903Z">
        <seg>// 关闭写入器和套接字 writer.close() socket.close()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compare record timestamp with current watermark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155905Z" creationid="xingcan" creationdate="20190628T155905Z">
        <seg>// 比较记录时间戳和当前水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compare temperature difference with threshold val tempDiff = (r.temperature - lastTemp.get).abs if (tempDiff &gt; 1.7) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T040906Z" creationid="xccui" creationdate="20190701T023227Z">
        <seg>// 比较温差和阈值 val tempDiff = (r.temperature - lastTemp.get).abs if (tempDiff &gt; 1.7) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compares the temperature readings and raises alerts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062424Z" creationid="xccui" creationdate="20190630T062424Z">
        <seg>// 来比较读数并发出警报</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compute average temperature using a user-defined function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042729Z" creationid="xccui" creationdate="20190612T042729Z">
        <seg>// 使用用户自定义函数计算平均温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compute every 10 seconds the max temperature per sensor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062213Z" creationid="xccui" creationdate="20190706T062213Z">
        <seg>// 每10秒为每个传感器计算一次最高温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compute the result from the accumulator and return it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T035917Z" creationid="xccui" creationdate="20190624T004735Z">
        <seg>// 根据累加器计算并返回结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compute time for next early firing by rounding watermark to second</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200550Z" creationid="xccui" creationdate="20190626T200550Z">
        <seg>// 将水位线上取整到秒来计算下一次触发时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compute timestamp of new clean up timer as record timestamp + one hour</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210546Z" creationid="xccui" creationdate="20190704T210515Z">
        <seg>// 将清理状态的计时器设置为比记录时间戳晚一小时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// configure a new threshold for the sensor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042639Z" creationid="xccui" creationdate="20190702T042607Z">
        <seg>// 为指定传感器配置新的阈值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// configure client with host and port of queryable state proxy</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040138Z" creationid="xccui" creationdate="20190707T040138Z">
        <seg>// 利用可查询式状态代理的主机名和端口来配置客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// configure path for checkpoints on the remote filesystem</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025722Z" creationid="xccui" creationdate="20190704T025722Z">
        <seg>// 远程文件系统检查点配置路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// configure the state backend</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025733Z" creationid="xccui" creationdate="20190704T025733Z">
        <seg>// 配置状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// connect keyed sensor stream and broadcasted rules stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024501Z" creationid="xccui" creationdate="20190702T024501Z">
        <seg>// 联结键值分区传感数据流和广播的规则流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// connect readings and switches</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210051Z" creationid="xccui" creationdate="20190622T031702Z">
        <seg>// 联结读数和开关</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// connect streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T205938Z" creationid="xccui" creationdate="20190615T040821Z">
        <seg>// 将两条流联结</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// connect streams with broadcast</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210009Z" creationid="xccui" creationdate="20190615T051801Z">
        <seg>// 利用广播联结数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// connect to embedded in-memory Derby</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045216Z" creationid="xccui" creationdate="20190714T045216Z">
        <seg>// 连接到嵌入式内存Derby数据库</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// convert Fahrenheit to Celsius with an inline lambda function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053316Z" creationid="xccui" creationdate="20190612T042248Z">
        <seg>// 使用内联lambda函数把华氏温度转为摄氏温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// count readings and update results if late readings arrive</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034051Z" creationid="xingcan" creationdate="20190628T165338Z">
        <seg>// 如果遇到迟到读数，则重新计数并更新结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// count readings per window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155050Z" creationid="xingcan" creationdate="20190628T155050Z">
        <seg>// 计算每个窗口内的读数个数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// count the number of readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034415Z" creationid="xccui" creationdate="20190629T034024Z">
        <seg>// 计算读数个数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create 1h event-time windows every 15 minutes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060053Z" creationid="xccui" creationdate="20190623T060053Z">
        <seg>// 每隔15分钟创建1小时的事件时间窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create 1h processing-time windows every 15 minutes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060138Z" creationid="xccui" creationdate="20190623T060138Z">
        <seg>// // 每隔15分钟创建1小时的处理时间窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a DataStream[SensorReading] from a stream source</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042034Z" creationid="xccui" creationdate="20190612T042034Z">
        <seg>// 从流式数据源中创建DataStream[SensorReading]对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a FsStateBackend that checkpoints to the /tmp/ckp folder</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022904Z" creationid="xccui" creationdate="20190801T022904Z">
        <seg>//创建一个检查点路径为/tmp/ckp的FsStateBackend</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a MemoryStateBackend</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022641Z" creationid="xccui" creationdate="20190801T022641Z">
        <seg>// 创建一个MemoryStateBackend</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a RocksDBStateBackend that writes incremental checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025100Z" creationid="xccui" creationdate="20190801T025100Z">
        <seg>// 创建一个将检查点增量写入/tmp/ckp目录的RocksDBStateBackend</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a configured copy of the backend</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030138Z" creationid="xccui" creationdate="20190801T030138Z">
        <seg>// 为配置后的的状态后端创建一个副本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a local stream execution environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T050137Z" creationid="xccui" creationdate="20190612T045528Z">
        <seg>// 创建一个本地的流式执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a new accumulator to start a new aggregate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004409Z" creationid="xccui" creationdate="20190624T004327Z">
        <seg>// 创建一个累加器来启动聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a remote stream execution environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T050140Z" creationid="xccui" creationdate="20190612T045541Z">
        <seg>// 创建一个远程的流式执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create and configure state backend of your choice</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022104Z" creationid="xccui" creationdate="20190801T022104Z">
        <seg>// 创建并配置所选的状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create and register histogram DropwizardHistogramWrapper histogramWrapper = new DropwizardHistogramWrapper(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033645Z" creationid="xccui" creationdate="20190803T033645Z">
        <seg>// 创建并注册直方图 DropwizardHistogramWrapper histogramWrapper = new DropwizardHistogramWrapper(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create configuration and set options</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030030Z" creationid="xccui" creationdate="20190801T030030Z">
        <seg>// 创建配置并设置选项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create event-time session windows with a 15 min gap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061512Z" creationid="xccui" creationdate="20190623T061512Z">
        <seg>// 创建15分钟间隔的事件时间会话窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create keyed state descriptor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041828Z" creationid="xccui" creationdate="20190702T041828Z">
        <seg>// 创建键值分区状态描述符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create processing-time session windows with a 15 min gap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061550Z" creationid="xccui" creationdate="20190623T061550Z">
        <seg>// 创建15分钟间隔的处理时间会话窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create state descriptor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064304Z" creationid="xccui" creationdate="20190630T064304Z">
        <seg>// 创建状态描述符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create transaction file and writer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041429Z" creationid="xccui" creationdate="20190716T041429Z">
        <seg>// 创建事务文件及写入器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// default constructor is present</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044839Z" creationid="xccui" creationdate="20190617T044839Z">
        <seg>// 提供了默认构造函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// define a keyed window operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041328Z" creationid="xccui" creationdate="20190622T041328Z">
        <seg>// 定义键值分区窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// define a nonkeyed window-all operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T023956Z" creationid="xccui" creationdate="20190622T041443Z">
        <seg>// 定义一个非键值分区的全量窗口（window-all）算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// define a side output tag</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023928Z" creationid="xccui" creationdate="20190622T023928Z">
        <seg>// 定义副输出标签</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// delete previous timer and register new timer ctx.timerService().deleteEventTimeTimer(curTimer) ctx.timerService().registerEventTimeTimer(newTimer)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210630Z" creationid="xccui" creationdate="20190704T210630Z">
        <seg>// 删除前一个计时器并注册一个新的计时器 ctx.timerService().deleteEventTimeTimer(curTimer) ctx.timerService().registerEventTimeTimer(newTimer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// direct execution context to forward result future to callback object</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T205822Z" creationid="xccui" creationdate="20190716T205736Z">
        <seg>// 用于将结果Future转发给回调对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// disable chaining for Map2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203629Z" creationid="xccui" creationdate="20190730T203629Z">
        <seg>// 禁止Map2进行任务链接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do not emit a watermark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054855Z" creationid="xccui" creationdate="20190620T054855Z">
        <seg>// 不发出水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do not fail the job on a checkpointing error</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T204448Z" creationid="xccui" creationdate="20190731T204448Z">
        <seg>// 不要因为检查点生成错误导致作业失败</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do some cleanup, e.g., close connections to external systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034545Z" creationid="xccui" creationdate="20190619T034545Z">
        <seg>// 做一些清理工作，例如关闭和外部系统的连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do some initialization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034334Z" creationid="xccui" creationdate="20190619T034334Z">
        <seg>// 进行一些初始化工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do some more processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034522Z" creationid="xccui" creationdate="20190619T034459Z">
        <seg>// 做一些额外处理工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// e.g., establish a connection to an external system</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034357Z" creationid="xccui" creationdate="20190619T034357Z">
        <seg>// 例如和外部系统建立连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emit freezing alarm if temperature is below 32F</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T203300Z" creationid="xccui" creationdate="20190622T024013Z">
        <seg>// 如果温度低于32F则发出冻结警报</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emit late readings to a side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154955Z" creationid="xingcan" creationdate="20190628T154955Z">
        <seg>// 将迟到读数发至副输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emit new counters</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162604Z" creationid="xccui" creationdate="20190702T162604Z">
        <seg>// 发出新的计数器值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emit update with subtask index and counter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T150754Z" creationid="xccui" creationdate="20190701T052656Z">
        <seg>// 发出由子任务索引号和数目组成的更新元组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emit watermark if reading is from sensor_1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054836Z" creationid="xccui" creationdate="20190620T054836Z">
        <seg>// 如果读数来自sensor_1则发出水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emitting the corresponding time window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052429Z" creationid="xccui" creationdate="20190626T044132Z">
        <seg>// 发出相应的时间窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// enable checkpoint compression</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T204755Z" creationid="xccui" creationdate="20190731T204755Z">
        <seg>// 开启检查点压缩</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// enable checkpointing with an interval of 10 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T030721Z" creationid="xccui" creationdate="20190731T030721Z">
        <seg>// 启用10秒为间隔的检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// enable queryable state and set its external identifier</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T061042Z" creationid="xccui" creationdate="20190706T061042Z">
        <seg>// 启用可查询式状态并设置其外部标识符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// enable reading forwarding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032317Z" creationid="xccui" creationdate="20190622T032317Z">
        <seg>// 开启读数转发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// event-time session windows assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061436Z" creationid="xccui" creationdate="20190623T061436Z">
        <seg>// 事件时间会话窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// event-time sliding windows assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055959Z" creationid="xccui" creationdate="20190623T055959Z">
        <seg>// 事件时间滑动窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// execute application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044712Z" creationid="xccui" creationdate="20190612T042805Z">
        <seg>// 开始执行应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// execute insert statement</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045832Z" creationid="xccui" creationdate="20190714T045832Z">
        <seg>// 执行插入语句</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// execute insert statement if update statement did not update any row</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045746Z" creationid="xccui" creationdate="20190714T045746Z">
        <seg>// 如果数据更新条数为零则执行插入语句</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// fetch the last temperature from state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064415Z" creationid="xccui" creationdate="20190630T064415Z">
        <seg>// 从状态中获取上一次的温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// filter for persons of age &gt; 18</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041250Z" creationid="xccui" creationdate="20190616T071056Z">
        <seg>// 过滤出那些年龄大于18的人</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// filter for persons with age &gt; 18</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041258Z" creationid="xccui" creationdate="20190617T041209Z">
        <seg>// 过滤出那些年龄大于18的人</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// filter switches enable forwarding of readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031601Z" creationid="xccui" creationdate="20190622T031601Z">
        <seg>// 开启读数转发的过滤开关</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// final evaluation and purge window state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200753Z" creationid="xccui" creationdate="20190626T200736Z">
        <seg>// 进行最终计算并清除窗口状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// finalize result in ProcessWindowFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043634Z" creationid="xccui" creationdate="20190625T043634Z">
        <seg>// 在ProcessWindowFunction中计算最终结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// fire trigger to evaluate window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200900Z" creationid="xccui" creationdate="20190626T200900Z">
        <seg>// 触发进行窗口计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// first evaluation, emit first result out.collect((id, ctx.window.getEnd, cnt, "first")) isUpdate.update(true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034424Z" creationid="xccui" creationdate="20190629T034424Z">
        <seg>// 首次计算并发出结果 out.collect((id, ctx.window.getEnd, cnt, "first")) isUpdate.update(true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// first stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040749Z" creationid="xccui" creationdate="20190615T040720Z">
        <seg>// 第一条流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// firstSeen will be false if not set yet</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200329Z" creationid="xccui" creationdate="20190626T200329Z">
        <seg>// 如果之前没有设置过值firstSeen为false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// forward all readings to the regular output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T024045Z" creationid="xccui" creationdate="20190622T024045Z">
        <seg>//将所有读数发到常规输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// generate watermarks every 5 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045800Z" creationid="xccui" creationdate="20190620T045800Z">
        <seg>// 每5秒生成一次水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// generated watermark with 1 min tolerance</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051127Z" creationid="xccui" creationdate="20190620T051127Z">
        <seg>// 生成具有1分钟容忍度的水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get broadcasted state handle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042551Z" creationid="xccui" creationdate="20190702T042551Z">
        <seg>// 获取广播状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get default parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061553Z" creationid="xccui" creationdate="20190616T061553Z">
        <seg>// 获取默认并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get default parallelism as configured in the cluster config or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060212Z" creationid="xccui" creationdate="20190616T054814Z">
        <seg>// 获取通过集群配置或提交客户端指定的默认并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get previous temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071425Z" creationid="xccui" creationdate="20190621T071425Z">
        <seg>// 获取前一个温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get read-only broadcast state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T061944Z" creationid="xccui" creationdate="20190702T042705Z">
        <seg>// 获取只读的广播状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get room from Derby table as Future</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211801Z" creationid="xccui" creationdate="20190716T210221Z">
        <seg>// 以Future形式从Derby表中获取房间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get room if there is one</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211850Z" creationid="xccui" creationdate="20190716T211551Z">
        <seg>// 如果有剩余房间就获取一个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get the CheckpointConfig from the StreamExecutionEnvironment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T030833Z" creationid="xccui" creationdate="20190731T030833Z">
        <seg>// 从StreamExecutionEnvironment中获取CheckpointConfig</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get threshold for sensor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042738Z" creationid="xccui" creationdate="20190702T042738Z">
        <seg>// 获取指定传感器的阈值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get timestamp of current timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210606Z" creationid="xccui" creationdate="20190704T210606Z">
        <seg>// 获取当前计时器的时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// group readings in 1 hour windows with 15 min offset</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054519Z" creationid="xccui" creationdate="20190623T054519Z">
        <seg>// 将读数按照大小1小时、偏移量15分钟的时间窗口分组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// group readings in 1s event-time windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054536Z" creationid="xccui" creationdate="20190623T042926Z">
        <seg>// 将读数按照1秒事件时间窗口分组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// group readings in 1s processing-time windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054528Z" creationid="xccui" creationdate="20190623T045155Z">
        <seg>// 将读数按照1秒处理时间窗口分组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// group readings in 5 second tumbling windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042710Z" creationid="xccui" creationdate="20190612T042607Z">
        <seg>// 将读数按5秒的滚动窗口分组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// hold timestamp of currently active disable timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032225Z" creationid="xccui" creationdate="20190622T032225Z">
        <seg>// 用于保存当前活动的停止计时器的时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// hostname of JobManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045601Z" creationid="xccui" creationdate="20190612T045601Z">
        <seg>// JobManager的主机名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// how many sensors to query</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040040Z" creationid="xccui" creationdate="20190707T040040Z">
        <seg>// 需要查询的传感器数量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// how often to query the state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040053Z" creationid="xccui" creationdate="20190707T040053Z">
        <seg>// 状态的查询频率</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// in a queryable state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062257Z" creationid="xccui" creationdate="20190706T062257Z">
        <seg>// 存入可查询式状态中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// increment counter if threshold is exceeded</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052519Z" creationid="xccui" creationdate="20190701T052519Z">
        <seg>// 如果超过阈值计数器加一</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// incrementally compute min and max temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043609Z" creationid="xccui" creationdate="20190625T043609Z">
        <seg>// 增量计算最低和最高温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// index of the subtask</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T150739Z" creationid="xccui" creationdate="20190701T052350Z">
        <seg>// 子任务的索引号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ingest sensor readings with a SensorSource SourceFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042138Z" creationid="xccui" creationdate="20190612T042134Z">
        <seg>// 利用SensorSource SourceFunction获取传感器读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ingest sensor stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T072814Z" creationid="xccui" creationdate="20190619T072814Z">
        <seg>// 读入传感器流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initialize cnt variable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034518Z" creationid="xccui" creationdate="20190713T034518Z">
        <seg>// 初始化cnt变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initialize keyed state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162956Z" creationid="xccui" creationdate="20190702T162956Z">
        <seg>// 初始化键值分区状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initialize local variable with state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163420Z" creationid="xccui" creationdate="20190702T163338Z">
        <seg>// 利用算子状态初始化本地的变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initialize operator state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163216Z" creationid="xccui" creationdate="20190702T163216Z">
        <seg>// 初始化算子状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// jobId of running QueryableStateJob</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035953Z" creationid="xccui" creationdate="20190707T035953Z">
        <seg>// 运行QueryableStateJob的jobId</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// key by sensor id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062315Z" creationid="xccui" creationdate="20190621T070917Z">
        <seg>// 以传感器id为键值进行分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// key by sensor ids</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031728Z" creationid="xccui" creationdate="20190622T031728Z">
        <seg>// 以传感器id为键值进行分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// keyBy two connected streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T205947Z" creationid="xccui" creationdate="20190615T050140Z">
        <seg>// 对两个联结后的数据流按键值分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// local count variable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052543Z" creationid="xccui" creationdate="20190701T052412Z">
        <seg>// 本地计数器变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// local variable for the operator high temperature cnt</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162232Z" creationid="xccui" creationdate="20190702T162232Z">
        <seg>// 在本地用于存储算子实例高温数目的变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// loop forever</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040238Z" creationid="xccui" creationdate="20190707T040238Z">
        <seg>// 死循环</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// main() defines and executes the DataStream program</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041854Z" creationid="xccui" creationdate="20190612T041854Z">
        <seg>// 通过main()方法定义并执行DataStream程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// make sure we process at least 30s without checkpointing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T032235Z" creationid="xccui" creationdate="20190731T202718Z">
        <seg>// 确保我们至少可以在不受检查点干扰情况下处理30秒</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// merge two accumulators and return the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T035920Z" creationid="xccui" creationdate="20190624T004856Z">
        <seg>// 合并两个累加器并返回合并结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// monitor stream for readings with freezing temperatures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022810Z" creationid="xccui" creationdate="20190622T022810Z">
        <seg>// 监控冷冻温度数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// name of transaction file is returned to later identify the transaction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T044117Z" creationid="xccui" creationdate="20190716T041526Z">
        <seg>// 返回事务文件名，便于日后识别</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// no previous temperature defined; just update the last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023135Z" creationid="xccui" creationdate="20190701T023135Z">
        <seg>// 之前的温度还未定义，只需更新前一个温度值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// not the first evaluation, emit an update</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034446Z" creationid="xccui" creationdate="20190629T034446Z">
        <seg>// 并非首次计算，发出更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// number of restart attempts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154437Z" creationid="xingcan" creationdate="20190801T154437Z">
        <seg>// 重启尝试次数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// obtain the keyed state handle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041843Z" creationid="xccui" creationdate="20190702T041843Z">
        <seg>// 获取键值分区状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// obtain the state handle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064429Z" creationid="xccui" creationdate="20190630T064324Z">
        <seg>// 获得状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// open socket and writer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024838Z" creationid="xccui" creationdate="20190714T024714Z">
        <seg>// 打开套接字并获得写入器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// optional: specify the evictor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014922Z" creationid="xccui" creationdate="20190626T014922Z">
        <seg>// 可选项：指定移除器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// optional: specify the trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014906Z" creationid="xccui" creationdate="20190626T014906Z">
        <seg>// 可选项：指定触发器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// organize readings by sensor id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042353Z" creationid="xccui" creationdate="20190612T042353Z">
        <seg>// 按照传感器id组织数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// output the lowest and highest temperature reading every 5 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030641Z" creationid="xccui" creationdate="20190625T030641Z">
        <seg>// 每5秒输出最低温和最高温读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// override the application-wide value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025201Z" creationid="xccui" creationdate="20190703T025142Z">
        <seg>// 会覆盖应用级别的数值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// partition and key the stream on the sensor ID</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062056Z" creationid="xccui" creationdate="20190630T062056Z">
        <seg>// 根据传感器ID进行键值分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// path of transaction file is built from current time and task index</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041404Z" creationid="xccui" creationdate="20190716T041404Z">
        <seg>// 事务文件的路径由当前时间和任务索引决定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// port of JobManager process</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045623Z" creationid="xccui" creationdate="20190612T045623Z">
        <seg>// JobManager的端口号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// prepare insert and update statements</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045242Z" creationid="xccui" creationdate="20190714T045242Z">
        <seg>// 预编译插入及更新语句</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// print header line of dashboard table</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040215Z" creationid="xccui" creationdate="20190707T040215Z">
        <seg>// 打印仪表盘展示表的标题行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// print result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041330Z" creationid="xccui" creationdate="20190707T041330Z">
        <seg>// 打印结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// print result stream to standard out</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042754Z" creationid="xccui" creationdate="20190612T042754Z">
        <seg>// 将结果流打印到标准输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// print the main output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022926Z" creationid="xccui" creationdate="20190622T022926Z">
        <seg>// 打印主输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// process late readings for 5 additional seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165246Z" creationid="xingcan" creationdate="20190628T165246Z">
        <seg>// 额外处理5秒的迟到读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// processing-time session windows assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061532Z" creationid="xccui" creationdate="20190623T061532Z">
        <seg>// 处理时间会话窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// processing-time sliding windows assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060124Z" creationid="xccui" creationdate="20190623T060124Z">
        <seg>// 处理时间滑动窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// project to sensor id and temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062146Z" creationid="xccui" creationdate="20190706T062146Z">
        <seg>// 仅保留传感器id和温度字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// provide TypeInformation for the map lambda function's return type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062250Z" creationid="xccui" creationdate="20190617T062250Z">
        <seg>// 为map lambda函数的返回类型提供TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// provide the TypeInformation for the output data type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061937Z" creationid="xccui" creationdate="20190617T061937Z">
        <seg>// 为输出数据类型提供TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// register initial timer only for first element</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200413Z" creationid="xccui" creationdate="20190626T200413Z">
        <seg>// 仅为第一个元素注册初始计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// register next early firing timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200822Z" creationid="xccui" creationdate="20190626T200822Z">
        <seg>// 注册下一个用于提前触发的计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// register state for last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210327Z" creationid="xccui" creationdate="20190704T210327Z">
        <seg>// 注册用于最近一次温度的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// register state for last timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210431Z" creationid="xccui" creationdate="20190704T210348Z">
        <seg>// 注册用于前一个计时器的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// register timer for the window end ctx.registerEventTimeTimer(window.getEnd) firstSeen.update(true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200624Z" creationid="xccui" creationdate="20190626T200624Z">
        <seg>// 为窗口结束时间注册计时器 ctx.registerEventTimeTimer(window.getEnd) firstSeen.update(true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// remember current timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T071725Z">
        <seg>// 记住当前的计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// remove all state; forward switch will be false by default</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032654Z" creationid="xccui" creationdate="20190622T032654Z">
        <seg>// 移除所有状态，默认情况下转发开关关闭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// remove current timer and register new timer ctx.timerService().deleteEventTimeTimer(curTimerTimestamp) ctx.timerService().registerProcessingTimeTimer(timerTimestamp) disableTimer.update(timerTimestamp)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T033311Z" creationid="xccui" creationdate="20190622T032411Z">
        <seg>// 移除当前计时器并注册一个新的 ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp) ctx.timerService().registerProcessingTimeTimer(timerTimestamp) disableTimer.update(timerTimestamp)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// remove previous cnt</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034121Z" creationid="xccui" creationdate="20190713T034121Z">
        <seg>// 删除之前的cnt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// remove threshold for the sensor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042634Z" creationid="xccui" creationdate="20190702T042618Z">
        <seg>// 删除该传感器的阈值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// restore state by adding all longs of the list</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052858Z" creationid="xccui" creationdate="20190701T052858Z">
        <seg>// 将状态恢复为列表中的全部long值之和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// restores the state of the function from the provided list</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T045521Z" creationid="xccui" creationdate="20190701T045521Z">
        <seg>// 根据提供的列表恢复函数状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// retrieve and print the freezing alarms side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023910Z" creationid="xccui" creationdate="20190622T022908Z">
        <seg>// 获取并打印包含冷冻警报的副输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// retrieve late readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155640Z" creationid="xingcan" creationdate="20190628T155640Z">
        <seg>// 获取迟到读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// retrieve the late events from the side output as a stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155122Z" creationid="xingcan" creationdate="20190628T155122Z">
        <seg>// 从副输出中获取迟到事件的数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// return count as ten parts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062844Z" creationid="xccui" creationdate="20190701T062844Z">
        <seg>// 将计数值作为10个子部分返回</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// return record timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051156Z" creationid="xccui" creationdate="20190620T051156Z">
        <seg>// 返回记录的时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// return room</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211750Z" creationid="xccui" creationdate="20190716T211750Z">
        <seg>// 返回房间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a snapshot the state of the function as a list</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T045506Z" creationid="xccui" creationdate="20190701T045506Z">
        <seg>// 以列表形式返回一个函数状态的快照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// rounding down by 30 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044057Z" creationid="xccui" creationdate="20190626T044057Z">
        <seg>// 30秒取余</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// second stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040744Z" creationid="xccui" creationdate="20190615T040744Z">
        <seg>// 第二条流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// send out async queries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041304Z" creationid="xccui" creationdate="20190707T041304Z">
        <seg>// 发出异步查询</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// serialization schema</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T145408Z" creationid="xingcan" creationdate="20190709T144909Z">
        <seg>// 序列化的Schema</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set checkpointing interval to 10 seconds (10000 milliseconds)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204847Z" creationid="xccui" creationdate="20190702T204847Z">
        <seg>// 将检查点的生成周期设置为10秒（10000毫秒）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set disable forward timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032334Z" creationid="xccui" creationdate="20190622T032334Z">
        <seg>// 设置停止计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set mode to at-least-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T031003Z" creationid="xccui" creationdate="20190731T031003Z">
        <seg>// 设置为至少一次模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set parallelism of the environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060453Z" creationid="xccui" creationdate="20190616T060453Z">
        <seg>// 设置环境的并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set parallelism to 1 because only one thread can write to a socket</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024030Z" creationid="xccui" creationdate="20190714T024030Z">
        <seg>// 因为只有一个线程可以写入，所以设置并行度为1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set parameters for insert statement insertStmt.setString(1, r.id) insertStmt.setDouble(2, r.temperature)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045826Z" creationid="xccui" creationdate="20190714T045826Z">
        <seg>// 为插入语句设置参数 insertStmt.setString(1, r.id) insertStmt.setDouble(2, r.temperature)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set parameters for update statement and execute it updateStmt.setDouble(1, r.temperature) updateStmt.setString(2, r.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045417Z" creationid="xccui" creationdate="20190714T045417Z">
        <seg>// 设置更新语句的参数并执行 updateStmt.setDouble(1, r.temperature) updateStmt.setString(2, r.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set predefined options for spinning disk storage</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030935Z" creationid="xccui" creationdate="20190801T030935Z">
        <seg>// 设置针对机械磁盘存储的预定义选项</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set processing time timer for now + 1 second</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T071708Z">
        <seg>// 以当前时间+1秒设置处理时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set state backend</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022114Z" creationid="xccui" creationdate="20190801T022114Z">
        <seg>// 设置状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set the 2nd field to 42</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040517Z" creationid="xccui" creationdate="20190617T040501Z">
        <seg>// 将第二个字段设为42</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set the event time characteristic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044631Z" creationid="xccui" creationdate="20190620T044631Z">
        <seg>// 设置为事件时间特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set the maximum parallelism for this application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T024921Z" creationid="xccui" creationdate="20190703T025044Z">
        <seg>// 为应用设置最大并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set the maximum parallelism for this operator and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025128Z" creationid="xccui" creationdate="20190703T025128Z">
        <seg>// 为此算子设置最大并行度，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set up the streaming execution environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044717Z" creationid="xccui" creationdate="20190612T041910Z">
        <seg>// 设置流式执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shortcut for window.(SlidingEventTimeWindow.of(size, slide))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060210Z" creationid="xccui" creationdate="20190623T060210Z">
        <seg>// window.(SlidingEventTimeWindow.of(size, slide))的简写</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shortcut for window.(TumblingEventTimeWindows.of(size))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T053727Z" creationid="xccui" creationdate="20190623T053727Z">
        <seg>// window.(TumblingEventTimeWindows.of(size))的简写</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// sliding windows assigner using a shortcut method</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060157Z" creationid="xccui" creationdate="20190623T060157Z">
        <seg>// 使用窗口分配器简写方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// slot-sharing group "blue"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015414Z" creationid="xccui" creationdate="20190731T015414Z">
        <seg>// 处理槽共享组"blue"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// slot-sharing group "blue" is inherited from d</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015437Z" creationid="xccui" creationdate="20190731T015437Z">
        <seg>//从d继承处理槽共享组"blue"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// slot-sharing group "green"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015235Z" creationid="xccui" creationdate="20190731T015235Z">
        <seg>// 处理槽共享组"green"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// slot-sharing group "green" is inherited from a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015307Z" creationid="xccui" creationdate="20190731T015307Z">
        <seg>// 从a继承处理槽共享组"green"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// slot-sharing group "yellow"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015322Z" creationid="xccui" creationdate="20190731T015322Z">
        <seg>// 处理槽共享组"yellow"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// snapshot state as list with a single count</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T053234Z" creationid="xccui" creationdate="20190701T053234Z">
        <seg>// 将一个包含单个数目值的列表作为状态快照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// specify the JoinFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040220Z" creationid="xccui" creationdate="20190628T040220Z">
        <seg>// 指定JoinFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// specify the window assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041351Z" creationid="xccui" creationdate="20190622T041351Z">
        <seg>// 指定窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// split count into ten partial counts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062725Z" creationid="xccui" creationdate="20190701T062725Z">
        <seg>// 将计数值分成10个子部分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// start a new chain for Map2 and Filter2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T204402Z" creationid="xccui" creationdate="20190730T204402Z">
        <seg>// 为Map2和Filter2开启一个新的链接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// start master process</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T032417Z" creationid="xccui" creationdate="20190718T032417Z">
        <seg>// 启动主进程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// start worker process (adjust the name to start more than one TM) docker run -d --name flink-taskmanager-1 \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T032510Z" creationid="xccui" creationdate="20190718T032510Z">
        <seg>// 启动工作进程（启动多个TM时请选用不同名称） docker run -d --name flink-taskmanager-1 \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// state to check if this is the first evaluation of the window or not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034320Z" creationid="xccui" creationdate="20190629T034320Z">
        <seg>// 该状态用于标识是否是第一次对窗口进行计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// store max temperature of the last 10 secs for each sensor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062248Z" creationid="xccui" creationdate="20190706T062248Z">
        <seg>// 将每个传感器每10秒的最高温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// stores temperature of last sensor reading</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071510Z" creationid="xccui" creationdate="20190621T071334Z">
        <seg>// 存储最近一次传感器温度读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// stores timestamp of currently active timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T071403Z">
        <seg>// 存储当前活动计时器的时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// submit query and wait for result; this is a synchronous call</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211108Z" creationid="xccui" creationdate="20190716T211059Z">
        <seg>// 提交查询并等待结果，该调用是异步的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// subtasks are 0-indexed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T150730Z" creationid="xccui" creationdate="20190619T034418Z">
        <seg>// 子任务索引号从0开始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// sum the second field of the tuple in place</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T062132Z" creationid="xccui" creationdate="20190614T054550Z">
        <seg>// 滚动计算每个分区内元组第二个字段的总和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// switch to enable forwarding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T022842Z" creationid="xccui" creationdate="20190622T032055Z">
        <seg>// 转发开关</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// synchronize data emission and checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034040Z" creationid="xccui" creationdate="20190713T034040Z">
        <seg>// 使数据发出和检查点同步</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// target topic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T144806Z" creationid="xingcan" creationdate="20190709T144806Z">
        <seg>// 目标主题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// temperature changed by more than the threshold</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064508Z" creationid="xccui" creationdate="20190630T064508Z">
        <seg>// 温度变化超过阈值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// temperature decreased; delete current timer ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp) currentTimer.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T071603Z">
        <seg>// 温度下降，删除当前计时器 ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp) currentTimer.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// temperature increased and we have not set a timer yet</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T071647Z">
        <seg>// 温度升高并且还未设置计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// temperature increased by more than the threshold</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042813Z" creationid="xccui" creationdate="20190702T042813Z">
        <seg>// 温度增加超过阈值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the descriptor of the broadcast state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024323Z" creationid="xccui" creationdate="20190702T024323Z">
        <seg>// 广播状态的描述符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the descriptor of the broadcast state private lazy val thresholdStateDescriptor = new MapStateDescriptor[String, Double](</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041348Z" creationid="xccui" creationdate="20190702T041348Z">
        <seg>// 广播状态的描述符 private lazy val thresholdStateDescriptor = new MapStateDescriptor[String, Double](</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the keyed state handle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190702T041407Z">
        <seg>// 键值分区状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the keyed state handle for the last registered timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210438Z" creationid="xccui" creationdate="20190704T210223Z">
        <seg>// 前一个注册的计时器的键值分区状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the keyed state handle for the last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205652Z" creationid="xccui" creationdate="20190704T205652Z">
        <seg>// 用于存储最近一次温度的键值分区状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the map parallelism is set to double the default parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061644Z" creationid="xccui" creationdate="20190616T061644Z">
        <seg>// 设置map的并行度为默认并行度的两倍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the print sink parallelism is fixed to 2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061714Z" creationid="xccui" creationdate="20190616T061714Z">
        <seg>// print数据汇的并行度固定为2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the source runs with the default parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061610Z" creationid="xccui" creationdate="20190616T061610Z">
        <seg>// 数据源以默认并行度运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the state handle object</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064308Z" creationid="xccui" creationdate="20190630T064223Z">
        <seg>// 状态句柄对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this is a late reading =&gt; redirect it to the side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155935Z" creationid="xingcan" creationdate="20190628T155935Z">
        <seg>// 将迟到读数重定向到副输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// threshold exceeded; emit an alert and update the last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023316Z" creationid="xccui" creationdate="20190701T023253Z">
        <seg>// 超出阈值，发出警报并更新前一个温度值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// threshold not exceeded; just update the last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023334Z" creationid="xccui" creationdate="20190701T023310Z">
        <seg>// 没有超出阈值，仅更新前一个温度值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// timeout requests after 5 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201755Z" creationid="xccui" creationdate="20190716T201755Z">
        <seg>// 请求超时时间为5秒</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// to register timer callbacks and deal with state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192549Z" creationid="xccui" creationdate="20190626T192549Z">
        <seg>// 使其可以注册计时器回调并处理状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// to the /tmp/ckp folder</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025102Z" creationid="xccui" creationdate="20190801T025102Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update histogram</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033656Z" creationid="xccui" creationdate="20190803T033656Z">
        <seg>// 更新直方图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update keyed high temp counter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162525Z" creationid="xccui" creationdate="20190702T162525Z">
        <seg>// 更新键值分区的高温计数器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071505Z" creationid="xccui" creationdate="20190621T071505Z">
        <seg>// 更新最近一次的温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update lastTemp state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064711Z" creationid="xccui" creationdate="20190630T064711Z">
        <seg>// 更新lastTemp状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update local operator high temp counter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162537Z" creationid="xccui" creationdate="20190702T162458Z">
        <seg>// 更新本地算子实例的高温计数器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update maximum timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051141Z" creationid="xccui" creationdate="20190620T051141Z">
        <seg>// 更新最大时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update operator state with local state opCntState.clear() opCntState.add(opHighTempCnt)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163406Z" creationid="xccui" creationdate="20190702T163406Z">
        <seg>// 利用本地的状态更新算子状态 opCntState.clear() opCntState.add(opHighTempCnt)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update timer timestamp state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210642Z" creationid="xccui" creationdate="20190704T210642Z">
        <seg>//更新计时器时间戳状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// use event time for the application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041934Z" creationid="xccui" creationdate="20190612T041934Z">
        <seg>// 在应用中使用事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// wait for results</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041318Z" creationid="xccui" creationdate="20190707T041318Z">
        <seg>// 等待结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// wait to send out next queries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041551Z" creationid="xccui" creationdate="20190707T041426Z">
        <seg>// 等待发送下一组查询</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// write record to standard out</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064409Z" creationid="xccui" creationdate="20190715T064409Z">
        <seg>// 将记录写到标准输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// write sensor reading to socket writer.println(value.toString) writer.flush()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024849Z" creationid="xccui" creationdate="20190714T024849Z">
        <seg>// 将传感器读数写入套接字 writer.println(value.toString) writer.flush()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// write the sensor readings to a Derby table</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045054Z" creationid="xccui" creationdate="20190714T045054Z">
        <seg>// 将传感器读数写入Derby表中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// write the sensor readings to a socket</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T023952Z" creationid="xccui" creationdate="20190714T023952Z">
        <seg>// 将传感器读数写入套接字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// write the sensor readings to the standard out via a write-ahead log</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064228Z" creationid="xccui" creationdate="20190715T064228Z">
        <seg>// 利用WAL将传感器读数写入标准输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/savepoints/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T020448Z" creationid="xccui" creationdate="20190726T020448Z">
        <seg>/savepoints/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/savepoints/savepoint-:shortjobid-:savepointid/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T020546Z" creationid="xccui" creationdate="20190726T020546Z">
        <seg>/savepoints/savepoint-:shortjobid-:savepointid/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/savepoints/savepoint-:shortjobid-:savepointid/:xxx</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T021254Z" creationid="xccui" creationdate="20190726T021254Z">
        <seg>/savepoints/savepoint-:shortjobid-:savepointid/:xxx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/savepoints/savepoint-:shortjobid-:savepointid/_metadata</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T020643Z" creationid="xccui" creationdate="20190726T020643Z">
        <seg>/savepoints/savepoint-:shortjobid-:savepointid/_metadata</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0.10.x or later):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040430Z" creationid="xccui" creationdate="20190709T040430Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144704Z" creationid="esouser" creationdate="20190603T144704Z">
        <seg>1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 Flink’s batch processing API, the DataSet API, and its operators are separate from their corresponding streaming counterparts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122153Z" creationid="xccui" creationdate="20190605T122123Z">
        <seg>1 虽然Flink用于批处理的DataSet API及其算子都独立于对应的流处理部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 ListState and its performance characteristics are discussed in detail in Chapter 7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040517Z" creationid="xccui" creationdate="20190625T040517Z">
        <seg>1 有关ListState以及它的性能特征会在第7章详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 We also provide an examples-Java repository with all the examples implemented in Java.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T091304Z" creationid="xccui" creationdate="20190611T040200Z">
        <seg>1 我们还提供了一个examples-Java库，里面的示例都是用Java来完成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144730Z" creationid="esouser" creationdate="20190603T144730Z">
        <seg>10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 | Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130755Z" creationid="xccui" creationdate="20190605T130755Z">
        <seg>10 | 第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040413Z" creationid="xccui" creationdate="20190418T040413Z">
        <seg>10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>100</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035718Z" creationid="xccui" creationdate="20190418T035718Z">
        <seg>100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>100 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045154Z" creationid="xccui" creationdate="20190619T045154Z">
        <seg>100 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>100)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201759Z" creationid="xccui" creationdate="20190716T201759Z">
        <seg>100)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1005</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210838Z" creationid="esouser" creationdate="20190603T210838Z">
        <seg>1005</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>101</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035748Z" creationid="xccui" creationdate="20190418T035748Z">
        <seg>101</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>102</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035752Z" creationid="xccui" creationdate="20190418T035752Z">
        <seg>102</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>103</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145347Z" creationid="esouser" creationdate="20190603T145347Z">
        <seg>103</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>104</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145634Z" creationid="esouser" creationdate="20190603T145634Z">
        <seg>104</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>104 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045340Z" creationid="xccui" creationdate="20190619T045340Z">
        <seg>104 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>105</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035758Z" creationid="xccui" creationdate="20190418T035758Z">
        <seg>105</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>106</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145646Z" creationid="esouser" creationdate="20190603T145646Z">
        <seg>106</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>106 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045400Z" creationid="xccui" creationdate="20190619T045400Z">
        <seg>106 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>107</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145648Z" creationid="esouser" creationdate="20190603T145648Z">
        <seg>107</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>108</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035803Z" creationid="xccui" creationdate="20190418T035803Z">
        <seg>108</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>108 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045411Z" creationid="xccui" creationdate="20190619T045411Z">
        <seg>108 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>109</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145701Z" creationid="esouser" creationdate="20190603T145701Z">
        <seg>109</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040518Z" creationid="xccui" creationdate="20190418T040518Z">
        <seg>11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>110 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041850Z" creationid="xccui" creationdate="20190629T041850Z">
        <seg>110 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>111</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145756Z" creationid="esouser" creationdate="20190603T145756Z">
        <seg>111</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>112 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041907Z" creationid="xccui" creationdate="20190629T041907Z">
        <seg>112 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>113</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035807Z" creationid="xccui" creationdate="20190418T035807Z">
        <seg>113</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>115</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035811Z" creationid="xccui" creationdate="20190418T035811Z">
        <seg>115</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>116</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035815Z" creationid="xccui" creationdate="20190418T035815Z">
        <seg>116</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>117</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035819Z" creationid="xccui" creationdate="20190418T035819Z">
        <seg>117</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>118 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041922Z" creationid="xccui" creationdate="20190629T041922Z">
        <seg>118 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>119</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145851Z" creationid="esouser" creationdate="20190603T145851Z">
        <seg>119</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144741Z" creationid="esouser" creationdate="20190603T144741Z">
        <seg>12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>120</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035823Z" creationid="xccui" creationdate="20190418T035823Z">
        <seg>120</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>120 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041936Z" creationid="xccui" creationdate="20190629T041936Z">
        <seg>120 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>121</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035827Z" creationid="xccui" creationdate="20190418T035827Z">
        <seg>121</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>122</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035830Z" creationid="xccui" creationdate="20190418T035830Z">
        <seg>122</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>122 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041957Z" creationid="xccui" creationdate="20190629T041957Z">
        <seg>122 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>123</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150326Z" creationid="esouser" creationdate="20190603T150326Z">
        <seg>123</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1234,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054737Z" creationid="xccui" creationdate="20190612T054737Z">
        <seg>1234,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>124</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035833Z" creationid="xccui" creationdate="20190418T035833Z">
        <seg>124</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>125</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035837Z" creationid="xccui" creationdate="20190418T035837Z">
        <seg>125</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>126</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035840Z" creationid="xccui" creationdate="20190418T035840Z">
        <seg>126</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>127</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035847Z" creationid="xccui" creationdate="20190418T035847Z">
        <seg>127</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>129</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035856Z" creationid="xccui" creationdate="20190418T035856Z">
        <seg>129</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>13</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144752Z" creationid="esouser" creationdate="20190603T144752Z">
        <seg>13</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>130 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042016Z" creationid="xccui" creationdate="20190629T042016Z">
        <seg>130 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>131</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035859Z" creationid="xccui" creationdate="20190418T035859Z">
        <seg>131</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>132 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042020Z" creationid="xccui" creationdate="20190629T042020Z">
        <seg>132 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>134</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150328Z" creationid="esouser" creationdate="20190603T150328Z">
        <seg>134</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>135</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035903Z" creationid="xccui" creationdate="20190418T035903Z">
        <seg>135</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>136</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035913Z" creationid="xccui" creationdate="20190418T035913Z">
        <seg>136</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>137</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035917Z" creationid="xccui" creationdate="20190418T035917Z">
        <seg>137</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>14 | Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130837Z" creationid="xccui" creationdate="20190605T130837Z">
        <seg>14 | 10 | 第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>140</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035921Z" creationid="xccui" creationdate="20190418T035921Z">
        <seg>140</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>140 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042025Z" creationid="xccui" creationdate="20190629T042025Z">
        <seg>140 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>141</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035925Z" creationid="xccui" creationdate="20190418T035925Z">
        <seg>141</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>142</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035928Z" creationid="xccui" creationdate="20190418T035928Z">
        <seg>142</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>142 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042030Z" creationid="xccui" creationdate="20190629T042030Z">
        <seg>142 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>143</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035932Z" creationid="xccui" creationdate="20190418T035932Z">
        <seg>143</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>144</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035936Z" creationid="xccui" creationdate="20190418T035936Z">
        <seg>144</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>145</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150330Z" creationid="esouser" creationdate="20190603T150330Z">
        <seg>145</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>146</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210747Z" creationid="esouser" creationdate="20190603T210747Z">
        <seg>146</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>146 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042033Z" creationid="xccui" creationdate="20190629T042033Z">
        <seg>146 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>148</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210748Z" creationid="esouser" creationdate="20190603T210748Z">
        <seg>148</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>149</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035940Z" creationid="xccui" creationdate="20190418T035940Z">
        <seg>149</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>15</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014613Z" creationid="xccui" creationdate="20190225T014613Z">
        <seg>15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>150</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150822Z" creationid="esouser" creationdate="20190603T150822Z">
        <seg>150</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>150 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042039Z" creationid="xccui" creationdate="20190629T042039Z">
        <seg>150 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>152</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150824Z" creationid="esouser" creationdate="20190603T150824Z">
        <seg>152</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>152 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042046Z" creationid="xccui" creationdate="20190629T042046Z">
        <seg>152 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>153</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150825Z" creationid="esouser" creationdate="20190603T150825Z">
        <seg>153</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>154</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150827Z" creationid="esouser" creationdate="20190603T150827Z">
        <seg>154</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>154 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051735Z" creationid="xccui" creationdate="20190707T051735Z">
        <seg>154 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>156</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035944Z" creationid="xccui" creationdate="20190418T035944Z">
        <seg>156</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>158</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150921Z" creationid="esouser" creationdate="20190603T150921Z">
        <seg>158</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>16</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172722Z" creationid="xccui" creationdate="20190228T172722Z">
        <seg>16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>160</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150929Z" creationid="esouser" creationdate="20190603T150929Z">
        <seg>160</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>160 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051745Z" creationid="xccui" creationdate="20190707T051745Z">
        <seg>160 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>162 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051754Z" creationid="xccui" creationdate="20190707T051754Z">
        <seg>162 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>164</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151101Z" creationid="esouser" creationdate="20190603T151101Z">
        <seg>164</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>166</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151123Z" creationid="esouser" creationdate="20190603T151123Z">
        <seg>166</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>167</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035947Z" creationid="xccui" creationdate="20190418T035947Z">
        <seg>167</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>168</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151126Z" creationid="esouser" creationdate="20190603T151126Z">
        <seg>168</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>168 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051759Z" creationid="xccui" creationdate="20190707T051759Z">
        <seg>168 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>169</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035951Z" creationid="xccui" creationdate="20190418T035951Z">
        <seg>169</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>17</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045711Z" creationid="xccui" creationdate="20190329T045711Z">
        <seg>17</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>170</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035954Z" creationid="xccui" creationdate="20190418T035954Z">
        <seg>170</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>170 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051804Z" creationid="xccui" creationdate="20190707T051804Z">
        <seg>170 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>171</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035958Z" creationid="xccui" creationdate="20190418T035958Z">
        <seg>171</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>172</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040002Z" creationid="xccui" creationdate="20190418T040002Z">
        <seg>172</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>172 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051809Z" creationid="xccui" creationdate="20190707T051809Z">
        <seg>172 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>174</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040006Z" creationid="xccui" creationdate="20190418T040006Z">
        <seg>174</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>174 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051813Z" creationid="xccui" creationdate="20190707T051813Z">
        <seg>174 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>175</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040024Z" creationid="xccui" creationdate="20190418T040024Z">
        <seg>175</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>176</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040028Z" creationid="xccui" creationdate="20190418T040028Z">
        <seg>176</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>176 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051818Z" creationid="xccui" creationdate="20190707T051818Z">
        <seg>176 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>177</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151128Z" creationid="esouser" creationdate="20190603T151128Z">
        <seg>177</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>178 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051824Z" creationid="xccui" creationdate="20190707T051824Z">
        <seg>178 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>179</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151753Z" creationid="esouser" creationdate="20190603T151753Z">
        <seg>179</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>18</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014603Z" creationid="xccui" creationdate="20190225T014603Z">
        <seg>18</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>18 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041412Z" creationid="xccui" creationdate="20190606T041310Z">
        <seg>18 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>180</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040032Z" creationid="xccui" creationdate="20190418T040032Z">
        <seg>180</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>180 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051831Z" creationid="xccui" creationdate="20190707T051831Z">
        <seg>180 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>182</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040043Z" creationid="xccui" creationdate="20190418T040043Z">
        <seg>182</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>182 | Chapter 7: Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051841Z" creationid="xccui" creationdate="20190707T051841Z">
        <seg>182 | 第7章：状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>183</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151755Z" creationid="esouser" creationdate="20190603T151755Z">
        <seg>183</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>184</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151757Z" creationid="esouser" creationdate="20190603T151757Z">
        <seg>184</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>184 | Chapter 8: Reading from and Writing to External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023117Z" creationid="xccui" creationdate="20190717T023117Z">
        <seg>184 | 第8章：读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>185</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040048Z" creationid="xccui" creationdate="20190418T040048Z">
        <seg>185</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>186</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152029Z" creationid="esouser" creationdate="20190603T152029Z">
        <seg>186</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>186 | Chapter 8: Reading from and Writing to External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023127Z" creationid="xccui" creationdate="20190717T023127Z">
        <seg>186 | 第8章：读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>187</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040052Z" creationid="xccui" creationdate="20190418T040052Z">
        <seg>187</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>188</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040055Z" creationid="xccui" creationdate="20190418T040055Z">
        <seg>188</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>189</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040059Z" creationid="xccui" creationdate="20190418T040059Z">
        <seg>189</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>19</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045716Z" creationid="xccui" creationdate="20190329T045716Z">
        <seg>19</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>190</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040104Z" creationid="xccui" creationdate="20190418T040104Z">
        <seg>190</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>190 | Chapter 8: Reading from and Writing to External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023131Z" creationid="xccui" creationdate="20190717T023131Z">
        <seg>190 | 第8章：读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>191</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040107Z" creationid="xccui" creationdate="20190418T040107Z">
        <seg>191</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>192</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040111Z" creationid="xccui" creationdate="20190418T040111Z">
        <seg>192</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>192 | Chapter 8: Reading from and Writing to External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023138Z" creationid="xccui" creationdate="20190717T023138Z">
        <seg>192 | 第8章：读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>193</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040114Z" creationid="xccui" creationdate="20190418T040114Z">
        <seg>193</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>194</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210750Z" creationid="esouser" creationdate="20190603T210750Z">
        <seg>194</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>195</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040118Z" creationid="xccui" creationdate="20190418T040118Z">
        <seg>195</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>196</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040121Z" creationid="xccui" creationdate="20190418T040121Z">
        <seg>196</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>197</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040125Z" creationid="xccui" creationdate="20190418T040125Z">
        <seg>197</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>198</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040128Z" creationid="xccui" creationdate="20190418T040128Z">
        <seg>198</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>199</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040132Z" creationid="xccui" creationdate="20190418T040132Z">
        <seg>199</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1&gt; SensorReading(sensor_38,1515014051000,14.781835420242471)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043437Z" creationid="xccui" creationdate="20190611T043437Z">
        <seg>1&gt; SensorReading(sensor_38,1515014051000,14.781835420242471)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144708Z" creationid="esouser" creationdate="20190603T144708Z">
        <seg>2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035445Z" creationid="xccui" creationdate="20190418T035445Z">
        <seg>2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>20</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152503Z" creationid="xccui" creationdate="20190307T152503Z">
        <seg>20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>20 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041409Z" creationid="xccui" creationdate="20190606T041349Z">
        <seg>20 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>200</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040135Z" creationid="xccui" creationdate="20190418T040135Z">
        <seg>200</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2019-04-03: First Release</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210733Z" creationid="esouser" creationdate="20190603T210733Z">
        <seg>2019-04-03: First Release</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>202</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040138Z" creationid="xccui" creationdate="20190418T040138Z">
        <seg>202</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>203</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152055Z" creationid="esouser" creationdate="20190603T152055Z">
        <seg>203</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>204</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040141Z" creationid="xccui" creationdate="20190418T040141Z">
        <seg>204</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>204 | Chapter 8: Reading from and Writing to External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023144Z" creationid="xccui" creationdate="20190717T023144Z">
        <seg>204 | 第8章：读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>205</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040153Z" creationid="xccui" creationdate="20190418T040153Z">
        <seg>205</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>206</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152112Z" creationid="esouser" creationdate="20190603T152112Z">
        <seg>206</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>207</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152114Z" creationid="esouser" creationdate="20190603T152114Z">
        <seg>207</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>208</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040157Z" creationid="xccui" creationdate="20190418T040157Z">
        <seg>208</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>208 | Chapter 8: Reading from and Writing to External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023151Z" creationid="xccui" creationdate="20190717T023151Z">
        <seg>208 | 第8章：读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>209</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040201Z" creationid="xccui" creationdate="20190418T040201Z">
        <seg>209</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>21</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045720Z" creationid="xccui" creationdate="20190329T045720Z">
        <seg>21</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>210 | Chapter 8: Reading from and Writing to External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023157Z" creationid="xccui" creationdate="20190717T023157Z">
        <seg>210 | 第8章：读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>212</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040206Z" creationid="xccui" creationdate="20190418T040206Z">
        <seg>212</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>212 | Chapter 8: Reading from and Writing to External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023202Z" creationid="xccui" creationdate="20190717T023202Z">
        <seg>212 | 第8章：读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>216</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040209Z" creationid="xccui" creationdate="20190418T040209Z">
        <seg>216</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>218</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040212Z" creationid="xccui" creationdate="20190418T040212Z">
        <seg>218</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>218 | Chapter 8: Reading from and Writing to External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023206Z" creationid="xccui" creationdate="20190717T023206Z">
        <seg>218 | 第8章：读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>219</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152116Z" creationid="esouser" creationdate="20190603T152116Z">
        <seg>219</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>22</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045724Z" creationid="xccui" creationdate="20190329T045724Z">
        <seg>22</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>22 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041429Z" creationid="xccui" creationdate="20190606T041429Z">
        <seg>22 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>221</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040216Z" creationid="xccui" creationdate="20190418T040216Z">
        <seg>221</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>222 | Chapter 9: Setting Up Flink for Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042707Z" creationid="xccui" creationdate="20190725T042339Z">
        <seg>222 | 第9章：搭建Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>223</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152140Z" creationid="esouser" creationdate="20190603T152140Z">
        <seg>223</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>224</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040219Z" creationid="xccui" creationdate="20190418T040219Z">
        <seg>224</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>225</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040223Z" creationid="xccui" creationdate="20190418T040223Z">
        <seg>225</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>227</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040226Z" creationid="xccui" creationdate="20190418T040226Z">
        <seg>227</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>228</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040230Z" creationid="xccui" creationdate="20190418T040230Z">
        <seg>228</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>23</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045729Z" creationid="xccui" creationdate="20190329T045729Z">
        <seg>23</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>230</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040234Z" creationid="xccui" creationdate="20190418T040234Z">
        <seg>230</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>230 | Chapter 9: Setting Up Flink for Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042730Z" creationid="xccui" creationdate="20190725T042730Z">
        <seg>230 | 第9章：搭建Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>231</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040244Z" creationid="xccui" creationdate="20190418T040244Z">
        <seg>231</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>232</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152149Z" creationid="esouser" creationdate="20190603T152149Z">
        <seg>232</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>232 | Chapter 9: Setting Up Flink for Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042741Z" creationid="xccui" creationdate="20190725T042741Z">
        <seg>232 | 第9章：搭建Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>233</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152208Z" creationid="esouser" creationdate="20190603T152208Z">
        <seg>233</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>234</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152229Z" creationid="esouser" creationdate="20190603T152229Z">
        <seg>234</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>235</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152242Z" creationid="esouser" creationdate="20190603T152242Z">
        <seg>235</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>236</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152243Z" creationid="esouser" creationdate="20190603T152243Z">
        <seg>236</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>237</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152254Z" creationid="esouser" creationdate="20190603T152254Z">
        <seg>237</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>238</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040248Z" creationid="xccui" creationdate="20190418T040248Z">
        <seg>238</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>238 | Chapter 9: Setting Up Flink for Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042839Z" creationid="xccui" creationdate="20190725T042839Z">
        <seg>238 | 第9章：搭建Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>239</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152259Z" creationid="esouser" creationdate="20190603T152259Z">
        <seg>239</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>24</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045734Z" creationid="xccui" creationdate="20190329T045734Z">
        <seg>24</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>240</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152301Z" creationid="esouser" creationdate="20190603T152301Z">
        <seg>240</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>240 | Chapter 9: Setting Up Flink for Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042853Z" creationid="xccui" creationdate="20190725T042853Z">
        <seg>240 | 第9章：搭建Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>241</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040252Z" creationid="xccui" creationdate="20190418T040252Z">
        <seg>241</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>242</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152303Z" creationid="esouser" creationdate="20190603T152303Z">
        <seg>242</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>242 | Chapter 9: Setting Up Flink for Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042909Z" creationid="xccui" creationdate="20190725T042909Z">
        <seg>242 | 第9章：搭建Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>243</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040304Z" creationid="xccui" creationdate="20190418T040304Z">
        <seg>243</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>244</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152336Z" creationid="esouser" creationdate="20190603T152336Z">
        <seg>244</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>244 | Chapter 9: Setting Up Flink for Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042922Z" creationid="xccui" creationdate="20190725T042922Z">
        <seg>244 | 第9章：搭建Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>245</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152338Z" creationid="esouser" creationdate="20190603T152338Z">
        <seg>245</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>246</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040311Z" creationid="xccui" creationdate="20190418T040311Z">
        <seg>246</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>246 | Chapter 10: Operating Flink and Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040121Z" creationid="xccui" creationdate="20190807T040121Z">
        <seg>246 | 第10章：Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>247</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040319Z" creationid="xccui" creationdate="20190418T040319Z">
        <seg>247</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>248 | Chapter 10: Operating Flink and Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040131Z" creationid="xccui" creationdate="20190807T040131Z">
        <seg>248 | 第10章：Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>25</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032750Z" creationid="xccui" creationdate="20190327T032750Z">
        <seg>25</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>250 | Chapter 10: Operating Flink and Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040136Z" creationid="xccui" creationdate="20190807T040136Z">
        <seg>250 | 第10章：Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>251</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040329Z" creationid="xccui" creationdate="20190418T040329Z">
        <seg>251</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>252</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152340Z" creationid="esouser" creationdate="20190603T152340Z">
        <seg>252</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>252 | Chapter 10: Operating Flink and Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040143Z" creationid="xccui" creationdate="20190807T040143Z">
        <seg>252 | 第10章：Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>255</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040332Z" creationid="xccui" creationdate="20190418T040332Z">
        <seg>255</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>256</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040336Z" creationid="xccui" creationdate="20190418T040336Z">
        <seg>256</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>257</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040340Z" creationid="xccui" creationdate="20190418T040340Z">
        <seg>257</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>258</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040344Z" creationid="xccui" creationdate="20190418T040344Z">
        <seg>258</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>259</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040347Z" creationid="xccui" creationdate="20190418T040347Z">
        <seg>259</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>26</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042440Z" creationid="xccui" creationdate="20190328T042440Z">
        <seg>26</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>260</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152342Z" creationid="esouser" creationdate="20190603T152342Z">
        <seg>260</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>260 | Chapter 10: Operating Flink and Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040147Z" creationid="xccui" creationdate="20190807T040147Z">
        <seg>260 | 第10章：Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>261</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040350Z" creationid="xccui" creationdate="20190418T040350Z">
        <seg>261</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>262</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040354Z" creationid="xccui" creationdate="20190418T040354Z">
        <seg>262</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>262 | Chapter 10: Operating Flink and Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040151Z" creationid="xccui" creationdate="20190807T040151Z">
        <seg>262 | 第10章：Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>263</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040357Z" creationid="xccui" creationdate="20190418T040357Z">
        <seg>263</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>264</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040400Z" creationid="xccui" creationdate="20190418T040400Z">
        <seg>264</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>265</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040404Z" creationid="xccui" creationdate="20190418T040404Z">
        <seg>265</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>266</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040408Z" creationid="xccui" creationdate="20190418T040408Z">
        <seg>266</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>267</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040417Z" creationid="xccui" creationdate="20190418T040417Z">
        <seg>267</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>268</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040422Z" creationid="xccui" creationdate="20190418T040422Z">
        <seg>268</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>269</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040426Z" creationid="xccui" creationdate="20190418T040426Z">
        <seg>269</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>27</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045740Z" creationid="xccui" creationdate="20190329T045740Z">
        <seg>27</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>270</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152403Z" creationid="esouser" creationdate="20190603T152403Z">
        <seg>270</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>270 | Chapter 10: Operating Flink and Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040155Z" creationid="xccui" creationdate="20190807T040155Z">
        <seg>270 | 第10章：Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>272 | Chapter 10: Operating Flink and Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040201Z" creationid="xccui" creationdate="20190807T040201Z">
        <seg>272 | 第10章：Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>273</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152405Z" creationid="esouser" creationdate="20190603T152405Z">
        <seg>273</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>274</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040430Z" creationid="xccui" creationdate="20190418T040430Z">
        <seg>274</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>278</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152406Z" creationid="esouser" creationdate="20190603T152406Z">
        <seg>278</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>279</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040434Z" creationid="xccui" creationdate="20190418T040434Z">
        <seg>279</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>28</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042035Z" creationid="xccui" creationdate="20190329T042035Z">
        <seg>28</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>28 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041447Z" creationid="xccui" creationdate="20190606T041447Z">
        <seg>28 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>280</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152407Z" creationid="esouser" creationdate="20190603T152407Z">
        <seg>280</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>280 | Chapter 10: Operating Flink and Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040206Z" creationid="xccui" creationdate="20190807T040206Z">
        <seg>280 | 第10章：Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>281</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152417Z" creationid="esouser" creationdate="20190603T152417Z">
        <seg>281</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>282</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040438Z" creationid="xccui" creationdate="20190418T040438Z">
        <seg>282</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>282 | Chapter 11: Where to Go from Here?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T163133Z" creationid="xingcan" creationdate="20190807T163133Z">
        <seg>282 | 第11章：还有什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>283</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040442Z" creationid="xccui" creationdate="20190418T040442Z">
        <seg>283</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>285</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040446Z" creationid="xccui" creationdate="20190418T040446Z">
        <seg>285</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>288</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040449Z" creationid="xccui" creationdate="20190418T040449Z">
        <seg>288</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>289</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040453Z" creationid="xccui" creationdate="20190418T040453Z">
        <seg>289</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>29</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041918Z" creationid="xccui" creationdate="20190329T041918Z">
        <seg>29</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>292</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040457Z" creationid="xccui" creationdate="20190418T040457Z">
        <seg>292</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>295</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040501Z" creationid="xccui" creationdate="20190418T040501Z">
        <seg>295</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2&gt; SensorReading(sensor_31,1515014051000,23.924656183848732)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043428Z" creationid="xccui" creationdate="20190611T043428Z">
        <seg>2&gt; SensorReading(sensor_31,1515014051000,23.924656183848732)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2PC sink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170233Z" creationid="xccui" creationdate="20190708T170233Z">
        <seg>2PC数据汇</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144712Z" creationid="esouser" creationdate="20190603T144712Z">
        <seg>3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024959Z" creationid="xccui" creationdate="20190329T024959Z">
        <seg>3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>30</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041931Z" creationid="xccui" creationdate="20190329T041931Z">
        <seg>30</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>300</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040504Z" creationid="xccui" creationdate="20190418T040504Z">
        <seg>300</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>30000L)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185037Z" creationid="xccui" creationdate="20190710T185037Z">
        <seg>30000L)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>301</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040508Z" creationid="xccui" creationdate="20190418T040508Z">
        <seg>301</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>302</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040511Z" creationid="xccui" creationdate="20190418T040511Z">
        <seg>302</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>303</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040524Z" creationid="xccui" creationdate="20190418T040524Z">
        <seg>303</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>305</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040528Z" creationid="xccui" creationdate="20190418T040528Z">
        <seg>305</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>307</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040548Z" creationid="xccui" creationdate="20190418T040548Z">
        <seg>307</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>309</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040556Z" creationid="xccui" creationdate="20190418T040556Z">
        <seg>309</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>31</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144754Z" creationid="esouser" creationdate="20190603T144754Z">
        <seg>31</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>32</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144246Z" creationid="esouser" creationdate="20190603T144246Z">
        <seg>32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>32°F.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023250Z" creationid="xccui" creationdate="20190622T023250Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>33</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000312Z" creationid="xccui" creationdate="20190401T000312Z">
        <seg>33</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>34</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032117Z" creationid="xccui" creationdate="20190401T032117Z">
        <seg>34</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>34 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041516Z" creationid="xccui" creationdate="20190606T041516Z">
        <seg>34 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>35</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142146Z" creationid="xccui" creationdate="20190401T142146Z">
        <seg>35</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>36</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195532Z" creationid="xccui" creationdate="20190401T195532Z">
        <seg>36</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>37</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195520Z" creationid="xccui" creationdate="20190401T195520Z">
        <seg>37</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>38</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210323Z" creationid="xccui" creationdate="20190402T210323Z">
        <seg>38</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>38 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032532Z" creationid="xccui" creationdate="20190610T032532Z">
        <seg>38 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>39</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152744Z" creationid="xccui" creationdate="20190405T152744Z">
        <seg>39</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3&gt; SensorReading(sensor_34,1515014051000,23.871433252250583)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043441Z" creationid="xccui" creationdate="20190611T043441Z">
        <seg>3&gt; SensorReading(sensor_34,1515014051000,23.871433252250583)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144716Z" creationid="esouser" creationdate="20190603T144716Z">
        <seg>4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4 | Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130806Z" creationid="xccui" creationdate="20190605T130806Z">
        <seg>4 | 第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035634Z" creationid="xccui" creationdate="20190418T035634Z">
        <seg>4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>40</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035845Z" creationid="xccui" creationdate="20190406T035845Z">
        <seg>40</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>41</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043712Z" creationid="xccui" creationdate="20190406T043712Z">
        <seg>41</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>42</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023551Z" creationid="xccui" creationdate="20190407T023551Z">
        <seg>42</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>43</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052401Z" creationid="xccui" creationdate="20190416T052401Z">
        <seg>43</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>44</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052407Z" creationid="xccui" creationdate="20190416T052407Z">
        <seg>44</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>45</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152127Z" creationid="xccui" creationdate="20190411T152127Z">
        <seg>45</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>46</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150539Z" creationid="xccui" creationdate="20190412T150539Z">
        <seg>46</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>46 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032601Z" creationid="xccui" creationdate="20190610T032601Z">
        <seg>46 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>47</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150532Z" creationid="xccui" creationdate="20190412T150532Z">
        <seg>47</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>48</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155341Z" creationid="xccui" creationdate="20190412T155341Z">
        <seg>48</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>48 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032635Z" creationid="xccui" creationdate="20190610T032635Z">
        <seg>48 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>49</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T041055Z" creationid="xccui" creationdate="20190414T041055Z">
        <seg>49</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4&gt; SensorReading(sensor_32,1515014051000,4.118569049862492)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043432Z" creationid="xccui" creationdate="20190611T043432Z">
        <seg>4&gt; SensorReading(sensor_32,1515014051000,4.118569049862492)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154425Z" creationid="xingcan" creationdate="20190801T154425Z">
        <seg>5,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5, TimeUnit.SECONDS,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201730Z" creationid="xccui" creationdate="20190716T201730Z">
        <seg>5, TimeUnit.SECONDS,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035624Z" creationid="xccui" creationdate="20190329T035624Z">
        <seg>5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>50</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055624Z" creationid="xccui" creationdate="20190414T055624Z">
        <seg>50</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>51</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042843Z" creationid="xccui" creationdate="20190415T042843Z">
        <seg>51</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>52</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041533Z" creationid="xccui" creationdate="20190416T041533Z">
        <seg>52</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>53</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050113Z" creationid="xccui" creationdate="20190416T050113Z">
        <seg>53</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>54</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052001Z" creationid="xccui" creationdate="20190416T052001Z">
        <seg>54</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>54 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032746Z" creationid="xccui" creationdate="20190610T032746Z">
        <seg>54 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>55</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032942Z" creationid="xccui" creationdate="20190418T032942Z">
        <seg>55</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>56</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035459Z" creationid="xccui" creationdate="20190418T035459Z">
        <seg>56</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>57</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035503Z" creationid="xccui" creationdate="20190418T035503Z">
        <seg>57</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>58</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035507Z" creationid="xccui" creationdate="20190418T035507Z">
        <seg>58</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>59</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035514Z" creationid="xccui" creationdate="20190418T035514Z">
        <seg>59</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144719Z" creationid="esouser" creationdate="20190603T144719Z">
        <seg>6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035852Z" creationid="xccui" creationdate="20190418T035852Z">
        <seg>6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>60</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144757Z" creationid="esouser" creationdate="20190603T144757Z">
        <seg>60</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>60 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032806Z" creationid="xccui" creationdate="20190610T032806Z">
        <seg>60 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>61</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035518Z" creationid="xccui" creationdate="20190418T035518Z">
        <seg>61</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>62</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044716Z" creationid="xccui" creationdate="20190504T044716Z">
        <seg>62</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>63</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035522Z" creationid="xccui" creationdate="20190418T035522Z">
        <seg>63</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>64</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T154733Z" creationid="esouser" creationdate="20190514T154733Z">
        <seg>64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>65</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035526Z" creationid="xccui" creationdate="20190418T035526Z">
        <seg>65</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>66</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035530Z" creationid="xccui" creationdate="20190418T035530Z">
        <seg>66</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>67</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035534Z" creationid="xccui" creationdate="20190418T035534Z">
        <seg>67</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>69</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144652Z" creationid="esouser" creationdate="20190603T144652Z">
        <seg>69</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040015Z" creationid="xccui" creationdate="20190418T040015Z">
        <seg>7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>70</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035544Z" creationid="xccui" creationdate="20190418T035544Z">
        <seg>70</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>707-829-0104 (fax)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210841Z" creationid="esouser" creationdate="20190603T210841Z">
        <seg>707-829-0104 (fax)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>71</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035548Z" creationid="xccui" creationdate="20190418T035548Z">
        <seg>71</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>72</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035552Z" creationid="xccui" creationdate="20190418T035552Z">
        <seg>72</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>72 | Chapter 4: Setting Up a Development Environment for Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T142736Z" creationid="xccui" creationdate="20190611T040223Z">
        <seg>72 | 第4章：设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>73</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035600Z" creationid="xccui" creationdate="20190418T035600Z">
        <seg>73</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>74</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035605Z" creationid="xccui" creationdate="20190418T035605Z">
        <seg>74</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>74 | Chapter 4: Setting Up a Development Environment for Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T142736Z" creationid="xccui" creationdate="20190612T012857Z">
        <seg>74 | 设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>75</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144915Z" creationid="esouser" creationdate="20190603T144915Z">
        <seg>75</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>76</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035608Z" creationid="xccui" creationdate="20190418T035608Z">
        <seg>76</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>77</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035612Z" creationid="xccui" creationdate="20190418T035612Z">
        <seg>77</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>78</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035616Z" creationid="xccui" creationdate="20190418T035616Z">
        <seg>78</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>79</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035621Z" creationid="xccui" creationdate="20190418T035621Z">
        <seg>79</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144723Z" creationid="esouser" creationdate="20190603T144723Z">
        <seg>8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040147Z" creationid="xccui" creationdate="20190418T040147Z">
        <seg>8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>800-998-9938 (in the United States or Canada) 707-829-0515 (international or local)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210840Z" creationid="esouser" creationdate="20190603T210840Z">
        <seg>800-998-9938 (in the United States or Canada) 707-829-0515 (international or local)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>81</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145036Z" creationid="esouser" creationdate="20190603T145036Z">
        <seg>81</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>82</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145105Z" creationid="esouser" creationdate="20190603T145105Z">
        <seg>82</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>82 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045214Z" creationid="xccui" creationdate="20190619T045214Z">
        <seg>82 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>83</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145112Z" creationid="esouser" creationdate="20190603T145112Z">
        <seg>83</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>84</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035625Z" creationid="xccui" creationdate="20190418T035625Z">
        <seg>84</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>84 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045231Z" creationid="xccui" creationdate="20190619T045231Z">
        <seg>84 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>86 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045250Z" creationid="xccui" creationdate="20190619T045250Z">
        <seg>86 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>87</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035628Z" creationid="xccui" creationdate="20190418T035628Z">
        <seg>87</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>89</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035642Z" creationid="xccui" creationdate="20190418T035642Z">
        <seg>89</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144727Z" creationid="esouser" creationdate="20190603T144727Z">
        <seg>9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040300Z" creationid="xccui" creationdate="20190418T040300Z">
        <seg>9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>90</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035645Z" creationid="xccui" creationdate="20190418T035645Z">
        <seg>90</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9020-9040:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055900Z" creationid="xccui" creationdate="20190804T055900Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>92</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035652Z" creationid="xccui" creationdate="20190418T035652Z">
        <seg>92</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>93</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035656Z" creationid="xccui" creationdate="20190418T035656Z">
        <seg>93</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>94</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035701Z" creationid="xccui" creationdate="20190418T035701Z">
        <seg>94</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>96</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145618Z" creationid="esouser" creationdate="20190603T145618Z">
        <seg>96</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>97</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035705Z" creationid="xccui" creationdate="20190418T035705Z">
        <seg>97</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>978-1-491-97429-2 [LSI]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210743Z" creationid="esouser" creationdate="20190603T210743Z">
        <seg>978-1-491-97429-2 [LSI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>98</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145619Z" creationid="esouser" creationdate="20190603T145619Z">
        <seg>98</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>98 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045312Z" creationid="xccui" creationdate="20190619T045312Z">
        <seg>98 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>99</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035714Z" creationid="xccui" creationdate="20190418T035714Z">
        <seg>99</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>: CompletableFuture[ValueState[(String, Double)]] = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041607Z" creationid="xccui" creationdate="20190707T041607Z">
        <seg>: CompletableFuture[ValueState[(String, Double)]] = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;/dependency&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T124908Z" creationid="xccui" creationdate="20190706T124908Z">
        <seg>&lt;/dependency&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;/description&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052546Z" creationid="xccui" creationdate="20190721T052546Z">
        <seg>&lt;/description&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;/property&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052550Z" creationid="xccui" creationdate="20190721T052550Z">
        <seg>&lt;/property&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;S extends State&gt; S getPartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192924Z" creationid="xccui" creationdate="20190626T192924Z">
        <seg>&lt;S extends State&gt; S getPartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;artifactId&gt;flink-connector-cassandra_2.12&lt;/artifactId&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T203325Z" creationid="xccui" creationdate="20190711T203325Z">
        <seg>&lt;artifactId&gt;flink-connector-cassandra_2.12&lt;/artifactId&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;artifactId&gt;flink-connector-kafka_2.12&lt;/artifactId&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T171254Z" creationid="xccui" creationdate="20190708T171254Z">
        <seg>&lt;artifactId&gt;flink-connector-kafka_2.12&lt;/artifactId&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;artifactId&gt;flink-metrics-dropwizard&lt;/artifactId&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033002Z" creationid="xccui" creationdate="20190803T033002Z">
        <seg>&lt;artifactId&gt;flink-metrics-dropwizard&lt;/artifactId&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;artifactid&gt;flink-queryable-state-client-java_2.12&lt;/artifactid&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T124900Z" creationid="xccui" creationdate="20190706T124900Z">
        <seg>&lt;artifactid&gt;flink-queryable-state-client-java_2.12&lt;/artifactid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;dependency&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T124831Z" creationid="xccui" creationdate="20190706T124831Z">
        <seg>&lt;dependency&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;description&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052541Z" creationid="xccui" creationdate="20190721T052541Z">
        <seg>&lt;description&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T171251Z" creationid="xccui" creationdate="20190708T171251Z">
        <seg>&lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;groupid&gt;org.apache.flink&lt;/groupid&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T124834Z" creationid="xccui" creationdate="20190706T124834Z">
        <seg>&lt;groupid&gt;org.apache.flink&lt;/groupid&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;host&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043711Z" creationid="xccui" creationdate="20190804T043711Z">
        <seg>&lt;host&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;host&gt;.jobmanager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043030Z" creationid="xccui" creationdate="20190804T043030Z">
        <seg>&lt;host&gt;.jobmanager</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;host&gt;.jobmanager.&lt;job_name&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043055Z" creationid="xccui" creationdate="20190804T043055Z">
        <seg>&lt;host&gt;.jobmanager.&lt;job_name&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;host&gt;.taskmanager.&lt;tm_id&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043103Z" creationid="xccui" creationdate="20190804T043103Z">
        <seg>&lt;host&gt;.taskmanager.&lt;tm_id&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;host&gt;.taskmanager.&lt;tm_id&gt;.&lt;job_name&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043114Z" creationid="xccui" creationdate="20190804T043114Z">
        <seg>&lt;host&gt;.taskmanager.&lt;tm_id&gt;.&lt;job_name&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;host&gt;.taskmanager.&lt;tm_id&gt;.&lt;job_name&gt;.&lt;task_name&gt;.&lt;subtask_index&gt; Operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043128Z" creationid="xccui" creationdate="20190804T043128Z">
        <seg>&lt;host&gt;.taskmanager.&lt;tm_id&gt;.&lt;job_name&gt;.&lt;task_name&gt;.&lt;subtask_index&gt; 算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;job_id&gt;, &lt;job_name&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043723Z" creationid="xccui" creationdate="20190804T043723Z">
        <seg>&lt;job_id&gt;, &lt;job_name&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;name&gt;yarn.resourcemanager.am.max-attempts&lt;/name&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052509Z" creationid="xccui" creationdate="20190721T052509Z">
        <seg>&lt;name&gt;yarn.resourcemanager.am.max-attempts&lt;/name&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;operator_id&gt;, &lt;operator_name&gt;, &lt;subtask_index&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043741Z" creationid="xccui" creationdate="20190804T043741Z">
        <seg>&lt;operator_id&gt;, &lt;operator_name&gt;, &lt;subtask_index&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;property&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052505Z" creationid="xccui" creationdate="20190721T052505Z">
        <seg>&lt;property&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;subtask_index&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043733Z" creationid="xccui" creationdate="20190804T043733Z">
        <seg>&lt;subtask_index&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Eager &lt;t1/&gt;watermarks ensure low latency but provide lower confidence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210541Z" creationid="xccui" creationdate="20190412T210445Z">
        <seg>激进的水位线策略保证了低延迟，但随之而来的是低可信度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 1-4&lt;t1/&gt; shows a stateful Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T033047Z" creationid="xccui" creationdate="20190305T033047Z">
        <seg>图1-4展示了一个状态化的Flink应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 1-5&lt;t1/&gt; sketches a service architecture composed of event-driven streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152610Z" creationid="xccui" creationdate="20190307T152501Z">
        <seg>图1-5粗略展示了一个由事件驱动型应用组成的服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 2-1&lt;t1/&gt; shows a dataflow program that extracts and counts hashtags from an input stream of tweets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021625Z" creationid="xccui" creationdate="20190401T000354Z">
        <seg>图2-1展示了一个从推文输入流中提取并计算主题标签数目的dataflow程序，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 3-2&lt;t1/&gt; visualizes the relationship of TaskManag&lt;t2/&gt;‐&lt;t3/&gt; ers, slots, tasks, and operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042900Z" creationid="xccui" creationdate="20190423T042900Z">
        <seg>图3-2展示了TaskManager、处理槽、任务以及算子之间的关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Parallelization becomes complicated, since results depend on&lt;t1/&gt; &lt;t2/&gt;both the state and incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035629Z" creationid="xccui" creationdate="20190415T033359Z">
        <seg>由于结果需要同时依赖状态和到来的事件，状态并行化变得异常复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;The third and biggest challenge that comes with stateful opera&lt;t1/&gt;‐&lt;t2/&gt; &lt;t3/&gt;tors is ensuring that state can be recovered and results will be correct even in the presence of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035117Z" creationid="xccui" creationdate="20190415T034953Z">
        <seg>最后一个也是最大的挑战在于，状态化算子需要保证状态可以恢复，即便出现故障也要确保结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t13/&gt;Figure 2-9&lt;t14/&gt; shows a session win&lt;t15/&gt;‐&lt;t16/&gt; dow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193517Z" creationid="xccui" creationdate="20190409T193517Z">
        <seg>图2-9展示了一个会话窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t2/&gt;Figure 2-5 &lt;t3/&gt;shows a rolling minimum aggregation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035707Z" creationid="xccui" creationdate="20190406T035523Z">
        <seg>图2-5展示了一个求最小值的滚动聚合，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t2/&gt;Figure 3-7&lt;t3/&gt; show the same pipeline would be executed without task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155109Z" creationid="esouser" creationdate="20190514T154644Z">
        <seg>图3-7展示了同一个流水线如何非任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t3/&gt;The truth is that processing time can indeed&lt;t4/&gt; &lt;t5/&gt;be useful in some cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043840Z" creationid="xccui" creationdate="20190414T040757Z">
        <seg>事实上，处理时间在某些情况下确有其用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 2-13&lt;t5/&gt; shows that an event-time window would correctly place events in a window, reflecting the reality of how things happened, even though some events were &lt;t6/&gt;delayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150703Z" creationid="xccui" creationdate="20190412T150441Z">
        <seg>如图2-13所示，即便事件有延迟，事件时间窗口也能准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 2-2&lt;t5/&gt; shows a physical dataflow graph for the logical graph of &lt;t6/&gt;Figure 2-1&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T003231Z" creationid="xccui" creationdate="20190401T003231Z">
        <seg>图2-2展示了图2-1中逻辑图对应的物理dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 3-3&lt;t5/&gt; illustrates this design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051331Z" creationid="xccui" creationdate="20190502T051232Z">
        <seg>图3-3阐明了这一设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 3-4&lt;t5/&gt; visualizes this architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044158Z" creationid="xccui" creationdate="20190504T043809Z">
        <seg>图3-4展示了这一架构，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t5/&gt;Figure 2-6&lt;t6/&gt; shows a count-based tumbling window that discretizes the input stream into buckets of 4 elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023319Z" creationid="xccui" creationdate="20190407T022549Z">
        <seg>图2-6中基于数量的滚动窗口将输入流按每4个元素一组分配到不同的通中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t6/&gt;Figure 2-10&lt;t7/&gt; shows a parallel count-based tumbling window of length 2 which is partitioned by event color.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195846Z" creationid="xccui" creationdate="20190409T195846Z">
        <seg>图2-10展示了一个按事件颜色划分、基于数量2的并行滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t7/&gt;Figure 2-7&lt;t8/&gt; shows a time-based tumbling window that gathers events into buckets and triggers computation every 10 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023521Z" creationid="xccui" creationdate="20190407T023312Z">
        <seg>图2-7中基于时间的滚动窗口将事件汇集到桶中，每10分钟触发一次计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t8/&gt;Figure 1-2&lt;t9/&gt; depicts a microservice architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172840Z" creationid="xccui" creationdate="20190228T172718Z">
        <seg>图1-2描绘了微服务的架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;task_id&gt;, &lt;task_name&gt;, &lt;task_attempt_id&gt;, &lt;task_attempt_num&gt;,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043730Z" creationid="xccui" creationdate="20190804T043730Z">
        <seg>&lt;task_id&gt;, &lt;task_name&gt;, &lt;task_attempt_id&gt;, &lt;task_attempt_num&gt;,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;value&gt;4&lt;/value&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052537Z" creationid="xccui" creationdate="20190721T052537Z">
        <seg>&lt;value&gt;4&lt;/value&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;version&gt;1.7.1&lt;/version&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T124904Z" creationid="xccui" creationdate="20190706T124904Z">
        <seg>&lt;version&gt;1.7.1&lt;/version&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;version&gt;flink-version&lt;/version&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033005Z" creationid="xccui" creationdate="20190803T033005Z">
        <seg>&lt;version&gt;flink-version&lt;/version&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; filter(T): Boolean</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052938Z" creationid="xccui" creationdate="20190613T052938Z">
        <seg>&gt; filter(T): Boolean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; flatMap(T, Collector[O]): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T061035Z" creationid="xccui" creationdate="20190613T061035Z">
        <seg>&gt; flatMap(T, Collector[O]): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; flatMap1(IN1, Collector[OUT]): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042926Z" creationid="xccui" creationdate="20190615T042926Z">
        <seg>&gt; flatMap1(IN1, Collector[OUT]): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; flatMap2(IN2, Collector[OUT]): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042921Z" creationid="xccui" creationdate="20190615T042921Z">
        <seg>&gt; flatMap2(IN2, Collector[OUT]): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; getKey(IN): KEY</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051101Z" creationid="xccui" creationdate="20190618T051101Z">
        <seg>&gt; getKey(IN): KEY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; map(T): O</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050345Z" creationid="xccui" creationdate="20190613T050345Z">
        <seg>&gt; map(T): O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; map1(IN1): OUT</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042859Z" creationid="xccui" creationdate="20190615T042859Z">
        <seg>&gt; map1(IN1): OUT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; map2(IN2): OUT</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042906Z" creationid="xccui" creationdate="20190615T042906Z">
        <seg>&gt; map2(IN2): OUT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; reduce(T, T): T</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061913Z" creationid="xccui" creationdate="20190614T061913Z">
        <seg>&gt; reduce(T, T): T</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; select(IN): Iterable[String]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061016Z" creationid="xccui" creationdate="20190615T061016Z">
        <seg>&gt; select(IN): Iterable[String]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>?parallelism=16</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201801Z" creationid="xccui" creationdate="20190729T201801Z">
        <seg>?parallelism=16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Column(name = "sensorId") var id: String, @Column(name = "temperature") var temp: Float) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220255Z" creationid="xccui" creationdate="20190711T220255Z">
        <seg>@Column(name = "sensorId") var id: String, @Column(name = "temperature") var temp: Float) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Override</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031854Z" creationid="xccui" creationdate="20190803T031854Z">
        <seg>@Override</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Table(keyspace = "example", name = "sensors")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220249Z" creationid="xccui" creationdate="20190711T220249Z">
        <seg>@Table(keyspace = "example", name = "sensors")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052010Z" creationid="xccui" creationdate="20190612T052010Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Bit of History</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030041Z" creationid="esouser" creationdate="20190603T143127Z">
        <seg>历史回顾</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A CheckpointCommitter as discussed before</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T055801Z" creationid="xccui" creationdate="20190715T060857Z">
        <seg>一个之前介绍过的CheckpointCommitter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A DataStream does not have to eventually flow into a sink opera‐ tor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T212239Z" creationid="xccui" creationdate="20190713T212239Z">
        <seg>一个DataStream不必非要向数据汇算子写出数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A FileInputFormat used in a DataStream application should also implement the CheckpointableInputFormat interface, which defines methods to checkpoint and reset the the current reading position of an InputFormat within a file split.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T192530Z" creationid="xccui" creationdate="20190710T192530Z">
        <seg>DataStream应用中所用到的FileInputFormat还需要实现CheckpointableInputFormat接口，该接口定义了生成检查点以及针对某个输入划分重置InputFormat中读取位置的相关方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A FileInputFormat, which is responsible for reading the content of the files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185145Z" creationid="xccui" creationdate="20190710T185145Z">
        <seg>一个FileInputFormat对象，负责读数文件内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A FileSystem class implements file‐ system operations, such as reading from and writing to files, creating directories or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T041302Z" creationid="xccui" creationdate="20190722T041118Z">
        <seg>每个FileSystem类都实现了文件系统的基本操作，包括读写文件、创建文件或目录，以及列出目录内容等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink DataStream application can assign timestamps and generate watermarks to a stream in three ways:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033951Z" creationid="xccui" creationdate="20190607T033951Z">
        <seg>Flink DataStream应用可以通过三种方式分配时间戳和生成水位线：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink HA setup requires a running Apache ZooKeeper cluster and a persistent remote storage, such as HDFS, NFS, or S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T160844Z" creationid="xccui" creationdate="20190720T160844Z">
        <seg>Flink的HA设置需要运行一个Apache ZooKeeper集群和一个持久化远程存储（例如HDFS、NFS或S3）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink Kafka consumer can be configured to automatically discover new topics that match the regular expression or new partitions that were added to a topic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T042240Z" creationid="xccui" creationdate="20190709T042240Z">
        <seg>我们可以通过配置让Flink Kafka消费者自动发现满足给定正则表达式的新主题或添加到主题中的新分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink YARN session is started with the ./bin/yarn-session.sh script, which also uses various parameters to control the size of containers, the name of the YARN</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T142216Z" creationid="xccui" creationdate="20190719T013652Z">
        <seg>你可以通过./bin/yarn-session.sh脚本启动一个Flink YARN会话，该脚本同样设有很多用于控制容器大小及YARN应用名称或提供动态属性的参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink application that runs with fault tolerance enabled periodically takes a check‐ point of its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T024541Z" creationid="xccui" creationdate="20190731T020419Z">
        <seg>在启用容错功能的情况下，Flink会周期性地将应用状态存储检查点中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink process (JobManager or Task‐ Manager) instantiates one FileSystem object for each configured filesystem and shares it across all local tasks to guarantee that configured constraints such as limits</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T041622Z" creationid="xccui" creationdate="20190722T041520Z">
        <seg>Flink进程（JobManager或TaskManager）会为每个配置的文件系统实例化一个FileSystem对象，并让它们在所有本地任务之间共享以保证配置的约束（例如开启的最大连接数）可以生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink setup consists for four different components that work together to execute streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033459Z" creationid="xccui" creationdate="20190418T033431Z">
        <seg>Flink的设置包含4个不同组件，它们相互协作，共同执行流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink setup consists of four different components that work together to execute streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T055536Z" creationid="xccui" creationdate="20190606T141214Z">
        <seg>Flink的搭建需要四个不同组件，它们相互协作、共同执行流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink setup consists of multiple processes that typically run distributed across multiple machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T043917Z" creationid="xccui" creationdate="20190418T030126Z">
        <seg>它的搭建涉及多个进程，它们通常会分布在多台机器上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink setup for Kubernetes is defined with two deployments—one for the pod run‐ ning the master process and the other for the worker process pods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024521Z" creationid="xccui" creationdate="20190720T024521Z">
        <seg>在Kubernetes上搭建Flink需要通过两个Deployment来完成——一个用于运行主进程的Pod，另一个用于工作进程的Pod。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink standalone deployment does not rely on a resource provider, such as YARN or Kubernetes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T024844Z" creationid="xccui" creationdate="20190721T024844Z">
        <seg>Flink独立集群部署模式无须依赖YARN或Kubernetes这样的资源提供者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink worker process stores data on the local filesystem for multiple reasons, including receiving application JAR files, writing log files, and maintaining applica‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T151926Z" creationid="xccui" creationdate="20190724T042436Z">
        <seg>出于多种原因，Flink的工作进程需要在本地文件系统上存储数据，其中包括接收应用的JAR包，写日志，以及在配置了RocksDB状态后端时维护状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Function Cannot Choose Which ConnectedStreams to Read</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T043536Z" creationid="xccui" creationdate="20190615T043536Z">
        <seg>函数无法选择从哪条流读取数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Gauge metric calculates a value of any type at a point in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T025258Z" creationid="xccui" creationdate="20190803T025258Z">
        <seg>Gauge指标用于计算在某个时间点一个任意类型的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Java JRE is not sufficient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T072139Z" creationid="xccui" creationdate="20190611T015626Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A JobManager requests one or more slots to execute an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T061536Z" creationid="xccui" creationdate="20190723T061536Z">
        <seg>JobManager需要请求一个或多个处理槽来执行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Kafka sink is added to a DataStream application as shown in Example 8-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T171245Z" creationid="xccui" creationdate="20190708T171245Z">
        <seg>示例8-2中展示了如何将Kafka数据汇添加到DataStream应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Kafka source connector is created as shown in Example 8-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T205832Z" creationid="xccui" creationdate="20190708T205832Z">
        <seg>示例8-1展示了如何创建一个Kafka数据源连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeySelector function extracts a key from an input event:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051016Z" creationid="xccui" creationdate="20190618T050945Z">
        <seg>它可以从输入事件中提取键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeySelector function receives an input item and returns a key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051811Z" creationid="xccui" creationdate="20190618T051811Z">
        <seg>KeySelector函数接受一个输入项，返回一个键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Keyed Stream is constructed by calling the DataStream.keyBy() method that defines a key on a stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T020727Z" creationid="xccui" creationdate="20190630T040405Z">
        <seg>你可以通过在一条数据流上调用定义键值的DataStream.keyBy()方法来得到一个KeyedStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyedProcessFunction that emits a warning if the temperature of a sensor monotonically increases for 1 second in processing time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063441Z" creationid="xccui" creationdate="20190620T055114Z">
        <seg>KeyedProcessFunction，如果传感器温度在处理时间1秒内持续增加，则发出警告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyedStream can be processed using the map, flatMap, and filter transformations that you saw earlier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060940Z" creationid="xccui" creationdate="20190614T045801Z">
        <seg>KeyedStream也支持使用你之见看到过的map、flatMap和filter等转换进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyedStream is partitioned on the specified key and remembers the key definition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T020749Z" creationid="xccui" creationdate="20190630T040446Z">
        <seg>KeyedStream会根据指定键值进行分区并记住键值的定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Kubernetes deployment for a Flink master</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024846Z" creationid="xccui" creationdate="20190720T024846Z">
        <seg>用于Flink主进程的Kubernetes Deployment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Kubernetes deployment for two Flink workers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025716Z" creationid="xccui" creationdate="20190720T025716Z">
        <seg>针对两个Flink工作进程的Kubernetes Deployment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Kubernetes service for the Flink master</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T031939Z" creationid="xccui" creationdate="20190720T031939Z">
        <seg>针对Flink主进程的Kubernetes Service</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ProcessFunction that emits records to a side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023338Z" creationid="xccui" creationdate="20190622T023338Z">
        <seg>向副输出发送记录的ProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ProcessFunction that filters out late sensor readings and redirects them to a side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155618Z" creationid="xingcan" creationdate="20190628T155618Z">
        <seg>用于过滤出迟到的传感器读数并将其重定向到副输出的ProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ProcessWindowFunction that computes the lowest and highest temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030825Z" creationid="xccui" creationdate="20190625T030825Z">
        <seg>该ProcessWindowFunction用于计算每个窗口内的最低和最高温度读数，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ProcessWindowFunction that utilizes per- window state needs to implement its clear() method to clean up any window-</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024757Z" creationid="xccui" creationdate="20190624T024757Z">
        <seg>使用了单个窗口状态的ProcessWindowFunction需要实现clear()方法，在窗口清除前清理仅供当前窗口使用的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Quick Look at Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143155Z" creationid="esouser" creationdate="20190603T143155Z">
        <seg>Flink快览</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Quick Look at Flink | 13</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130830Z" creationid="xccui" creationdate="20190605T130830Z">
        <seg>Flink快览| 13</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ReduceFunction accepts two values of the same type and combines them into a single value of the same type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T225024Z" creationid="xccui" creationdate="20190623T224729Z">
        <seg>ReduceFunction接收两个同类型的值并将它们组合成一个类型不变的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A RichFlatMapFunction with operator list state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052313Z" creationid="xccui" creationdate="20190701T052313Z">
        <seg>使用了算子列表状态的RichFlatMapFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A RollingPolicy determines when a task creates a new part file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T021318Z" creationid="xccui" creationdate="20190711T021246Z">
        <seg>RollingPolicy用来决定任务何时创建一个新的分块文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A StreamingFileSink in bulk-encoding mode cannot choose a Roll ingPolicy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T183147Z" creationid="xccui" creationdate="20190711T183147Z">
        <seg>工作在批量编码模式下的StreamingFileSink无法选择RollingPolicy。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A StreamingFileSink in bulk-encoding mode requires a BulkWriter.Factory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T171426Z" creationid="xccui" creationdate="20190711T171328Z">
        <seg>批量编码模式下的StreamingFileSink需要接收一个BulkWriter.Factory。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager can execute several tasks at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T070611Z" creationid="xccui" creationdate="20190423T041158Z">
        <seg>一个TaskManager允许同时执行多个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager container registers itself at the JobMaster and offers its processing slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T224425Z" creationid="xccui" creationdate="20190729T224425Z">
        <seg>TaskManager容器会将自身和所提供的处理槽在JobMaster上注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager executes its tasks multi-threaded in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062942Z" creationid="xccui" creationdate="20190424T062935Z">
        <seg>TaskManager会在同一个JVM进程内以多线程的方式执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager executes its tasks multithreaded in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144850Z" creationid="xccui" creationdate="20190606T144850Z">
        <seg>TaskManager会在同一个JVM进程内以多线程的方式执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager needs one dedicated network buffer for each receiving task that any of its tasks need to send data to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T192438Z" creationid="xccui" creationdate="20190504T043448Z">
        <seg>对于每一个接收任务，TaskManager都要提供一个专用的网络缓冲区，用于接收其他任务发来的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager offers a certain number of processing slots to control the number of tasks it is able to concurrently execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T063916Z" creationid="xccui" creationdate="20190606T144350Z">
        <seg>TaskManager通过提供固定数量的处理槽来控制可以并行执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager process (and with it, all tasks running on it) may fail at any point in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061850Z" creationid="xccui" creationdate="20190608T053527Z">
        <seg>而考虑到TaskManager进程以及它上面所有运行的任务都可能在任意时间出现故障，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager provides a certain number of processing slots to control the number of tasks that it can concurrently execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042642Z" creationid="xccui" creationdate="20190423T042443Z">
        <seg>TaskManager通过提供一定数量的处理槽来控制可以并发执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager provides a certain number of slots that are registered at and governed by the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T061440Z" creationid="xccui" creationdate="20190723T061440Z">
        <seg>每个TaskManager都能提供一定数量的处理槽，这些处理槽由ResourceManager统一注册和管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Taste of Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T063919Z" creationid="xccui" creationdate="20190225T014731Z">
        <seg>初识Flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TypeSerializer to serialize the input records</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T060909Z" creationid="xccui" creationdate="20190715T060909Z">
        <seg>一个用于序列化输入记录的TypeSerializer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A WAL sink that writes to the standard output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064205Z" creationid="xccui" creationdate="20190715T064205Z">
        <seg>写入标准输出的WAL数据汇</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Welcoming Community</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152601Z" creationid="esouser" creationdate="20190603T152601Z">
        <seg>欢迎加入社区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Welcoming Community | 283</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T152359Z" creationid="xccui" creationdate="20190807T040640Z">
        <seg>欢迎加入社区 | 283</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A WindowAssigner is typed to the type of the incoming elements and the type of the windows to which the elements are assigned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042056Z" creationid="xccui" creationdate="20190626T042056Z">
        <seg>WindowAssigner的类型由到达元素的类型以及元素分配的目标窗口类型组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A background thread asynchronously copies the local snapshot to the remote storage and notifies the task once it completes the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203709Z" creationid="xccui" creationdate="20190609T203432Z">
        <seg>后台进程会异步将本地状态快照拷贝到远程存储，然后在完成检查点后通知任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bucket is a subdirectory of the base path that is configured with the builder of Stream ingFileSink—"/base/path" in Example 8-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T212830Z" creationid="xccui" creationdate="20190710T210621Z">
        <seg>每个桶都代表了由StreamingFileSink构建器配置的基础路径（示例8-4中的"/bash/path"）下的一个子目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bulk-encoding StreamingFileSink is created as shown in Example 8-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T024458Z" creationid="xccui" creationdate="20190711T024458Z">
        <seg>示例8-5展示了如何创建一个批量编码的StreamingFileSink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call to this</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T055532Z" creationid="xccui" creationdate="20190630T055532Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A checkpoint barrier carries a checkpoint ID to identify the checkpoint it belongs to  and logically splits a stream into two parts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060953Z" creationid="xccui" creationdate="20190609T060708Z">
        <seg>为了标识所属的检查点，每个检查点分隔符都会带有一个检查点编号，这样就把一条数据流从逻辑上分成了两个部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A checkpoint is committed in two steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T051418Z" creationid="xccui" creationdate="20190715T051418Z">
        <seg>该过程分为两步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A checkpoint is initiated by the JobManager by sending a message with a new check‐ point ID to each data source task as shown in Figure 3-20.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T063006Z" creationid="xccui" creationdate="20190609T062451Z">
        <seg>如图3-20所示，JobManager会向每个数据源任务发送一个新的检查点编号，以此来启动检查点生成流程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client submits a job to the Dispatcher, which internally starts a JobManager thread and provides the JobGraph for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T155337Z" creationid="xccui" creationdate="20190717T155337Z">
        <seg>客户端将作业提交到Dispatcher，后者会在内部启动一个JobManager线程并提供用于执行的JobGraph。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common approach is to mount a network-shared directory with the Flink distri‐ bution on each machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T140234Z" creationid="xccui" creationdate="20190717T200510Z">
        <seg>常用方法是将存有Flink发行版的网络共享目录（network-shared directory）挂载到每台机器上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common case is when a task per&lt;t0/&gt;‐&lt;t1/&gt; forms idempotent operations, like maximum or minimum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050227Z" creationid="xccui" creationdate="20190416T050227Z">
        <seg>一个常见情况就是某个任务执行一些诸如求最大值或最小值的幂等操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common case is when a task performs idempotent operations, like maximum or min‐ imum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035358Z" creationid="xccui" creationdate="20190606T035358Z">
        <seg>一个常见情况就是某个任务执行一些诸如求最大值或最小值的幂等操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common command-line tool to interact with REST API is curl.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T040925Z" creationid="xccui" creationdate="20190729T040925Z">
        <seg>curl是一个在命令行模式下与REST API进行交互的常见工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common example is invalid or corrupt input data the application is not able to handle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T152519Z" creationid="xingcan" creationdate="20190801T152519Z">
        <seg>一个常见的例子是输入中出现了应用无法处理的无效或损坏数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common pattern is to write results into a database or key-value store and have other applications retrieve the result from that datastore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T035555Z" creationid="xccui" creationdate="20190705T141914Z">
        <seg>常见的分享模式是把结果写入数据库或键值存储中，再由其他应用从这些存储中获取结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common reason for growing state is keyed state on an evolving key domain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T140355Z" creationid="xccui" creationdate="20190704T140355Z">
        <seg>导致状态增长的一个常见原因是键值状态的键值域不断发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common requirement for streaming applications is to adjust the parallelism of operators due to increasing or decreasing input rates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062024Z" creationid="xccui" creationdate="20190608T054343Z">
        <seg>流式应用的一项基本需求是根据输入数据到达速率的变化调整算子并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common requirement in streaming applications is to distribute the same informa‐ tion to all parallel instances of a function and maintain it as recoverable state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T052353Z" creationid="xccui" creationdate="20190701T202835Z">
        <seg>流式应用的一个常见需求是将相同信息发送到函数的所有并行实例上，并将它们作为可恢复的状态进行维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common requirement of many applications is to process groups of events that share a certain property together.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060555Z" creationid="xccui" creationdate="20190614T043547Z">
        <seg>很多应用需要将事件按照某个属性分组后再进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common requirement when working with streams is to connect or join the events of two streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T203248Z" creationid="xccui" creationdate="20190627T204650Z">
        <seg>数据流操作的另一个常见需求是对两条数据流中的事件进行联结（connect）或Join。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common use case for timers is to clear keyed state after some period of inactivity for a key or to implement custom time-based windowing logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190621T061800Z">
        <seg>它的常见用途是在某些键值不再使用后清除键值分区状态或实现一些基于时间的自定义窗口逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consistent checkpoint of a stateful streaming application is a copy of the state of each of its tasks at a point when all tasks have processed exactly the same input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223148Z" creationid="xccui" creationdate="20190608T155358Z">
        <seg>状态化流式应用的一致性检查点是在所有任务处理完等量的原始输入后对全部任务状态进行的一个拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consistent checkpoint of a streaming application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T225015Z" creationid="xccui" creationdate="20190608T225008Z">
        <seg>某流式应用的一致性检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consumer that reads from a topic can be configured with an isolation level (via</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T212747Z" creationid="xccui" creationdate="20190709T212747Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A container is started from an image that defines the software in the container.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T140423Z" creationid="xccui" creationdate="20190718T015513Z">
        <seg>容器需要通过定义其内部软件的镜像启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A container that is started from this image automati‐ cally starts a TaskManager, which connects to the ResourceManager and registers its slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190606T143759Z">
        <seg>容器通过镜像启动后会自动运行TaskManager，后者可以连接ResourceManager并注册处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A counterexample is a source connector that reads data from a network socket, which immediately discards delivered the data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T055053Z" creationid="xccui" creationdate="20190712T160407Z">
        <seg>反例是从网络套接字读取数据的数据源连接器，套接字会在数据传递后立即将其丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A custom trigger may fire several times, computing new or updated results</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185857Z" creationid="xccui" creationdate="20190626T185623Z">
        <seg>自定义触发器可能会触发多次，你不但可以计算全新的结果或对已有结果进行更新，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A data source can ingest data from a TCP socket, a file, a Kafka topic, or a sensor data interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060131Z" creationid="xccui" creationdate="20190405T152258Z">
        <seg>数据源可以从TCP套接字、文件、Kafka主题或传感器数据接口中获取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A data stream is a potentially unbounded sequence of events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142859Z" creationid="xccui" creationdate="20190401T142812Z">
        <seg>数据流是一个可能无限的事件序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A data warehouse is a specialized database system for analytical query workloads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T184243Z" creationid="xccui" creationdate="20190228T184243Z">
        <seg>数据仓库是一个用来执行分析类查询的专业化数据库系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dataflow graph must have at least</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000307Z" creationid="xccui" creationdate="20190401T000240Z">
        <seg>一个dataflow图至少要有一个数据源和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dataflow graph must have at least one data source and one data sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224932Z" creationid="xccui" creationdate="20190605T224929Z">
        <seg>一个Dataflow图至少要有一个数据源和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dependency that is added to the classpath like this is available to (and might interfere with) all applications that run on the Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T010114Z" creationid="xccui" creationdate="20190619T042001Z">
        <seg>像这样加入Classpath的依赖会对一个Flink设置中所有运行的应用可见（可能会产生干扰）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A deployment defines a specific number of pods, or containers, to run.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T023303Z" creationid="xccui" creationdate="20190719T023303Z">
        <seg>一个Deployment定义了一组需要运行的特定数量的Pod或容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A detached Flink session can be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T014556Z" creationid="xccui" creationdate="20190719T014430Z">
        <seg>并利用YARN的应用工具（application utilities）将其终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failure can occur during any of these steps and the system has to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042813Z" creationid="xccui" creationdate="20190415T042639Z">
        <seg>上述任何一个步骤都可能发生故障，系统必须在故障场景下明确定义其行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failure can occur during any of these steps and the system has to clearly define its behavior in a failure scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T190655Z" creationid="xccui" creationdate="20190606T033607Z">
        <seg>上述任何一个步骤都可能发生故障，而系统必须在故障情况下明确定义其行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failure recovery would fail if Flink attempted to recover from a savepoint that was removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T182024Z" creationid="xccui" creationdate="20190726T181849Z">
        <seg>如果恢复的目标保存点已经删除，则故障恢复过程将会失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A filesystem is represented in Flink by an implementation of the org.apache.flink.core.fs.FileSystem class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T032602Z" creationid="xccui" creationdate="20190722T032556Z">
        <seg>在Flink中，每个文件系统都由org.apache.flink.core.fs.FileSystem类的一个实现来表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A filter operation that only retains white values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055741Z" creationid="xccui" creationdate="20190613T052343Z">
        <seg>仅保留白色值的Filter操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A filter transformation is specified by calling the DataStream.filter() method and pro‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055658Z" creationid="xccui" creationdate="20190613T052155Z">
        <seg>通过调用DataStream.filter()方法可以指定filter转换产生一个数据类型不变的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A flatMap operation that outputs white squares, duplicates black squares, and drops gray squares</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054751Z" creationid="xccui" creationdate="20190613T054718Z">
        <seg>输出白色方块，复制黑色方块，丢弃灰色方块的flatMap操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A full data type can be selected using the wildcard field expression "_" (underscore character):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040454Z" creationid="xccui" creationdate="20190618T050750Z">
        <seg>可以使用通配符字段表达式"_"选择全部字段：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function can work with operator list state by implementing the ListCheckpointed interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T040044Z" creationid="xccui" creationdate="20190701T040044Z">
        <seg>若要在函数中使用算子列表状态，需要实现ListCheckpointed接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function implementing the CheckpointedFunction interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T154746Z" creationid="xccui" creationdate="20190702T154746Z">
        <seg>实现了CheckpointedFunction接口的函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function is implemented by implementing the interface or extending the abstract class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T053826Z" creationid="xccui" creationdate="20190618T053826Z">
        <seg>因此可以通过实现接口或继承抽象类的方式实现函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function with broadcast state is applied on two streams in three steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040831Z" creationid="xccui" creationdate="20190702T040401Z">
        <seg>为了在两条数据流上应用带有广播状态的函数需要经过三个步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function with keyed state must be applied on a KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062552Z" creationid="xccui" creationdate="20190630T062503Z">
        <seg>使用键值分区状态的函数必须作用在KeyedStream上，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A highly available Flink setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T194903Z" creationid="xccui" creationdate="20190606T194859Z">
        <seg>Flink高可用设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A highly-available Flink Setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051925Z" creationid="xccui" creationdate="20190502T051925Z">
        <seg>Flink高可用设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A job ID that is passed to the CheckpointCommitter to identify commit informa‐ tion across application restarts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T062726Z" creationid="xccui" creationdate="20190715T062726Z">
        <seg>一个传递给CheckpointCommitter，用于应用重启后标识提交信息的任务ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A job can recover from a worker failure if a sufficient number of processing slots is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T135726Z" creationid="xccui" creationdate="20190717T160917Z">
        <seg>只要有足够多的剩余处理槽，作业就可以从工作进程故障中恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key group is a partition of keys and Flink’s  way of assigning keys to   tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062208Z" creationid="xccui" creationdate="20190608T055919Z">
        <seg>每个键值组都包含了部分键值，Flink以此为单位把键值分配给不同任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A keyBy operation that partitions events based on color</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051146Z" creationid="xccui" creationdate="20190614T051146Z">
        <seg>基于颜色对事件进行分区的keyBy操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A late element is an element that arrives at an operator when a computation to which it would need to contribute has already been performed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T152220Z" creationid="xingcan" creationdate="20190628T151903Z">
        <seg>所谓迟到指的是元素到达算子后，它本应参与贡献的计算已经执行完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A local Flink cluster is started by calling ./bin/ start-cluster.sh.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T175650Z" creationid="xccui" creationdate="20190717T175650Z">
        <seg>Flink本地集群的启动方式是执行./bin/start-cluster.sh。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A local or distributed standalone cluster is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T140305Z" creationid="xccui" creationdate="20190717T214014Z">
        <seg>还可以利用./bin/stop-cluster.sh脚本来停止本地或分布式独立集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A logical dataflow graph to continuously count hashtags (nodes represent operators and edges denote data dependencies)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044508Z" creationid="xccui" creationdate="20190605T224959Z">
        <seg>一个持续统计主题标签数目的Dataflow逻辑图（顶点表示算子，边表示数据依赖）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A logical dataflow graph to continuously count hashtags.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T001230Z" creationid="xccui" creationdate="20190401T001056Z">
        <seg>持续计算主题标签数量的dataflow逻辑图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A map operation that transforms every square into a circle of the same color</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045716Z" creationid="xccui" creationdate="20190613T045716Z">
        <seg>将方形转换为相同颜色圆形的map操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A master process mainly manages compute resources (ResourceManager) and coordinates the execution of applications (JobManager), while a worker process takes care of the heavy lifting and processes potentially large amounts of data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T062835Z" creationid="xccui" creationdate="20190723T062835Z">
        <seg>主进程主要管理计算资源（ResourceManager）和协调应用（JobManager）执行；而工作进程要负责繁重的工作以及处理潜在庞大规模的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A microservice architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172821Z" creationid="xccui" creationdate="20190228T172821Z">
        <seg>微服务架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A microservices architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T201100Z" creationid="esouser" creationdate="20190603T201100Z">
        <seg>微服务架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A minimum Properties configu‐ ration consists of two entries, "bootstrap.servers" and "group.id".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T021903Z" creationid="xccui" creationdate="20190709T020106Z">
        <seg>Properties至少需要两个配置项，"bootstrap.servers"和"group.id"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more challenging problem than TaskManager failures are JobManager failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T043044Z" creationid="xccui" creationdate="20190502T042522Z">
        <seg>和TaskManager相比，JobManager发生故障会更为棘手。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new JobManager that takes over the work of the failed master performs the following steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190503T192209Z" creationid="xccui" creationdate="20190502T052425Z">
        <seg>新接手工作的JobManager会执行以下步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new JobManager that takes over the work of the failed master performs the following steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195042Z" creationid="xccui" creationdate="20190606T195042Z">
        <seg>新接手工作的JobManager会执行以下步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new watermark is emitted if the method returns a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054517Z" creationid="xccui" creationdate="20190620T054517Z">
        <seg>如果该方法返回一个非空、且大于之前值的水位线，算子就会将这个新水位线发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parallel count-based tumbling window of length 2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014208Z" creationid="xccui" creationdate="20190606T014058Z">
        <seg>基于数量2的并行滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parallel count-based tumbling window of length 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195913Z" creationid="xccui" creationdate="20190409T195913Z">
        <seg>基于数量2的并行滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A path to a Flink archive</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034300Z" creationid="xccui" creationdate="20190730T034251Z">
        <seg>Flink归档文件路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A path to an application JAR file</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034313Z" creationid="xccui" creationdate="20190730T034313Z">
        <seg>应用程序JAR文件路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A periodic watermark assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051030Z" creationid="xccui" creationdate="20190620T051030Z">
        <seg>周期性水位线分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A physical dataflow plan for counting hashtags (nodes represent tasks)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044512Z" creationid="xccui" creationdate="20190605T233201Z">
        <seg>主题标签计数的物理Dataflow计划（顶点表示任务）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A physical dataflow plan for counting hashtags.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021747Z" creationid="xccui" creationdate="20190401T021452Z">
        <seg>主题标签计数的物理dataflow计划，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pod is a container that is started and managed by Kubernetes.4</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T014848Z" creationid="xccui" creationdate="20190719T014848Z">
        <seg>Pod是由Kubernetes启动并管理的容器。4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A precommitted trans‐ action may not receive further writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T055554Z" creationid="xccui" creationdate="20190716T052911Z">
        <seg>预提交过后的事务将不再接收额外的数据写入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A process function can easily filter out late events by comparing their timestamps with the current watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T041354Z" creationid="xingcan" creationdate="20190628T153844Z">
        <seg>处理函数可以通过比较时间戳和当前水位线的方式轻松过滤掉迟到事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A process function can identify late events by comparing event timestamps with the current watermark and emitting them using the regular side-output API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T041525Z" creationid="xingcan" creationdate="20190628T155348Z">
        <seg>处理函数可以通过比较事件时间的时间戳和当前水位线来识别迟到事件，并使用常规的副输出API将其发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing slot can execute one slice of an application—one parallel task of each operator of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T070721Z" creationid="xccui" creationdate="20190606T144414Z">
        <seg>每个处理槽可以执行应用的一部分，即算子的一个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing slot is able to execute one slice of an application, i.e., one parallel task of each operator of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042814Z" creationid="xccui" creationdate="20190423T042808Z">
        <seg>每个处理槽可以执行应用的一部分，即应用内算子的一个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window continues counting time even after Alice’s phone gets disconnected</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023919Z" creationid="xccui" creationdate="20190606T023909Z">
        <seg>在爱丽丝手机离线后继续计时的处理时间窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window continues counting time when Alice’s phone gets disconnected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145324Z" creationid="xccui" creationdate="20190412T145316Z">
        <seg>在爱丽丝手机离线后继续计时的处理时间窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window includes all events that happen to have arrived at the window operator within a time period, as meas&lt;t2/&gt;‐&lt;t3/&gt; ured by the wall-clock of its machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T144411Z" creationid="xccui" creationdate="20190412T144411Z">
        <seg>基于处理时间的窗口包含了那些恰好在一段时间内到达窗口算子的事件，这里的时间段是按照机器时间测量的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window includes all events that happen to have arrived at the window operator within a time period, as meas‐ ured by the wall clock of its machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155618Z" creationid="xccui" creationdate="20190606T023838Z">
        <seg>基于处理时间的窗口会包含那些恰好在一段时间内到达窗口算子的事件，这里的时间段是按照机器时间测量的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A project import wizard will guide you though the next steps, such as selecting the Maven project to import (there should only be one), selecting the SDK, and naming the project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041529Z" creationid="xccui" creationdate="20190611T041529Z">
        <seg>根据导入向导的指示完成后续步骤，例如：选择要导入的Maven项目（应该只有一个），选择SDK，为项目命名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A punctuated watermark assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054747Z" creationid="xccui" creationdate="20190620T054747Z">
        <seg>定点水位线分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A query must not be configured to emit POJOs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T222845Z" creationid="xccui" creationdate="20190711T222845Z">
        <seg>如果是POJO的情况，则不可指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A receiving task grants some credit to a sending task, i.e., a number of network buffers that are reserved to receive its data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T143724Z" creationid="esouser" creationdate="20190513T210814Z">
        <seg>一个接收任务会给一个发送任务授予一定的信用度，其实就是保留一些用来接收它数据的网络缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A receiving task grants some credit to a sending task, the number of network buffers that are reserved to receive its data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194828Z" creationid="xccui" creationdate="20190606T202733Z">
        <seg>接收任务会给发送任务授予一定的信用值，其实就是保留一些用来接收它数据的网络缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recent approach to overcome the tight bundling of applications is the microservice design pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190227T233935Z" creationid="xccui" creationdate="20190227T042104Z">
        <seg>近些年提出的微服务模式可以克服这种应用紧耦合情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recent approach to overcoming the tight bundling of applications is the microservices design pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200619Z" creationid="esouser" creationdate="20190603T200240Z">
        <seg>近些年提出的微服务设计模式可以克服这种应用紧耦合情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reduce transformation does</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T054103Z" creationid="xccui" creationdate="20190614T061516Z">
        <seg>reduce转换不会改变数据类型，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A request ID to check whether the rescaling request was successful or not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201714Z" creationid="xccui" creationdate="20190729T201714Z">
        <seg>一个用于检查扩缩容操作是否成功完成的请求ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A request ID to check whether the savepoint trigger action completed successfully</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T181216Z" creationid="xccui" creationdate="20190729T181216Z">
        <seg>一个用于检查保存点所触发的操作是否已经成功完成的请求ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A request ID to check whether the savepoint was successfully disposed or not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200802Z" creationid="xccui" creationdate="20190729T200802Z">
        <seg>用于检查保存点是否已经成功删除的请求ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A request to cancel the application will only succeed if the save‐ point was successfully taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T193305Z" creationid="xccui" creationdate="20190729T193305Z">
        <seg>只有在保存点成功创建后，取消应用的请求才会生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A resettable SourceFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T033917Z" creationid="xccui" creationdate="20190713T033917Z">
        <seg>可重置的SourceFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A resettable source function needs to implement the Checkpoin tedFunction interface and should store the reading offsets and all related meta infor‐ mation, such as file paths or partition ID, in operator list state or operator union list</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T162809Z" creationid="xccui" creationdate="20190712T162809Z">
        <seg>可重置的数据源函数需要实现CheckpointedFunction接口，并把所有读取偏移和相关的元数据信息（例如文件路径或分区ID）存入算子列表状态或算子联合列表状态中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A return value of true preserves the input event and forwards it to the output, and false results in dropping the event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053832Z" creationid="xccui" creationdate="20190613T052016Z">
        <seg>如果返回值为true，那么它会保留输入事件并将其转发到输出，否则它会把事件丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling aggregation does not require a user-defined func‐ tion but receives an argument that specifies on which field the aggregate is computed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T061924Z" creationid="xccui" creationdate="20190614T052539Z">
        <seg>滚动聚合虽然不需要用户自定义函数，但需要接收一个用于指定聚合目标字段的参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling aggregation is an aggregation, such as sum, minimum, and maximum, that is continuously updated for each input event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061147Z" creationid="xccui" creationdate="20190406T034203Z">
        <seg>滚动聚合（例如求和、求最小值和求最大值）会根据每个到来的事件持续更新结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling aggre‐ gate operator keeps an aggregated value for every observed key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T061807Z" creationid="xccui" creationdate="20190614T052118Z">
        <seg>滚动聚合算子会对每一个遇到过的键值保存一个聚合结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling maximum of the input stream on the specified field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053531Z" creationid="xccui" creationdate="20190614T053531Z">
        <seg>滚动计算输入流中指定字段的最大值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling maximum of the input stream that returns the event with the highest</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053838Z" creationid="xccui" creationdate="20190614T053838Z">
        <seg>滚动计算输入流中迄今为止最大值，返回该值所在事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum aggregation operation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011943Z" creationid="xccui" creationdate="20190606T011943Z">
        <seg>求最小值的滚动聚合操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum aggregation operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035912Z" creationid="xccui" creationdate="20190406T035912Z">
        <seg>求最小值的滚动聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum of the input stream on the specified field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052715Z" creationid="xccui" creationdate="20190614T052715Z">
        <seg>滚动计算输入流中指定字段的最小值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum of the input stream that returns the event with the lowest</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053812Z" creationid="xccui" creationdate="20190614T053741Z">
        <seg>滚动计算输入流中迄今为止最小值，返回该值所在事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling sum of the input stream on the specified field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052657Z" creationid="xccui" creationdate="20190614T052657Z">
        <seg>滚动计算输入流中指定字段的和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A savepoint can be taken for a running application with the command-line client as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033252Z" creationid="xccui" creationdate="20190726T033252Z">
        <seg>你可以在命令行客户端使用如下命令为正在运行的应用生成一个保存点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A savepoint consists mainly of serialized state data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T045844Z" creationid="xccui" creationdate="20190705T045844Z">
        <seg>保存点主要由序列化后的状态数据组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A savepoint is a directory in a persistent data storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T015355Z" creationid="xccui" creationdate="20190726T015355Z">
        <seg>每个保存点都对应一个持久化数据存储上的目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A savepoint is basically identical to a checkpoint—it is a consistent and complete snapshot of an application’s state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T165226Z" creationid="xccui" creationdate="20190726T014417Z">
        <seg>保存点和检查点本质上类似，二者都是应用状态的一致性完整快照，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A savepoint is removed with the command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035126Z" creationid="xccui" creationdate="20190726T035120Z">
        <seg>删除保存点的的命令是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A savepoint will always be started regardless of how many checkpoints are in progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T032818Z" creationid="xccui" creationdate="20190731T203547Z">
        <seg>无论有多少检查点生正在生成过程中，保存点操作都会照常触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A second, job-independent image is used to deploy TaskManager containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190606T143748Z">
        <seg>另一个和作业无关的镜像负责部署TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A second, job-independent image is used to deploy TaskManagers containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T035719Z" creationid="xccui" creationdate="20190423T035719Z">
        <seg>另一个和作业无关的映像负责部署TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A service defines a policy for how a certain group of pods can be accessed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T023939Z" creationid="xccui" creationdate="20190719T023939Z">
        <seg>一个Service定义了一组Pod的访问策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A session window assigner places elements into nonoverlapping windows of activity of varying size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T030223Z" creationid="xccui" creationdate="20190623T060814Z">
        <seg>会话窗口将元素放入长度可变且不重叠的窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A session window assigner places elements into varying size windows defined</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061311Z" creationid="xccui" creationdate="20190623T061311Z">
        <seg>会话窗口分配器将元素置于由会话间隔决定的大小的可变窗口中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A shorter checkpointing interval causes higher overhead during regu‐ lar processing but can enable faster recovery because less data needs to be reproc‐ essed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T205930Z" creationid="xccui" creationdate="20190702T205930Z">
        <seg>较短的间隔会为常规处理带来较大的开销，但由于恢复时要重新处理的数据量较小，所以恢复速度会更快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A side output is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T015023Z" creationid="xccui" creationdate="20190622T015023Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A similar effect appears for operators with two input streams whose watermarks sig‐ nificantly diverge.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T072253Z" creationid="xccui" creationdate="20190607T033031Z">
        <seg>当算子两个输入流的水位线差距很大时，也会产生类似影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple SinkFunction that writes to a socket</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T023939Z" creationid="xccui" creationdate="20190714T023939Z">
        <seg>一个简单的套接字写入SinkFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple dashboard application that queries the state of a Flink application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035807Z" creationid="xccui" creationdate="20190707T035807Z">
        <seg>一个简单的Flink应用状态查询仪表盘</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple example is a task that continuously counts how many records it receives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054633Z" creationid="xccui" creationdate="20190607T054544Z">
        <seg>我们以一个持续计算接收到多少条记录的简单任务为例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sliding window assigner places elements into fixed-size, possibly overlap‐ ping windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054822Z" creationid="xccui" creationdate="20190623T054822Z">
        <seg>滑动窗口分配器将元素置于大小固定且可能重叠的窗口中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A so-called type extractor analyzes the generic types and return types of all functions to obtain the respective TypeInformation objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T035416Z" creationid="xccui" creationdate="20190617T052355Z">
        <seg>一个名为类型提取器的组件会分析所有函数的泛型类型及返回类型，以获取相应的TypeInformation对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A solution for this problem is to remove the state of expired keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T141917Z" creationid="xccui" creationdate="20190704T141917Z">
        <seg>该问题的解决方案是从状态中删除那些过期的键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A source function assigns timestamps and emits watermarks through its SourceCon text object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T035720Z" creationid="xccui" creationdate="20190713T035616Z">
        <seg>数据源函分配时间戳和发出水位线需要依靠内部的SourceContext对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A source function can decide when to mark itself as idle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T051729Z" creationid="xccui" creationdate="20190713T051729Z">
        <seg>数据源函数可以在任何时间通过调用SourceContext.markAsTemporarilyIdle()方法将自身标记为空闲状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A source function can replay its output if the external system that provides the data exposes an API to retrieve and reset a reading offset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152919Z" creationid="xccui" creationdate="20190712T152852Z">
        <seg>如果外部系统提供了获取和重置读取偏移的相关接口，那么数据源函数就可以重放输出数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A source function emits a stream of records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034220Z" creationid="xccui" creationdate="20190607T034220Z">
        <seg>源函数会发出一条记录流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A source function that supports output replay needs to be integrated with Flink’s checkpointing mechanism and must persist all current reading positions when a checkpoint is taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T161204Z" creationid="xccui" creationdate="20190712T161204Z">
        <seg>支持输出重放的数据源函数需要和Flink的检查点机制集成，并在生成检查点时持久化所有当前的读取位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A split operation that splits the input stream into a stream of white events and a stream of others</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T054207Z" creationid="xccui" creationdate="20190615T054207Z">
        <seg>将输入流拆分为白色事件和其他颜色事件的split操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A standalone Flink cluster consists of at least one master process and at least one TaskManager process that run on one or more machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T153154Z" creationid="xccui" creationdate="20190717T153154Z">
        <seg>一个Flink独立集群至少包含一个主进程和一个TaskManager进程，它们可以运行在一台或多台机器上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A state backend is responsible for two things: local state management and checkpointing state to a remote location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061621Z" creationid="xccui" creationdate="20190608T051505Z">
        <seg>状态后端主要负责两件事：本地状态管理和将状态以检查点的形式写入远程存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A state backend takes care of checkpointing the state of a task to a remote and persistent storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155107Z" creationid="xccui" creationdate="20190608T053657Z">
        <seg>状态后端负责将任务状态以检查点形式写入远程持久化存储，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A state primitive defines the struc‐ ture of the state for an individual key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T020849Z" creationid="xccui" creationdate="20190630T040912Z">
        <seg>状态原语定义了单个键值对应的状态结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stateful KeyedProcessFunction that cleans its state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205611Z" creationid="xccui" creationdate="20190704T205553Z">
        <seg>可以清除状态的KeyedProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stateful stream processing task</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054231Z" creationid="xccui" creationdate="20190607T054231Z">
        <seg>带有状态的流处理任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stateful streaming application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T033106Z" creationid="xccui" creationdate="20190305T033106Z">
        <seg>状态化流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream processor that operates a data pipeline should also feature many source and sink connectors to read data from and write data to various storage sys‐ tems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T161736Z" creationid="xccui" creationdate="20190605T042729Z">
        <seg>执行数据管道应用的流处理引擎为了支持不同外部系统的数据读写，还需要提供多样化的数据源、数据汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream processor that operates data pipelines should also fea&lt;t0/&gt;‐&lt;t1/&gt; ture many source and sink connectors to read data from and write data to various storage systems and formats.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014637Z" creationid="xccui" creationdate="20190317T015024Z">
        <seg>执行数据管道的流处理引擎为了支持不同格式或外部系统的数据读写，还需要提供多样化的数据源、汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream that is written to an event log can be read many times by the same or different consumers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T054850Z" creationid="xccui" creationdate="20190305T054850Z">
        <seg>写入事件日志的数据流可以被相同或不同的消费者重复读取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream transformation is applied on one or more streams and converts them into one or more output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T053609Z" creationid="xccui" creationdate="20190613T013226Z">
        <seg>流式转换以一个或多个数据流为输入，并将它们转换成一个或多个输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream with timestamped records and watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T065112Z" creationid="xccui" creationdate="20190606T205321Z">
        <seg>包含带有时间戳的记录及水位线的数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream with timestamped records and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042320Z" creationid="xccui" creationdate="20190523T042320Z">
        <seg>带有时间戳记录和水位线的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming analytics application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044651Z" creationid="xccui" creationdate="20190605T044651Z">
        <seg>流式分析应用示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming analytics application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062137Z" creationid="xccui" creationdate="20190317T062137Z">
        <seg>流式分析应用示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming applica&lt;t0/&gt;‐&lt;t1/&gt; tion cannot continue processing if the responsible JobManager process disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T043208Z" creationid="xccui" creationdate="20190502T043155Z">
        <seg>如果负责管理的JobManager进程消失，流式应用将无法继续处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming applica‐ tion cannot continue processing if the responsible JobManager process disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145814Z" creationid="xccui" creationdate="20190606T145814Z">
        <seg>如果负责管理的JobManager进程消失，流式应用将无法继续处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming operator with a UDF that turns each incoming event into a black event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T155750Z" creationid="xccui" creationdate="20190405T155317Z">
        <seg>带有UDF的流式算子会将每个到来的事件变黑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming operator with a function that turns each incoming event into a darker event</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060814Z" creationid="xccui" creationdate="20190606T011608Z">
        <seg>带有函数的流式算子会将每个到来事件的颜色变深</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A system scope</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T220241Z" creationid="xccui" creationdate="20190803T220241Z">
        <seg>一个系统域</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task maintains a partition watermark for each input partition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T071617Z" creationid="xccui" creationdate="20190607T024100Z">
        <seg>一个任务会为它的每个输入分区都维护一个分区水位线（partition watermark）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task might need to commit multiple transactions if an acknowledgment message is lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041229Z" creationid="xccui" creationdate="20190716T041229Z">
        <seg>如果某个确认消息丢失，任务可能需要一次提交多个事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task of a stateful operator typically reads and updates its state for each incoming record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051142Z" creationid="xccui" creationdate="20190607T230111Z">
        <seg>状态化算子的任务通常会对每一条到来的记录读写状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task only acknowledges a checkpoint if the remote write succeeded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T163544Z" creationid="xingcan" creationdate="20190801T163544Z">
        <seg>只有当远程写入成功后，任务才会确认检查点完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task receives some input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054300Z" creationid="xccui" creationdate="20190607T054300Z">
        <seg>任务首先会接收一些输入数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task tracks for each partition its current reading offset and includes it into its checkpoint data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T205002Z" creationid="xccui" creationdate="20190708T205002Z">
        <seg>任务会跟踪每一个它所负责分区的偏移，并将它们纳入到检查点数据之中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A textbook setup consists of a stream processor, a batch pro&lt;t4/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032914Z" creationid="xccui" creationdate="20190327T032745Z">
        <seg>一个典型的配置需要包含流处理引擎、批处理引擎、"提速"存储、批量存储和一系列负责向批处理引擎中加载数据及调度任务的工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A third option to specify keys are KeySelector functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050950Z" creationid="xccui" creationdate="20190618T050826Z">
        <seg>第三种指定键值的方法是使用KeySelector函数，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A topic is an event log that guaran‐ tees that events are read in the same order in which they were written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T202236Z" creationid="xccui" creationdate="20190708T201959Z">
        <seg>每个主题都是一个事件日志，其事件读取顺序和写入顺序完全相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A traditional approach to synchronize data in different storage systems is periodic ETL jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T062152Z" creationid="xccui" creationdate="20190604T055001Z">
        <seg>在不同存储系统间同步数据的传统方式是定期执行ETL作业，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A traditional data warehouse architecture for data analytics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203717Z" creationid="esouser" creationdate="20190603T203647Z">
        <seg>用于数据分析的传统数据仓库架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A traditional data warehouse architecture for data analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194730Z" creationid="xccui" creationdate="20190228T194625Z">
        <seg>用于数据分析的传统数据仓库架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A transaction must be open and accept writes for the duration of a checkpoint interval.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T024353Z" creationid="xccui" creationdate="20190716T024353Z">
        <seg>在检查点的间隔期内，事务需要保持开启状态并允许数据写入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A transaction must wait to be committed until a checkpoint completion notifica‐ tion is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T024634Z" creationid="xccui" creationdate="20190716T024634Z">
        <seg>事务只有在接收到检查点完成通知后才可以提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A transactional sink that writes to files</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041116Z" creationid="xccui" creationdate="20190716T041116Z">
        <seg>写文件的事务性数据汇</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A trigger can decide based on assigned elements or registered timers (similar to a process function) to evaluate or purge the contents of its window at specific points in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053247Z" creationid="xccui" creationdate="20190625T053247Z">
        <seg>触发器可以根据已分配的元素或注册的计时器（类似处理函数）来决定在某些特定时刻执行计算或清除窗口中的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A trigger can decide to fire based on progress in time- or data-specific conditions, such as element count or certain observed element values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052653Z" creationid="xccui" creationdate="20190626T181714Z">
        <seg>它的触发条件可以是时间，也可以是某些特定的数据条件，如元素数量或某些观测到的元素值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A trigger can define and use custom, per-window and per-key state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T034923Z" creationid="xccui" creationdate="20190626T034923Z">
        <seg>触发器中可以定义和使用针对每个窗口、每个键值的自定义状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A trigger can register timers to be called back at certain points in time—for example, to evaluate a window or purge its contents.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052043Z" creationid="xccui" creationdate="20190626T034731Z">
        <seg>你可以在触发器中注册计时器，用于在将来某个时间点触发回调（例如对窗口进行计算或清理其内容）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tumbling window assigner places elements into fixed-size, nonoverlapping windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T025630Z" creationid="xccui" creationdate="20190623T042229Z">
        <seg>滚动窗口分配器将元素放入大小固定且互不重叠的窗口中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tumbling window assigner places elements into nonoverlapping, fixed-size win‐ dows, as shown in Figure 6-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T025621Z" creationid="xccui" creationdate="20190623T042155Z">
        <seg>如图6-1所示，滚动窗口分配器会将元素放入大小固定且相互不重叠的窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tumbling window assigner receives one parameter, the window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042554Z" creationid="xccui" creationdate="20190623T042447Z">
        <seg>滚动窗口分配器只接收一个参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A typical curl</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T041111Z" creationid="xccui" creationdate="20190729T041111Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A typical example is a stream of click events where clicks have a session id attribute that expires after some time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T141432Z" creationid="xccui" creationdate="20190704T141225Z">
        <seg>一个典型的例子是有一条包含会话id属性的点击事件流，其中的会话id会在一段时间后过期。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A union operation that merges two input streams into one</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064258Z" creationid="xccui" creationdate="20190614T064258Z">
        <seg>将两条输入流合二为一的union操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value of -1 disables the REST API and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T211636Z" creationid="xccui" creationdate="20190729T040837Z">
        <seg>将值设为-1表示禁用REST API和Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark is a global progress metric that indicates a certain point in time when we are confident that no more delayed events will arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205155Z" creationid="xccui" creationdate="20190412T204632Z">
        <seg>水位线是一个全局进度指标，表示我们确信再不会有延迟事件到来的某个时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark is a global progress metric that indicates the point in time when we are confident that no more delayed events will arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160912Z" creationid="xccui" creationdate="20190606T025336Z">
        <seg>水位线是一个全局进度指标，表示我们确信不会再有延迟事件到来的某个时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark tells operators that no more events with a timestamp less than or equal to the watermark are expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T051557Z" creationid="xccui" creationdate="20190620T020532Z">
        <seg>水位线用于告知算子不必再等那些时间戳小于或等于水位线的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark with a timestamp T indi‐ cates that all subsequent records should have timestamps &gt; T.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T051957Z" creationid="xccui" creationdate="20190606T205434Z">
        <seg>一个时间戳为T的水位线表示，接下来所有记录的时间戳一定都大于T。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark with a timestamp t indicates that all subsequent records should have timestamps &gt; t.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042656Z" creationid="xccui" creationdate="20190523T042649Z">
        <seg>一个拥有时间戳t的水位线表示，接下来所有记录的时间戳一定都大于t。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A welcoming community</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030250Z" creationid="xccui" creationdate="20190225T030250Z">
        <seg>欢迎加入社区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window assigner for tumbling event-time windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042315Z" creationid="xccui" creationdate="20190626T042315Z">
        <seg>用于滚动事件时间窗口的窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window assigner produces a WindowedStream (or All WindowedStream if applied on a nonkeyed DataStream).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T035710Z" creationid="xccui" creationdate="20190622T035710Z">
        <seg>窗口分配器会产生一个WindowedStream（如果用在非键值分区的DataStream上则是AllWindowedStream）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window assigner that determines how the elements of the input stream are grouped into windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T023733Z" creationid="xccui" creationdate="20190622T035445Z">
        <seg>一个用于决定输入流中的元素该如何分组的窗口分配器（window assigner）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window consists of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033005Z" creationid="xccui" creationdate="20190626T033005Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window function that is applied on a WindowedStream (or AllWindowedStream)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T040059Z" creationid="xccui" creationdate="20190622T035910Z">
        <seg>一个作用于WindowedStream（或AllWindowedStream）上用于处理分配到窗口中元素的窗口函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window is created when the WindowAssigner assigns the first element to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032622Z" creationid="xccui" creationdate="20190626T032622Z">
        <seg>窗口会在WindowAssigner首次对它分配元素时创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window only stores the current result of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T225105Z" creationid="xccui" creationdate="20190623T225105Z">
        <seg>窗口只需要存储当前聚合结果——</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window operator creates and typically also deletes windows while it processes incoming stream elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T031225Z" creationid="xccui" creationdate="20190626T031225Z">
        <seg>窗口算子在处理到达的数据流元素时需要新建窗口，并且通常还需要将其删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window operator with a full window function (the circles in each window represent its collected raw input records)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054032Z" creationid="xccui" creationdate="20190625T054003Z">
        <seg>配置了全量窗口函数的窗口算子（每个窗口内的圆圈表示收集的原始输入记录）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window operator with allowed lateness will not delete a window and its state after the watermark passes the window’s end timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164620Z" creationid="xingcan" creationdate="20190628T164432Z">
        <seg>配置了该属性的窗口算子在水位线超过窗口的结束时间戳之后不会立即删除窗口，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window operator with an incremental aggregation and full window func‐ tion (the single circle in each window represents its aggregated window state)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T214226Z" creationid="xccui" creationdate="20190625T214226Z">
        <seg>配置了增量聚合及全量窗口函数的窗口算子（每个窗口内的单个圆圈表示聚合后的窗口状态）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window operator with an incremental aggregation function (the single cir‐ cle in each window represents its aggregated window state)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T214234Z" creationid="xccui" creationdate="20190625T053641Z">
        <seg>配置了增量聚合函数的窗口算子（每个窗口内的单个圆圈表示聚合后的窗口状态）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040532Z" creationid="xccui" creationdate="20190418T040532Z">
        <seg>A.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ACC add(IN value, ACC accumulator);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004442Z" creationid="xccui" creationdate="20190624T004442Z">
        <seg>ACC add(IN value, ACC accumulator);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ACC createAccumulator();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004329Z" creationid="xccui" creationdate="20190624T004329Z">
        <seg>ACC createAccumulator();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ACC merge(ACC a, ACC b);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004858Z" creationid="xccui" creationdate="20190624T004858Z">
        <seg>ACC merge(ACC a, ACC b);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>API, each WindowAssigner has a default trigger that is used unless an explicit trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051655Z" creationid="xccui" creationdate="20190626T024913Z">
        <seg>系统对于没有显式定义触发器的WindowAssigner都会提供一个默认的触发器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ability to run streaming applications 24/7 with very little downtime due to its highly available setup (no single point of failure), tight integration with Kuber‐ netes, YARN, and Apache Mesos, fast recovery from failures, and the ability to dynamically scale jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T053313Z" creationid="xccui" creationdate="20190605T121543Z">
        <seg>支持高可用性配置（无单点失效），和Kubernetes、YARN、Apache Mesos紧密集成，快速故障恢复，动态扩缩容作业等。基于上述特点，它可以7×24小时运行流式应用，几乎无须停机。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ability to update the application code of jobs and migrate jobs to different Flink clusters without losing the state of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T121551Z" creationid="xccui" creationdate="20190605T121551Z">
        <seg>允许在不丢失应用状态的前提下更新作业的程序代码或进行跨Flink集群的作业迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>About Completed Checkpoints” for details about the interface):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T035003Z" creationid="xccui" creationdate="20190715T035003Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>About the Authors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T033038Z" creationid="xccui" creationdate="20190808T033038Z">
        <seg>关于作者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access to timestamps and watermarks through the API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042406Z" creationid="xccui" creationdate="20190529T042406Z">
        <seg>通过API访问时间戳和水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing state stored by the RocksDB state back‐ end is slower but its state may grow very large.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053243Z" creationid="xccui" creationdate="20190608T053046Z">
        <seg>后者状态访问会慢一些，但允许状态变得很大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acknowledgments</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210942Z" creationid="esouser" creationdate="20190603T210849Z">
        <seg>致谢</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acquisitions Editor: Rachel Roumeliotis Development Editor: Alicia Young Production Editor: Katherine Tozer Copyeditor: Christina Edwards Proofreader: Charles Roumeliotis</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210719Z" creationid="esouser" creationdate="20190603T210719Z">
        <seg>Acquisitions Editor: Rachel Roumeliotis Development Editor: Alicia Young Production Editor: Katherine Tozer Copyeditor: Christina Edwards Proofreader: Charles Roumeliotis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Action</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162126Z" creationid="xccui" creationdate="20190729T045103Z">
        <seg>行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Actually, every 5 seconds, Flink invokes the getCurrentWatermark() method of AssignerWithPeriodicWatermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045929Z" creationid="xccui" creationdate="20190620T045929Z">
        <seg>实际上，Flink会每隔5秒调用一次AssignerWithPeriodicWatermarks中的getCurrentWatermark()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ad-hoc analysis of live data in consumer technology</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045434Z" creationid="xccui" creationdate="20190605T045434Z">
        <seg>消费者技术中的实时数据即席分析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ad-hoc analysis of live data in consumer technology.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033630Z" creationid="xccui" creationdate="20190319T033607Z">
        <seg>消费者技术中的实时数据即席分析等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding a data processing system, such as Apache Flink, requires careful considera‐ tions because it does not include its own storage layer but relies on external storage systems to ingest and persist data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T042304Z" creationid="xccui" creationdate="20190708T045605Z">
        <seg>添加一个像Apache Flink这样的数据处理系统需要经过深思熟虑，因为它没有包含内置的存储层，而是依赖外部存储系统来传入和持久化数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding external dependencies is a common requirement when implementing Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034846Z" creationid="xccui" creationdate="20190619T034645Z">
        <seg>在实现Flink应用时经常需要添加一些外部依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding the following lines to your configuration will define a JMX reporter “my_reporter” that listens to ports</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055858Z" creationid="xccui" creationdate="20190804T055858Z">
        <seg>你可以通过在配置中添加以下几行来定义一个名为"my_reporter"、监听端口9020-9040的JMX汇报器：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional parameters specify</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T202617Z" creationid="xccui" creationdate="20190716T202617Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional require&lt;t2/&gt;‐&lt;t3/&gt; ments to successfully support streaming analytics applications are support for event-time processing in order to produce correct and deterministic results and the ability to process large amounts of data in little time, i.e., high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033210Z" creationid="xccui" creationdate="20190319T033109Z">
        <seg>为了成功支持流式分析应用，还有一些额外需求：支持事件时间处理以便产生正确及确定的结果，能够在短时间内处理大量数据（高吞吐）等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional requirements for data pipelines are the ability to process large amounts of data in short time, i.e., support for high throughput, and the capability to scale an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T014732Z" creationid="xccui" creationdate="20190317T014732Z">
        <seg>它的额外需求是能够在短时间内处理大批量数据，即高吞吐和支持应用扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, a KeyedPro cessFunction[KEY, IN, OUT] provides the following two methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053335Z" creationid="xccui" creationdate="20190621T053335Z">
        <seg>除此之外，KeyedProcessFunction[KEY, IN, OUT]还提供了以下两个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the stream processor needs to ensure internal state consistency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044439Z" creationid="xccui" creationdate="20190416T044427Z">
        <seg>此外，流处理引擎需要确保内部状态的一致性，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you can fast forward the computation to the present so that once your program catches up with the events happening now, it can continue as a real-time application using exactly the same program logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025218Z" creationid="xccui" creationdate="20190606T025120Z">
        <seg>此外，你可以把计算"快进"到现在，这样一旦你的程序赶上了当前事件产生的进度，它能够以完全相同的程序逻辑作为实时应用继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you can fast-forward the computation to the present so that once your program catches</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155334Z" creationid="xccui" creationdate="20190412T154959Z">
        <seg>此外，你可以把计算"快进"到现在，这样一旦你的程序赶上了当前事件产生的进度，它能够以相同的程序逻辑作为实时应用继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T213219Z" creationid="xccui" creationdate="20190704T213219Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all barriers are sent out, the source continues its regu‐ lar operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T154506Z" creationid="xccui" creationdate="20190609T154335Z">
        <seg>在将所有分隔符发出后，数据源将恢复常规工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all buffered records have been emitted, the task continues processing its input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193332Z" creationid="xccui" creationdate="20190609T193332Z">
        <seg>待所有缓冲的记录处理完后，任务就会继续处理输入流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all, you probably gather metrics because you want to create a real-time dashboard or feed the measurements to another application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055133Z" creationid="xccui" creationdate="20190804T055046Z">
        <seg>毕竟你收集指标的目的可能是要创建实时仪表盘或将测量数据发往另一个应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After an application is restarted from a checkpoint, its internal state is exactly the same as when the checkpoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T064059Z" creationid="xccui" creationdate="20190609T051324Z">
        <seg>应用从检查点恢复以后，它的内部状态会和生成检查点的时候完全一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After dividing a large file into multiple splits, the splits can be distributed to multiple reader tasks to read the file in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T191928Z" creationid="xccui" creationdate="20190710T191928Z">
        <seg>在将一个大文件分割后，这些划分就可以分配给多个读取任务来并行读取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After it has been started, a TaskManager registers its slots at the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062107Z" creationid="xccui" creationdate="20190418T051651Z">
        <seg>在TaskManager启动后，会将它的处理槽在ResourceManager中注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After it has been started, a TaskManager registers its slots to the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061234Z" creationid="xccui" creationdate="20190606T142555Z">
        <seg>TaskManager在启动后，会向ResourceManager注册它的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After reading this chapter, you will know how to implement a stream processing application with basic functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T032952Z" creationid="xccui" creationdate="20190612T032952Z">
        <seg>本章过后，你将了解如何实现一个具有基本功能的流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After reading this chapter, you will know how to set up and configure a Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T032344Z" creationid="xccui" creationdate="20190717T032344Z">
        <seg>阅读本章将使你了解如何搭建和配置Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After starting, a TaskManager registers itself at the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T140632Z" creationid="xccui" creationdate="20190718T022448Z">
        <seg>TaskManager启动后会在ResourceManager上注册自己。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, Flink does all of this.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T042759Z" creationid="xccui" creationdate="20190605T042752Z">
        <seg>Flink同样可以做到上述一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, Flink provides all required features to success&lt;t2/&gt;‐&lt;t3/&gt; fully operate data pipelines and includes many connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T024845Z" creationid="xccui" creationdate="20190317T024845Z">
        <seg>Flink 同样为执行数据管道提供了全部所需特性以及多种连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, a Flink application must enable check‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T163542Z" creationid="xingcan" creationdate="20190709T163438Z">
        <seg>Flink应用依然需要启用检查点并从一个可重置的数据源消费数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, we hope you walk away from this book with a better understanding of the capabilities and possibilities of Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T054701Z" creationid="xccui" creationdate="20190807T053855Z">
        <seg>我们希望你在读完本书后能够对Apache Flink的功能和潜力有一个更深的理解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AggregateFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002621Z" creationid="xccui" creationdate="20190624T002621Z">
        <seg>AggregateFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregating State.get() computes the final result and returns it as an Iterable with a single element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061143Z" creationid="xccui" creationdate="20190630T061056Z">
        <seg>AggregatingState.get()方法会计算最终结果并将其作为Iterable中唯一的元素返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AggregatingState[I, O] behaves similar to ReducingState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T060850Z" creationid="xccui" creationdate="20190630T060752Z">
        <seg>AggregatingState[I, O]和ReducingState行为类似，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregation operations are stateful and combine the current state with the incoming event to produce an updated aggregate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061239Z" creationid="xccui" creationdate="20190606T011759Z">
        <seg>聚合操作都是状态化的，它们通过将新到来的事件合并到已有状态来生成更新后的聚合值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregation operations are stateful and combine the current state with the incoming event to produce an updated aggregate value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T034808Z" creationid="xccui" creationdate="20190406T034634Z">
        <seg>这些聚合操作是状态化的，它们通过将新到来的事件合并到已有状态来生成更新后的聚合值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alice is a devoted player who plays the game every morning during her commute to work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T150319Z" creationid="xccui" creationdate="20190411T150319Z">
        <seg>爱丽丝是个铁杆玩家，每天早晨上班路上都会玩这个游戏。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alice keeps on playing and the game events are buffered in her phone.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154630Z" creationid="xccui" creationdate="20190411T151259Z">
        <seg>爱丽丝继续玩她的，此时游戏产生的事件会缓存在手机里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All Java and Scala primitive types, such as Int (or Integer for Java), String, and Double, are supported.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T025037Z" creationid="xccui" creationdate="20190616T070259Z">
        <seg>Flink支持所有Java和Scala的原始类型，例如Int（Java中是Integer）、String和Double。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All assigners we discuss here are time-based and were introduced in “Operations on Data Streams” on page 22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T024144Z" creationid="xccui" creationdate="20190623T032624Z">
        <seg>所有接下来要讨论的分配器都是基于时间的，我们在第22页"数据流上的操作"一节对它们都做过介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All built-in window assigners provide a default trigger that triggers the evaluation of a window once the (processing or event) time passes the end of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T033331Z" creationid="xccui" creationdate="20190623T033331Z">
        <seg>所有内置的窗口分配器都提供了一个默认的触发器，一旦（处理或事件）时间超过了窗口的结束时间就会触发窗口计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All events of the broadcasted stream are replicated and sent to all parallel operator instances of the subsequent processing function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T052019Z" creationid="xccui" creationdate="20190615T051939Z">
        <seg>所有广播流的事件都会被复制多份并分别发往后续处理函数所在算子的每个实例；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All events that are pro‐ cessed in the same parallel task of an operator have access to the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T041134Z" creationid="xccui" creationdate="20190701T035437Z">
        <seg>因此同一算子并行任务在处理任何事件时都可以访问相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All external communication with Flink services—submitting and controlling applica‐ tions and accessing the REST interface—happens over REST/HTTP endpoints.8 You can enable SSL encryption for these connections as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T152317Z" creationid="xccui" creationdate="20190725T030243Z">
        <seg>所有访问Flink服务的外部通信（提交和控制应用以及访问REST接口）都是通过REST/HTTP端点（endpoint）来进行的。8 你同样可以为这些连接启用SSL加密或相互验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All fields are public or accessible through getters and setters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T043446Z" creationid="xccui" creationdate="20190617T043446Z">
        <seg>所有字段都是公有的或提供了相应的getter及setter方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All fields have types that are supported by Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044633Z" creationid="xccui" creationdate="20190617T044620Z">
        <seg>所有字段类型都必须是Flink所支持的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All functions are evaluated by an individual task running in a dedicated thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T202032Z" creationid="esouser" creationdate="20190514T154729Z">
        <seg>其中每个函数都交由单独的任务、在特定线程内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All images you build afterwards in this shell are deployed to Mini‐ kube’s image registry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T045158Z" creationid="xccui" creationdate="20190730T045158Z">
        <seg>之后你在此Shell中构建的所有镜像都会部署到Minikube的镜像注册表中了，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All issues related to state consistency, failure handling, and efficient storage and access are taken care of by Flink so that developers can focus on the logic of their applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060233Z" creationid="xccui" creationdate="20190607T055712Z">
        <seg>所有和状态一致性、故障处理以及高效存取相关的问题都由Flink负责搞定，这样开发人员就可以专注于自己的应用逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the previously mentioned use cases for savepoints follow the same pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214212Z" creationid="xccui" creationdate="20190609T214125Z">
        <seg>所有之前提到的保存点相关用例都遵循同一个模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these parameters need to be added to Flink’s configuration file (./conf/flink-conf.yaml).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T062324Z" creationid="xccui" creationdate="20190721T062324Z">
        <seg>所有这些都需要作为参数添加到Flink的配置文件（./conf/flink-conf.yaml）中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these systems are typically designed with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T155645Z" creationid="xccui" creationdate="20190226T155406Z">
        <seg>如图1-1所示，上述类型的应用系统通常都会设置独立的数据处理层（应用程序自身）和数据存储层（事务性数据库系统）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these systems store data in different formats and data structures that provide the best performance for their specific access pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T161517Z" creationid="xccui" creationdate="20190604T053820Z">
        <seg>为了在各自访问模式下都能达到最佳性能，上述系统会将数据以不同格式或数据结构存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these systems store data in different representations and data structures that provide the best performance for their specific purpose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T065328Z" creationid="xccui" creationdate="20190314T065141Z">
        <seg>为了达到各自场景下的最佳性能，上述系统会以不同表示形式或数据结构存储数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other dependencies an application requires must be explicitly provided.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035737Z" creationid="xccui" creationdate="20190619T035725Z">
        <seg>对于应用的其它依赖则必须显式提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All parameters can be defined in the ./conf/flink-conf.yaml file, which is organized as a flat YAML file of key-value pairs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T150800Z" creationid="xccui" creationdate="20190723T041632Z">
        <seg>所有这些参数都可以在./conf/flink-conf.yaml文件中定义。该文件是一个存储键值的扁平化YAML文件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All parameters can be explicitly specified within the code of an application as described in “Tuning Checkpointing and Recovery”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043954Z" creationid="xccui" creationdate="20190724T043954Z">
        <seg>所有参数都可以在应用代码中显式指定（详见"调整检查点和恢复"一节）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All process functions implement the RichFunction interface and hence offer open(), close(), and getRuntimeContext() methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053257Z" creationid="xccui" creationdate="20190621T053257Z">
        <seg>所有处理函数都实现了RichFunction接口，因此可以提供open()、close()、getRunteimContext()等方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All processes are manually started, and there is no component that monitors these processes and restarts them in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T025125Z" creationid="xccui" creationdate="20190721T025125Z">
        <seg>所有进程都是手动启动，不存在用于监视和在它们发生故障时将其重启的组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All processes run as regular Java JVM processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T153224Z" creationid="xccui" creationdate="20190717T153224Z">
        <seg>所有进程都是作为普通的JVM进程来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All records are correctly written and the sendValues() method returns true; however, the program fails before CheckpointCommitter is called or Checkpoint Committer fails to commit the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065553Z" creationid="xccui" creationdate="20190715T065553Z">
        <seg>所有记录都已成功写入，setValues()方法返回true，但程序在调用CheckpointCommitter前出现故障或CheckpointCommitter未能成功提交检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All records that are processed by a Flink event-time streaming application must be accompanied by a timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T064203Z" creationid="xccui" creationdate="20190523T035328Z">
        <seg>由Flink事件时间流式应用处理的所有记录都必须包含时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All records with a timestamp greater than a given timestamp (requires Kafka</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040417Z" creationid="xccui" creationdate="20190709T040417Z">
        <seg>所有时间戳大于某个给定值的记录（需要Kafka 0.10.x或之后的版本）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All rights reserved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210712Z" creationid="esouser" creationdate="20190603T210712Z">
        <seg>All rights reserved.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All scripts only work for local setups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T214629Z" creationid="xccui" creationdate="20190717T214629Z">
        <seg>所有脚本都只适用于本地搭建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All started TaskManager processes register themselves at the active ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T025708Z" creationid="xccui" creationdate="20190721T025708Z">
        <seg>所有启动后的TaskManager进程都会将自己在活动的ResourceManager中注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All state modifications due to records that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061818Z" creationid="xccui" creationdate="20190609T061818Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All state primitives can be cleared by calling State.clear().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061253Z" creationid="xccui" creationdate="20190630T061253Z">
        <seg>所有状态原语都支持调用State.clear()方法来进行清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All subse‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T200922Z" creationid="xccui" creationdate="20190715T200922Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All tasks of operators that are members of the same slot-sharing group are processed by the same slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T011941Z" creationid="xccui" creationdate="20190731T011941Z">
        <seg>所属同一处理槽共享组的算子，其任务都会由相同的处理槽处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far are &lt;t0/&gt;global&lt;t1/&gt; windows and operate on the full stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193652Z" creationid="xccui" creationdate="20190409T193652Z">
        <seg>至今为止你所见到的所有窗口都是基于全流数据的全局窗口（global window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far are windows that operate on the full stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063859Z" creationid="xccui" creationdate="20190606T013831Z">
        <seg>迄今为止你所见到的所有窗口都是基于全流数据的全局窗口（global window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far need to buffer data before performing an operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T204023Z" creationid="xccui" creationdate="20190409T203631Z">
        <seg>至今为止所有你看到的窗口类型都要在执行实际操作前缓冲数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far need to buffer data before producing a result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064341Z" creationid="xccui" creationdate="20190606T014514Z">
        <seg>至今为止你见到的所有窗口类型都要在生成结果前缓冲数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All these use cases require collecting real-time data, analyzing it with low latency, and immediately reacting to the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T054203Z" creationid="xccui" creationdate="20190317T053847Z">
        <seg>所有这些用例都需要收集实时数据、进行低延迟地分析并立即响应结果，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All transformations in this section produce a DataStream whereas keyBy() results in a KeyedStream, on which transformation with access to keyed state can be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190615T070620Z">
        <seg>所有本节介绍的转换都会生成一个DataStream，而keyBy()会生成一个KeyedStream。基于后者可以应用那些能够访问键值分区状态的转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All you have to do is define a function with keyed state and make the state queryable by calling the set Queryable(String) method on the StateDescriptor before obtaining the state han‐ dle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T040207Z" creationid="xccui" creationdate="20190706T060607Z">
        <seg>你要做的就是定义一个具有键值分区状态的函数，然后在获取状态句柄之前调用StateDescriptor的setQueryable(String)方法。这样，目标状态就变为可查询的了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All you have to do is start an application with the run command and additionally provide a path to a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T040206Z" creationid="xccui" creationdate="20190727T040200Z">
        <seg>你只需在使用run命令启动应用时利用-s选项提供额外的保存点路径即可：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allowed lateness can be specified using the allowedLateness() method as Example 6-22 demonstrates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165139Z" creationid="xingcan" creationdate="20190628T165139Z">
        <seg>如示例6-22所示，我们可以使用allowedLateness()方法指定延迟容忍度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Along with the previously discussed window functions, these components work together in a window operator to group and process elements in windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051103Z" creationid="xccui" creationdate="20190625T051506Z">
        <seg>这些组件可以和之前讨论的窗口函数协同工作，一起实现对于元素的窗口化分组和处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also the internals of a stream processor that supports event-time are more involved than the internals of a system that purely operates in processing-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T033738Z" creationid="xccui" creationdate="20190523T033738Z">
        <seg>此外，相比纯粹使用处理时间，支持事件时间的流处理引擎内部要更加复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also used for module and package names, and to show commands or other text that should be typed literally by the user and the output of commands.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210806Z" creationid="esouser" creationdate="20190603T210806Z">
        <seg>Also used for module and package names, and to show commands or other text that should be typed literally by the user and the output of commands.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, a checkpoint will not fail because a local state copy failed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T163804Z" creationid="xingcan" creationdate="20190801T163804Z">
        <seg>同时，检查点也不会因为本地状态副本出现问题而失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the ProcessWindowFunction.clear() method is invoked to clean up all custom per-window state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184923Z" creationid="xccui" creationdate="20190626T184905Z">
        <seg>同时，调用ProcessWindowFunction.clear()方法来清理那些自定义的单个窗口状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the internals of a stream processor that supports event time are more involved than the internals of a system that purely operates in processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T063757Z" creationid="xccui" creationdate="20190606T204405Z">
        <seg>此外，相比纯粹使用处理时间的引擎，支持事件时间的流处理引擎内部要更加复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the overall result of the streaming appli‐ cation will be in an inconsistent state while the replay is in progress because some results will be overridden while others are not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T072248Z" creationid="xccui" creationdate="20190708T072248Z">
        <seg>同时，在重放进行过程中，由于某些结果会被覆盖而某些则不会，所以流式应用的整体结果将处于不一致的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the versions of values for multiple keys might be out of sync.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T202410Z" creationid="xccui" creationdate="20190711T202410Z">
        <seg>同时，对于多个键的值而言，其版本可能会不同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alterna&lt;t4/&gt;‐&lt;t5/&gt; tively, Flink provides a feature called queryable state which allows users to expose the state of an application as a key-lookup table and make it accessible for external appli&lt;t6/&gt;‐&lt;t7/&gt; cations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T060943Z" creationid="xccui" creationdate="20190317T060535Z">
        <seg>而Flink提供了一项名为可查询状态（queryable state）的功能，允许用户将应用的状态以键查表（key-lookup table）的形式发布出去，供其他外部应用访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, a 95th-percentile latency value of 10 ms means that 95% of events are processed within 10 ms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234036Z" creationid="xccui" creationdate="20190605T234036Z">
        <seg>而第95百分位延迟在10毫秒意味着95%的事件会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070120Z" creationid="xccui" creationdate="20190615T070120Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, it is also possible to explicitly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T071607Z" creationid="xccui" creationdate="20190630T071607Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can spec‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054159Z" creationid="xccui" creationdate="20190623T054159Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although a program is executed in a single JVM, records are serialized for cross- thread communication and possibly state persistance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T093927Z" creationid="xccui" creationdate="20190611T054835Z">
        <seg>虽然程序运行在单个JVM内，但出于跨线程通信和潜在的状态持久化需求考虑，记录都会被序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although not being covered in this book but certainly worth mentioning is that Flink also provides support for analytical SQL queries over streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T040637Z" creationid="xccui" creationdate="20190319T040637Z">
        <seg>虽然本书中并未涉及，但值得一提的是，Flink还支持基于数据流的分析型SQL查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this means Flink processes some messages twice (before and after the failure), the mechanism still achieves exactly-once state consistency because the state of all operators was reset to a point that had not seen this data yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T064240Z" creationid="xccui" creationdate="20190609T053400Z">
        <seg>虽然这意味着Flink会重复处理部分消息，但上述机制仍然可以实现精确一次的状态一致性，因为所有算子的状态都会重置到过去还没有处理过那些数据的时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although we don’t cover it here, Flink also provides support for analytical SQL quer‐ ies over streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160052Z" creationid="xccui" creationdate="20190605T045441Z">
        <seg>虽然本书中没有过多涉及，但值得一提的是，Flink还支持对于数据流的分析型SQL查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Amazon S3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042940Z" creationid="xccui" creationdate="20190725T042940Z">
        <seg>Amazon S3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Among other APIs, Cassandra fea‐ tures the Cassandra Query Language (CQL), a SQL-like language to read and write records and create, modify, and delete database objects, such as keyspaces and tables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T201429Z" creationid="xccui" creationdate="20190711T201429Z">
        <seg>在其他API方面，Cassandra提供了CQL（Cassandra Query Language）。这是一种类SQL语言，可用于读写记录以及创建、修改和删除数据库对象（如键空间和表）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Among other options, it can configure the hostnames and ports of one or more contact points; define load</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T221628Z" creationid="xccui" creationdate="20190711T221433Z">
        <seg>Cluster的配置选项包括针对一个或多个连接点（contact point）的主机名和端口、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T202926Z" creationid="xccui" creationdate="20190701T202926Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An ETL process extracts data from a transactional database, transforms it into a common representation that might include validation, value normalization, encoding, deduplication, and schema trans‐ formation, and finally loads it into the analytical database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T144947Z" creationid="esouser" creationdate="20190603T202811Z">
        <seg>ETL的基本流程是：从事务型数据库中提取数据，将其转换为通用表示形式（可能包含数据验证、数据归一化、编码、去重、Schema转换等工作），最终加载到分析型数据库中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An ETL process extracts data from a transactional database, transforms it into a common representation which might include validation, value normalization, encoding, de-duplication, and schema transformation, and finally loads it into the analytical database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192143Z" creationid="xccui" creationdate="20190228T190902Z">
        <seg>ETL的基本流程是：从事务型数据库中提取数据，将其转换为通用表示形式（可能包含数据验证、数据归一化、编码、去重、格式转换等工作），最终写入到分析型数据库中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An IDE for Java and/or Scala development.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T020738Z" creationid="xccui" creationdate="20190611T020738Z">
        <seg>用于Java/Scala开发的IDE。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative is to use an event log to distribute updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T062315Z" creationid="xccui" creationdate="20190604T062308Z">
        <seg>另一个替代方案是使用事件日志系统来分发更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative to log4j is logback and Flink provides default configuration files for this backend as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T035423Z" creationid="xccui" creationdate="20190807T035423Z">
        <seg>如果不想用log4j，可将其换为logback。Flink同样为该后端提供了默认的配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application can be canceled in two ways: with or without a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T183231Z" creationid="xccui" creationdate="20190726T183231Z">
        <seg>你可以通过两种方式取消应用：使用或不使用保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application consists of multiple operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T071000Z" creationid="xccui" creationdate="20190609T214422Z">
        <seg>每个应用都会包含很多算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application is recovered in three steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040030Z" creationid="xccui" creationdate="20190609T040030Z">
        <seg>应用恢复要经过3个步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application is started from an uploaded JAR file using the REST call that is shown in Table 10-10 .</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T050116Z" creationid="xccui" creationdate="20190729T050055Z">
        <seg>你可以使用表10-10中的REST调用利用上传的JAR文件启动应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application receiving game events would experience a gap when the train goes through a tunnel and network con&lt;t0/&gt;‐&lt;t1/&gt; nection is lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152946Z" creationid="xccui" creationdate="20190411T152813Z">
        <seg>当地铁进入隧道断网时，应用接收游戏事件会经历一段间隙。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application receiving online mobile game events played on the subway would experience a gap when the network connection is lost, but events are buffered in the player’s phone and delivered when the connection is restored</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023511Z" creationid="xccui" creationdate="20190606T015305Z">
        <seg>当地铁进入隧道断网时，应用接收游戏事件会中断一会，此时事件会缓存在玩家手机中，并在网络恢复后发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application that aims to provide end-to-end exactly-once guarantees requires spe‐ cial sink connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T062751Z" creationid="xccui" creationdate="20190708T062735Z">
        <seg>应用若想提供端到端的精确一次性保障，需要一些特殊的数据汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application with a function that has a queryable state is executed just like any other application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T063318Z" creationid="xccui" creationdate="20190706T063318Z">
        <seg>具有可查询式状态的函数并不会改变应用的执行方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An appli‐ cation can recover from a TaskManager failure as long as enough processing slots are on standby to compensate for the lost TaskManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T034334Z" creationid="xccui" creationdate="20190721T034334Z">
        <seg>只要有足够多的处理槽随时来接替那些无法工作的TaskManager，应用就可以从TaskManager故障中恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An attribution usually includes the title, author, publisher, and ISBN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210823Z" creationid="esouser" creationdate="20190603T210823Z">
        <seg>An attribution usually includes the title, author, publisher, and ISBN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An early contributor to Flink, she has worked on its graph processing library, Gelly, and on early versions of the Table API and streaming SQL.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T035233Z" creationid="xccui" creationdate="20190808T035233Z">
        <seg>作为Flink早期的贡献者，她参与了图计算库Gelly以及初期版本Table API和流式SQL的建设工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An early firing trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200121Z" creationid="xccui" creationdate="20190626T200121Z">
        <seg>可提前触发的触发器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An element can be added to zero, one, or multiple windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041408Z" creationid="xccui" creationdate="20190626T041408Z">
        <seg>每个元素可以被加到零个、一个或多个窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An element of the first input will not be joined with an element of the second input even if they are just 1 second apart from each other but assigned to two different windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T143512Z" creationid="xccui" creationdate="20190628T055552Z">
        <seg>那么一旦来自两个输入的元素没有被划分到同一窗口，它们就无法Join在一起，即使二者彼此仅相差1秒钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An embedded execution mode starts Flink applications as a single JVM process which can be used to run and debug Flink jobs within an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T053733Z" creationid="xccui" creationdate="20190328T053510Z">
        <seg>Flink的嵌入式执行模式可将应用以单个JVM进程的方式启动，方便在IDE里运行和调试Flink作业，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event log stores and distributes event streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T054357Z" creationid="xccui" creationdate="20190305T054122Z">
        <seg>事件日志负责存储事件流并将其分布式化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event time window computation will yield the same result no matter how fast the stream is pro‐ cessed or when the events arrive at the operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024326Z" creationid="xccui" creationdate="20190606T024326Z">
        <seg>无论数据流的处理速度如何、事件到达算子的顺序怎样，基于事件时间的窗口都会生成同样的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-driven application architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213914Z" creationid="esouser" creationdate="20190603T213914Z">
        <seg>事件驱动型应用架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-driven application architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152556Z" creationid="xccui" creationdate="20190307T152556Z">
        <seg>事件驱动型应用架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-time window computation will yield the same result no matter how fast the stream is pro&lt;t0/&gt;‐&lt;t1/&gt; cessed or when the events arrive at the operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T151505Z" creationid="xccui" creationdate="20190412T151505Z">
        <seg>无论数据流的处理速度如何、事件到达算子的顺序怎样，基于事件时间的窗口都会生成同样的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-time window triggers when the watermarks declare that all timestamps for a certain time interval have been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T045728Z" creationid="xccui" creationdate="20190619T071049Z">
        <seg>只有依靠水位线声明某个时间间隔内所有时间戳都已接收时，事件时间窗口才会触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An evictor can remove collected elements from the con‐ tents of a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014627Z" creationid="xccui" creationdate="20190626T014450Z">
        <seg>它可以用来从窗口中删除已经收集的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example application would be a real-time monitoring dashboard that displays event aggregates as they are received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031104Z" creationid="xccui" creationdate="20190414T043802Z">
        <seg>一个常见示例应用是实时监控仪表盘，它会接收并展示事件聚合结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example is the well-known Yahoo!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T191430Z" creationid="xccui" creationdate="20190716T191430Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An idempotent SinkFunction that writes to a JDBC database</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T203934Z" creationid="xccui" creationdate="20190714T044810Z">
        <seg>利用JDBC写数据库的幂等性SinkFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An idempotent operation can be performed several times but will only result in a sin‐ gle change.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T063359Z" creationid="xccui" creationdate="20190708T063359Z">
        <seg>幂等操作可以多次执行，但只会导致一次改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An important choice that affects the performance of an application is the state back‐ end that maintains its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T044328Z" creationid="xccui" creationdate="20190724T044231Z">
        <seg>影响应用程序性能的一个重要方面是用以维护状态的状态后端的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An input split defines a range on a file,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T191725Z" creationid="xccui" creationdate="20190710T191725Z">
        <seg>每个输入划分都定义了文件中的某个范围，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance of the function class can then be passed as an argument to the filter transformation:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054126Z" creationid="xccui" creationdate="20190618T054126Z">
        <seg>随后可将函数类的实例作为参数传递给filter转换：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interesting property of watermarks is that they allow an application to control result completeness and latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T065330Z" creationid="xccui" creationdate="20190529T035835Z">
        <seg>水位线的意义之一在于它允许应用控制结果的完整性和延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interval</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025805Z" creationid="xccui" creationdate="20190628T025805Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interval join joining two streams A and B</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025304Z" creationid="xccui" creationdate="20190628T025154Z">
        <seg>流A和流B上基于间隔的Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interval join needs to buffer records from one or both inputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T031036Z" creationid="xccui" creationdate="20190628T031036Z">
        <seg>基于间隔的Join需要同时对双流的记录进行缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An iteration of the 2PC protocol succeeds when all sink tasks committed their transactions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T213055Z" creationid="xccui" creationdate="20190715T213055Z">
        <seg>在全部数据汇任务成功提交自己的事务后，一轮2PC协议的迭代就此结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An on-going effort of the Flink community is to evolve Flink towards a system with a unified batch and streaming API and runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T061543Z" creationid="xccui" creationdate="20190328T061256Z">
        <seg>社区正在努力的一个方向就是将Flink发展成为在API及运行时层面都能做到批流统一的系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An ongoing effort of the Flink community is to evolve Flink toward a system with a truly unified batch and streaming API and runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122304Z" creationid="xccui" creationdate="20190605T122304Z">
        <seg>社区正在努力的一个方向就是将Flink发展成为在API及运行时层面都能做到批流统一的系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An online retailer is able to recommend products to users while they are browsing on the retailer’s website; mobile games can give virtual gifts to users to keep them in a game or offer in-game purchases at the right moment; manufacturers can monitor the behavior of machines and trigger maintenance actions to reduce production outages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T053555Z" creationid="xccui" creationdate="20190317T053555Z">
        <seg>在线商家可以在用户浏览店铺页面的同时为其推荐产品；移动游戏为了提高用户粘性可以适时为其发放虚拟礼品或提供内购折扣；制造商可以通过监测机器行为及时触发维护，从而减少生产中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator based on event time uses watermarks to determine the completeness of its ingested records and the progress of its operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031058Z" creationid="xccui" creationdate="20190621T031058Z">
        <seg>基于事件时间的算子使用水位线来判断输入记录的完整度以及自身的操作进度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator inherits the slot-sharing group of its input operators if they are</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015144Z" creationid="xccui" creationdate="20190731T014949Z">
        <seg>如果一个算子所有输入都属于同一处理槽共享组，那么该算子也会将这个组继承；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator pipeline that complies with the requirements of task chaining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T200254Z" creationid="xccui" creationdate="20190606T203431Z">
        <seg>满足任务链接条件的算子流水线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator pipeline that complies with the requirements of task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152418Z" creationid="esouser" creationdate="20190514T152418Z">
        <seg>满足任务链接需求的算子流水线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator that is applied on a KeyedStream is applied in the context</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T020822Z" creationid="xccui" creationdate="20190630T040707Z">
        <seg>作用在KeyedStream上的算子会同时拥有它的键值定义上下文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator that supports recomputing and updating of emitted results needs to pre‐ serve all state required for the computation after the first result was emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T162344Z" creationid="xingcan" creationdate="20190628T162344Z">
        <seg>支持重新计算和对已发出结果进行更新的算子需要保留那些用于再次计算结果的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An opera‐ tor that is applied on a connected and keyed stream has access to keyed state.3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T063240Z" creationid="xccui" creationdate="20190615T051502Z">
        <seg>作用在已经按照键值分区且已联结的数据流上的算子可以访问键值分区状态。3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional user scope</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T220238Z" creationid="xccui" creationdate="20190803T220238Z">
        <seg>一个可选的用户域</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An org.apache.flink.metrics.Counter metric measures a count and provides methods for increment and decrement.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T025025Z" creationid="xccui" creationdate="20190803T025025Z">
        <seg>org.apache.flink.metrics.Counter指标用于测量计数并提供了相应的增减方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unmodified application can always be restarted from its save‐ point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T050615Z" creationid="xccui" creationdate="20190727T050615Z">
        <seg>如果没有被修改过，应用总是可以从之前生成的保存点重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Analytical Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142900Z" creationid="esouser" creationdate="20190603T142900Z">
        <seg>分析型处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Analyzing user behavior in mobile applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045426Z" creationid="xccui" creationdate="20190605T045425Z">
        <seg>移动应用中的用户行为分析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Analyzing user behavior in mobile applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033623Z" creationid="xccui" creationdate="20190319T033421Z">
        <seg>移动应用中的用户行为分析，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And everyone knows that the mobile inter&lt;t0/&gt;‐&lt;t1/&gt; net connection in the Berlin subway is lousy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151131Z" creationid="xccui" creationdate="20190411T150417Z">
        <seg>而众所周知，柏林地铁上手机网络信号很差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And everyone knows that the mobile internet connection in the Berlin subway is lousy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T015018Z" creationid="xccui" creationdate="20190606T014954Z">
        <seg>而众所周知，柏林地铁上手机上网信号很差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And how do we even know that data will be delayed?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T203758Z" creationid="xccui" creationdate="20190412T161851Z">
        <seg>此外，我们如何得知数据会产生延迟？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And in those cases, will the output be deterministic?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043528Z" creationid="xccui" creationdate="20190415T043222Z">
        <seg>在上述情况下，结果是否确定？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And in those cases, will the out‐ put be deterministic?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033643Z" creationid="xccui" creationdate="20190606T033643Z">
        <seg>在上述情况下，结果是否确定？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And what if a window triggers multiple times?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T053030Z" creationid="xccui" creationdate="20190806T052851Z">
        <seg>再进一步，如果窗口会多次触发计算又该如何处理？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anomaly detection (e.g., to detect attempts to intrude a computer network)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055449Z" creationid="esouser" creationdate="20190603T213713Z">
        <seg>异常检测（例如：计算机网络入侵检测）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anomaly detection, e.g., to detect attempts to intrude a computer network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T151741Z" creationid="xccui" creationdate="20190307T151741Z">
        <seg>异常检测（例如：计算机网络入侵检测）等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another approach that works for many storage systems is idempotent updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054318Z" creationid="xccui" creationdate="20190609T054237Z">
        <seg>另一种适用于很多存储系统的方法是幂等更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another case is when you need to periodically report results in real time, independently of their accuracy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180821Z" creationid="xccui" creationdate="20190606T031009Z">
        <seg>另一种情况是，你需要周期性地实时报告结果而无论其准确性如何。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another case is when you need to periodically report results in real-time, independently of their accuracy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043410Z" creationid="xccui" creationdate="20190414T043410Z">
        <seg>另一种情况是，你需要周期性地实时报告结果，而不考虑其准确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another factor that affects latency and consequently throughput is the time it takes to process an event, or the time it takes for each customer to be served in the coffee shop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T205647Z" creationid="xccui" creationdate="20190402T205438Z">
        <seg>影响延迟和相应吞吐的另一因素是处理单个事件的时间，即在咖啡店服务每一名顾客所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another feature are per-window and per-key global states.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T040921Z" creationid="xccui" creationdate="20190624T012333Z">
        <seg>另一项功能是访问单个窗口的状态及每个键值的全局状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another good practice is to update state only once per function call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T033020Z" creationid="xccui" creationdate="20190704T034315Z">
        <seg>此外我们建议每次函数调用只更新一次状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another important aspect of source functions are timestamps and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034621Z" creationid="xccui" creationdate="20190713T034621Z">
        <seg>另一个与数据源函数相关的重要方面是时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another improvement was the dissolution of the latency-throughput trade-off.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T134512Z" creationid="xccui" creationdate="20190327T134512Z">
        <seg>系统另一方面的改进是消除了延迟和吞吐的代价权衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another improvement was the dissolu‐ tion of the latency/throughput tradeoff.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T163854Z" creationid="xccui" creationdate="20190605T053453Z">
        <seg>它的另一项改进是无需让用户在延迟和吞吐之间做出困难的抉择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another problem source functions have to deal with are instances that become idle and do not emit anymore data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T042254Z" creationid="xccui" creationdate="20190713T042254Z">
        <seg>数据源函数要面对的另一个问题是那些空闲下来不再发出数据的实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another state backend serializes state objects and puts them into RocksDB, which writes them to local hard disks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T052613Z" creationid="xccui" creationdate="20190608T052302Z">
        <seg>另一类状态后端会把状态对象序列化后存到RocksDB里面，RocksDB负责将它们写到本地硬盘上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another technique to reduce the checkpointing algorithm’s impact on the processing latency is to tweak the barrier alignment step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T065720Z" creationid="xccui" creationdate="20190609T204102Z">
        <seg>我们还可以对分隔符对齐这一步进行调整，以降低检查点算法对处理延迟的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve equivalent functionality is using record acknowledgements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T043605Z" creationid="xccui" creationdate="20190416T043447Z">
        <seg>另一个实现同样功能的途径是启用记录确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve equivalent functionality is using record acknowledgments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193821Z" creationid="xccui" creationdate="20190606T034729Z">
        <seg>还有一个实现同样功能的途径是启用记录确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve the same result is to hire a second barista and exploit parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054629Z" creationid="xccui" creationdate="20190605T235436Z">
        <seg>另一个殊途同归的办法是再雇一个咖啡师，即利用并行解决问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve the same result is to hire a second barista, that is, to exploit parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211453Z" creationid="xccui" creationdate="20190402T211202Z">
        <seg>另一个殊途同归的办法是再雇一个咖啡师，即利用并发解决问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to define keys and select fields is by using String-based field expres‐ sions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T041602Z" creationid="xccui" creationdate="20190618T041433Z">
        <seg>另一种定义键值和选择字段的方法是使用基于字符串的字段表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Answering a question by citing this book and quoting example code does not require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210820Z" creationid="esouser" creationdate="20190603T210820Z">
        <seg>Answering a question by citing this book and quoting example code does not require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any JVM-based application can query the queryable state of a running Flink applica‐ tion by using QueryableStateClient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T124605Z" creationid="xccui" creationdate="20190706T124605Z">
        <seg>所有基于JVM的应用都可以使用QueryableStateClient对运行中Flink的可查询式状态进行查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any application that processes a stream of events and does not just perform trivial record-at-a-time transformations needs to be stateful, i.e., have the ability to store and access intermediate data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T030539Z" creationid="xccui" creationdate="20190305T030539Z">
        <seg>任何需要处理事件流的应用程序，如果支持跨多条记录的转换操作，则必须是状态化的，因为需要存储和访问中间结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any application that processes a stream of events and does not just perform trivial record-at-a-time transformations needs to be stateful, with the ability to store and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T073044Z" creationid="esouser" creationdate="20190603T205538Z">
        <seg>任何一个处理事件流的应用，如果要支持跨多条记录的转换操作，都必须是状态化的，即能够存储和访问中间结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any sink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170057Z" creationid="xccui" creationdate="20190708T170057Z">
        <seg>任意数据汇</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Cassandra Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055025Z" creationid="xccui" creationdate="20190225T025211Z">
        <seg>Apache Cassandra数据汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Cassandra is a popular, scalable, and highly available column store database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T193110Z" creationid="xccui" creationdate="20190711T193110Z">
        <seg>Apache Cassandra是一个非常流行的、具有可伸缩和高可用特性的列式存储数据库系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T042850Z" creationid="xccui" creationdate="20190606T042850Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink Web UI home screen</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T034421Z" creationid="xccui" creationdate="20190802T034421Z">
        <seg>Apache Flink Web UI主界面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink can be deployed on Kubernetes as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T142627Z" creationid="xccui" creationdate="20190719T022715Z">
        <seg>Apache Flink也对此做了相应支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink can be easily integrated with Hadoop YARN and HDFS and other com‐ ponents of the Hadoop ecosystem, such as HBase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T145544Z" creationid="xccui" creationdate="20190722T005906Z">
        <seg>Apache Flink可以很容易地与Hadoop YARN、HDFS及其他Hadoop生态组件（如HBase）相集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink checks all these boxes and is a very good choice to run event-driven applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T064114Z" creationid="xccui" creationdate="20190314T062533Z">
        <seg>Apache Flink 能够同时涵盖上述全部特性，是运行事件驱动型应用的一个非常好的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink checks all these boxes and is a very good choice to run this class of applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T074800Z" creationid="xccui" creationdate="20190604T053710Z">
        <seg>Apache Flink能够同时涵盖上述全部特性，是运行该类应用的一个非常好的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink features a resettable source connector to ingest data in files as streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T183935Z" creationid="xccui" creationdate="20190710T183935Z">
        <seg>Apache Flink提供了一个可重置的数据源连接器，支持将文件中的数据提取成数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink features queryable state to address use cases that usually would require an external datastore to share data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T162535Z" creationid="xccui" creationdate="20190705T162535Z">
        <seg>为了解决通常意义上需要外部数据存储才能分享数据的问题，Apache Flink提供了可查询式状态（queryable state）功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink has a growing and welcoming community with contributors and users all around the world.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T163849Z" creationid="xingcan" creationdate="20190807T163849Z">
        <seg>Apache Flink拥有一个不断成长的友好社区，其中的贡献者和用户来自全球各地。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink is a distributed stream processor of the third generation with a compet&lt;t0/&gt;‐&lt;t1/&gt; itive feature set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T041127Z" creationid="xccui" creationdate="20190328T002907Z">
        <seg>Apache Flink是一个集众多具有竞争力的特性于一身的第三代流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink is a distributed stream processor with intuitive and expressive APIs to implement stateful stream processing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014455Z" creationid="xccui" creationdate="20190225T191847Z">
        <seg>Apache Flink是一个分布式流处理引擎，它提供了直观且极富表达力的API来实现状态化流处理应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink is a third-generation distributed stream processor with a competitive feature set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054018Z" creationid="xccui" creationdate="20190605T054018Z">
        <seg>Apache Flink是一个集众多具有竞争力的特性于一身的第三代流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink offers many parameters to configure its behavior and tweak its perfor‐ mance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T041638Z" creationid="xccui" creationdate="20190723T041547Z">
        <seg>Apache Flink提供了很多用来配置行为和调节性能的参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink provides a script to build job-specific Flink Docker images.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190730T030740Z">
        <seg>Apache Flink提供了一个用于针对特定作业构建Flink Docker镜像的脚本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink provides connectors to read data from and write data to a variety of storage systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170457Z" creationid="xccui" creationdate="20190708T170457Z">
        <seg>Apache Flink为很多外部存储系统都提供了相应的数据读写连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink provides the AsyncFunction to mitigate the latency of remote I/O calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T192319Z" creationid="xccui" creationdate="20190716T192254Z">
        <seg>Apache Flink提供的AsyncFunction可以有效降低I/O调用所带来的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink stores application state locally in memory or in an embedded database and not in a remote database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T031826Z" creationid="xccui" creationdate="20190305T031826Z">
        <seg>Apache Flink使用本地内存和嵌入式数据库（而非远程数据库）存储状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink stores the application state locally in memory or in an embedded data‐ base.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210000Z" creationid="esouser" creationdate="20190603T205946Z">
        <seg>Apache Flink使用本地内存和嵌入式数据库存储状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink supports Kerberos authentication and can be configured to encrypt all network communication with SSL.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T022650Z" creationid="xccui" creationdate="20190725T022331Z">
        <seg>Apache Flink支持Kerberos身份验证，可以利用SSL对网络通信进行加密。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink uses filesystems for various tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T150118Z" creationid="xccui" creationdate="20190722T030921Z">
        <seg>文件系统在Apache Flink中用途广泛。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Hadoop YARN</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040315Z" creationid="xccui" creationdate="20190418T040315Z">
        <seg>Apache Hadoop YARN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Kafka Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055004Z" creationid="xccui" creationdate="20190225T025141Z">
        <seg>Apache Kafka数据汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Kafka Source Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054953Z" creationid="xccui" creationdate="20190225T025132Z">
        <seg>Apache Kafka数据源连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Kafka is a distributed streaming platform.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T201608Z" creationid="xccui" creationdate="20190708T201532Z">
        <seg>Apache Kafka是一个分布式流处理平台。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Maven 3.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T020152Z" creationid="xccui" creationdate="20190611T020152Z">
        <seg>Apache Maven 3.x版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Parquet, which organizes and compresses records in a columnar for‐ mat, is a file format that requires bulk encoding.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T023549Z" creationid="xccui" creationdate="20190711T023549Z">
        <seg>Apache Parquet会以列式来组织和压缩记录，因此该文件格式需要批量编码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from creating your own histogram implementation, Flink also allows you to use a DropWizard histogram by adding the dependency in the following:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T032959Z" creationid="xccui" creationdate="20190803T032959Z">
        <seg>除了创建你自己的直方图实现外，Flink还允许你通过添加以下依赖使用DropWizard直方图：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from having a practical value, windows also enable semantically interesting queries on streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T065640Z" creationid="xccui" creationdate="20190406T042112Z">
        <seg>除了产生单个有用的结果，窗口操作还支持在数据流上完成一些语义方面很有价值的查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appendix Title.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040542Z" creationid="xccui" creationdate="20190418T040542Z">
        <seg>附录标题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application Consistency Guarantees</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025111Z" creationid="xccui" creationdate="20190225T025111Z">
        <seg>应用的一致性保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application Consistency Guarantees | 185</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T070108Z" creationid="xccui" creationdate="20190708T070108Z">
        <seg>应用的一致性保障 | 185</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application Deployment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021747Z" creationid="xccui" creationdate="20190225T021747Z">
        <seg>应用部署</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application submission and component interactions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143131Z" creationid="xccui" creationdate="20190606T143129Z">
        <seg>应用提交及组件交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application submission and component interactions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024603Z" creationid="xccui" creationdate="20190423T024603Z">
        <seg>应用提交及组件交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ApplicationMaster is YARN’s master process of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052535Z" creationid="xccui" creationdate="20190721T052535Z">
        <seg>ApplicationMaster是YARN中应用的主进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T043128Z" creationid="xccui" creationdate="20190725T043128Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications are usually connected to external services or face human users and con‐ tinuously process incoming events such as orders, email, or clicks on a website.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T052224Z" creationid="esouser" creationdate="20190603T195414Z">
        <seg>这些应用通常会连接外部服务或实际用户，并持续处理诸如订单、邮件、网站点击等传入的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications can also be individually operated and scaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055838Z" creationid="esouser" creationdate="20190603T214115Z">
        <seg>同时，所有应用都支持独立操作和扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications can be individually operated and scaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T073447Z" creationid="xccui" creationdate="20190308T073358Z">
        <seg>同时，全部应用都支持独立操作和扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications can read their input from and write their results to files (see “Filesystem Source Connector”), application checkpoints and metadata are persisted in remote filesystems for recovery (see “Checkpoints, Savepoints, and State Recovery”), and some internal components lev‐ erage filesystems to distribute data to tasks, such as application JAR files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T031446Z" creationid="xccui" creationdate="20190722T031405Z">
        <seg>应用可以从文件读取输入或将结果写入文件（请见"文件系统数据源连接器"），应用检查点和元数据会保存在远程文件系统中以供恢复使用（请见"检查点，保存点及状态恢复"），一些内部组件会使用文件系统将数据（例如应用的JAR文件）分发到各任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications consume the results by merging approximated results from the speed table and the accurate results from the batch table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052646Z" creationid="xccui" creationdate="20190605T052414Z">
        <seg>为了获取最终结果，应用需要将"提速表"中的近似结果以及批处理表中的精确结果合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications consume the results from the Serving Layer by merging the most recent but only approximated results from the speed table and the older but accurate result from the batch table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T045050Z" creationid="xccui" creationdate="20190322T053047Z">
        <seg>应用通过合并"提速表"中的较新的近似结果以及批处理表中较旧的精确结果来从服务层获取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications need to explicitly enable the periodic checkpointing mechanism via the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204732Z" creationid="xccui" creationdate="20190702T204629Z">
        <seg>应用需要像示例7-9中那样，显式地在StreamExecutionEnvironment中启用周期性检查点机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145100Z" creationid="esouser" creationdate="20190603T145053Z">
        <seg>应用转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply streaming transformations to implement the application logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043619Z" creationid="xccui" creationdate="20190612T043619Z">
        <seg>通过一系列流式转换来实现应用逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022606Z" creationid="xccui" creationdate="20190225T022606Z">
        <seg>应用转换操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying AsyncFunction on a DataStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201717Z" creationid="xccui" creationdate="20190716T201717Z">
        <seg>在DataStream上应用AsyncFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying Functions on Windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023223Z" creationid="xccui" creationdate="20190225T023223Z">
        <seg>在窗口上应用函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a CoProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031414Z" creationid="xccui" creationdate="20190622T031414Z">
        <seg>应用CoProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a FlatMapFunction with a keyed ValueState</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062303Z" creationid="xccui" creationdate="20190630T062017Z">
        <seg>应用一个带有键值分区ValueState的FlatMapFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a ProcessFunction that emits to a side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T203037Z" creationid="xccui" creationdate="20190622T022702Z">
        <seg>将数据发送至副输出的ProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a ReduceFunction for incremental aggregation and a ProcessWindowFunction for finalizing the window result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043549Z" creationid="xccui" creationdate="20190625T043549Z">
        <seg>使用ReduceFunction执行增量聚合，使用ProcessWindowFunction计算最终结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a reduce lambda function on a WindowedStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002403Z" creationid="xccui" creationdate="20190624T002403Z">
        <seg>在WindowedStream上应用reduce lambda函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying an AggregateFunction on a WindowedStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005444Z" creationid="xccui" creationdate="20190624T005444Z">
        <seg>在WindowedStream上应用AggregateFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>April 2019:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210727Z" creationid="esouser" creationdate="20190603T210727Z">
        <seg>April 2019:</seg>
      </tuv>
    </tu>
    <tu>
      <note>后面加了一个service</note>
      <tuv lang="EN-US">
        <seg>Architecture and Enabling Queryable State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151548Z" creationid="xccui" creationdate="20190225T025000Z">
        <seg>可查询式状态服务的架构及启用方式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Architecture of Flink’s queryable state service</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T024222Z" creationid="xccui" creationdate="20190706T024222Z">
        <seg>Flink可查询式状态服务的架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguably, one could use an external system to also manage streaming state, even though this design choice might introduce additional latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T054652Z" creationid="xccui" creationdate="20190414T054541Z">
        <seg>讲道理，虽然可能引入额外延迟，但完全可以同样用一个外部系统来管理流式状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguably, we could use an external system to also manage streaming state, even though this design choice might introduce additional latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182838Z" creationid="xccui" creationdate="20190606T032201Z">
        <seg>按理说，我们也可以使用外部系统来管理流处理过程中的状态，即便这样可能会引入额外延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays, Lists, Maps, Enums, and other special types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T045252Z" creationid="xccui" creationdate="20190617T045252Z">
        <seg>数组、列表、映射、枚举以及其他特殊类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As  men‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T061052Z" creationid="xccui" creationdate="20190716T061052Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a Windows user you can use the Windows subsystem for Linux (WSL), Cygwin, or a Linux virtual machine to run Flink in a UNIX environ‐ ment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T071807Z" creationid="xccui" creationdate="20190611T014711Z">
        <seg>如果你是Windows用户，可以使用自带的WSL、Cygwin或Linux虚拟机来在UNIX环境下运行Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a consequence, a single inactive partition causes the whole application to stall because the application’s watermarks do not make progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T022830Z" creationid="xccui" creationdate="20190709T022746Z">
        <seg>因此，单个非活跃的分区就会导致整个应用停止运行，因为整个应用的水位线都不会前进。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a consequence, processing systems like Flink need to maintain several dedicated connectors to be able to read events from and write events to the most commonly used message queues, event logs, filesystems, key- value stores, and database systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T194915Z" creationid="xccui" creationdate="20190708T194915Z">
        <seg>因此，类似Flink这样的处理系统就需要维护很多专用的连接器，以便能够从最常用的消息队列、事件日志、文件系统、键值存储以及数据库系统中读写事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a con‐ sequence, an application with default operator identifiers is very limited in how it can be evolved without losing state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T071336Z" creationid="xccui" creationdate="20190610T025637Z">
        <seg>因此使用默认算子标识的应用如果不想丢失状态，那么改动空间会比较有限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described before, transactional sink connectors need to be integrated with Flink’s checkpointing mechanism because they may only commit data to the external system when a checkpoint completes successfully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T034140Z" creationid="xccui" creationdate="20190715T034140Z">
        <seg>如前所述，由于事务性数据汇连接器可能只会在检查点成功完成后才将数据写入外部系统，所以它需要与Flink的检查点机制做好集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in “Scaling Stateful Operators” on page 56, Flink distributes keyed state on the granularity of so-called key groups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T020220Z" creationid="xccui" creationdate="20190729T020220Z">
        <seg>我们在第56页"状态化算子扩缩容"一节介绍过，Flink以键值组为单位分配键值状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed before, Flink requires a sufficient amount of processing slots in order to execute all tasks of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205357Z" creationid="xccui" creationdate="20190428T205349Z">
        <seg>如前所述，为了执行应用的全部任务，Flink需要足够数量的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed before, Flink requires a sufficient number of processing slots in order to execute all tasks of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145426Z" creationid="xccui" creationdate="20190606T145426Z">
        <seg>如前所述，为了执行应用的全部任务，Flink需要足够数量的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed before, elements are assigned to windows by</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T031512Z" creationid="xccui" creationdate="20190626T031512Z">
        <seg>如前所述，元素会通过WindowAssigner分配给窗口，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in “A Quick Look at Flink” on page 12, the program generates read events for multiple thermal sensors, converts the temperature of the events from Fahrenheit to Celsius, and computes the average temperature of each sensor every second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053343Z" creationid="xccui" creationdate="20190611T042330Z">
        <seg>我们在第12页"Flink快览"中讲过，这个程序会模拟生成多个热传感器的读数事件，将其中的温度由华氏度改为摄氏度，然后计算每个传感器每秒钟的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in “Checkpoints, Savepoints, and State Recovery” on page 58, a check‐ point is only successful if all operator tasks successfully checkpointed their states to the checkpoint storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T193043Z" creationid="xccui" creationdate="20190702T201740Z">
        <seg>正如第58页"检查点、保存点及状态恢复"一节所述，在所有算子任务都成功将其状态写入检查点存储后，整体的检查点才算创建成功。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in “Event-Time Processing” on page 47, your application needs to pro‐ vide two important pieces of information to Flink in order to operate in event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T050825Z" creationid="xccui" creationdate="20190620T014933Z">
        <seg>我们在第47页"事件时间处理"一节中讲到，为了在事件时间模式下工作，应用需要向Flink提供两项重要信息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in “Scaling Stateful Operators” on page 56, the list struc‐ ture supports changing the parallelism of functions with operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T045820Z" creationid="xccui" creationdate="20190701T054835Z">
        <seg>其实这个问题的答案已经在第56页"状态化算子扩缩容"中提到了——列表结构允许对使用了算子状态的函数修改并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in “Setting the Parallelism” on page 96, the parallelism of an application and its operators can be specified in different ways.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190728T041741Z" creationid="xccui" creationdate="20190728T041741Z">
        <seg>我们在第96页"设置并行度"一节介绍过，应用程序及其算子的并行度有多种指定方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed, the end-to-end consistency guarantees of an application depend on the properties of its sink connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024944Z" creationid="xccui" creationdate="20190714T024944Z">
        <seg>如前所述，应用端到端的一致性保障取决于其数据汇连接器的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed, watermarks can be used to balance result completeness and result latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T205129Z" creationid="xingcan" creationdate="20190628T144503Z">
        <seg>我们在之前介绍过，水位线可用来平衡结果的完整性和延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As explained in “Com‐ ponents of a Flink Setup” on page 38, a Flink application is submitted to the JobMan‐ ager (master), which distributes execution tasks to one or more TaskManagers (workers).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T092408Z" creationid="xccui" creationdate="20190611T051138Z">
        <seg>正如之前第38页"搭建Flink所需组件"中介绍的，Flink应用会提交至JobManager（master），后者负责将需要执行的任务分配给一个或多个TaskManager（worker）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As for the tuples, we filter the DataStream by age:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T025454Z" creationid="xccui" creationdate="20190617T041008Z">
        <seg>和使用元组的情况一样，我们对DataStream按照年龄进行过滤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As indicated by name, these functions are applicable in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T052024Z" creationid="xccui" creationdate="20190621T051948Z">
        <seg>从名字就能看出，这些函数适用于不同的上下文环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned earlier, GenericWriteAheadSink cannot provide bulletproof exactly- once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065011Z" creationid="xccui" creationdate="20190715T065011Z">
        <seg>如前所述，GenericWriteAheadSink无法百分之百提供精确一次保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned, an application can only be started from a savepoint if it is compatible with the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T205028Z" creationid="xccui" creationdate="20190727T050523Z">
        <seg>我们在前文提到过，应用只有和保存点兼容时才可以从该保存点启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As motivated in &lt;t2/&gt;Chapter 2&lt;t3/&gt;, a certain degree of timestamp out-of-orderness is given in basically all real-world use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040054Z" creationid="xccui" creationdate="20190523T040054Z">
        <seg>正如第2章所述，基本上所有现实世界的应用场景都会出现一定程度的时间戳乱序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As of version 0.10.0, Kafka supports message timestamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T022904Z" creationid="xccui" creationdate="20190709T022904Z">
        <seg>Kafka从版本0.10.0开始支持消息时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As one could imagine, supporting stateful operators comes with a few implementa&lt;t0/&gt;‐&lt;t1/&gt; tion challenges:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T033138Z" creationid="xccui" creationdate="20190414T055834Z">
        <seg>不难想象，支持状态化算子将面临很多实现上的挑战：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As pointed out in “Event-Time Processing” and “Assigning Timestamps and Generating</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034741Z" creationid="xccui" creationdate="20190713T034741Z">
        <seg>正如在"事件时间处理"及"分配时间戳和生成水位线"章节提到的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As previously stated, stateful stream processing is a versatile and flexible design archi‐ tecture that can be used for many different use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T160957Z" creationid="esouser" creationdate="20190603T211912Z">
        <seg>综上所述，状态化流处理是一类用途广泛、灵活多变的设计模式，可用来解决很多不同的用例问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As previously stated, stateful streaming processing is a versatile and flexible design pattern and can be used to address many different use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T145813Z" creationid="xccui" creationdate="20190305T145258Z">
        <seg>如上所述，状态化流处理是一种用途广泛、灵活多变的设计模式，可用来解决很多不同的用例问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As seen in “Time Semantics”, a certain degree of timestamp out-of- orderness is given in basically all real-world use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T064354Z" creationid="xccui" creationdate="20190606T204903Z">
        <seg>正如"时间语义"一节所述，基本上所有现实应用场景都会出现一定程度的时间戳乱序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in &lt;t3/&gt;Figure 1-8&lt;t4/&gt;, you will see some statistics about the local Flink cluster you just started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035221Z" creationid="xccui" creationdate="20190329T035158Z">
        <seg>如图1-8所示，你会看到一些有关刚刚启动的本地Flink集群的统计信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in &lt;t4/&gt;Figure 2-12&lt;t5/&gt;, in Alice’s case, a processing-time window would continue counting time when her phone gets discon&lt;t6/&gt;‐&lt;t7/&gt; nected, thus not accounting for her game activity during that time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145241Z" creationid="xccui" creationdate="20190412T144815Z">
        <seg>如图2-12所示，在爱丽丝的例子中，处理时间窗口在她手机离线后会继续计时，因此不会把她在那段时间的活动考虑在内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in Figure 1-8, you will see some statistics about the local Flink cluster you just started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123250Z" creationid="xccui" creationdate="20190605T123250Z">
        <seg>如图1-8所示，你会看到一些有关刚刚启动的本地Flink集群的统计信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in Figure 2-12, in Alice’s case, a processing-time window would continue counting time when her phone gets discon‐ nected, thus not accounting for her game activity during that time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155718Z" creationid="xccui" creationdate="20190606T023852Z">
        <seg>如图2-12所示，在爱丽丝的例子中，处理时间窗口在她手机离线后会继续计时，因此不会把她离线那段时间的活动考虑在内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in Figure 3-4, each of the four sender tasks needs at least four network buf‐ fers to send data to each of the receiver tasks and each receiver task requires at least four buffers to receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193121Z" creationid="xccui" creationdate="20190606T200713Z">
        <seg>如图3-4所示，每个发送端任务至少需要4个网络缓冲区来向任一接收端任务发送数据。而同样，每个接收端任务也需要至少4个缓冲区来接收数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as a task has received barriers from all its input partitions, it initiates a check‐ point at the state backend and broadcasts the checkpoint barrier to all of its down‐ stream connected tasks as shown in Figure 3-23.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T192605Z" creationid="xccui" creationdate="20190609T175243Z">
        <seg>如图3-23所示，任务在收齐全部输入分区发送的分隔符后，就会通知状态后端开始生成检查点，同时把检查点分隔符广播到下游相连的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as enough slots become available, the JobMaster con‐ tainer deploys the application for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T224520Z" creationid="xccui" creationdate="20190729T224520Z">
        <seg>一旦有了足够多的处理槽，JobMaster容器就会部署并执行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as one parti‐ tion does not advance its watermarks or becomes completely idle and does not ship any records or watermarks, the event-time clock of a task will not advance and the timers of the task will not trigger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054409Z" creationid="xccui" creationdate="20190607T032231Z">
        <seg>只要有一个分区的水位线没有前进，或分区完全空闲下来不再发送任何记录或水位线，任务的事件时间时钟就不会前进，继而导致计时器无法触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the first event comes in, it will be immediately processed with the minimum latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T205859Z" creationid="xccui" creationdate="20190401T204654Z">
        <seg>当第一个事件到来，系统会立刻以尽可能低的延迟进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the key space evolves, the state of expired keys becomes stale and useless.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T033355Z" creationid="xccui" creationdate="20190704T141808Z">
        <seg>随着键值空间的不断变化，状态中那些过期的键值会变得陈旧且失去价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the name suggests, a dataflow program describes how data flows between opera&lt;t0/&gt;‐&lt;t1/&gt; tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T175511Z" creationid="xccui" creationdate="20190329T175404Z">
        <seg>顾名思义，dataflow程序描述了数据如何在操作之间流动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the name suggests, a dataflow program describes how data flows between opera‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T043133Z" creationid="xccui" creationdate="20190605T224746Z">
        <seg>顾名思义，Dataflow程序描述了数据如何在不同操作之间流动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the name suggests, the window join is based on Flink’s windowing mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T034142Z" creationid="xccui" creationdate="20190628T034142Z">
        <seg>顾名思义，基于窗口的Join需要用到Flink中的窗口机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As usual, BulkWriter.Factory is an interface that can be implemented for custom</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T183036Z" creationid="xccui" creationdate="20190711T182954Z">
        <seg>BulkWriter.Factory自身同样也是一个接口，我们可以用它来自定义文件格式，例如Apache Orc。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As usual, result records are emitted by passing them to the Collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062255Z" creationid="xccui" creationdate="20190621T053914Z">
        <seg>照例，你可以在方法中将结果记录传递给Collector发送出去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with histograms, you can use DropWizard meters by adding the flink- metrics-dropwizard dependency in your pom.xml and wrapping the meter in a DropwizardMeterWrapper class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T034136Z" creationid="xccui" creationdate="20190803T034136Z">
        <seg>和直方图一样，你可以通过在pom.xml中添加flink-metrics-dropwizard依赖并将meter包在DropwizardMeterWrapper类中来使用DropWizard meter。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see in Example 6-13, the ReduceFunction and ProcessWindowFunction are both defined in the reduce() method call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T044915Z" creationid="xccui" creationdate="20190625T044805Z">
        <seg>可以看到，示例6-13在调用reduce()方法时既用到了ReduceFunction也用到了ProcessWindowFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see in Example 8-8, we do not specify an INSERT query.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T213227Z" creationid="xccui" creationdate="20190711T213203Z">
        <seg>从示例8-8可以看出，我们没有指定INSERT查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, the Trigger API can be used to implement sophisticated logic by pro‐ viding access to time and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193725Z" creationid="xccui" creationdate="20190626T193725Z">
        <seg>如你所见，Trigger API的时间和状态访问机制允许你用它来实现复杂逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, the implementation of the interface is not too involved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053749Z" creationid="xccui" creationdate="20190716T053749Z">
        <seg>如你所见，TwoPhaseCommitSinkFunction实现起来并不复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, these are the same parameters we used when deploying the job- specific image with docker-compose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T213953Z" creationid="xccui" creationdate="20190730T044305Z">
        <seg>不难看出，此处使用的参数和使用docker-compose部署针对特定作业的镜像相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you learned in “Time Semantics”, Flink’s time- based operators can be applied with different notions of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T011550Z" creationid="xccui" creationdate="20190619T050204Z">
        <seg>正如你在"时间语义"一节所看到的，Flink内部基于时间的算子可以在不同的时间概念下使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you learned in “Timestamps” on page 47, time‐ stamps either exist in the data before entering the data processing pipeline, or are assigned by the application at the sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T045601Z" creationid="xccui" creationdate="20190619T070828Z">
        <seg>正如在第47页"时间戳"一节所介绍的，时间戳在数据进入处理管道之前就已经存在其中，或者需要由应用在数据源处分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you might expect, maintaining streaming applications is more challenging than maintaining batch applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T160747Z" creationid="xccui" creationdate="20190726T005338Z">
        <seg>不难想象，维护流式应用要比维护批处理应用更具挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you might imagine, supporting stateful operators comes with a few implementa‐ tion challenges:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032848Z" creationid="xccui" creationdate="20190606T032848Z">
        <seg>不难想象，支持状态化算子将面临很多实现上的挑战：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you saw in “Data Parallelism and Task Parallelism” on page 18, Flink splits data streams into partitions and processes each partition in parallel by a separate operator task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T053459Z" creationid="xccui" creationdate="20190607T014501Z">
        <seg>正如第18页"数据并行和任务并行"一节所述，Flink会将数据流划分为不同的分区，并将它们交由不同的算子任务来并行执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigner with periodic watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045349Z" creationid="xccui" creationdate="20190620T045349Z">
        <seg>周期性水位线分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigner with punctuated watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T053715Z" creationid="xccui" creationdate="20190620T053715Z">
        <seg>定点水位线分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning Timestamps and Generating Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040510Z" creationid="esouser" creationdate="20190603T145731Z">
        <seg>分配时间戳和生成水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning timestamps and generating watermarks in a SourceFunction is discussed in “Source Functions, Timestamps, and Watermarks” on page 204.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T052740Z" creationid="xccui" creationdate="20190620T021059Z">
        <seg>在SourceFunction中分配时间戳和生成水位线将在204页"数据源函数、时间戳和水位线"一节讨论，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning unique identifiers to operators is mandatory for most application changes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T030857Z" creationid="xccui" creationdate="20190705T030857Z">
        <seg>大多数应用的改动都需要以分配算子唯一标识为前提。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning watermarks periodically means that we instruct the system to emit water‐ marks and advance the event time in fixed intervals of machine time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045615Z" creationid="xccui" creationdate="20190620T045615Z">
        <seg>周期性分配水位线的含义是我们会指示系统以固定的机器时间间隔来发出水位线并推动事件时间前进。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming you are running a local Flink setup that exposes its REST API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T041500Z" creationid="xccui" creationdate="20190729T041500Z">
        <seg>假设你所搭建和运行的本地Flink其REST API使用的端口是8081，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AsyncFunction concurrently sends multiple queries and processes their results asyn‐ chronously.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T192709Z" creationid="xccui" creationdate="20190716T192311Z">
        <seg>该函数能够同时发出多个查询并对其结果进行异步处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AsyncFunction on a DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201700Z" creationid="xccui" creationdate="20190716T201700Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AsyncFunction that queries a JDBC database</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T203909Z" creationid="xccui" creationdate="20190716T203909Z">
        <seg>利用JDBC查询数据库的AsyncFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Asynchronous checkpointing significantly reduces the time until a task continues to process data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203815Z" creationid="xccui" creationdate="20190609T203754Z">
        <seg>异步生成检查点可以有效降低任务恢复数据处理所需等待的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Asynchronously Accessing External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T060014Z" creationid="xccui" creationdate="20190225T025331Z">
        <seg>异步访问外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Asynchronously Accessing External Systems | 217</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T210057Z" creationid="xccui" creationdate="20190716T210057Z">
        <seg>异步访问外部系统 | 217</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At high load, this change will also increase through&lt;t2/&gt;‐&lt;t3/&gt; put, because more customers will be served in the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211113Z" creationid="xccui" creationdate="20190402T210925Z">
        <seg>这样在高峰时段，相同时间内可以服务的顾客数量多了，吞吐量也自然会提高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At high load, this change will also increase throughput, because more customers will be served in the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054612Z" creationid="xccui" creationdate="20190605T235407Z">
        <seg>这样在高峰时段，相同时间内可以服务的顾客数量多了，吞吐量自然也会提高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the book’s GitHub page, you will find one repository with Scala examples and one repository with Java exam‐ ples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T091123Z" creationid="xccui" creationdate="20190611T035708Z">
        <seg>在本书的GitHub页面上，你会看到两个分别包含Scala示例和Java示例的代码仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the same time, it is also one of the trickiest metrics to define in a distributed streaming engine with rich semantics such as Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T050455Z" creationid="xccui" creationdate="20190806T050455Z">
        <seg>而同时，它对于像Flink这样具有丰富语义的分布式流处理引擎而言，也是最难定义的指标之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the same time, long-running applications need to be maintained.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T212353Z" creationid="xccui" creationdate="20190702T212353Z">
        <seg>同时，我们也需要对长时间运行的应用进行一些维护，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the same time, the result completeness might suffer because relevant records might not be included in the result and would be considered as late records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T070054Z" creationid="xccui" creationdate="20190529T040337Z">
        <seg>但同时结果的完整性可能会受影响，因为可能有部分相关记录被视为迟到记录，没能参与运算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the source: Timestamps and watermarks can be assigned and generated by a SourceFunction when a stream is ingested into an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054644Z" creationid="xccui" creationdate="20190607T034006Z">
        <seg>在数据源完成：我们可以利用SourceFunction在应用读入数据流的时候分配时间戳和生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point the system has reached the peak throughput and further increasing the event rate will only result in worse latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T201509Z" creationid="xccui" creationdate="20190402T201054Z">
        <seg>此时系统吞吐已到极限，一味提高事件到达速率只会让延迟更糟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, it should be clear that latency and throughput are not independent met‐ rics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053804Z" creationid="xccui" creationdate="20190605T234918Z">
        <seg>至此你应该已经清楚，延迟和吞吐并非相互独立的指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, it should be quite clear that latency and throughput are not independ&lt;t0/&gt;‐&lt;t1/&gt; ent metrics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T203113Z" creationid="xccui" creationdate="20190402T203103Z">
        <seg>至此你应该很清楚，延迟和吞吐并非相互独立的指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, the system has reached its peak throughput and further increasing the event rate will only result in worse latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234736Z" creationid="xccui" creationdate="20190605T234736Z">
        <seg>此时系统吞吐已到极限，一味提高事件到达速率只会让延迟更糟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, you might be wondering why we would even bother with processing time if event time solves all of our problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180343Z" creationid="xccui" creationdate="20190606T030452Z">
        <seg>此刻你可能会有些疑惑：既然事件时间能够解决所有问题，为何还要去操心处理时间？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, you might be wondering: &lt;t0/&gt;Since event time solves all of our problems, why&lt;t1/&gt; &lt;t2/&gt;even bother considering processing time?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T040412Z" creationid="xccui" creationdate="20190414T040247Z">
        <seg>此刻你可能会有些疑惑：既然事件时间能够解决所有问题，为什么还去费劲地考虑处理时间呢？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-Least-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050818Z" creationid="xccui" creationdate="20190415T050818Z">
        <seg>至少一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-Most-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050811Z" creationid="xccui" creationdate="20190415T050757Z">
        <seg>至多一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-least-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034515Z" creationid="xccui" creationdate="20190606T034515Z">
        <seg>至少一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-least-once Idempotent sink  At-most-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170124Z" creationid="xccui" creationdate="20190708T170124Z">
        <seg>至少一次 幂等性数据汇  至多一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-least-once guarantees for the Kafka sink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T160817Z" creationid="xingcan" creationdate="20190709T153813Z">
        <seg>Kafka数据汇的至少一次保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-most-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034320Z" creationid="xccui" creationdate="20190606T034320Z">
        <seg>至多一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-most-once is the trivial case that guarantees processing of each event at most once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T192042Z" creationid="xccui" creationdate="20190606T034341Z">
        <seg>至多一次是一种最简单的情况，它保证每个事件至多被处理一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-most-once is the trivial case that guarantees processing of each event at-most-once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T184428Z" creationid="xccui" creationdate="20190415T184345Z">
        <seg>至多一次也是最简单的情况，它保证每个事件至多被处理一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Available Variables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043623Z" creationid="xccui" creationdate="20190804T043623Z">
        <seg>可用变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Available variables to configure the formatting of metrics scopes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043702Z" creationid="xccui" creationdate="20190804T043702Z">
        <seg>用于配置指标域格式的可用变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Average values hide the true distribution of processing delays and might make it hard to detect problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051114Z" creationid="xccui" creationdate="20190401T155435Z">
        <seg>平均值会掩盖处理延迟的真实分布，从而导致难以发现问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avro-generated classes are automatically identified by Flink and handled as POJOs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T025618Z" creationid="xccui" creationdate="20190617T045142Z">
        <seg>Flink还会将Avro自动生成的类作为POJO处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Back-pressured tasks will display a HIGH sign; otherwise you should see a nice green OK message displayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T152459Z" creationid="xingcan" creationdate="20190802T152459Z">
        <seg>如果任务已经触发背压将显示一个HIGH标志，否则你会看到一个漂亮的绿色OK信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backpressure metrics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T161706Z" creationid="xccui" creationdate="20190729T161706Z">
        <seg>背压指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Based on the key, the events of the stream are assigned to partitions, so that all</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T061101Z" creationid="xccui" creationdate="20190614T050345Z">
        <seg>根据键值，流中的事件会被分到不同的分区，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Based on the received watermarks, the operator computes a point in time up to which it expects to have received relevant input records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031819Z" creationid="xccui" creationdate="20190621T031242Z">
        <seg>根据收到的水位线，算子会计算一个所有相关输入记录都已接收完毕的预期时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022712Z" creationid="xccui" creationdate="20190225T022712Z">
        <seg>基本转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic statistics such as the name of the application, the start time (and end time), and information about the executed tasks including the number of ingested and emitted records and bytes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T153232Z" creationid="xccui" creationdate="20190729T153232Z">
        <seg>基本统计信息，例如：应用名称，开始时间（和结束时间），有关执行任务的信息（包括接收我发出的记录数和字节数）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic transformations are transformations on individual events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T054628Z" creationid="xccui" creationdate="20190613T024209Z">
        <seg>作用于单个事件的基本转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic transformations process individual events, meaning that each output record was produced from a single input record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T054905Z" creationid="xccui" creationdate="20190613T024932Z">
        <seg>基本转换会单独处理每个事件，这意味着每条输出记录都由单条输入记录所生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Batch applications can - in addition to pipelined communication - exchange data by collecting outgoing data at the sender.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045346Z" creationid="xccui" creationdate="20190504T045346Z">
        <seg>批处理应用除了流水线式通信，还可以在发送端收集全部需要发出的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Batch applications can—in addition to pipelined communication—exchange data by collecting outgoing data at the sender.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193021Z" creationid="xccui" creationdate="20190606T200625Z">
        <seg>批处理应用除了流水线式通信之外，还可以在发送端收集需要发出的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Batch jobs are internally represented as dataflow programs and run on the same underlying execution runtime as streaming jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T154250Z" creationid="xingcan" creationdate="20190807T154250Z">
        <seg>在内部，批处理作业同样会表示为Dataflow程序并和流式作业共享底层运行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200742Z" creationid="esouser" creationdate="20190603T200742Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because efficient state access is crucial to processing records with low latency, each parallel task locally maintains its state to ensure fast state accesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051223Z" creationid="xccui" creationdate="20190608T051037Z">
        <seg>因此高效的状态访问对于记录处理的低延迟而言至关重要。为了保证快速访问状态，每个并行任务都会把状态维护在本地。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it writes data to disk and supports incremental checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T024204Z" creationid="xccui" creationdate="20190704T024204Z">
        <seg>因为它能够将数据写入磁盘，且支持增量检查点（详见第58页"检查点、保存点及状态恢复"一节），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because local state can be maintained and checkpointed in different ways, state backends are pluggable—two applications can use different state backend implementations to maintain their states.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T025233Z" creationid="xccui" creationdate="20190703T214504Z">
        <seg>由于本地状态的维护及写入检查点的方式多种多样，所以状态后端被设计为可插拔的（pluggable）——两个应用可以选择不同的状态后端实现来维护其状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because microservices are strictly decoupled from each other and only communicate over well defined inter&lt;t4/&gt;‐&lt;t5/&gt; faces, each microservice can be implemented with a custom technology stack includ&lt;t6/&gt;‐&lt;t7/&gt; ing programming language, libraries, and data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172603Z" creationid="xccui" creationdate="20190227T234310Z">
        <seg>由于微服务彼此间严格解耦且仅通过定义良好的接口通信，因此每个微服务可以选用不同的技术栈，即编程语言、类库和数据存储等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the choice of the timestamp is application-specific and the watermarks depend on the timestamps and characteris‐ tics of the stream, applications have to explicitly assign timestamps and generate watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054558Z" creationid="xccui" creationdate="20190607T033908Z">
        <seg>由于不同的应用会选择不同的时间戳，而水位线依赖于时间戳和数据流本身的特征，所以应用必须显式地分配时间戳和生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the paths in the metadata file are absolute, moving a savepoint to a different path will render it unusable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T020421Z" creationid="xccui" creationdate="20190726T020421Z">
        <seg>由于元数据文件中存储的是绝对路径，所以将保存点移动到其他路径会使其失效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this strategy replicates data and involves network communication, it is fairly expensive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233449Z" creationid="xccui" creationdate="20190401T135000Z">
        <seg>该策略会把数据复制多份且涉及网络通信，因此代价十分昂贵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before a sink task emits its first record, it starts a transaction on the external sink system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T200820Z" creationid="xccui" creationdate="20190715T200820Z">
        <seg>数据汇任务在发出首个记录之前，会先在外部数据汇系统中开启一个事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before adding a new component into the mix, a logical question to ask should be, “How well does it work with the other com‐ ponents in my stack?”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T042235Z" creationid="xccui" creationdate="20190708T045057Z">
        <seg>在向其中添加新组件之前，我们一般都会先思考一个问题，"新加的组件和现有组件栈兼容情况如何？"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before comparing the temperature measurements and updating the last temperature,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T212613Z" creationid="xccui" creationdate="20190704T211924Z">
        <seg>在对温度值进行比较并更新最近一次温度之前，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before diving into the details of how to set up Flink on Kubernetes, we need to briefly explain a few Kubernetes terms:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T022927Z" creationid="xccui" creationdate="20190719T022927Z">
        <seg>但在深入了解部署详情之前，我们需要简要解释几个Kubernetes的常用术语：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before execution, these are translated into physical dataflow graphs of connected parallel tasks, each running some operator logic, consuming input streams and producing output streams for other tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185357Z" creationid="xccui" creationdate="20190606T033145Z">
        <seg>在实际执行前，它们需要被翻译成物理Dataflow图，其中会包含很多相连的并行任务。每个任务都要运行一部分算子逻辑，消费输入流并为其他任务生成输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before execution, these are translated into physical dataflow graphs of many connected parallel tasks, each running some operator logic, consuming input streams and producing output streams for other tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T041429Z" creationid="xccui" creationdate="20190415T041131Z">
        <seg>在执行之前，他们需要被翻译为连接很多并行任务的物理dataflow图。其中每个任务都要运行一部分算子逻辑，消费输入流并为其他任务生成输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before manually deleting a pending file, you need to check whether it is lingering or about to be committed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T191651Z" creationid="xccui" creationdate="20190711T191552Z">
        <seg>在手动删除它们之前，你需要检查文件是否是因为延迟所致或者马上将要提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before the rise of modern stream processors, a common approach to process unbounded data was to repeatedly schedule jobs over small batches of incoming events on a batch processing system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182116Z" creationid="xccui" creationdate="20190606T031812Z">
        <seg>在现代流处理引擎兴起之前，处理无限数据的通用办法是将到来事件分成小批次，然后不停地在批处理系统上调度并运行作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we delve into the fundamentals of stream processing, let’s look at the back‐ ground on dataflow programming and the terminology we will use throughout this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T043338Z" creationid="xccui" creationdate="20190605T224735Z">
        <seg>在深入探索流处理的基础知识之前，我们需要先介绍Dataflow编程的必要背景，并建立起贯穿整书的术语体系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we delve into the fundamentals of stream processing, we must first introduce the necessary background on &lt;t0/&gt;dataflow&lt;t1/&gt; programming and establish the terminology that we will use throughout this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T175319Z" creationid="xccui" creationdate="20190329T054324Z">
        <seg>在深入研究流处理的基本知识之前，我们需要先介绍dataflow编程的必要背景，建立起贯穿整书的术语体系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we describe the different types of guarantees, we need to clarify a few points that are often the source of confusion when discussing task failures in stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044835Z" creationid="xccui" creationdate="20190415T044718Z">
        <seg>在讨论不同类型的保障之前，我们需要澄清一些在讨论流处理引擎任务故障时容易导致困惑的点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we describe the different types of guarantees, we need to clarify a few points that are often the source of confusion when discussing task failures in stream pro‐ cessors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034159Z" creationid="xccui" creationdate="20190606T034159Z">
        <seg>在讨论不同类型的保障之前，我们需要澄清一些在讨论流处理引擎任务故障时容易导致困惑的点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we discuss its use cases, we briefly explain how stateful stream process&lt;t2/&gt;‐&lt;t3/&gt; ing works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T203558Z" creationid="xccui" creationdate="20190301T203506Z">
        <seg>在讨论这些用例之前，我们首先简要解释一下状态化流处理的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we discuss its use cases, we briefly explain how stateful stream processing works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T030447Z" creationid="esouser" creationdate="20190603T205531Z">
        <seg>在讨论这些场景之前，我们首先简要解释一下状态化流处理的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beijing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210636Z" creationid="esouser" creationdate="20190603T210636Z">
        <seg>Beijing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides ingesting or emitting data streams, enriching a data stream by looking up information in a remote database is another common use case that requires interact‐ ing with an external storage system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T190850Z" creationid="xccui" creationdate="20190716T190850Z">
        <seg>除了单纯的收发之外，我们还经常需要利用从远程数据库获取的信息来丰富数据流，此时也会涉及和外部存储系统的交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides removing the need for an additional operator, assigning timestamps and gen‐ erating watermarks in a source function can be beneficial if one parallel instance of a source function consumes records from multiple stream partitions, such as partitions of a Kafka topic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T040326Z" creationid="xccui" creationdate="20190713T040326Z">
        <seg>在数据源函数中分配时间戳和生成水位线除了免去一个额外的算子外，还会在单个数据源并行实例从多个数据流分区（例如Kafka某主题的多个分区）中消费数据时受益。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides resource considerations for the recovery, there are two other recovery-related topics we will discuss: restart strategies and local recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T151126Z" creationid="xingcan" creationdate="20190801T150907Z">
        <seg>恢复过程除了资源因素，还有两个值得讨论的主题：重启策略和本地恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides starting standby TaskManagers, a standalone deployment does not need addi‐ tional configuration to be able to recover from TaskManager failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T025623Z" creationid="xccui" creationdate="20190721T025411Z">
        <seg>有了后备TaskManager，独立集群部署无需额外配置就可以从TaskManager故障中恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the much shorter time needed for an event to be incorporated into an analyt‐ ics result, there is another, less obvious, advantage of streaming analytics applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155621Z" creationid="xccui" creationdate="20190605T044658Z">
        <seg>除了将事件整合到分析结果的用时更短，流式分析应用还有另一个不太明显的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the much smaller time for an event to be incorporated into an analytics result, there is another, less obvious, advantage of streaming analytics applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062434Z" creationid="xccui" creationdate="20190317T062251Z">
        <seg>除了将事件整合到分析结果用时较短，流式分析应用还有另一个不太显眼的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides watermarks, Flink has many features to tweak the exact behavior of time-based oper‐ ations, such as process functions and window triggers, and offers different ways to handle late data, which are discussed in “Handling Late Data” on page 148.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T061436Z" creationid="xccui" creationdate="20190621T042913Z">
        <seg>除了水位线，Flink还有很多功能可用于调整时间相关相关操作（例如处理函数和窗口触发器）的具体行为。此外，它还提供了不同的方法来处理迟到数据，相关内容会在148页"处理迟到数据"一节进行讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beware of Clock Skew</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T032712Z" creationid="xccui" creationdate="20190807T032712Z">
        <seg>小心时钟偏差</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Black squares are duplicated, and gray squares are filtered out.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054533Z" creationid="xccui" creationdate="20190613T054410Z">
        <seg>如果是黑色方块会将其复制；如果是灰色方块会将其过滤掉。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blogs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040541Z" creationid="xccui" creationdate="20190807T040541Z">
        <seg>博客</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bob and Alice play the same game but have different mobile pro‐ viders.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160457Z" creationid="xccui" creationdate="20190606T024443Z">
        <seg>虽然玩的游戏相同，但鲍勃和爱丽丝的移动网络供应商不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bob and Alice play the same game but they have different mobile providers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T152216Z" creationid="xccui" creationdate="20190412T152216Z">
        <seg>鲍勃和爱丽丝虽然玩的游戏相同，但他们的移动网络供应商不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bootstrap a Flink Maven Project</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004254Z" creationid="esouser" creationdate="20190603T145025Z">
        <seg>创建Flink Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bootstrap a Flink Maven project</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022358Z" creationid="xccui" creationdate="20190225T022358Z">
        <seg>启用Flink Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boston</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210638Z" creationid="esouser" creationdate="20190603T210638Z">
        <seg>Boston</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both aspects are discussed in later sections of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T185654Z" creationid="xccui" creationdate="20190607T185654Z">
        <seg>我们同样会在本章稍后讨论它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both connectors are fully self-contained and do not expose any dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T043541Z" creationid="xccui" creationdate="20190722T043541Z">
        <seg>这两个连接器都可以独立工作，没有暴露任何对外的依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both context objects offer a method getBroad castState(MapStateDescriptor) that provides access to a broadcast state handle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T051303Z" creationid="xccui" creationdate="20190702T051303Z">
        <seg>虽然两个上下文对象都提供了getBroadcastState(MapStateDescriptor)方法来获得广播状态句柄，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both functions are typed on the types of the first and second input stream and on the type of the output stream and define two methods—one for each input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T022802Z" creationid="xccui" creationdate="20190615T041305Z">
        <seg>两个函数都是以两条输入流的类型外加输出流的类型作为其类型参数，它们为两条输入流定义了各自的处理方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both input streams are keyed on their key attributes and the common window assigner maps events of both streams to common windows, meaning a window stores</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T204325Z" creationid="xccui" creationdate="20190628T052614Z">
        <seg>两条的输入流都会根据各自的键值属性进行分区，公共窗口分配器会将二者的事件映射到公共窗口内（其中同时存储了两条流中数据）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both kinds of queries are executed by a data warehouse in a batch processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194232Z" creationid="xccui" creationdate="20190228T194049Z">
        <seg>无论哪一类查询，都是在数据仓库中以批处理的方式执行，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both kinds of queries are executed by a data warehouse in a batch processing fashion, as shown in Figure 1-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203619Z" creationid="esouser" creationdate="20190603T203548Z">
        <seg>如图1-3所示，无论哪一类查询，都是在数据仓库中以批处理的方式执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both methods are called with an Iterable that serves all elements that were added to the window, the number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203311Z" creationid="xccui" creationdate="20190627T202634Z">
        <seg>它们的参数都是一个针对窗口内已有元素的Iterable对象、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both methods are overloaded for different combinations of parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T202203Z" creationid="xccui" creationdate="20190716T202203Z">
        <seg>它们二者都提供了多个不同参数组合的重载方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both template files contain placeholders that need to be replaced with actual values:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T044015Z" creationid="xccui" creationdate="20190730T044015Z">
        <seg>两个模板文件都包含需要用实际值替换的占位符：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both templates implement the CheckpointListener interface to receive notifications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T034956Z" creationid="xccui" creationdate="20190715T034956Z">
        <seg>这两个模板都实现了CheckpointListener接口（有关该接口的详情，请参阅"接收检查点完成通知"一节），支持从JobManager接收有关检查点完成的通知：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both were covered in Chapter 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T204316Z" creationid="xccui" creationdate="20190704T204316Z">
        <seg>我们已经在第6章对它们进行了介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060543Z" creationid="xccui" creationdate="20190607T184737Z">
        <seg>广播状态（broadcast state）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast state can be combined with a regular DataStream or KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T203704Z" creationid="xccui" creationdate="20190701T203650Z">
        <seg>它可以和常规的DataStream或KeyedStream结合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast state is an improved version of the broadcast()- connect() transformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T023304Z" creationid="xccui" creationdate="20190615T052518Z">
        <seg>广播状态是broadcast()-connect()转换的一个改进版本，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BroadcastProcessFunc tion does not expose a timer service to register timers and consequently does not offer an onTimer() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T053727Z" creationid="xccui" creationdate="20190702T053727Z">
        <seg>BroadcastProcessFunction没有提供用于注册计时器的时间服务，因此也就没有onTimer()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BroadcastProcessFunction and KeyedBroadcastProcessFunction differ from a regular CoProcessFunction because the element processing methods are not sym‐ metric.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T045838Z" creationid="xccui" creationdate="20190702T045716Z">
        <seg>BroadcastProcessFunction和KeyedBroadcastProcessFunction与常规CoProcessFunction不同，它们针对两条流内元素的处理方法是非对称的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BroadcastStream must be put as an argument in the connect() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040905Z" creationid="xccui" creationdate="20190702T040905Z">
        <seg>BroadcastStream必须以参数形式传给connect()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcasted Events Might Not Arrive in Deterministic Order</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T153227Z" creationid="xccui" creationdate="20190702T055306Z">
        <seg>广播事件的到达顺序可能不确定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffering is a mandatory technique to fully utilize the bandwidth of network connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T210224Z" creationid="esouser" creationdate="20190513T210224Z">
        <seg>若想充分利用网络连接带宽，缓冲是一项必要技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffering is needed to fully utilize the bandwidth of network connec‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194605Z" creationid="xccui" creationdate="20190606T202532Z">
        <seg>若想充分利用网络连接带宽，就需要对数据进行缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffers that need to be sent to the other TaskManager are multiplexed over the same network connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T201324Z" creationid="xccui" creationdate="20190606T200905Z">
        <seg>所有需要向对方TaskManager传输数据的缓冲区会复用同一个网络连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffers which need to be sent to the other Task&lt;t0/&gt;‐&lt;t1/&gt; Manager are multiplexed over the same network connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044411Z" creationid="xccui" creationdate="20190504T044411Z">
        <seg>需要发往同一个TaskManager的缓冲区数据会复用同一个网络连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bugs need to be fixed, functionality adjusted, added, or removed, or the parallelism of the operator needs to be adjusted to account for higher or lower data rates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T015155Z" creationid="xccui" creationdate="20190702T212532Z">
        <seg>例如：修复Bug，添加、删除或调整功能，或针对不同的数据到来速率调整算子的并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Build Flink for a specific Hadoop version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T023004Z" creationid="xccui" creationdate="20190722T023004Z">
        <seg>针对特定版本的Hadoop构建Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Building a job-specific Flink Docker image</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190730T030659Z">
        <seg>针对特定作业构建Flink Docker镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Building a so-called fat JAR file is the preferred way to handle application dependen‐ cies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041550Z" creationid="xccui" creationdate="20190619T042139Z">
        <seg>我们推荐使用构建"胖JAR"的方式来处理应用依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-in Window Assigners</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023153Z" creationid="xccui" creationdate="20190225T023153Z">
        <seg>内置窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bulk-encoding formats can only be combined with the OnCheckpointRollingPolicy, which rolls in-progress part files on every checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T183304Z" creationid="xccui" creationdate="20190711T183304Z">
        <seg>批量编码格式只能与OnCheckpointRollingPolicy结合使用，后者会在每次生成检查点的时候生成新的分区文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bundle all dependencies into the application JAR file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041343Z" creationid="xccui" creationdate="20190619T041343Z">
        <seg>将所有依赖打进应用的JAR包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bundling and Deploying Applications in Containers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025949Z" creationid="xccui" creationdate="20190225T025949Z">
        <seg>在容器中打包并部署应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But first, let’s define the term data stream: a data stream is a potentially unbounded sequence of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045638Z" creationid="xccui" creationdate="20190605T233637Z">
        <seg>在此之前我们先给出数据流的定义：数据流是一个可能无限的事件序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But first, we define the term &lt;t0/&gt;data stream&lt;t1/&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142649Z" creationid="xccui" creationdate="20190401T142637Z">
        <seg>在此之前需要先定义数据流：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But in practice you might want to partition a stream into multiple logical streams and define parallel windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013841Z" creationid="xccui" creationdate="20190606T013841Z">
        <seg>但在实际应用中，你可能会想将数据流划分为多条逻辑流并定义一些并行窗口（parallel window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But it differs from regular list state in how it is restored in the case of a failure or when an application is started from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184651Z" creationid="xccui" creationdate="20190607T184610Z">
        <seg>但在进行故障恢复或从某个保存点启动应用时，状态的恢复方式和普通列表状态有所不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But there are much more time-critical applications whose semantics we need to guarantee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155411Z" creationid="xccui" creationdate="20190411T154442Z">
        <seg>但其实还有更多时间敏感应用，需要我们对其处理语义进行保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But what if your job is a long- running streaming job?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T045416Z" creationid="xccui" creationdate="20190725T045416Z">
        <seg>但如果是需要长时间运行的流式作业又该如何？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But your Flink journey has just started, and this chapter points to the possible paths you can take from here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T041333Z" creationid="xccui" creationdate="20190807T041050Z">
        <seg>但你和Flink的结伴之旅才刚刚开始，本章将为你指引后续的前进方向。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By calling setFlushOnCheck point(false) on the sink object, you can disable this waiting.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T161431Z" creationid="xingcan" creationdate="20190709T161357Z">
        <seg>你可以在数据汇连接器对象上调用setFlushOnCheckpoint(false)来禁用该等待。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By changing the data type of a state, such as changing a ValueState[Int] to a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T044303Z" creationid="xccui" creationdate="20190705T044241Z">
        <seg>通过更改状态的数据类型，例如将ValueState[Int]改为ValueState[Double]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By changing the type of a state primitive, as for example by changing a Value State[List[String]] to a ListState[String]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T044340Z" creationid="xccui" creationdate="20190705T044255Z">
        <seg>通过更改状态原语类型，例如将ValueState[List[String]]改为ListState[String]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By computing results only based on the actual data, these systems are also able to process historical data in the same way as “live” data, i.e., data which is inges&lt;t0/&gt;‐&lt;t1/&gt; ted as soon as it is produced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T134332Z" creationid="xccui" creationdate="20190327T051803Z">
        <seg>由于只需依靠实际数据本身计算结果，此类系统可以将历史数据当做"实时"数据进行处理，如同它们一产生就传入系统一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By configuring only a single slot per TaskManager, you can isolate applications across TaskManagers, i.e., run only tasks of a single application on a TaskManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063739Z" creationid="xccui" creationdate="20190424T063555Z">
        <seg>通过将每个TaskManager配置成只有一个处理槽，可以将应用在TaskManager级别进行隔离，即每个TaskManager只运行单个应用的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By configuring only a single slot per TaskManager, you can isolate applications across TaskManagers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071718Z" creationid="xccui" creationdate="20190606T144935Z">
        <seg>如果将每个TaskManager配置成只有一个处理槽，则可以限制应用在TaskManager级别进行隔离，即每个TaskManager只运行单个应用的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, 10% of the JVM heap size is used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T040658Z" creationid="xccui" creationdate="20190724T040507Z">
        <seg>默认配置是使用JVM堆内存的10%。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Flink allows only one checkpoint to be in progress at a time to avoid checkpointing takeing away too many resources needed for regular processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T031718Z" creationid="xccui" creationdate="20190731T031718Z">
        <seg>默认情况下，Flink一次只允许生成一个检查点，以免它占用常规处理太多资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Flink assigns unique operator identifiers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T023152Z" creationid="xccui" creationdate="20190609T220319Z">
        <seg>默认情况下，Flink会给每个算子分配一个唯一标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Flink creates checkpoints to guarantee exactly-once state consistency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T031132Z" creationid="xccui" creationdate="20190731T030913Z">
        <seg>默认情况下，Flink会通过创建检查点保证内部状态的精确一次语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Flink looks up user-code classes first in the child (user-code) classloader and then in parent (system) classloader to prevent version clashes in case a job uses</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T060311Z" creationid="xccui" creationdate="20190723T055953Z">
        <seg>为了防止作业和Flink使用相同依赖而引起冲突，Flink在默认情况下会先从用户类加载器中查找用户类，如果没有发现再去父（系统）类加载器中查找。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Flink starts JVM processes using the Java executable linked by the PATH environment variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T043646Z" creationid="xccui" creationdate="20190723T043646Z">
        <seg>Flink默认会使用PATH环境变量中的Java执行文件来启动JVM进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Flink uses the SLF4J logging abstraction together with the log4j logging framework.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T033343Z" creationid="xccui" creationdate="20190807T033042Z">
        <seg>默认情况下，Flink使用SLF4J日志抽象和log4j日志框架。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Flink will not start applications that do not restore all states that are con‐ tained in a savepoint to avoid losing the state in the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043338Z" creationid="xccui" creationdate="20190705T043338Z">
        <seg>为了避免保存点中的状态丢失，Flink在默认情况下不会启动那些无法将保存点中的状态全部恢复的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, RocksDB is optimized for SSD storage and does not provide great performance if state is stored on spinning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030556Z" creationid="xccui" creationdate="20190801T030556Z">
        <seg>默认情况下，RocksDB针对SSD存储做出了很多优化，因此在使用传统机械硬盘存储状态时性能可能并不出色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, SSL authentication and encryption is not enabled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T040015Z" creationid="xccui" creationdate="20190725T040015Z">
        <seg>SSL验证和加密在默认情况下都处于关闭状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, StreamingFileSink uses a DefaultRollingPolicy, which is configured to roll part files when they exceed 128 MB or are older than 60 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T022546Z" creationid="xccui" creationdate="20190711T021952Z">
        <seg>默认情况下，StreamingFileSink将使用DefaultRollingPolicy，它会在现有文件大小超过128MB或打开时间超过60秒时创建一个新的分块文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T064253Z" creationid="xccui" creationdate="20190621T064253Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, a failing checkpoint causes an exception that results in an application restart.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T204107Z" creationid="xccui" creationdate="20190731T204030Z">
        <seg>默认情况下，检查点生成失败会抛出异常导致应用重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, both are exposed on port 8081.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T040130Z" creationid="xccui" creationdate="20190729T040130Z">
        <seg>默认情况下，二者都会使用8081端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, checkpoints are canceled after 10 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T203747Z" creationid="xccui" creationdate="20190731T203747Z">
        <seg>默认情况下，检查点生成操作会在10分钟后被取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, connect() does not establish a relationship</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045619Z" creationid="xccui" creationdate="20190615T045619Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, data is written to the default tem‐ porary directory as determined by the Java system property java.io.tmpdir, or /tmp on Linux and MacOS.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T042752Z" creationid="xccui" creationdate="20190724T042752Z">
        <seg>默认情况下，数据会写入默认临时目录（由Java系统变量java.io.tmpdir决定，或Linux及MacOS下的/tmp目录）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, each operator is in the "default" slot-sharing group.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T014805Z" creationid="xccui" creationdate="20190731T014805Z">
        <seg>默认情况下，所有算子都属于"default"处理槽共享组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, it automatically restarts failed master and TaskManager containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T051655Z" creationid="xccui" creationdate="20190721T051655Z">
        <seg>默认情况下它会自动重启发生故障的主进程容器和TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, it is started with 1 GB JVM heap memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T062949Z" creationid="xccui" creationdate="20190723T062949Z">
        <seg>它默认的JVM堆内存数量只有1GB。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, local recovery is deactivated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T024846Z" creationid="xccui" creationdate="20190802T024846Z">
        <seg>默认情况下，本地恢复处于禁用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, only the core API dependencies (DataStream and DataSet APIs) are loaded by a Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035728Z" creationid="xccui" creationdate="20190619T035618Z">
        <seg>默认情况下，Flink集群只会加载核心API依赖（DataStream和DataSet API），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, operators run with the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190728T041857Z" creationid="xccui" creationdate="20190728T041857Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the Flink Kafka</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T030942Z" creationid="xccui" creationdate="20190710T030942Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the client</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T125222Z" creationid="xccui" creationdate="20190706T125222Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the client does not return after submitting the application but waits for it to terminate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170117Z" creationid="xccui" creationdate="20190726T030500Z">
        <seg>默认情况下，客户端在提交应用后不会立即返回，而是会等待其终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the client submits an application to the Flink master specified by the ./conf/flink-conf.yaml file (see the configuration for different setups in “System Configuration”).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T032048Z" creationid="xccui" creationdate="20190726T031820Z">
        <seg>默认情况下，客户端会将应用提交到./conf/flink-conf.yaml文件中所指定的Flink主进程（有关其他配置请参阅"系统配置"一节）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the parallelism of all operators of an application is set as the parallelism of the application’s execution environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T024412Z" creationid="xccui" creationdate="20190616T051647Z">
        <seg>默认情况下，应用内所有算子的并行度都会被设置为应用执行环境的并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the script prints the connec‐ tion information of the session cluster and does not return.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T013937Z" creationid="xccui" creationdate="20190719T013937Z">
        <seg>默认情况下，该脚本会打印出会话集群的连接信息，但并不会结束返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, tumbling windows are aligned to the epoch time, 1970-01-01-00:00:00.000.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T053903Z" creationid="xccui" creationdate="20190623T053903Z">
        <seg>默认情况下，滚动窗口会和纪元时间1970-01-01-00:00:00.000对齐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By injecting the barrier into its output stream, the source function defines the stream position on which the checkpoint is taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T154906Z" creationid="xccui" creationdate="20190609T154731Z">
        <seg>通过向输出流中注入分隔符，数据源函数定义了需要在流中哪些位置生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By lever&lt;t0/&gt;‐&lt;t1/&gt; aging thread-parallelism inside of a TaskManager and the option to deploy several TaskManager processes per host, Flink offers a lot of flexibility to trade off perfor&lt;t2/&gt;‐&lt;t3/&gt; mance and resource isolation when deploying applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T064328Z" creationid="xccui" creationdate="20190424T063958Z">
        <seg>通过在TaskManager内部采用线程并行以及支持在每个主机上部署多个TaskManager进程，Flink为部署应用时性能和资源隔离的取舍提供了极大的自由度，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By leveraging thread parallelism inside a TaskManager and deploying several TaskMan‐ ager processes per host, Flink offers a lot of flexibility to trade off performance and resource isolation when deploying applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071701Z" creationid="xccui" creationdate="20190606T145021Z">
        <seg>通过在TaskManager内部采用线程并行以及在每个主机上部署多个TaskManager进程，Flink为部署应用时性能和资源隔离的取舍提供了极大的自由度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By only computing results based on actual data, these systems are also able to process historical data in the same way as “live” data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T163531Z" creationid="xccui" creationdate="20190605T053408Z">
        <seg>由于只需依靠实际数据计算结果，此类系统可以将历史数据当做"实时"数据进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By only writing data once a checkpoint is completed, the transac‐ tional approach does not suffer from the replay inconsistency of the idempotent writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T073536Z" creationid="xccui" creationdate="20190708T073402Z">
        <seg>通过只在检查点完成后写入数据，这种事务性的方法虽然不会像幂等性写那样出现重放过程中的不一致现象，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By processing several streams in parallel, you can lower the latency while processing more events at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T212443Z" creationid="xccui" creationdate="20190402T212226Z">
        <seg>通过并行处理多条数据流，你可以在处理更多事件的同时降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By processing several streams in parallel, you lower the latency while processing more events at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235732Z" creationid="xccui" creationdate="20190605T235730Z">
        <seg>通过并行处理多条数据流，可以在处理更多事件的同时降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By providing a custom FlinkKafkaPartitioner, you can control how records are routed to topic partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T035333Z" creationid="xccui" creationdate="20190710T035333Z">
        <seg>你可以通过提供一个自定义的FlinkKafkaPartitioner来控制数据到主题分区的路由方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By providing a list of state objects, functions with operator state can implement this logic using the snapshotState() and restoreState() methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052117Z" creationid="xccui" creationdate="20190701T060050Z">
        <seg>而通过提供状态对象列表，状态化函数就能使用snapshotState()和restoreState()方法来实现自动化逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By relying on event time, we can guarantee result correctness even in cases of out-of- order data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025039Z" creationid="xccui" creationdate="20190606T024500Z">
        <seg>依靠事件时间，我们可以保证在数据乱序的情况下结果依然正确，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By relying on event time, we can guarantee result correctness even in such cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T154750Z" creationid="xccui" creationdate="20190412T154249Z">
        <seg>依靠事件时间，我们可以保证上述情况中结果正确，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By resetting the state of a (possibly modified) application and replaying the input, it is possible to fix a bug of the applica&lt;t2/&gt;‐&lt;t3/&gt; tion and repair its effects, deploy new versions of an application without losing its state, or run what-if or A/B tests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T063011Z" creationid="xccui" creationdate="20190312T215231Z">
        <seg>通过重置（变更后）应用的状态并重放输入，可以修复应用bug或消除影响，在不丢失状态的情况下部署新版本，进行假设验证或A/B测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191706Z" creationid="xccui" creationdate="20190225T191706Z">
        <seg>第1章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 10</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T043126Z" creationid="xccui" creationdate="20190725T043126Z">
        <seg>第10章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 11</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040353Z" creationid="xccui" creationdate="20190807T040353Z">
        <seg>第11章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053436Z" creationid="xccui" creationdate="20190329T045754Z">
        <seg>第2章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053535Z" creationid="xccui" creationdate="20190416T053535Z">
        <seg>第3章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 4</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T042834Z" creationid="xccui" creationdate="20190606T042834Z">
        <seg>第4章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 5</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014844Z" creationid="xccui" creationdate="20190612T014822Z">
        <seg>第5章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 6</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045924Z" creationid="xccui" creationdate="20190619T045924Z">
        <seg>第6章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 7</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042404Z" creationid="xccui" creationdate="20190629T042404Z">
        <seg>第7章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 8</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T053612Z" creationid="xccui" creationdate="20190707T053612Z">
        <seg>第8章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 9</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023725Z" creationid="xccui" creationdate="20190717T023725Z">
        <seg>第9章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CONTEXT defines</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052346Z" creationid="xccui" creationdate="20190716T052259Z">
        <seg>CONTEXT用于指定一个可选的自定义上下文对象的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CONTINUE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184358Z" creationid="xccui" creationdate="20190626T184358Z">
        <seg>CONTINUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CPU</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025545Z" creationid="xccui" creationdate="20190225T025545Z">
        <seg>CPU</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CREATE KEYSPACE IF NOT EXISTS example</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210039Z" creationid="xccui" creationdate="20190711T210039Z">
        <seg>CREATE KEYSPACE IF NOT EXISTS example</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CREATE TABLE IF NOT EXISTS example.sensors ( sensorId VARCHAR,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210045Z" creationid="xccui" creationdate="20190711T210045Z">
        <seg>CREATE TABLE IF NOT EXISTS example.sensors ( sensorId VARCHAR,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Called after windowing function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201923Z" creationid="xccui" creationdate="20190627T201923Z">
        <seg>在窗口函数之后调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Called before windowing function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201901Z" creationid="xccui" creationdate="20190627T201901Z">
        <seg>在窗口函数之前调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Canceling an Application Might Fail</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T185221Z" creationid="xccui" creationdate="20190726T185221Z">
        <seg>应用可能会取消失败</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Canceling an Application with a Savepoint Might Fail</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T181458Z" creationid="xccui" creationdate="20190729T043501Z">
        <seg>生成保存点并取消应用可能会失败</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Canceling an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035354Z" creationid="xccui" creationdate="20190726T035354Z">
        <seg>取消应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cancelled job bc0b2ad61ecd4a615d92ce25390f61ad.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T184701Z" creationid="xccui" creationdate="20190726T184701Z">
        <seg>Cancelled job bc0b2ad61ecd4a615d92ce25390f61ad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cancels the application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162409Z" creationid="xccui" creationdate="20190729T162409Z">
        <seg>取消应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case class fields are accessed by name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040708Z" creationid="xccui" creationdate="20190617T040708Z">
        <seg>样例类的字段可以按名称访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cassandra models datasets as tables of rows that consist of multiple typed col‐ umns.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T193249Z" creationid="xccui" creationdate="20190711T193249Z">
        <seg>Cassandra将数据集建模成由多个类型的列所组成的行表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cassandra sinks are created and configured using a builder that is obtained by calling the CassandraSink.addSink() method with the DataStream object that should be emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T211558Z" creationid="xccui" creationdate="20190711T211147Z">
        <seg>Cassandra数据汇的创建和配置都是通过构建器来完成的，为此，我们要以写出目标DataStream对象为参数去调用CassandraSink.addSink()方法，得到一个构建器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CassandraSink.addSink(readings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212849Z" creationid="xccui" creationdate="20190711T212849Z">
        <seg>CassandraSink.addSink(readings)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cassandra’s data model is based on primary keys, and all writes to Cassandra happen with upsert semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T201733Z" creationid="xccui" creationdate="20190711T201733Z">
        <seg>Cassandra的数据模型是基于主键的，因此对于它的写操作都遵循Upsert语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Categories include CPU utilization, memory used, number of active threads, garbage collection statistics, network metrics such as the number of queued input/output buf‐ fers, cluster-wide metrics such as the number or running jobs and available resources, job metrics including runtime, the number of retries and checkpointing information, I/O statistics including the number of record exchanges locally and remotely, water‐ mark information, connector-specific metrics, etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015054Z" creationid="xingcan" creationdate="20190802T153015Z">
        <seg>指标类别包括CPU利用率，内存使用情况，活动的线程数，垃圾回收统计，网络指标（例如输入或输出缓冲区的堆积情况），集群范围的指标（例如正在运行的作业数量或信息及可用资源），作业指标（包括运行时信息、重试次数和检查点信息），I/O统计数据（包括本地或远程交换的记录数），水位线信息以及连接器特定指标等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chained task execution with fused function in a single thread and data pass&lt;t0/&gt;‐&lt;t1/&gt; ing via method calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153822Z" creationid="esouser" creationdate="20190514T153152Z">
        <seg>在结合多个函数的链接任务执行过程中，数据通过方法调用传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chained task execution with fused functions in a single thread and data passing via method calls</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T201402Z" creationid="xccui" creationdate="20190606T203806Z">
        <seg>单线程执行的链接任务"融合"了多个函数，并通过方法调用进行数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes in the configuration file are not effective until Flink is restarted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T042221Z" creationid="xccui" creationdate="20190723T042221Z">
        <seg>所有对于该配置文件的修改都需要重启Flink才能生效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the Input Data Type of Built-in Stateful Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T041125Z" creationid="xccui" creationdate="20190705T041125Z">
        <seg>改变内置状态化算子的输入数据类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the data type of a state is possible in a few specific cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T052753Z" creationid="xccui" creationdate="20190705T044439Z">
        <seg>在某些特定情况下，你可以改变状态的数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 1 gives an overview of stateful stream processing, data processing appli‐ cation architectures, application designs, and the benefits of stream processing over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T061459Z" creationid="esouser" creationdate="20190603T155541Z">
        <seg>第1章是概述，我们在其中概括了状态化流处理、数据处理应用的架构和设计以及流处理和传统方法相比的优势所在，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 1 is an overview of stateful stream processing, data processing application architectures, application designs, and benefits over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T165303Z" creationid="xccui" creationdate="20190225T163756Z">
        <seg>第1章是概览，我们在其中回顾了状态化流处理、数据处理应用的架构和设计以及和传统方法相比的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 covers operation, monitoring, and maintenance of streaming applications that run 24/7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T170937Z" creationid="xccui" creationdate="20190225T170900Z">
        <seg>第10章涵盖了针对7*24小时运行的流处理任务的操作、监控和运维等内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 covers operation, monitoring, and maintenance of streaming applica‐ tions that run 24/7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T143453Z" creationid="esouser" creationdate="20190603T162607Z">
        <seg>第10章涵盖了针对7×24小时运行的流处理应用的操作、监控和运维等内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 describes how to trigger and dispose savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T070234Z" creationid="xccui" creationdate="20190609T211058Z">
        <seg>第10章介绍了如何生成和删除保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 discusses job submission and the REST interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042321Z" creationid="xccui" creationdate="20190725T042240Z">
        <seg>第10章将讨论作业提交和REST接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 explains how to take savepoints of running applications and how to start a new application from an existing savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T031041Z" creationid="xccui" creationdate="20190705T031041Z">
        <seg>第10章介绍了如何为运行中的应用创建保存点以及如何从现有的保存点启动一个新的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 gives guidance on how to operate stateful applications—taking and restoring from application savepoints, rescaling applications, and performing application upgrades.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="xccui" creationdate="20190630T033104Z">
        <seg>第10章指导你如何操纵状态化应用，具体包括创建和恢复应用保存点，对应用进行扩缩容以及应用更新等内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 will discuss how the DataStream API allows to control the assignment and grouping of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210039Z" creationid="xccui" creationdate="20190428T210014Z">
        <seg>在第10章会讨论如何通过DataStream API控制任务分配及分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172807Z" creationid="xccui" creationdate="20190228T172807Z">
        <seg>第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2 discussed important concepts of distributed stream processing, such as parallelization, time, and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T042610Z" creationid="xccui" creationdate="20190606T135925Z">
        <seg>我们在第2章主要讨论了分布式流处理中的一些重要概念，例如：并行、时间和状态等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2 discusses fundamental concepts and challenges of stream processing and its content is rather independent of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T165317Z" creationid="xccui" creationdate="20190225T164744Z">
        <seg>第2章主要讨论流处理的基本概念和挑战，这些内容都是独立于Flink而存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2 discusses the fundamental concepts and challenges of stream process‐ ing, independent of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T223303Z" creationid="esouser" creationdate="20190603T155834Z">
        <seg>第2章主要讨论流处理的基本概念和挑战，这些内容均是独立于Flink而存在的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032105Z" creationid="xccui" creationdate="20190401T032105Z">
        <seg>第二章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 3 describes Flink’s system architecture and internals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T061520Z" creationid="xccui" creationdate="20190225T164833Z">
        <seg>第3章是描述Flink的系统架构和内部实现，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053634Z" creationid="xccui" creationdate="20190416T053630Z">
        <seg>第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 4 explains how to set up an environment to develop and debug Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T061543Z" creationid="esouser" creationdate="20190603T161023Z">
        <seg>第4章讲解如何配置用于开发和调试Flink应用的环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 5 introduces you to the basics of the Flink’s DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031541Z" creationid="esouser" creationdate="20190603T161252Z">
        <seg>第5章介绍Flink DataStream API的基础知识，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 5 will introduce you to the basics of the DataStream API, and Chapters 6, 7, and 8 will introduce everything you need to know about time-based operators, state‐ ful functions, and source and sink connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T095058Z" creationid="xccui" creationdate="20190612T011507Z">
        <seg>我们会在第5章介绍DataStream API的基础知识，在第6、7、8章分别介绍有关基于时间的算子、状态化函数以及数据源和数据汇连接器的全部内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 6 discusses the time-based operators of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T061640Z" creationid="esouser" creationdate="20190603T161540Z">
        <seg>第6章讨论DataStream API中基于时间的算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 7 explains how to implement stateful functions and discusses everything around this topic, such as the performance, robustness, and evolution of stateful functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051954Z" creationid="esouser" creationdate="20190603T162033Z">
        <seg>第7章介绍如何实现状态化函数以及一些与之相关的问题，例如性能、健壮性、状态函数演变等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 8 presents Flink’s most commonly used source and sink connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T051434Z" creationid="esouser" creationdate="20190603T162256Z">
        <seg>第8章介绍Flink中最常用的数据源（Data Source）和数据汇（Data Sink）连接器，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 9 discusses how to set up and configure Flink clusters in various environments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162601Z" creationid="esouser" creationdate="20190603T162601Z">
        <seg>第9章讨论如何针对不同环境搭建和配置Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 9 discusses how to setup and configure Flink clusters in various environ&lt;t0/&gt;‐&lt;t1/&gt; ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T170602Z" creationid="xccui" creationdate="20190225T170602Z">
        <seg>第9章讨论如何针对不同环境搭建和配置Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 9 explains how to set up and configure Flink to reliably process stateful applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T032855Z" creationid="xccui" creationdate="20190630T032457Z">
        <seg>第9章介绍了如何设置Flink使其能够可靠地处理状态化应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapters 2 and 3 discussed the foundations of stateful stream processing and related details of Flink’s architecture, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T032617Z" creationid="xccui" creationdate="20190630T032445Z">
        <seg>第2、3两章分别讨论了状态化流处理的基础以及Flink架构的相关细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapters 4 to 8 is where you get our hands dirty and start developing Flink applica&lt;t0/&gt;‐&lt;t1/&gt; tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191540Z" creationid="xccui" creationdate="20190225T165503Z">
        <seg>第4到8章会带你着手开发Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check the Configuration of Your Kafka Cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T032535Z" creationid="xccui" creationdate="20190710T032523Z">
        <seg>检查Kafka集群的配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CheckpointCommitter is used to store information about completed check‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T223917Z" creationid="xccui" creationdate="20190711T223845Z">
        <seg>CheckpointCommitter用来将已完成的检查点信息写入外部数据存储中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CheckpointedFunction instead of the ListCheckpointed interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063643Z" creationid="xccui" creationdate="20190701T063643Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpointing and State Backends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154914Z" creationid="xccui" creationdate="20190225T025624Z">
        <seg>检查点和状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpointing can be an expensive operation since the amount of data that needs to be copied to a persistent storage can be quite large.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T024621Z" creationid="xccui" creationdate="20190731T025121Z">
        <seg>由于在生成检查点时可能需要将大量数据写入持久化存储中，所以其代价可能非常昂贵</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpointing metrics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T161643Z" creationid="xccui" creationdate="20190729T161643Z">
        <seg>检查点指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints are automatically created, loaded in case of a failure, and automatically removed by Flink (depending on the configuration of the application).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T014616Z" creationid="xccui" creationdate="20190726T014616Z">
        <seg>检查点会自动创建，在发生故障时自动加载并由Flink自动删除（取决于应用具体配置）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints are enabled on the StreamExecutionEnvironment:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T030649Z" creationid="xccui" creationdate="20190731T030649Z">
        <seg>检查点可以通过StreamExecutionEnvironment来启用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints are implemented based on barriers that flow with the data and therefore avoid global synchronization across all operators of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T184515Z" creationid="xccui" creationdate="20190702T163830Z">
        <seg>它内部的检查点是基于和数据一起流动的分隔符来实现的，因此可以避免在应用所有算子间的全局同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints are periodically taken and automatically discarded according to a configurable policy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T205603Z" creationid="xccui" creationdate="20190609T205454Z">
        <seg>检查点会周期性地生成，而且会根据配置的策略自动丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints, Savepoints, and State Recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154749Z" creationid="xccui" creationdate="20190225T022126Z">
        <seg>检查点、保存点及状态恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints, Savepoints, and State Recovery | 59</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032759Z" creationid="xccui" creationdate="20190610T032759Z">
        <seg>检查点、保存点及状态恢复 | 59</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choosing a State Backend</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T055659Z" creationid="xccui" creationdate="20190225T024742Z">
        <seg>选择状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choosing a State Primitive</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024815Z" creationid="xccui" creationdate="20190225T024815Z">
        <seg>选择状态原语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classloading issues are not uncommon when running jobs with external dependen‐ cies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T044246Z" creationid="xccui" creationdate="20190723T044246Z">
        <seg>当你运行具有外部依赖关系的作业时，可能会经常遇到类加载方面的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CoMapFunction and CoFlatMapFunction as argument respectively.2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T041022Z" creationid="xccui" creationdate="20190615T041022Z">
        <seg>它们分别接收一个CoMapFunction和一个CoFlatMapFunction作为参数。2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CoProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210745Z" creationid="esouser" creationdate="20190603T210745Z">
        <seg>CoProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collected metrics of an application at various levels of detail</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T161637Z" creationid="xccui" creationdate="20190729T161637Z">
        <seg>以不同详细程度收集的应用程序指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collections.singletonList(new TimeWindow(startTime, endTime))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044135Z" creationid="xccui" creationdate="20190626T044135Z">
        <seg>Collections.singletonList(new TimeWindow(startTime, endTime))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Colophon</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T213538Z" creationid="xccui" creationdate="20190807T213538Z">
        <seg>后记</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining events of two streams is a very common requirement in stream process‐ ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T160725Z" creationid="xccui" creationdate="20190613T160725Z">
        <seg>在流处理中，合并两条数据流中的事件是一个非常普遍的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Command-Line Client on Windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T021654Z" creationid="xccui" creationdate="20190726T021654Z">
        <seg>Windows系统中的命令行客户端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Committing a transaction must be an idempotent operation—the sink or exter‐ nal system should be able to notice that a transaction was already committed or a repeated commit must have no effect.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T031447Z" creationid="xccui" creationdate="20190716T031447Z">
        <seg>提交事务的操作必须是幂等的，即数据汇或外部系统需要知道某个事务是否已经提交，或者让重复提交变得无效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common CEP use cases include financial applications, fraud detection, monitoring and alerting in complex systems, and detecting network intru‐ sion or suspicious user behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T162045Z" creationid="xingcan" creationdate="20190807T162045Z">
        <seg>常见的CEP用例包括金融应用，欺诈检测，复杂系统中的监控和报警，以及检测网络入侵或可以用户行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common antipatterns that must be avoided include:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T213432Z" creationid="xccui" creationdate="20190716T213432Z">
        <seg>日常中应该避免一些反面模式包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common challenges that distributed systems need to address are allocation and man&lt;t0/&gt;‐&lt;t1/&gt; agement of compute resources in a cluster, process coordination, durable and avail&lt;t2/&gt;‐&lt;t3/&gt; able data storage, and failure recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T031359Z" creationid="xccui" creationdate="20190418T031209Z">
        <seg>分布式系统需要应对的常见挑战包括分配和管理集群计算资源、进程协调、持久化及可用数据存储、故障恢复等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common challenges that distributed systems need to address are allocation and man‐ agement of compute resources in a cluster, process coordination, durable and highly available data storage, and failure recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T044118Z" creationid="xccui" creationdate="20190606T140641Z">
        <seg>分布式系统需要应对的常见挑战包括分配和管理集群计算资源，进程协调，持久且高可用的数据存储及故障恢复等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common choices are IntelliJ IDEA, Eclipse, or Netbeans with the appropriate plugins (such as for Maven, Git, and Scala support).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T072541Z" creationid="xccui" creationdate="20190611T030527Z">
        <seg>常见选项有IntelliJ IDEA、Eclipse或Netbeans，它们都需要相应安装一些插件（例如Maven插件、Git插件及Scala插件）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Companies employ many different applications to run their business, such as enter&lt;t0/&gt;‐&lt;t1/&gt; prise resource planning (ERP) systems, customer relationship management (CRM) software, or web-based applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T184326Z" creationid="xccui" creationdate="20190226T155328Z">
        <seg>一般公司都会使用很多不同种类的应用来运营业务，例如企业资源规划（ERP）系统、客户关系管理（CRM）软件、基于web的应用等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Companies use all kinds of applications for their day-to-day business activities, such as enterprise resource planning (ERP) systems, customer relationship management (CRM) software, and web-based applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T051250Z" creationid="esouser" creationdate="20190603T194537Z">
        <seg>公司在日常业务运营过程中会用到各类应用，例如企业资源规划（ERP）系统、客户关系管理（CRM）软件、基于web的应用等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compared to field positions and field expressions, an advantage of KeySelector functions is that the resulting key is strongly typed due to the generic types of the KeySelector class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052507Z" creationid="xccui" creationdate="20190618T052507Z">
        <seg>和使用字段位置以及字段表达式相比，KeySelector函数的一大好处是它返回的键值是强类型的，因为KeySelector类需要提供泛型参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CompletableFuture[ValueState[(String, Double)]]](numSensors) val results = new Array[Double](numSensors)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040147Z" creationid="xccui" creationdate="20190707T040147Z">
        <seg>CompletableFuture[ValueState[(String, Double)]]](numSensors) val results = new Array[Double](numSensors)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Complex data structures can also be stored as value state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T215859Z" creationid="xccui" creationdate="20190607T215731Z">
        <seg>该值也可以是某个复杂数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components of a Flink Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T215253Z" creationid="xccui" creationdate="20190225T021731Z">
        <seg>搭建Flink所需组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Composite keys consisting of more than one tuple field can also be defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040154Z" creationid="xccui" creationdate="20190618T033324Z">
        <seg>你还可以利用多个元组字段定义复合键值，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computation results can be updated based on late events and updates have to be emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T205233Z" creationid="xingcan" creationdate="20190628T153009Z">
        <seg>根据迟到事件更新并发出计算结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compute the average temperature every 5 seconds for a stream of sensors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041632Z" creationid="xccui" creationdate="20190612T041632Z">
        <seg>针对传感器数据流每5秒计算一次平均温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computing the minimum and maximum temperature per sensor and window using a ProcessWindowFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030617Z" creationid="xccui" creationdate="20190625T030617Z">
        <seg>使用ProcessWindowFunction计算每个传感器在每个窗口内的最低温和最高温。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concep‐ tually, the list entries of all parallel operator tasks are collected and evenly redistrib‐ uted to a smaller or larger number of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062425Z" creationid="xccui" creationdate="20190608T060433Z">
        <seg>理论上，所有并行算子任务的列表条目会被统一收集起来，随后均匀分配到更少或更多的任务之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuration key</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T042950Z" creationid="xccui" creationdate="20190804T042950Z">
        <seg>配置键</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuration of a HA Flink cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T203643Z" creationid="xccui" creationdate="20190720T203643Z">
        <seg>配置Flink HA集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuration parameter is only used by the DataSet API and not by the Data‐ Stream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T061335Z" creationid="xccui" creationdate="20190618T061320Z">
        <seg>注意，Configuration参数只在DataSet API中使用而并没有在DataStream API中用到，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configurations with a single slot per TaskManager have better resource isolation and can prevent a misbehaving application from interfering with unrelated applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T034828Z" creationid="xccui" creationdate="20190724T034828Z">
        <seg>如果将每个TaskManager配置成只有单个处理槽可以更好地隔离资源，防止行为不当的应用对其他无关应用的干扰。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Checkpointing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T213355Z" creationid="xccui" creationdate="20190225T030042Z">
        <seg>配置检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030108Z" creationid="xccui" creationdate="20190225T030108Z">
        <seg>配置故障恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring RocksDBStateBackend for an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025642Z" creationid="xccui" creationdate="20190704T025642Z">
        <seg>为应用配置RocksDBStateBackend</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring State Backends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030054Z" creationid="xccui" creationdate="20190225T030054Z">
        <seg>配置状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Time Characteristics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023020Z" creationid="xccui" creationdate="20190225T023020Z">
        <seg>配置时间特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Time Characteristics | 111</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041858Z" creationid="xccui" creationdate="20190629T041858Z">
        <seg>配置时间特征 | 111</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring keyed state to be queryable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T060913Z" creationid="xccui" creationdate="20190706T060913Z">
        <seg>将键值分区状态设置为可查询的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring the Logging Behavior</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030154Z" creationid="xccui" creationdate="20190225T030154Z">
        <seg>配置日志行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring the Logging Behavior | 279</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040337Z" creationid="xccui" creationdate="20190807T040337Z">
        <seg>配置日志行为 | 279</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring the memory of a worker process is a bit more involved because there are multiple components that allocate different types of memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T063400Z" creationid="xccui" creationdate="20190723T063400Z">
        <seg>配置工作进程的内存要复杂一些，因为会有多个组件分别占用不同类型的内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring the restart strategy of an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154416Z" creationid="xingcan" creationdate="20190801T154416Z">
        <seg>配置应用重启策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring these options is important to ensure reliable and smooth operation of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T030232Z" creationid="xccui" creationdate="20190731T025821Z">
        <seg>配置好这些选项，对于保证生产环境中流式应用的可靠、稳定运维非常重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connect, coMap, and coFlatMap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T065150Z" creationid="xccui" creationdate="20190614T065132Z">
        <seg>Connect，coMap，coFlatMap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connecting a broadcast stream and keyed event stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024304Z" creationid="xccui" creationdate="20190702T024304Z">
        <seg>联结广播流和键值分区事件流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connecting a stateful streaming application running on Flink and an event log is interesting for multiple reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T065137Z" creationid="xccui" creationdate="20190305T060607Z">
        <seg>出于很多原因，将运行在Flink之上的状态化流处理应用和事件日志系统相连会很有意义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connectors to the most commonly used storage systems such as Apache Kafka, Apache Cassandra, Elasticsearch, JDBC, Kinesis, and (distributed) filesystems such as HDFS and S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T121502Z" creationid="xccui" creationdate="20190605T121502Z">
        <seg>用于最常见存储系统的连接器，如Apache Kafka、Apache Cassandra、Elasticsearch、JDBC、Kinesis以及（分布式）文件系统（HDFS和S3等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, a running application needs to be replaced by an updated version usually without losing the state of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T021139Z" creationid="xccui" creationdate="20190704T214350Z">
        <seg>这往往要求我们在不丢失状态的前提下对当前运行的应用进行版本更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, all records with the same key access the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061254Z" creationid="xccui" creationdate="20190607T191804Z">
        <seg>因此所有键值相同的记录都能访问到一样的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, an application needs enough spare resources for the catch-up phase after the application was restarted to successfully resume its regular processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T150454Z" creationid="xingcan" creationdate="20190801T150454Z">
        <seg>因此，应用在从重启到成功恢复常规处理的进度追赶期间需要足够多的备用资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, each instance of the source function multiplexes the records of three stream partitions to emit them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T041825Z" creationid="xccui" creationdate="20190713T040757Z">
        <seg>因此，数据源函数实例需要将3个数据流分区中的记录混合发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, most Flink applications do not only depend on Flink’s Data‐ Stream API dependency and the Java SDK but also on additional third-party and Flink-internal dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035413Z" creationid="xccui" creationdate="20190619T035413Z">
        <seg>因此大多数Flink应用不仅需要依赖Flink的DataStream API和Java SDK，还需要额外的第三方库和Flink内部依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, records of both inputs are processed based on the same event-time clock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T030644Z" creationid="xccui" creationdate="20190607T030436Z">
        <seg>这就导致所有输入的记录都必须基于同一个事件时间时钟来处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, the GlobalWindows assigner requires a custom trigger and possibly an evictor to selectively</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052518Z" creationid="xccui" creationdate="20190626T044523Z">
        <seg>因此，GlobalWindows分配器需要一个自定义的触发器，可能还需要一个移除器来有选择地将元素从窗口状态中删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, the number of key groups of a stateful operator determines its maximum parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T031137Z" creationid="xccui" creationdate="20190729T031137Z">
        <seg>因此状态化算子键值组的数量决定了其最大并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, the processing latencies and state size of time-based opera‐ tors can significantly increase if a task does not receive new watermarks from all input tasks at regular intervals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T032904Z" creationid="xccui" creationdate="20190607T032902Z">
        <seg>因此，如果一个任务没有从全部输入任务以常规间隔接收新的水位线，就会导致时间相关算子的处理延迟或状态大小激增。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, these functions should only be used if the key values are from a constant and bounded domain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T183553Z" creationid="xccui" creationdate="20190704T183511Z">
        <seg>所以说，只有在键值域不变或有界的前提下才能使用这些函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, today’s data infrastructures often consist of many different storage systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T055926Z" creationid="xccui" creationdate="20190707T055926Z">
        <seg>因此，如今的数据基础设施通常都由很多不同的存储系统组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, you should either ensure the value of the broadcast state does not depend on the order in which the broadcasted mes‐ sages are received or ensure the parallelism of the broadcasting operator is set to 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T055655Z" creationid="xccui" creationdate="20190702T055655Z">
        <seg>因此你需要确保广播状态的值不依赖于收到广播消息的顺序，或者将上游广播算子的并行度设置为1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conse‐ quently, GlobalWindows will never be completely cleaned up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044816Z" creationid="xccui" creationdate="20190626T044806Z">
        <seg>因此，它永远不会被彻底清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conse‐ quently, an application can only be operated under exactly-once state consistency if all input streams are consumed by resettable data sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T053412Z" creationid="xccui" creationdate="20190609T050740Z">
        <seg>因此只有所有输入流都是来自于可重置的数据源，应用才支持精确一次的状态一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conse‐ quently, there is no window without at least one element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032952Z" creationid="xccui" creationdate="20190626T032733Z">
        <seg>因此，每个窗口至少会有一个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consid&lt;t0/&gt;‐&lt;t1/&gt; ering that streaming applications might run for several days, months, or even years, you need to make sure that state can be reliably recovered under failures and that your system can guarantee accurate results even if things break.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T205442Z" creationid="xccui" creationdate="20190409T205052Z">
        <seg>考虑到流式应用可能需要成日、甚至长年累月地运行，因此必须保证出错时状态能进行可靠的恢复，即使发生故障系统也能提供准确的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider Bob, another player of the online mobile game, who happens to be on the same train as Alice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160443Z" creationid="xccui" creationdate="20190412T152139Z">
        <seg>假设有另一位名叫鲍勃的玩家也在玩那个在线手游，他恰好和爱丽丝在同一趟地铁上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider a program that analyzes events generated by users playing an online mobile game.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T153748Z" creationid="xccui" creationdate="20190606T014733Z">
        <seg>假设有某个应用程序会分析用户玩在线手游时产生的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider a program that analyzes events generated by users playing online mobile games.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T211520Z" creationid="xccui" creationdate="20190409T211346Z">
        <seg>考虑某程序会分析用户玩在线手游时产生的事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that ana&lt;t3/&gt;‐&lt;t4/&gt; lyzes online user behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025233Z" creationid="xccui" creationdate="20190407T025046Z">
        <seg>假设有一个应用要在线分析用户行为，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that analyzes online user behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013553Z" creationid="xccui" creationdate="20190606T013553Z">
        <seg>假设有一个应用要在线分析用户行为，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that monitors a forest area and outputs an alert when‐ ever there is a high risk of fire.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T035523Z" creationid="xccui" creationdate="20190615T035523Z">
        <seg>假设有一个森林区域监控应用会在火灾发生风险很高时报警。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that provides real-time traffic information to drivers so that they can avoid congested routes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043400Z" creationid="xccui" creationdate="20190406T043152Z">
        <seg>假设有一个应用能向司机提供实时路况信息以帮助他们躲避拥堵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider for example a streaming join opera&lt;t2/&gt;‐&lt;t3/&gt; tion or a holistic aggregate, such as median.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041531Z" creationid="xccui" creationdate="20190406T041221Z">
        <seg>例如：流连接或是像求中位数的整体聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the case where Alice starts popping bubbles while her phone is connected to the network and sends events to the analysis application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151136Z" creationid="xccui" creationdate="20190411T150723Z">
        <seg>因此考虑如下情况：爱丽丝开始消泡泡的时候手机还能联网向分析应用发送事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the case where Alice starts pop‐ ping bubbles while her phone is connected to the network and sends events to the analysis application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154618Z" creationid="xccui" creationdate="20190606T015023Z">
        <seg>因此考虑如下情况：爱丽丝开始消泡泡的时候手机还能联网向分析应用发送事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following case classes:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T045952Z" creationid="xccui" creationdate="20190618T045952Z">
        <seg>考虑以下样例类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following example of keying a stream of Tuple3[Int, Int, Int] on the first field and computing a rolling sum on the second field:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T062121Z" creationid="xccui" creationdate="20190614T054424Z">
        <seg>以下例子中，我们对一个Tuple3[Int, Int, Int]类型的数据流按照第一个字段进行键值分区，然后滚动计算第二个字段的总和：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider, for example, a streaming join opera‐ tion or a holistic aggregate, such as the median function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151824Z" creationid="xccui" creationdate="20190606T012013Z">
        <seg>例如：流式Join或者像是求中位数的整体聚合（holistic aggregate）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considering that streaming applications might run for several days, months, or even years, you need to make sure that state can be reliably recovered under failures and that your system can guarantee accurate results even if things break.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064633Z" creationid="xccui" creationdate="20190606T014534Z">
        <seg>考虑到流式应用可能需要整日、甚至长年累月地运行，因此必须保证出错时其状态能进行可靠的恢复，并且即使系统发生故障系统也能提供准确的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considering the color of the input event as the key, Figure 5-4 assigns black events to one partition and all other events to another partition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T061607Z" creationid="xccui" creationdate="20190614T051108Z">
        <seg>我们假设以输入事件的颜色作为键值，图5-4中将所有黑色事件分到一个任务，而将其他事件分到另一个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considering window operators complicate latency tracking even further, if an event contributes to several windows, do we need to report the latency of the first invocation or do we need to wait until we evaluate all windows an event might belong to?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T053003Z" creationid="xccui" creationdate="20190806T052332Z">
        <seg>而窗口算子会使延迟追踪变得更加复杂。如果事件被同时分配到多个窗口，那么我们应该以第一次窗口调用时的延迟为准还是等它所有参与的窗口都计算完后再来测量？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consistent Checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154728Z" creationid="xccui" creationdate="20190225T022145Z">
        <seg>一致性检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant width</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210802Z" creationid="esouser" creationdate="20190603T210802Z">
        <seg>Constant width</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant width italic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210807Z" creationid="esouser" creationdate="20190603T210807Z">
        <seg>Constant width italic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consult the Flink documentation for a full list of configuration options per supported reporter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T060030Z" creationid="xccui" creationdate="20190804T060030Z">
        <seg>要获得每个所支持汇报器的完整配置选项，请参阅Flink文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consult the Flink documentation for detailed instructions on enabling and configuring Kerberos authentication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T023402Z" creationid="xccui" creationdate="20190725T023402Z">
        <seg>有关启用和配置Kerberos身份验证的详细说明，请参阅Flink文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consult the Kafka documentation for additional configuration properties.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T020145Z" creationid="xccui" creationdate="20190709T020145Z">
        <seg>其他配置属性请参照Kafka文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consult “State Management” on page 53 for more details on keyed state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T040059Z">
        <seg>有关键值分区状态的详细信息请参照第53页"状态管理"一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consumers of the log incorporate the updates into the affected data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154237Z" creationid="xccui" creationdate="20190605T040435Z">
        <seg>日志的消费方会将这些更新整合到相关数据存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Context object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T015116Z" creationid="xccui" creationdate="20190622T015116Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controlling Task Chaining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030013Z" creationid="xccui" creationdate="20190225T030013Z">
        <seg>控制任务链接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controlling Task Scheduling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025953Z" creationid="xccui" creationdate="20190225T025953Z">
        <seg>控制任务调度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controlling Task Scheduling | 261</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040234Z" creationid="xccui" creationdate="20190807T040234Z">
        <seg>控制任务调度 | 261</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controlling task scheduling with slot-sharing groups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015221Z" creationid="xccui" creationdate="20190731T015221Z">
        <seg>通过处理槽共享组控制任务调度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions Used in This Book</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210758Z" creationid="esouser" creationdate="20190603T210758Z">
        <seg>Conventions Used in This Book</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Con‐ sider a scenario where you detect a bug in your deployed application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T044430Z" creationid="xccui" creationdate="20190725T044430Z">
        <seg>考虑这样一种场景——你在已部署的应用中发现一个Bug。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright 2019 Fabian Hueske and Vasiliki Kalavri, 978-1-491-97429-2.”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210826Z" creationid="esouser" creationdate="20190603T210826Z">
        <seg>Copyright 2019 Fabian Hueske and Vasiliki Kalavri, 978-1-491-97429-2.”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright © 2019 Fabian Hueske, Vasiliki Kalavri.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210711Z" creationid="esouser" creationdate="20190603T210711Z">
        <seg>Copyright © 2019 Fabian Hueske, Vasiliki Kalavri.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-Based Windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T035233Z" creationid="xccui" creationdate="20190623T035233Z">
        <seg>基于数量的窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-based tumbling window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013112Z" creationid="xccui" creationdate="20190606T013111Z">
        <seg>基于数量的滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-based tumbling window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023544Z" creationid="xccui" creationdate="20190407T023544Z">
        <seg>基于数量的滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-based tumbling windows define how many events are collected before triggering evaluation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063415Z" creationid="xccui" creationdate="20190406T051102Z">
        <seg>基于数量的（count-based）滚动窗口定义了在触发计算前需要集齐多少条事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Counter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T024929Z" creationid="xccui" creationdate="20190803T024929Z">
        <seg>Counter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create a Cassandra sink for POJOs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212846Z" creationid="xccui" creationdate="20190711T212846Z">
        <seg>为POJO类型创建Cassandra数据汇</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating Type Information for Data Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145213Z" creationid="esouser" creationdate="20190603T145213Z">
        <seg>为数据类型创建类型信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating TypeInformation for data types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022835Z" creationid="xccui" creationdate="20190225T022835Z">
        <seg>为数据类型创建TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating a Cassandra sink for tuples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210800Z" creationid="xccui" creationdate="20190711T210800Z">
        <seg>创建一个针对元组的Cassandra数据汇</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating a Flink Kafka sink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T171130Z" creationid="xccui" creationdate="20190708T171130Z">
        <seg>创建一个Flink Kafka数据汇</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating a Flink Kafka source</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T212357Z" creationid="xccui" creationdate="20190708T205847Z">
        <seg>创建Flink kafka数据源连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating a StreamingFileSink in bulk-encoding mode</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T182200Z" creationid="xccui" creationdate="20190710T182200Z">
        <seg>创建块编码模式的StreamingFileSink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating a StreamingFileSink in row-encoding mode</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205905Z" creationid="xccui" creationdate="20190710T205905Z">
        <seg>以行编码方式创建一个StreamingFileSink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating a filesystem source</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T184946Z" creationid="xccui" creationdate="20190710T184946Z">
        <seg>创建文件系统数据源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-Based Flow Control</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202504Z" creationid="esouser" creationdate="20190603T144321Z">
        <seg>基于信用值的流量控制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-based Flow Control</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T143815Z" creationid="xccui" creationdate="20190225T021817Z">
        <seg>基于信用度的流量控制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-based flow control reduces latency because senders can ship data as soon as the receiver has enough resources to accept it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T195422Z" creationid="xccui" creationdate="20190606T203100Z">
        <seg>由于发送端可以在接收端有足够资源时立即传输数据，所以基于信用值的流量控制可以有效降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-based flow control reduces the latency because senders can ship data as soon as the receiver has enough resources to accept it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T144033Z" creationid="esouser" creationdate="20190514T143810Z">
        <seg>由于发送端可以在接收端有足够资源时立即传输数据，因此基于信用度的流量控制可以降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, Flink offers three state backends, the MemoryStateBackend, the FsState Backend, and the RocksDBStateBackend:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T025802Z" creationid="xccui" creationdate="20190703T221736Z">
        <seg>目前，Flink提供了三种状态后端：MemoryStateBackend，FsStateBackend以及RocksDBStateBackend：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, Flink provides eight different process functions: ProcessFunction, Keyed ProcessFunction, CoProcessFunction, ProcessJoinFunction, BroadcastProcess Function, KeyedBroadcastProcessFunction, ProcessWindowFunction, and ProcessAllWindowFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T051333Z" creationid="xccui" creationdate="20190621T051333Z">
        <seg>目前，Flink提供了8种不同的处理函数：ProcessFunction、KeyedProcessFunction、CoProcessFunction、ProcessJoinFunction、BroadcastProcessFunction、KeyedBroadcastProcessFunction、ProcessWindowFunction以及ProcessAllWindowFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, the two APIs use separate execution environments and cannot be mixed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T154439Z" creationid="xingcan" creationdate="20190807T154439Z">
        <seg>目前，这两类API都有各自独立的执行环境，还无法混合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050033Z" creationid="xccui" creationdate="20190616T050033Z">
        <seg>自定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom Configuration in Flink Images</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190721T060705Z">
        <seg>在Flink镜像中自定义配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom Partitioning and Writing Message Timestamps</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T033746Z" creationid="xccui" creationdate="20190710T033746Z">
        <seg>自定义分区和写入消息时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom window operators are discussed in detail later in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T042043Z" creationid="xccui" creationdate="20190622T042043Z">
        <seg>详细内容会在本节稍后讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom-defined state in a trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T034823Z" creationid="xccui" creationdate="20190626T034823Z">
        <seg>触发器中的自定义状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom-defined trigger state and registered trigger timers are not cleared because this state is opaque to the window operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040724Z" creationid="xccui" creationdate="20190626T040339Z">
        <seg>自定义触发器状态和触发器中注册的计时器将不会被清除，因为这些状态对于窗口算子而言是不可见的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Customizing Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023237Z" creationid="xccui" creationdate="20190225T023237Z">
        <seg>自定义窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DELETE /jars/&lt;jarId&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045858Z" creationid="xccui" creationdate="20190729T045858Z">
        <seg>DELETE /jars/&lt;jarId&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DELETE_ON_CANCELLATION retains the checkpoint only after the application com‐ pletely fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T205522Z" creationid="xccui" creationdate="20190731T205522Z">
        <seg>DELETE_ON_CANCELLATION只有在应用完全失败后才会保留检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T050347Z" creationid="xccui" creationdate="20190612T051345Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data &lt;t0/&gt;ingestion&lt;t1/&gt; is the operation of fetching raw data from exter&lt;t2/&gt;‐&lt;t3/&gt; nal sources and converting it into a format that is suitable for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152000Z" creationid="xccui" creationdate="20190405T152000Z">
        <seg>数据接入操作从外部数据源获取原始数据并将其转换成适合后续处理的格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data &lt;t6/&gt;egress&lt;t7/&gt; is the operation of producing output in a form that is suitable for consumption by external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152354Z" creationid="xccui" creationdate="20190405T152354Z">
        <seg>数据输出操作将数据以适合外部系统使用的格式输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Exchange Strategies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143856Z" creationid="esouser" creationdate="20190603T143856Z">
        <seg>数据交换策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Parallelism and Task Parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054700Z" creationid="esouser" creationdate="20190603T143838Z">
        <seg>数据并行和任务并行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Pipelines</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142926Z" creationid="esouser" creationdate="20190603T142926Z">
        <seg>数据管道</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Pipelines and Real-time ETL</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014644Z" creationid="xccui" creationdate="20190225T014644Z">
        <seg>数据管道和实时ETL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Transfer between TaskManagers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T043826Z" creationid="xccui" creationdate="20190504T043826Z">
        <seg>TaskManager之间的数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Transfer in Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021809Z" creationid="xccui" creationdate="20190225T021809Z">
        <seg>Flink中的数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Transfer in Flink | 45</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032549Z" creationid="xccui" creationdate="20190610T032549Z">
        <seg>Flink中的数据传输 | 45</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data and data processing have been omnipresent in businesses for many decades.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063852Z" creationid="esouser" creationdate="20190603T193512Z">
        <seg>几十年来，数据和数据处理在各类商业领域中无处不在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data arriving to the Lambda architecture is ingested by the stream processor as well as written to a batch storage such as HDFS.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014858Z" creationid="xccui" creationdate="20190322T044236Z">
        <seg>该架构中到来的数据会同时发往流处理引擎和写入批量存储（如：HDFS）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data arriv‐ ing at the lambda architecture is ingested by the stream processor and also written to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T035717Z" creationid="xccui" creationdate="20190605T051850Z">
        <seg>在该架构中，到来的数据会同时发往流处理引擎和写入批量存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data can be stored in many different systems, such as filesystems, object stores, rela‐ tional database systems, key-value stores, search indexes, event logs, message queues, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T041947Z" creationid="xccui" creationdate="20190707T053736Z">
        <seg>我们日常可以把数据存储在很多不同的系统中，例如：文件系统，对象存储，关系数据库系统，键值存储，搜索索引，事件日志以及消息队列等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data egress is the operation of producing output in a form suitable for consumption by external sys‐ tems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060157Z" creationid="xccui" creationdate="20190606T010152Z">
        <seg>数据输出操作是将数据以适合外部系统使用的格式输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015028Z" creationid="xccui" creationdate="20190225T015028Z">
        <seg>数据交换策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies can be automatically chosen by the execu&lt;t0/&gt;‐&lt;t1/&gt; tion engine depending on the semantics of the operators or explicitly imposed by the dataflow programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034641Z" creationid="xccui" creationdate="20190401T034618Z">
        <seg>这些策略可以由执行引擎根据算子的语义自动选择，也可以由dataflow编码人员显式指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies can be automatically chosen by the execu‐ tion engine depending on the semantics of the operators or explicitly imposed by the dataflow programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233342Z" creationid="xccui" creationdate="20190605T233342Z">
        <seg>这些策略可以由执行引擎根据算子的语义自动选择，也可以由Dataflow编程人员显式指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies define how data items are assigned to tasks in a physical dataflow graph.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044914Z" creationid="xccui" creationdate="20190401T034226Z">
        <seg>数据交换策略定义了如何将数据项分配给物理Dataflow图中的不同任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142204Z" creationid="xccui" creationdate="20190401T142204Z">
        <seg>数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data ingestion and data egress</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151752Z" creationid="xccui" creationdate="20190405T151752Z">
        <seg>数据接入和数据输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data ingestion and data egress operations allow the stream processor to communicate with external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151836Z" creationid="xccui" creationdate="20190405T151836Z">
        <seg>数据接入和数据输出操作允许流处理引擎和外部系统进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data ingestion is the operation of fetching raw data from exter‐ nal sources and converting it into a format suitable for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060212Z" creationid="xccui" creationdate="20190606T005219Z">
        <seg>数据接入操作是从外部数据源获取原始数据并将其转换成适合后续处理的格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data parallelism and task parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015011Z" creationid="xccui" creationdate="20190225T015011Z">
        <seg>数据并发度和任务并发度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data parallelism is use&lt;t2/&gt;‐&lt;t3/&gt; ful because it allows for processing large volumes of data and spreading the computa&lt;t4/&gt;‐&lt;t5/&gt; tion load across several computing nodes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T031923Z" creationid="xccui" creationdate="20190401T031116Z">
        <seg>数据并行非常有用，因为它支持处理大规模数据，能够将计算负载分配到多个节点上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data parallelism is use‐ ful because it allows for processing large volumes of data and spreading the computa‐ tion load across several computing nodes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044756Z" creationid="xccui" creationdate="20190605T233252Z">
        <seg>数据并行非常有用，因为它能够将计算负载分配到多个节点上从而允许处理大规模的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data pipelines must be able to process large amounts of data in a short time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T042639Z" creationid="xccui" creationdate="20190605T042639Z">
        <seg>它需要在短时间内处理大批量数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data processing frameworks are sensitive components of a company’s IT infrastruc‐ ture and need to be secured against unauthorized use and access to data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T152220Z" creationid="xccui" creationdate="20190725T022213Z">
        <seg>数据处理框架属于公司IT基础架构中的敏感组件，我们需要对其采取某些保护措施，以防出现未经授权的使用或数据访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data stream processing is not a novel technology.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045907Z" creationid="xccui" creationdate="20190319T041222Z">
        <seg>数据流处理并非是一项新技术，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data that resides in such storage systems can be queried with and processed by a SQL-on-Hadoop engine, for example Apache Hive, Apache Drill, or Apache Impala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T072705Z" creationid="esouser" creationdate="20190603T203856Z">
        <seg>而它们中的数据也可以通过很多基于Hadoop的SQL引擎（如Apache Hive、Apache Drill或Apache Impala）进行查询和处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data that resides in such storage systems is accessible to several SQL-on-Hadoop engines, as for example Apache Hive, Apache Drill, or Apache Impala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T032911Z" creationid="xccui" creationdate="20190301T032911Z">
        <seg>而它们中的数据也可以通过很多基于Hadoop的SQL引擎（如：Apache Hive、Apache Drill、Apache Impala）进行访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data transfer between TaskManagers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T200559Z" creationid="xccui" creationdate="20190606T200556Z">
        <seg>TaskManager之间的数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataSet programs are speci‐ fied as a series of transformations just like DataStream programs with the difference that a DataSet is a bounded data collection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T153613Z" creationid="xingcan" creationdate="20190807T153613Z">
        <seg>DataSet程序和DataStream程序一样，都是由一系列转换操作组成；但二者的不同在于DataSet是一个有界的数据集。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream but reorganize it by partitioning or grouping.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052753Z" creationid="xccui" creationdate="20190612T052753Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream&lt;Person&gt; persons = env.fromElements(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044917Z" creationid="xccui" creationdate="20190617T044917Z">
        <seg>DataStream&lt;Person&gt; persons = env.fromElements(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream&lt;Person&gt; persons = tuples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062214Z" creationid="xccui" creationdate="20190617T062214Z">
        <seg>DataStream&lt;Person&gt; persons = tuples</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; tuples = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062211Z" creationid="xccui" creationdate="20190617T062211Z">
        <seg>DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; tuples = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream&lt;Tuple3&lt;Integer, String, Long&gt;&gt; javaInput = ... javaInput.keyBy("f2") // key Java tuple by 3rd field</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T043408Z" creationid="xccui" creationdate="20190618T043408Z">
        <seg>DataStream&lt;Tuple3&lt;Integer, String, Long&gt;&gt; javaInput = ... javaInput.keyBy("f2") // Java元组以第3个字段为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Datadog</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055529Z" creationid="xccui" creationdate="20190804T055529Z">
        <seg>Datadog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow Graphs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143808Z" creationid="esouser" creationdate="20190603T143808Z">
        <seg>Dataflow图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow graphs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015000Z" creationid="xccui" creationdate="20190225T015000Z">
        <seg>Dataflow图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow graphs like the one in Figure 2-1 are called logical because they convey a high-level view of the computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044138Z" creationid="xccui" creationdate="20190605T233042Z">
        <seg>类似图2-1的Dataflow图被称作逻辑图，因为它们表达了高层视角下的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow graphs like the one of &lt;t0/&gt;Figure 2-1&lt;t1/&gt; are called logical because they convey a high-level view of the computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T002544Z" creationid="xccui" creationdate="20190401T001357Z">
        <seg>诸如图2-1之类的dataflow图被称作逻辑图，因为它们描述了高层视角下的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow programs are commonly represented as directed graphs, where nodes are called operators and represent computations and edges represent data dependen&lt;t2/&gt;‐&lt;t3/&gt; cies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190331T214808Z" creationid="xccui" creationdate="20190331T060933Z">
        <seg>dataflow程序通常会表示为有向图。其中节点称为算子（operator），表示计算；而边表示数据间的依赖关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow programs are commonly represented as directed graphs, where nodes are called operators and represent computations and edges represent data dependen‐ cies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044422Z" creationid="xccui" creationdate="20190605T224809Z">
        <seg>Dataflow程序通常会以有向图进行表示。图中顶点称为算子，表示计算；而边表示数据间的依赖关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug Flink Applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144924Z" creationid="esouser" creationdate="20190603T144924Z">
        <seg>在IDE中调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug Flink applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022345Z" creationid="xccui" creationdate="20190225T022345Z">
        <seg>在IDE中调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Keyed State at RuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="esouser" creationdate="20190603T150900Z">
        <seg>在RuntimeContext中声明键值分区状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Keyed State at the RuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024537Z" creationid="xccui" creationdate="20190225T024537Z">
        <seg>在RuntimeContext中声明Keyed State</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decreasing or increasing the parallelism of an application is not difficult.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T054946Z" creationid="xccui" creationdate="20190727T054946Z">
        <seg>减少或增加应用的并行度并不困难。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T042959Z" creationid="xccui" creationdate="20190804T042959Z">
        <seg>默认值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default value is 2, i.e., an application is restarted at most once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052653Z" creationid="xccui" creationdate="20190721T052653Z">
        <seg>默认值是2，即应用最多重启一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Keys and Referencing Fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062314Z" creationid="esouser" creationdate="20190603T145323Z">
        <seg>定义键值和引用字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Keys and Referencing Fields | 103</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045324Z" creationid="xccui" creationdate="20190619T045324Z">
        <seg>定义键值和引用字段 | 103</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Slot Sharing Groups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030021Z" creationid="xccui" creationdate="20190225T030021Z">
        <seg>定义Slot共享组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Slot-Sharing Groups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152401Z" creationid="esouser" creationdate="20190603T152401Z">
        <seg>定义处理槽共享组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023144Z" creationid="xccui" creationdate="20190225T023144Z">
        <seg>定义窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a Cassandra example table</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210036Z" creationid="xccui" creationdate="20190711T210036Z">
        <seg>定义Cassandra示例表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a window operator with a side output for late events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154911Z" creationid="xingcan" creationdate="20190628T154911Z">
        <seg>在窗口算子中为迟到事件定义副输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a window operator with an allowed lateness of 5 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165202Z" creationid="xingcan" creationdate="20190628T165202Z">
        <seg>定义延迟容忍度为5秒的窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining keys and referencing fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022905Z" creationid="xccui" creationdate="20190225T022905Z">
        <seg>定义key和引用字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining the Maximum Parallelism of Keyed State Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190225T024714Z">
        <seg>为使用键值分区状态的算子定义最大并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining the user scope “MyMetrics”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T050204Z" creationid="xccui" creationdate="20190804T050204Z">
        <seg>定义用户域"MyMetrics"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deletes the JAR file referenced by the provided ID</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T050025Z" creationid="xccui" creationdate="20190729T050025Z">
        <seg>删除给定ID对应的JAR文件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting a Savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035217Z" creationid="xccui" creationdate="20190726T035217Z">
        <seg>删除保存点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depend&lt;t0/&gt;‐&lt;t1/&gt; ing on the application, you might care about &lt;t2/&gt;average&lt;t3/&gt; latency, &lt;t4/&gt;maximum&lt;t5/&gt; latency, or &lt;t6/&gt;percentile &lt;t7/&gt;latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T154750Z" creationid="xccui" creationdate="20190401T154546Z">
        <seg>根据应用的不同，你可能会关注平均延迟，最大延迟或延迟的百分位数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dependencies included in the classpath of Flink processes by default are automatically excluded from the JAR file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T010114Z" creationid="xccui" creationdate="20190619T043140Z">
        <seg>默认情况下，JAR包中会自动排除那些Flink进程的Classpath中所包含的依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on    the environment (YARN, Mesos, Kubernetes, standalone cluster), some steps can be omitted or components might run in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T062647Z" creationid="xccui" creationdate="20190606T143213Z">
        <seg>根据环境的不同（YARN、Mesos、Kubernetes或独立集群），图中某些步骤其实可以省略，同时也可会有多个组件运行在同一JVM进程中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on how an application is submitted for execution (discussed in the next section), a dispatcher might not be required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024404Z" creationid="xccui" creationdate="20190423T024404Z">
        <seg>根据应用提交执行的方式（会在下节讨论），dispatcher可能并非必需。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on how an application is submitted for execution (dis‐ cussed in “Application Deployment”), a dispatcher might not be required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061935Z" creationid="xccui" creationdate="20190606T142947Z">
        <seg>某些应用提交执行的方式（我们会在"应用部署"一节讨论）可能用不到Dispatcher。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on how an operator is connected with its predecessor or successor operators, its tasks can receive records and water‐ marks from one or more input partitions and emit records and watermarks to one or more output partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T053644Z" creationid="xccui" creationdate="20190607T015151Z">
        <seg>根据算子的上下游连接情况，其任务可能需要同时接收来自多个输入分区的记录和水位线，也可能需要将它们发送到多个输出分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the application requirements, you might want to ignore such events, log them, or use them to correct previous results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T040224Z" creationid="xccui" creationdate="20190414T032650Z">
        <seg>根据应用需求的不同，你可能想直接忽略那些事件，将它们写入日志或利用它们去修正之前的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the business logic, an event-driven application can trigger actions such as sending an alert or an email or write events to an outgoing event stream that is possibly consumed by another event-driven application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T024745Z" creationid="xccui" creationdate="20190307T024745Z">
        <seg>根据业务逻辑的不同，此类应用可能触发告警或发送电子邮件之类的操作，也支持将事件写入输出流以供其他同类应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the business logic, an event-driven application can trigger actions such as sending an alert or an email or write events to an outgoing event stream to be consumed by another event-driven application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T033752Z" creationid="esouser" creationdate="20190603T213520Z">
        <seg>根据业务逻辑的不同，此类应用可支持触发警报或发送电子邮件之类的操作，也可支持将事件写入输出流以供其他同类应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the business requirements, late data can later be integrated into the results of the streaming application with a periodic backfill process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154732Z" creationid="xingcan" creationdate="20190628T154732Z">
        <seg>根据业务需求，迟到数据可通过定期回填过程（backfill process）集成到流式应用的结果中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the characteristics of an application, the size of its state, and the state backend and its configuration, a checkpoint can take up to a few minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T031453Z" creationid="xccui" creationdate="20190731T031134Z">
        <seg>取决于应用自身特征、状态大小、状态后端及其配置，生成一次检查点可能需要几分钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the concrete implementation of the sink opera‐ tor, the records can be written to any kind of storage or message system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T051310Z" creationid="xccui" creationdate="20190715T051234Z">
        <seg>根据数据汇算子的具体实现，这些记录可以被写入任意一个存储或消息系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the encoding of a file, it can be necessary to only generate a single split</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T192029Z" creationid="xccui" creationdate="20190710T192029Z">
        <seg>根据文件的编码方式，有时候只能生成一个划分，将文件作为一个整体读入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the failure that caused an application to crash, the application could be killed by the same failure again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T152035Z" creationid="xingcan" creationdate="20190801T152035Z">
        <seg>根据导致应用崩溃的故障不同，应用有可能被相同的故障再次"杀死"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the scheduling intervals it may take hours or days until a data point is included in a report.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T031535Z" creationid="xccui" creationdate="20190317T031535Z">
        <seg>根据调度周期的不同，数据可能会在数小时或数天后才出现在报告中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the sink operators of an application, some result records might be emitted multiple times to downstream sys‐ tems, such as an event log, a filesystem, or a database, during the recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054005Z" creationid="xccui" creationdate="20190609T053722Z">
        <seg>根据应用所采用的数据汇算子，在恢复期间，某些结果记录可能会向下游系统（如事件日志系统、文件系统或数据库）发送多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the system from which the data is received, the data might be pushed or pulled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T151202Z" creationid="xccui" creationdate="20190712T151202Z">
        <seg>根据上游数据源系统的不同，数据可能以推送或拉取的形式获得。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the the environment (YARN, Mesos, Kubernetes, stand-alone cluster), some steps can be omitted or components might run in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024812Z" creationid="xccui" creationdate="20190423T024729Z">
        <seg>根据环境的不同（YARN、Mesos、Kubernetes、独立集群），有些步骤其实可以省略，同时可能会有多个组件运行在同一个JVM进程中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the type of execution environment, a JobManager is started as a local thread (local execution environment) or the JobGraph is sent to a remote JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T052337Z" creationid="xccui" creationdate="20190613T012430Z">
        <seg>根据执行环境类型的不同，系统可能会将JobManager作为本地线程启动（本地执行环境），也可能会将JobGraph发送到远程JobManager上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the use case and data store, the updates need to be processed before they can be incorporated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062601Z" creationid="xccui" creationdate="20190314T073211Z">
        <seg>根据用例和数据存储系统的不同，需要在更新的数据整合前对它们进行一些处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the use case, it is possible to apply an initial filtering or transformation on the input stream before</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T054947Z" creationid="xccui" creationdate="20190620T031942Z">
        <seg>根据用例的不同，如果某些初始化的过滤或其他转换操作不会引起元素的重新分发，那么可以考虑在分配时间戳之前使用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the use case, the transferred data may need to be normalized, enriched with external data, or aggregated before it is ingested by the target data store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154401Z" creationid="xccui" creationdate="20190605T041712Z">
        <seg>根据用例的不同，转存的数据可能需要归一化，利用外部输入丰富数据或在写入目标存储之前进行数据聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on whether the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T052005Z" creationid="xccui" creationdate="20190705T052005Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on whether the other stream is keyed or not, a KeyedBroadcastProcessFunction or BroadcastPro cessFunction can be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041206Z" creationid="xccui" creationdate="20190702T041041Z">
        <seg>根据另一条流是否已经按键值分区，该函数可能是KeyedBroadcastProcessFunction或BroadcastProcessFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depend‐ ing on the application, you might care about average latency, maximum latency, or percentile latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234017Z" creationid="xccui" creationdate="20190605T234017Z">
        <seg>根据应用的不同，你可能会关注平均延迟，最大延迟或延迟的百分位数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deploying data processing frameworks and applications on Kubernetes has become very popular.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T022645Z" creationid="xccui" creationdate="20190719T022645Z">
        <seg>基于Kubernetes部署数据处理框架及应用已经变得非常流行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deployment Modes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025408Z" creationid="xccui" creationdate="20190225T025402Z">
        <seg>部署模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deployment Modes | 223</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042717Z" creationid="xccui" creationdate="20190725T042717Z">
        <seg>部署模式 | 223</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deployment Modes | 231</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042737Z" creationid="xccui" creationdate="20190725T042737Z">
        <seg>部署模式 | 231</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deployments can be scaled up or down.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T023506Z" creationid="xccui" creationdate="20190719T023506Z">
        <seg>Deployment可以自由伸缩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DeserializationSchema and KeyedDeserializationSchema are public interfaces so you can always implement custom deserialization logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T213727Z" creationid="xccui" creationdate="20190708T213727Z">
        <seg>DeserializationSchema和KeyedDeserializationSchema都是公开接口，因此你可以随意实现自定义的反序列化逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designed for the special case where the state of each task of an operator is identi‐ cal.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060726Z" creationid="xccui" creationdate="20190607T184956Z">
        <seg>专门为那些需要保证算子的每个任务状态都相同的场景而设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Despite all these efforts, we recommend always dou‐ ble checking if an application can be evolved as planned before putting it into pro‐ duction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T035537Z" creationid="xccui" creationdate="20190705T054216Z">
        <seg>尽管如此，我们还是建议你在把应用投入到生产环境之前，仔细确认应用是否可以按计划更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Detailed and customizable collection of system and application metrics help to identify and react to problems ahead of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052524Z" creationid="xccui" creationdate="20190328T052451Z">
        <seg>详细、可自由定制的系统及应用指标集合有助于提前定位和响应问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Detailed and customizable collection of system and application metrics to iden‐ tify and react to problems ahead of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195844Z" creationid="xccui" creationdate="20190605T121631Z">
        <seg>提供了详细、可自由定制的系统及应用指标（metrics）集合，用于提前定位和响应问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deterministic keys are important to ensure all writes are correctly overwritten in case of a recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T043451Z" creationid="xccui" creationdate="20190714T043451Z">
        <seg>确定性的键值对于恢复期间覆盖写入的正确性非常重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disable task chaining for an operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203552Z" creationid="xccui" creationdate="20190730T203552Z">
        <seg>禁用算子的任务链接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disk Storage</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025610Z" creationid="xccui" creationdate="20190225T025610Z">
        <seg>磁盘存储</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disposes of a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200737Z" creationid="xccui" creationdate="20190729T200737Z">
        <seg>删除保存点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disposing savepoint 'hdfs:///xxx:50070/savepoints/savepoint-bc0b2a-63cf5d5ccef8'.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035208Z" creationid="xccui" creationdate="20190726T035208Z">
        <seg>Disposing savepoint 'hdfs:///xxx:50070/savepoints/savepoint-bc0b2a-63cf5d5ccef8'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distributed data processing frameworks like Apache Flink need to be set up to interact with several components such as resource managers, filesystems, and services for distributed coordination.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T135249Z" creationid="xccui" creationdate="20190717T031552Z">
        <seg>像Apache Flink这样的分布式数据处理框架需要通过设置与资源管理器、文件系统和分布式协调服务等多个组件进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution  Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064528Z" creationid="xccui" creationdate="20190615T064528Z">
        <seg>分发转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022750Z" creationid="xccui" creationdate="20190225T022750Z">
        <seg>分发转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution transformations reorganize stream events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T054724Z" creationid="xccui" creationdate="20190613T024707Z">
        <seg>对流中的事件进行重新组织的分发转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do Not Use start-zookeeper-quorum.sh for Production Setups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T203047Z" creationid="xccui" creationdate="20190720T203047Z">
        <seg>不要将start-zookeeper-quorum.sh用于生产环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not evaluate per element</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200646Z" creationid="xccui" creationdate="20190626T200646Z">
        <seg>不会针对每个元素都计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Docker</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040308Z" creationid="xccui" creationdate="20190418T040308Z">
        <seg>Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Docker containers are run by the operating system kernel of the host system and are therefore more lightweight than virtual machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T214433Z" creationid="xccui" creationdate="20190717T214433Z">
        <seg>Docker容器由宿主机的操作系统内核负责运行，因此它比虚拟机更为轻量级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Docker is a popular platform used to package and run applications in containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T214305Z" creationid="xccui" creationdate="20190717T214305Z">
        <seg>Docker是一个将应用打包并在容器中运行的流行平台。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Docker will download the requested image and its dependencies from Docker Hub and start the containers running Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190718T033842Z">
        <seg>利用上述命令，Docker将自动从Docker Hub下载所需的镜像及其依赖，并启动容器来运行Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does it include the time Alice was offline or not?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152409Z" creationid="xccui" creationdate="20190411T152118Z">
        <seg>需要把爱丽丝离线的时间考虑在内吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Download the JAR file that includes all example programs of this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035848Z" creationid="xccui" creationdate="20190329T035651Z">
        <seg>下载涵盖本书所有示例程序的JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Download the JAR file that includes examples in this book:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123515Z" creationid="xccui" creationdate="20190605T123435Z">
        <seg>下载涵盖本书所有示例的JAR文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dropping Late Events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150747Z" creationid="xccui" creationdate="20190225T023339Z">
        <seg>丢弃迟到事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dropping late events is the default behavior for event-time window operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T153632Z" creationid="xingcan" creationdate="20190628T153548Z">
        <seg>这也是事件时间窗口的默认行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DropwizardHistogramWrapper class as shown in Example 10-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033600Z" creationid="xccui" creationdate="20190803T033600Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to extensive support for user-defined functions, a wide variety of use cases can be covered by SQL.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T161258Z" creationid="xingcan" creationdate="20190807T161258Z">
        <seg>由于支持广泛的用户自定义函数，很多用例都可以直接用SQL来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to its checkpointing mechanism, Flink can achieve very good performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163923Z" creationid="xccui" creationdate="20190702T163923Z">
        <seg>得益于该检查点机制，Flink的性能会非常高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to its origin in the Hadoop ecosystem, YARN is typically used by data processing frameworks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T141058Z" creationid="xccui" creationdate="20190718T211145Z">
        <seg>由于源自Hadoop生态系统，YARN通常会用于数据处理框架中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the append-only characteristic of a socket, it is not possi‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T042636Z" creationid="xccui" creationdate="20190714T042448Z">
        <seg>由于套接字仅支持追加数据，所以无法实现幂等性写；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the append-only property of the log, events are always published to all consumers in exactly the same order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T060020Z" creationid="xccui" creationdate="20190305T054916Z">
        <seg>得益于日志的追加特性，无论向消费者发布几次，事件的顺序都能保持一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the single JVM execution mode, it is also possible to debug Flink applications in an IDE almost like any other program in your IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T092810Z" creationid="xccui" creationdate="20190611T052843Z">
        <seg>由于单JVM执行模式的存在，你可以像调试其他程序那样在IDE中调试Flink应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to these limitations, MemoryStateBackend is only rec‐ ommended for development and debugging purposes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T021722Z" creationid="xccui" creationdate="20190704T020912Z">
        <seg>由于存在这些限制，我们建议仅将MemoryStateBackend用于开发和调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to this feature, Flink’s Kafka sink is also able to provide exactly-once output guarantees given that the sink and Kafka are properly configured.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T161955Z" creationid="xingcan" creationdate="20190709T161955Z">
        <seg>由于有了该功能，Flink的kafka数据汇同样可以在自身和kafka都正确配置的前提下提供精确一次的输出保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to this replication of data, the data stores must be kept in sync.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T070309Z" creationid="xccui" creationdate="20190314T070309Z">
        <seg>由于数据存在多个副本，这些数据存储系统之间需要保持同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Duplicate processing might be acceptable if application correctness only depends on the completeness of information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T042104Z" creationid="xccui" creationdate="20190416T042059Z">
        <seg>如果正确性仅依赖信息的完整度，那重复处理或许可以接受。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dupli‐ cate processing might be acceptable if application correctness only depends on the completeness of information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034633Z" creationid="xccui" creationdate="20190606T034633Z">
        <seg>如果正确性仅依赖信息的完整度，那重复处理或许可以接受。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During exe&lt;t6/&gt;‐&lt;t7/&gt; cution, the JobManager is responsible for all actions that require a central coordi&lt;t8/&gt;‐&lt;t9/&gt; nation such as the coordination of checkpoints (see later section).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T050152Z" creationid="xccui" creationdate="20190418T035245Z">
        <seg>在执行过程中，JobManager负责所有需要集中协调的行为，例如：checkpoint协调（下节会提到）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, a TaskManager exchanges</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142706Z" creationid="xccui" creationdate="20190606T142706Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, a TaskManager exchanges data with other TaskManagers that run tasks of the same application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T052434Z" creationid="xccui" creationdate="20190418T052055Z">
        <seg>执行期间，运行同一应用不同任务的TaskManager之间会产生数据交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, the JobManager is responsible for all actions that require a central coordination such as the coordination of check‐ points (see “Checkpoints, Savepoints, and State Recovery”).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060319Z" creationid="xccui" creationdate="20190606T141827Z">
        <seg>在执行过程中，JobManager还要负责所有需要集中协调的操作，例如，创建检查点（见"检查点、保存点及状态恢复"）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, the sink registers the query as a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212556Z" creationid="xccui" creationdate="20190711T212251Z">
        <seg>执行过程中，数据汇会将该查询注册为一个预编译语句（prepared statement），并将元组、样例类或Row类型的字段转化为该语句相应的参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During recovery, all records of not- yet-committed checkpoints will be written again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065652Z" creationid="xccui" creationdate="20190715T065652Z">
        <seg>这样，在故障恢复期间，未提交的检查点所对应的全部记录都会被重写一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the execution of a streaming application, Flink periodically takes consistent checkpoints of the application’s state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T033400Z" creationid="xccui" creationdate="20190609T031849Z">
        <seg>在流式应用执行过程中，Flink会周期性地为应用状态生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the execution of an application, the JobManager receives the state handles (storage locations) of the individual task checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073145Z" creationid="xccui" creationdate="20190502T045939Z">
        <seg>在应用执行过程中，JobManager会接收每个任务检查点的状态句柄（存储位置）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL jobs periodically import data into a data store and the data is pro&lt;t0/&gt;‐&lt;t1/&gt; cessed by ad-hoc or scheduled queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T025952Z" creationid="xccui" creationdate="20190317T025429Z">
        <seg>ELT作业周期性地把数据导入数据存储系统，并通过即席或计划查询处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL jobs periodically import data into a datastore and the data is processed by ad-hoc or scheduled queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154640Z" creationid="xccui" creationdate="20190605T042806Z">
        <seg>ELT作业会周期性地把数据导入数据存储系统，并通过即席或计划查询处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL processes can be quite complex and often require technically sophisticated solutions to meet performance requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T064825Z" creationid="xccui" creationdate="20190228T191045Z">
        <seg>该流程可能会非常麻烦，通常需要复杂的技术方案来满足性能要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL processes need to run periodically to keep the data in the data warehouse synchronized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T024853Z" creationid="esouser" creationdate="20190603T202915Z">
        <seg>为了保持数据仓库中的数据同步，ETL过程需要周期性地执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TaskManager has a pool of network buffers (by default 32 KB in size) to send and receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T191455Z" creationid="xccui" creationdate="20190606T195742Z">
        <seg>每个TaskManager都有一个用于收发数据的网络缓冲池（默认32KB大小）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TaskManager has a pool of network buffers (by default 32KB in size) which are used to send and receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042430Z" creationid="xccui" creationdate="20190504T042430Z">
        <seg>每个TaskManager有一个用于收发数据的网络缓冲区池（默认32KB大小）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TaskManager provides a certain number of slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061037Z" creationid="xccui" creationdate="20190418T051523Z">
        <seg>每个TaskManager提供一定数量的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TaskMan‐ ager runs a state server that fetches the state of a queried key from the local state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T024045Z" creationid="xccui" creationdate="20190706T024036Z">
        <seg>状态服务器同样需要运行在每个TaskManager上面。它会根据查询的键值从本地状态后端取得状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each Task‐ Manager runs a client proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T022909Z" creationid="xccui" creationdate="20190706T022108Z">
        <seg>该客户端代理需要在每个TaskManager上面都运行一个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each application can be stateful and can locally manage its own state without accessing external datastores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214101Z" creationid="esouser" creationdate="20190603T214101Z">
        <seg>每个应用都可以是状态化的，只需要管理自身状态而无须访问外部数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each application can be stateful, i.e., locally manage its own state without accessing external data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T073303Z" creationid="xccui" creationdate="20190308T073224Z">
        <seg>每个应用都可以是状态化的，只需要管理自身状态而无须访问外部数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each bucket directory contains multiple part files that are concurrently written by multiple  parallel  instances  of  the  StreamingFileSink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T021258Z" creationid="xccui" creationdate="20190710T213614Z">
        <seg>每个桶对应的目录下都会包含很多分块文件（part file），由StreamingFileSink的多个并行实例对它们进行并发写入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each class of systems has been designed for specific access patterns and excels at serving a certain purpose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T053856Z" creationid="xccui" creationdate="20190707T053856Z">
        <seg>每一类系统都是针对某个特定的访问模式而设计的，它们在服务方面各有所长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each component has the follow‐ ing responsibilities:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141429Z" creationid="xccui" creationdate="20190606T141429Z">
        <seg>它们各自的职责如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each component provides its own guarantees and the end-to-end guarantee of the complete pipeline would be the weakest of each of its components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194657Z" creationid="xccui" creationdate="20190416T045936Z">
        <seg>在每个组件都提供自身的保障情况下，整个处理管道上端到端的保障会受制于保障最弱的那个组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each descriptor defines a separate broadcast state of the function that is later applied on the BroadcastStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040738Z" creationid="xccui" creationdate="20190702T040738Z">
        <seg>每个描述符都会为将来用于BroadcastStream的函数定义一个单独的广播状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each event carries a timestamp and the logical time of the system is defined by watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070339Z" creationid="xccui" creationdate="20190619T070339Z">
        <seg>每个事件时间都带有一个时间戳，而系统的逻辑时间是由水位线来定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each event must be associated with a timestamp that typically indicates when the event actually happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T050841Z" creationid="xccui" creationdate="20190620T015417Z">
        <seg>每个事件都需要关联一个时间戳，该时间戳通常用来表示事件的实际发生时间；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each incoming event can be routed to zero, one, or more output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053929Z" creationid="xccui" creationdate="20190615T053929Z">
        <seg>每一个到来的事件都可以被发往零个、一个或多个输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator can define one or more keyed and operator states.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T071020Z" creationid="xccui" creationdate="20190609T214500Z">
        <seg>而每个算子又可以定义一个或多个的键值或算子状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator is a member of a slot-sharing group.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T011540Z" creationid="xccui" creationdate="20190731T011438Z">
        <seg>具体而言，每个算子都会属于一个处理槽共享组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator is parallelized into one or multiple tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051232Z" creationid="xccui" creationdate="20190616T051232Z">
        <seg>每个算子都会产生一个或多个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each parallel source task can read from one or more partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T204708Z" creationid="xccui" creationdate="20190708T204708Z">
        <seg>每个并行数据源任务都可以从一个或多个分区读取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each partition is a stream of timestamped records and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T014920Z" creationid="xccui" creationdate="20190607T014705Z">
        <seg>每个分区作为一个数据流，都会包含带有时间戳的记录以及水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each partition is processed by a task that computes the sum  of all received numbers and forwards the updated sum to a sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062301Z" creationid="xccui" creationdate="20190609T062128Z">
        <seg>每一部分都会有一个任务负责对收到的全部数字求和，并将结果值更新至下游数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each reading will be added to four win‐ dows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055727Z" creationid="xccui" creationdate="20190623T055727Z">
        <seg>每个读数将被放入四个窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each row can be uniquely identified by its primary key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T193425Z" creationid="xccui" creationdate="20190711T193425Z">
        <seg>每一行都以其主键作为唯一标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each sender task needs at least four network buffers to send data to each receiver task and each receiver task requires at least four buffers to receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044254Z" creationid="xccui" creationdate="20190504T044254Z">
        <seg>每个发送端任务至少需要4个网络缓冲区来向任一接收端任务发送数据；同理每个接收端任务也需要至少4个缓冲区来接收数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each slot can process one slice of an application, one parallel task of every operator of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T061717Z" creationid="xccui" creationdate="20190723T061717Z">
        <seg>每个处理槽可以处理应用的一个"切片"，即应用程序每个算子的一个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each state backend provides imple‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221558Z" creationid="xccui" creationdate="20190703T221558Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each state is registered with a name that must be unique for the function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T155835Z" creationid="xccui" creationdate="20190702T065034Z">
        <seg>每个状态在注册时都要提供一个函数范围内唯一的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each task will process a subset of the operator’s input stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051313Z" creationid="xccui" creationdate="20190616T051313Z">
        <seg>每个任务负责处理算子输入流的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each win‐ dow object has an end timestamp that defines the point in time after which the window and its state can be deleted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T034136Z" creationid="xccui" creationdate="20190626T034136Z">
        <seg>每个窗口对象都有一个结束时间戳，它定义了可以安全删除窗口及其状态的时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eager watermarks ensure low latency but provide lower confidence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025637Z" creationid="xccui" creationdate="20190606T025637Z">
        <seg>激进的水位线策略保证了低延迟，但随之而来的是低可信度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Earlier in this chapter we explained that Flink can only provide satisfying consistency guarantees for applications that use source connectors that can replay their output data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152935Z" creationid="xccui" creationdate="20190712T152744Z">
        <seg>我们在本章的前面部分介绍过，Flink只有在数据源连接器可以重放输出数据的前提下才能为应用提供令人满意的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements are removed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203429Z" creationid="xccui" creationdate="20190627T203429Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements of both input streams are assigned to common windows and joined (or cogrouped) when a window is complete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T034504Z" creationid="xccui" creationdate="20190628T034504Z">
        <seg>其原理是将两条输入流中的元素分配到公共窗口中并在窗口完成时进行Join（或Cogroup）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements that are assigned to a window will be immediately aggregated</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T045728Z" creationid="xccui" creationdate="20190625T035728Z">
        <seg>你可以对分配给窗口的元素立即执行聚合，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emitting to Side Outputs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023126Z" creationid="xccui" creationdate="20190225T023126Z">
        <seg>向副输出发送数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enabling Failure Recovery for Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T055441Z" creationid="xccui" creationdate="20190225T024644Z">
        <seg>为状态化应用开启故障恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enabling checkpoint compression</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T204509Z" creationid="xccui" creationdate="20190731T204509Z">
        <seg>启用检查点压缩</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enabling checkpointing for an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204806Z" creationid="xccui" creationdate="20190702T204806Z">
        <seg>为应用开启检查点功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encoder is a simple interface with a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T024431Z" creationid="xccui" creationdate="20190711T024431Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption and authentication for communication to queryable state is not sup‐ ported yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T035813Z" creationid="xccui" creationdate="20190725T035813Z">
        <seg>Flini暂不支持对于可查询式状态通信进行加密和身份验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End- to-end guarantees refer to result correctness across the whole data processing pipe‐ line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035307Z" creationid="xccui" creationdate="20190606T035307Z">
        <seg>端到端的保障指的是在整个数据处理管道上结果都是正确的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end Exactly-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045106Z" creationid="xccui" creationdate="20190416T045106Z">
        <seg>端到端的精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end consistency guarantees for different combinations of sources and sinks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170015Z" creationid="xccui" creationdate="20190708T170015Z">
        <seg>不同数据源和数据汇组合所能实现的端到端的一致性保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end exactly-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035007Z" creationid="xccui" creationdate="20190606T035007Z">
        <seg>端到端的精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end guarantees refer to result cor&lt;t0/&gt;‐&lt;t1/&gt; rectness across the data processing pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045541Z" creationid="xccui" creationdate="20190416T045541Z">
        <seg>端到端的保障指的是在整个数据处理管道上结果都是正确的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensure Temporary Directories Are Not Automatically Cleaned</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043056Z" creationid="xccui" creationdate="20190724T043056Z">
        <seg>请确保临时目录不会被自动清除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring low latency is critical for many streaming applications, such as fraud detec&lt;t0/&gt;‐&lt;t1/&gt; tion, raising alarms, network monitoring, and offering services with strict service level agreements (SLAs).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T191615Z" creationid="xccui" creationdate="20190401T191318Z">
        <seg>保证低延迟对很多流式应用而言至关重要，例如：诈骗识别、警报触发、网络监测以及遵循服务级别协议（SLA）的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring low latency is critical for many streaming applications, such as fraud detec‐ tion, system alarms, network monitoring, and offering services with strict service- level agreements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234228Z" creationid="xccui" creationdate="20190605T234208Z">
        <seg>保证低延迟对很多流式应用而言至关重要，例如：诈骗识别、系统告警、网络监测以及遵循服务级别协议（SLA）的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring the Maintainability of Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024655Z" creationid="xccui" creationdate="20190225T024655Z">
        <seg>确保状态化应用的可维护性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring the Maintainability of Stateful Applications | 167</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052531Z" creationid="xccui" creationdate="20190707T052531Z">
        <seg>确保状态化应用的可维护性 | 167</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enter the base folder of Flink’s source code and run one of the commands in the following:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025150Z" creationid="xccui" creationdate="20190722T025136Z">
        <seg>准备好后就可以进入Flink源码根目录，运行下列命令之一：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Especially when a streaming job is part of a larger data processing pipeline or event-driven service in a user-facing application, you probably want to monitor its performance as precisely as possible and make sure it meets certain tar‐ gets for latency, throughput, resource utilization, etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T030312Z" creationid="xccui" creationdate="20190802T030312Z">
        <seg>尤其是当流式作业是作为一个更大的数据处理管道或面向用户的事件驱动服务的一部分时，你可能需要尽可能准确地监控其性能，并确保它可以满足延迟、吞吐和资源利用等目标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Essentially, it is the time interval between receiving an event and seeing the effect of processing this event in the output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050738Z" creationid="xccui" creationdate="20190401T151641Z">
        <seg>本质上，它是从接收事件到在输出中观察到事件处理效果的时间间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Essentially, this is a sim‐ plified version of the BucketingFileSink discussed earlier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T040953Z" creationid="xccui" creationdate="20190716T040953Z">
        <seg>本质上，它是我们之前讨论过的BucketingFileSink的一个简化版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Estimates mean there is room for errors, in which case you might gen‐ erate watermarks that are inaccurate, resulting in late data or an unnecessary increase in the application’s latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T060756Z" creationid="xccui" creationdate="20190621T033508Z">
        <seg>既然是估计，就会有误差，这意味着你可能会生成不准确的水位线，导致出现迟到数据或无谓增加应用处理延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluation functions can be aggregations like sum or minimum or custom operations applied on the buck&lt;t14/&gt;‐&lt;t15/&gt; et’s collected elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T050152Z" creationid="xccui" creationdate="20190406T045737Z">
        <seg>这些计算函数可以是某些聚合，例如：求和、求最小值或一些直接作用于桶内收集好元素的自定义聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluation functions can be aggregations like sum or minimum or custom operations applied on the bucket’s col‐ lected elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063031Z" creationid="xccui" creationdate="20190606T012907Z">
        <seg>这些计算函数可以是某些聚合，例如：求和、求最小值，也可以是一些直接作用于桶内收集元素的自定义操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though Flink is a distributed data processing system, you will typically develop and run initial tests on your local machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T072719Z" creationid="xccui" creationdate="20190611T031040Z">
        <seg>尽管Flink是一个分布式的数据处理系统，但你通常可以在本地机器上进行开发并运行一些初始测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though low latency is an attractive feature of stream processing, its true value is way beyond just fast analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014221Z" creationid="xccui" creationdate="20190606T014221Z">
        <seg>尽管低延迟是流处理中一个很吸引人的特性，但流处理的真正价值远不止提供快速分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though low latency is an attractive feature of stream processing, its true value is way beyond just offering fast analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T201052Z" creationid="xccui" creationdate="20190409T200416Z">
        <seg>尽管低延迟是流处理中一个很吸引人的特性，但流处理的真正价值远不止提供快速分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the underlying DataStream and DataSet APIs are separate, you can implement unified stream and batch analytics in Flink using its higher-level relational APIs: Table API and SQL.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T160611Z" creationid="xingcan" creationdate="20190807T160611Z">
        <seg>虽然Flink底层DataStream和DataSet的API是分开的，但你可以使用高层次的关系型API——Table API和SQL，实现流批一体的分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though time information and watermarks are crucial to many streaming appli‐ cations, you might have noticed that we cannot access them through the basic Data‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T061522Z" creationid="xccui" creationdate="20190621T043212Z">
        <seg>虽然时间信息和水位线对于很多流式应用都至关重要，但你可能已经注意到，我们无法通过前面介绍的DataStream API转换来访问它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though when writing the book we intended for it to be read in chapter order, readers familiar with a chapter’s content might want to skip it and readers excited about writing Flink code right away might want to read the practical chapters first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191312Z" creationid="xccui" creationdate="20190225T162157Z">
        <seg>尽管我们在写书的时候是按照预期的阅读顺序进行章节编排，但如果你已经对某些章节的内容很熟悉，仍然可以选择跳过；或者如果你迫不及待想接触Flink代码也可以选择先阅读实践章节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144203Z" creationid="esouser" creationdate="20190603T144203Z">
        <seg>事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event Time Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021843Z" creationid="xccui" creationdate="20190225T021843Z">
        <seg>事件时间处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020346Z" creationid="xccui" creationdate="20190225T020346Z">
        <seg>事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time completely decouples the processing speed from the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024245Z" creationid="xccui" creationdate="20190606T024245Z">
        <seg>事件时间将处理速度和结果内容彻底解耦。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time correctly places events in a window, reflecting the reality of how things happened</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024225Z" creationid="xccui" creationdate="20190606T024225Z">
        <seg>事件时间准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time is based on a &lt;t0/&gt;timestamp&lt;t1/&gt; that is attached on the events of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150123Z" creationid="xccui" creationdate="20190412T145549Z">
        <seg>它源自附加在流中事件的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time is based on a timestamp that is attached to the events of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155814Z" creationid="xccui" creationdate="20190606T023937Z">
        <seg>它以附加在数据流中事件的时间戳为依据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time is the time when an event in the stream actually happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023932Z" creationid="xccui" creationdate="20190606T023925Z">
        <seg>事件时间是数据流中事件实际发生的时间，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-Driven Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142916Z" creationid="esouser" creationdate="20190603T142916Z">
        <seg>事件驱动型应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-Time Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144458Z" creationid="esouser" creationdate="20190603T144458Z">
        <seg>事件时间处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-Time Processing | 47</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032621Z" creationid="xccui" creationdate="20190610T032621Z">
        <seg>事件时间处理 | 47</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014553Z" creationid="xccui" creationdate="20190225T014553Z">
        <seg>事件驱动型应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are an evolution of microservices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213735Z" creationid="esouser" creationdate="20190603T213735Z">
        <seg>事件驱动型应用本质上是之前讨论的微服务的演变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are an evolution of the previously discussed microservices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T151857Z" creationid="xccui" creationdate="20190307T151857Z">
        <seg>事件驱动型应用本质上是之前讨论的微服务的演变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are an interesting design pattern because they offer several benefits compared to the traditional architecture of separate storage and compute tiers or the popular microservice architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190312T212111Z" creationid="xccui" creationdate="20190308T073918Z">
        <seg>事件驱动型应用的设计模式之所以引起大家关注，主要是因为它和计算存储相互独立的传统架构以及流行的微服务架构相比，有很多优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are stateful streaming applications that ingest event streams and apply business logic on the received events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T015819Z" creationid="xccui" creationdate="20190307T015819Z">
        <seg>事件驱动型应用是一类通过接收事件流触发业务逻辑的状态化流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are stateful streaming applications that ingest event streams and process the events with application-specific business logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213515Z" creationid="esouser" creationdate="20190603T213335Z">
        <seg>事件驱动型应用是一类通过接收事件流触发特定应用业务逻辑的状态化流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications have quite high requirements on the stream processor that runs them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014619Z" creationid="xccui" creationdate="20190313T010614Z">
        <seg>事件驱动型应用对作为载体的底层流处理引擎具有极高的要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications offer several benefits compared to transactional applica‐ tions or microservices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T034025Z" creationid="esouser" creationdate="20190603T214152Z">
        <seg>与事务型应用和微服务架构相比，事件驱动型应用有很多优势：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time and processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054041Z" creationid="xccui" creationdate="20190605T054041Z">
        <seg>同时支持事件时间和处理时间语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time completely decouples the processing speed from the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150740Z" creationid="xccui" creationdate="20190412T150740Z">
        <seg>事件时间将处理速度和结果内容彻底解耦。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time correctly places events in a window, reflecting the reality of how things happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150649Z" creationid="xccui" creationdate="20190412T150619Z">
        <seg>事件时间准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time is the time when an event in the stream actually happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145554Z" creationid="xccui" creationdate="20190412T145346Z">
        <seg>事件时间是数据流中事件实际发生的时间，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time provides consistent and accurate results despite out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042352Z" creationid="xccui" creationdate="20190328T042125Z">
        <seg>事件时间能够针对无序事件提供一致、精确的结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time semantics provide consis‐ tent and accurate results despite out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054107Z" creationid="xccui" creationdate="20190605T054107Z">
        <seg>事件时间语义能够针对无序事件提供一致、精确的结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time streams also need to carry watermarks from which operators infer the current event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T015531Z" creationid="xccui" creationdate="20190620T015531Z">
        <seg>此外事件时间数据流还需要携带水位线，以供算子推断当前事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time timers fire when the next watermark is processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063339Z" creationid="xccui" creationdate="20190621T070525Z">
        <seg>事件时间计时器会在处理下一条水位线时触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time windows compute deterministic results even when events arrive out of order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071120Z" creationid="xccui" creationdate="20190619T071120Z">
        <seg>即便事件乱序到达，事件时间窗口也会计算出确定的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EventTime</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070157Z" creationid="xccui" creationdate="20190619T070157Z">
        <seg>EventTime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EventTimeTrigger.create()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044159Z" creationid="xccui" creationdate="20190626T044159Z">
        <seg>EventTimeTrigger.create()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are buffered in the player’s phone and delivered to the application when the network connection is restored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T153031Z" creationid="xccui" creationdate="20190411T153031Z">
        <seg>事件会缓存在玩家的手机里，网络恢复后才会发给应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are usually assigned to buckets based on data properties or based on time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T044950Z" creationid="xccui" creationdate="20190406T044901Z">
        <seg>事件通常会根据其时间或其他数据属性分配到不同桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are written to a durable, append-only log which means that the order of written events cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T054925Z" creationid="xccui" creationdate="20190305T054304Z">
        <seg>由于事件只能以追加的形式写入持久化日志中，因此其顺序无法在后期改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are written to a durable, append-only log, which means that the order of written events cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210612Z" creationid="esouser" creationdate="20190603T210612Z">
        <seg>由于事件只能以追加的形式写入持久化日志中，因此其顺序无法在后期改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events in a data stream can represent monitoring data, sensor measurements, credit card transactions, weather station observations, online user interactions, web searches, etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045805Z" creationid="xccui" creationdate="20190401T143030Z">
        <seg>数据流中的事件可以表示监控数据、传感器测量值、信用卡交易、气象站观测数据、在线用户交互以及网络搜索等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events with different keys can be processed by the same task, but the keyed state of a task’s function is always accessed in the scope of the current event’s key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190614T050816Z">
        <seg>虽然键值不同的事件也可能会在同一个任务上处理，但任务函数所能访问的键值分区状态始终会被约束在当前事件键值的范围内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eventually, the checkpoint barriers arrive at a sink task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193734Z" creationid="xccui" creationdate="20190609T193734Z">
        <seg>最终检查点分隔符到达数据汇任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every input event is emitted to the next operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T055033Z" creationid="xccui" creationdate="20190614T064709Z">
        <seg>每个输入消息都会被发往下游算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every record contains an average temperature of a sensor over a period of 5 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051811Z" creationid="xccui" creationdate="20190612T054622Z">
        <seg>其每条记录都会包含对应传感器在5秒内的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time a trigger is called it produces a TriggerResult that determines what should happen to the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052805Z" creationid="xccui" creationdate="20190626T184327Z">
        <seg>每次调用触发器都会生成一个TriggerResult，它用于决定窗口接下来的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time an element is added to a window, it is also passed to the trigger of the win‐ dow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052727Z" creationid="xccui" creationdate="20190625T052727Z">
        <seg>每个元素在加入窗口后还会被传递至该窗口的触发器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time the sink operator receives a check‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T045537Z" creationid="xccui" creationdate="20190715T043459Z">
        <seg>数据汇算子每收到一个检查点分隔符都会生成一个新的"记录章节"，并将接下来的所有记录追加写入该章节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Everything contained in a user func‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055230Z" creationid="xccui" creationdate="20190618T055230Z">
        <seg>用户函数中的全部内容都必须是可序列化的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EvictorContext evictorContext);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201910Z" creationid="xccui" creationdate="20190627T201910Z">
        <seg>EvictorContext evictorContext);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evictors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201305Z" creationid="xccui" creationdate="20190626T201305Z">
        <seg>移除器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evictors are often applied on a GlobalWindow for partial cleaning of the window— without purging the complete window state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T204119Z" creationid="xccui" creationdate="20190627T204119Z">
        <seg>移除器常用于GlobalWindow，它只会清理部分窗口内容而不会完全清除整个窗口状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evictors iterate over a list of elements in a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203535Z" creationid="xccui" creationdate="20190627T203535Z">
        <seg>移除器会遍历窗口中的元素列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evolving Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052801Z" creationid="xccui" creationdate="20190225T024857Z">
        <seg>更新状态化应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evolving Stateful Applications | 175</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052625Z" creationid="xccui" creationdate="20190707T052625Z">
        <seg>状态化应用的演变 | 175</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050839Z" creationid="xccui" creationdate="20190415T050839Z">
        <seg>精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034738Z" creationid="xccui" creationdate="20190606T034738Z">
        <seg>精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once guarantees for the Kafka sink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T160826Z" creationid="xingcan" creationdate="20190709T160826Z">
        <seg>Kafka数据汇的精确一次保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once is the strictest guarantee and hard to achieve.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034820Z" creationid="xccui" creationdate="20190606T034802Z">
        <seg>精确一次是最严格，也是最难实现的一类保障，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once means that not only will there be no event loss, but also updates on the internal state will be applied exactly once for each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194128Z" creationid="xccui" creationdate="20190606T034808Z">
        <seg>它表示不但没有事件丢失，而且每个事件对于内部状态的更新都只有一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once result guarantees means that not only there will be no event loss, but also updates on the internal state will be applied exactly once for each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044034Z" creationid="xccui" creationdate="20190416T043928Z">
        <seg>精确一次结果保障意味着不但没有事件丢失，而且每个事件对于内部状态的更新都只有一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once state consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195336Z" creationid="xccui" creationdate="20190605T054206Z">
        <seg>提供精确一次（exactly-once）的状态一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once state consistency is a requirement for end-to-end exactly-once consistency but is not the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T064800Z" creationid="xccui" creationdate="20190708T064800Z">
        <seg>精确一次的状态一致性是实现端到端精确一次一致的需求之一，二者并不一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once*</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170130Z" creationid="xccui" creationdate="20190708T170130Z">
        <seg>精确一次*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203544Z" creationid="xccui" creationdate="20190730T203544Z">
        <seg>示例10-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T204055Z" creationid="xccui" creationdate="20190730T204055Z">
        <seg>示例10-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-3 shows how to specify slot-sharing groups in a Flink DataStream application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015204Z" creationid="xccui" creationdate="20190731T015204Z">
        <seg>示例10-3展示了如何在Flink DataStream应用中指定处理槽共享组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015209Z" creationid="xccui" creationdate="20190731T015209Z">
        <seg>示例10-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154404Z" creationid="xingcan" creationdate="20190801T154404Z">
        <seg>示例10-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015215Z" creationid="xccui" creationdate="20190803T015215Z">
        <seg>示例10-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031737Z" creationid="xccui" creationdate="20190803T031737Z">
        <seg>示例10-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033607Z" creationid="xccui" creationdate="20190803T033607Z">
        <seg>示例10-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T050147Z" creationid="xccui" creationdate="20190804T050147Z">
        <seg>示例10-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-9 shows a MapFunction that logs every input record conversion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034157Z" creationid="xccui" creationdate="20190807T034037Z">
        <seg>示例10-9展示的MapFunction会将每一次输入记录转换都写入日志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 10-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034201Z" creationid="xccui" creationdate="20190807T034044Z">
        <seg>示例10-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035805Z" creationid="xccui" creationdate="20190612T035805Z">
        <seg>示例5-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-2 splits a stream of numbers into a stream of large numbers and a stream of small numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061613Z" creationid="xccui" creationdate="20190615T061613Z">
        <seg>示例5-2将一条数字流分成一条大数字流和一条小数字流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061618Z" creationid="xccui" creationdate="20190615T061618Z">
        <seg>示例 5-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-3 shows the methods of a RichFLatMapFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034219Z" creationid="xccui" creationdate="20190619T034206Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T031010Z" creationid="xccui" creationdate="20190618T031010Z">
        <seg>示例 5-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-1 shows how to set the time characteristic by revisiting the sensor stream‐ ing application code you wrote in “Hello, Flink!” on page 79.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T050649Z" creationid="xccui" creationdate="20190619T072317Z">
        <seg>示例6-1回顾了你在79页完成的"Hello, Flink!"流式应用代码中是如何设置时间特性的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T072525Z" creationid="xccui" creationdate="20190619T072359Z">
        <seg>示例6-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-10 shows a reduce lambda function that computes the mininum tempera‐ ture per sensor every 15 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T035635Z" creationid="xccui" creationdate="20190624T002241Z">
        <seg>示例6-10中展示的Lambda函数会计算每15秒的最低温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002248Z" creationid="xccui" creationdate="20190624T002248Z">
        <seg>示例6-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-11 shows how to use an AggregateFunction to compute the average tem‐ perature of sensor readings per window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005208Z" creationid="xccui" creationdate="20190624T005208Z">
        <seg>示例6-11展示了如何使用AggregateFunction计算每个窗口内传感器读数的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005411Z" creationid="xccui" creationdate="20190624T005411Z">
        <seg>示例6-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-12 groups the sensor reading stream into tumbling windows of 5 seconds and uses a ProcessWindowFunction to compute the lowest and highest temperature that occur within the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030330Z" creationid="xccui" creationdate="20190625T030330Z">
        <seg>示例6-12将传感器读数流按照每5秒的滚动窗口进行分组，随后使用ProcessWindowFunction计算每个窗口内的最低温和最高温。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T205813Z" creationid="xccui" creationdate="20190623T205813Z">
        <seg>示例6-12，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043448Z" creationid="xccui" creationdate="20190625T043448Z">
        <seg>示例6-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-14.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045020Z" creationid="xccui" creationdate="20190625T045020Z">
        <seg>示例6-14，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-15.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042257Z" creationid="xccui" creationdate="20190626T042257Z">
        <seg>示例6-15，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-16 shows a trigger that fires early, before the end time of the window is reached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T053242Z" creationid="xccui" creationdate="20190626T195643Z">
        <seg>示例6-16展示的触发器会在时间到达窗口结束时间之前提前触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200014Z" creationid="xccui" creationdate="20190626T200014Z">
        <seg>示例6-16，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-17 shows the Evictor interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201639Z" creationid="xccui" creationdate="20190626T201639Z">
        <seg>示例6-17中展示了Evictor接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-17.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201540Z" creationid="xccui" creationdate="20190627T201540Z">
        <seg>示例6-17，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-18.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025815Z" creationid="xccui" creationdate="20190628T025815Z">
        <seg>示例6-18，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-19 shows how to define a window join.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T034533Z" creationid="xccui" creationdate="20190628T034533Z">
        <seg>示例6-19展示了如何定义基于窗口的Join。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T034538Z" creationid="xccui" creationdate="20190628T034538Z">
        <seg>示例6-19，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044608Z" creationid="xccui" creationdate="20190620T044608Z">
        <seg>示例6-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-20 shows how to specify a window operator with a side output for late events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154837Z" creationid="xingcan" creationdate="20190628T154837Z">
        <seg>示例6-20展示了如何在窗口算子中为迟到事件指定副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-20.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154842Z" creationid="xingcan" creationdate="20190628T154842Z">
        <seg>示例6-20，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-21 shows a ProcessFunction that filters out late sensor readings from its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155512Z" creationid="xingcan" creationdate="20190628T155512Z">
        <seg>示例6-21展示了ProcessFunction如何从输入中过滤出迟到的传感器读数，并将其重定位到副输出流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-21.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155521Z" creationid="xingcan" creationdate="20190628T155521Z">
        <seg>示例6-21，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165144Z" creationid="xingcan" creationdate="20190628T165144Z">
        <seg>示例6-22，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-3 shows an assigner with periodic timestamps that produces watermarks by keeping track of the maximum element timestamp it has seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055550Z" creationid="xccui" creationdate="20190620T050837Z">
        <seg>示例6-3展示了一个周期性水位线分配器，它通过跟踪至今为止所见的最大元素时间戳来生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051021Z" creationid="xccui" creationdate="20190620T051021Z">
        <seg>示例6-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-4 shows a punctuated watermark assigner that emits a watermark for every reading it receives from the sensor with the ID "sensor_1".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T060437Z" creationid="xccui" creationdate="20190620T054733Z">
        <seg>示例6-4展示的定点水位线生成器会根据从ID为"sensor_1"的传感器接收到的所有读数产生水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054737Z" creationid="xccui" creationdate="20190620T054737Z">
        <seg>示例6-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054957Z" creationid="xccui" creationdate="20190620T054957Z">
        <seg>示例6-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-6 shows how to emit data from a ProcessFunction via DataStream of a side output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T202948Z" creationid="xccui" creationdate="20190622T022628Z">
        <seg>示例6-6展示了如何利用ProcessFunction向副输出的DataStream发送数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022633Z" creationid="xccui" creationdate="20190622T022633Z">
        <seg>示例6-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-7 shows the FreezingMonitor function that monitors a stream of sensor readings and emits a warning to a side output for readings with a temperature below</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T203204Z" creationid="xccui" creationdate="20190622T023245Z">
        <seg>示例6-7所示的FreezingMonitor函数用于监控传感器读数流，它会对读数温度低于32°F的记录向副输出发送警告。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023256Z" creationid="xccui" creationdate="20190622T023256Z">
        <seg>示例6-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-8 shows how to apply a CoProcessFunction to combine two streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T012415Z" creationid="xccui" creationdate="20190622T031359Z">
        <seg>示例6-8展示了如何使用CoProcessFunction来结合两条数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031407Z" creationid="xccui" creationdate="20190622T031407Z">
        <seg>示例6-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T022818Z" creationid="xccui" creationdate="20190622T031933Z">
        <seg>示例6-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-1 shows how to apply a FlatMapFunction with a keyed ValueState on a stream of sensor measurements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062254Z" creationid="xccui" creationdate="20190630T061537Z">
        <seg>示例7-1展示了如何在一条传感数据测量流上应用一个带有键值分区ValueState的FlatMapFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061957Z" creationid="xccui" creationdate="20190630T061957Z">
        <seg>示例7-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024115Z" creationid="xccui" creationdate="20190703T024115Z">
        <seg>示例7-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024958Z" creationid="xccui" creationdate="20190703T024958Z">
        <seg>示例7-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-12 shows how to configure a state backend (here, RocksDBStateBackend) for an application and all its stateful functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025623Z" creationid="xccui" creationdate="20190704T025623Z">
        <seg>示例7-12展示了如何为应用及其状态化函数配置状态后端（此处选用RocksDBStateBackend）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025628Z" creationid="xccui" creationdate="20190704T025628Z">
        <seg>示例7-12，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-13 shows a KeyedProcessFunction that compares two subsequent tem‐ perature measurements and raises an alert if the difference is greater than a certain</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205113Z" creationid="xccui" creationdate="20190704T204924Z">
        <seg>示例7-13展示的KeyedProcessFunction会对两个连续的温度测量值进行比较，如果二者的差值大于一个特定阈值就会发出警报。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T024303Z" creationid="xccui" creationdate="20190704T024303Z">
        <seg>示例7-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-14 shows how to make lastTempState queryable to illustrate the usage of the keyed state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T060846Z" creationid="xccui" creationdate="20190706T060846Z">
        <seg>示例7-14中以lastTempState状态为例，说明了如何将键值分区状态设置为可查询的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-14.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T060851Z" creationid="xccui" creationdate="20190706T060851Z">
        <seg>示例7-14，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-15 shows how to use a queryable state sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062055Z" creationid="xccui" creationdate="20190706T062055Z">
        <seg>示例7-15展示了如何使用可查询式状态的数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-15.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062059Z" creationid="xccui" creationdate="20190706T062059Z">
        <seg>示例7-15，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-16 shows a simple</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035708Z" creationid="xccui" creationdate="20190707T035708Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035729Z" creationid="xccui" creationdate="20190707T035729Z">
        <seg>示例7-16，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-2 shows the implementation of a FlatMapFunction with a keyed Value State that checks whether the measured temperature changed more than a config‐ ured threshold.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064132Z" creationid="xccui" creationdate="20190630T064132Z">
        <seg>示例7-2展示了如何实现带有键值分区ValueState的FlatMapFunction，该函数用来检测温度测量值的变化是否超过配置的阈值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064135Z" creationid="xccui" creationdate="20190630T064135Z">
        <seg>示例7-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-3 shows how to implement the previous example with the shortcut.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T040657Z" creationid="xccui" creationdate="20190701T022755Z">
        <seg>示例7-3展示了如何利用简写方式来实现上一个示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T022801Z" creationid="xccui" creationdate="20190701T022801Z">
        <seg>示例7-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-4 shows how to implement the ListCheckpointed interface for a function that counts temperature measurements that exceed a threshold per partition, for each</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052212Z" creationid="xccui" creationdate="20190701T052212Z">
        <seg>示例7-4展示了如何利用ListCheckpointed接口实现一个函数，其作用是在每个函数并行实例内，计算该分区数据超过某一阈值的温度值数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T045316Z" creationid="xccui" creationdate="20190701T052219Z">
        <seg>示例7-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062303Z" creationid="xccui" creationdate="20190701T062303Z">
        <seg>示例7-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-6 shows how to implement a tem‐ perature alert application with thresholds that can be dynamically configured via a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024117Z" creationid="xccui" creationdate="20190701T204421Z">
        <seg>示例7-6展示了如何实现用广播流动态配置阈值的温度报警应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024131Z" creationid="xccui" creationdate="20190702T024131Z">
        <seg>示例7-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-7 shows the implementation of a KeyedBroadcastProcessFunction that supports the dynamic configuration of sensor thresholds at runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041312Z" creationid="xccui" creationdate="20190702T041312Z">
        <seg>示例7-7展示了一个KeyedBroadcastProcessFunction的实现，它支持在运行时动态配置传感器阈值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041315Z" creationid="xccui" creationdate="20190702T041315Z">
        <seg>示例7-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-8 shows how the CheckpointedFunction interface is used to create a func‐ tion with keyed and operator state that counts per key and operator instance how</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T170410Z" creationid="xccui" creationdate="20190702T154649Z">
        <seg>示例7-8展示了如何使用CheckpointedFunciton接口创建一个函数，该函数分别利用键值分区状态和算子状态来计算每个键值分区内和每个算子实例内有多少传感器读数超过指定阈值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041753Z" creationid="xccui" creationdate="20190702T041753Z">
        <seg>示例7-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204740Z" creationid="xccui" creationdate="20190702T204740Z">
        <seg>示例7-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T205836Z" creationid="xccui" creationdate="20190708T205836Z">
        <seg>示例8-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-10 shows a simple source function that counts from 0 to Long.MaxValue.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152309Z" creationid="xccui" creationdate="20190712T152309Z">
        <seg>示例8-10展示了一个简单从0数到Long.MaxValue的数据源函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152345Z" creationid="xccui" creationdate="20190712T152345Z">
        <seg>示例8-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-11 makes the CountSource of Example 8-10 resettable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034153Z" creationid="xccui" creationdate="20190713T033850Z">
        <seg>示例8-11为示例8-10中CountSource的可重置版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T033909Z" creationid="xccui" creationdate="20190713T033905Z">
        <seg>示例8-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-12 shows a simple SinkFunction that writes sensor readings to a socket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T213149Z" creationid="xccui" creationdate="20190713T213149Z">
        <seg>示例8-12中展示了一个简单的SinkFunction，它用来将传感读数写入套接字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T023917Z" creationid="xccui" creationdate="20190714T023917Z">
        <seg>示例8-12，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-13 illustrates how to implement and use an idempotent SinkFunction that writes to a JDBC database, in this case an embedded Apache Derby database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T203920Z" creationid="xccui" creationdate="20190714T044729Z">
        <seg>示例8-13展示了如何实现和使用一个利用JDBC写数据库（本例中用到的是Apache Derby数据库）的幂等性SinkFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T044735Z" creationid="xccui" creationdate="20190714T044735Z">
        <seg>示例8-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-14 shows the implementation of a write-ahead sink that writes to the stan‐ dard output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T063655Z" creationid="xccui" creationdate="20190715T063556Z">
        <seg>示例8-14展示了如何实现一个写标准输出的WAL数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-14.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064147Z" creationid="xccui" creationdate="20190715T064147Z">
        <seg>示例8-14，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-15 shows a TwoPhaseCommitSinkFunc tion that writes with exactly-once guarantees to a filesystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T040917Z" creationid="xccui" creationdate="20190716T040917Z">
        <seg>示例8-15展示了的TwoPhaseCommitSinkFunction可以将数据以精确一次语义写文件系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-15.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T040957Z" creationid="xccui" creationdate="20190716T040957Z">
        <seg>示例8-15，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201706Z" creationid="xccui" creationdate="20190716T201706Z">
        <seg>示例8-16，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-17 shows DerbyAsyncFunction, which queries an embedded Derby database via its JDBC interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T203719Z" creationid="xccui" creationdate="20190716T203719Z">
        <seg>示例8-17展示的DerbyAsyncFunction可以通过JDBC接口查询嵌入式Derby数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-17.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T203723Z" creationid="xccui" creationdate="20190716T203723Z">
        <seg>示例8-17，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T171118Z" creationid="xccui" creationdate="20190708T171118Z">
        <seg>示例8-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-3 shows how to ingest a stream by reading text files line-wise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T184928Z" creationid="xccui" creationdate="20190710T184928Z">
        <seg>示例8-3展示了如何通过逐行读取文件来生成一个数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T184935Z" creationid="xccui" creationdate="20190710T184935Z">
        <seg>示例8-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-4 creates a StreamingFileSink with row encoding by providing an Encoder that writes single records to a part file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T023711Z" creationid="xccui" creationdate="20190711T023711Z">
        <seg>示例8-4创建了一个使用行编码的StreamingFileSink，它提供的编码器会将每一条记录单独写入分块文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-4 shows how to create a StreamingFile Sink with minimal configuration and append it to a stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205803Z" creationid="xccui" creationdate="20190710T205803Z">
        <seg>示例8-4展示了如何使用最少的配置来创建一个StreamingFileSink并将其添加到数据流后面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205808Z" creationid="xccui" creationdate="20190710T205808Z">
        <seg>示例8-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T182028Z" creationid="xccui" creationdate="20190710T182028Z">
        <seg>示例8-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210022Z" creationid="xccui" creationdate="20190711T210022Z">
        <seg>示例8-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-7 shows how to create a sink that writes a DataStream of tuples,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210629Z" creationid="xccui" creationdate="20190711T210629Z">
        <seg>示例8-7展示了如何创建一个用于将元组、样例类或Row类型的数据流写入Cassandra表的数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-7, it returns a builder for a Cassandra sink that handles Scala tuples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T211651Z" creationid="xccui" creationdate="20190711T211322Z">
        <seg>在示例8-7中，会返回一个针对Scala元组的Cassandra数据汇构建器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210737Z" creationid="xccui" creationdate="20190711T210737Z">
        <seg>示例8-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-8 shows how to configure a Cassandra sink for a POJO of type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212824Z" creationid="xccui" creationdate="20190711T212817Z">
        <seg>示例8-8展示了如何为POJO类型SensorReading配置一个Cassandra数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212831Z" creationid="xccui" creationdate="20190711T212831Z">
        <seg>示例8-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 8-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220142Z" creationid="xccui" creationdate="20190711T220142Z">
        <seg>示例8-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 9-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T032338Z" creationid="xccui" creationdate="20190718T032338Z">
        <seg>示例9-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 9-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024832Z" creationid="xccui" creationdate="20190720T024832Z">
        <seg>示例9-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 9-3 shows the deployment for worker pods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025620Z" creationid="xccui" creationdate="20190720T025620Z">
        <seg>示例9-3展示了工作进程Pod的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 9-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025624Z" creationid="xccui" creationdate="20190720T025624Z">
        <seg>示例9-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 9-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T031925Z" creationid="xccui" creationdate="20190720T031925Z">
        <seg>示例9-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 9-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T203635Z" creationid="xccui" creationdate="20190720T203635Z">
        <seg>示例9-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples for source con‐ nectors that support the checkpointing of reading positions are file-based sources that store the reading offsets in the byte stream of the file or a Kafka source that stores the reading offsets in the topic partitions it consumes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T054721Z" creationid="xccui" creationdate="20190708T054721Z">
        <seg>支持将读取位置写入检查点的数据源连接器有：基于文件的连接器（会存储文件字节流的读取偏移）以及Kafka连接器（会存储消费主题分区的读取偏移）等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of such systems are filesystems that provide the offset of a file stream and a seek method to move a file stream to a specific position or Apache Kafka, which provides offsets for each parti‐ tion of a topic and can set the reading position of a partition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T160426Z" creationid="xccui" creationdate="20190712T160106Z">
        <seg>例如：文件系统可提供文件流的读取偏移，并支持通过seek方法将文件流移动到特定位置；Apache Kafka可提供主题下每个分区的偏移地址，并允许我们设置分区的读取位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except from experiencing network delays, streams might be affected by many other factors resulting in events arriving &lt;t0/&gt;out-of-order&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T152014Z" creationid="xccui" creationdate="20190412T151943Z">
        <seg>除了遇到网络延迟外，数据流还可能受很多其他因素的影响，从而导致事件乱序到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035744Z" creationid="xccui" creationdate="20190418T035744Z">
        <seg>执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execute the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T045733Z" creationid="xccui" creationdate="20190612T044410Z">
        <seg>执行程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executes JDBC query in a thread and handles the resulting Future</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T205919Z" creationid="xccui" creationdate="20190716T205814Z">
        <seg>在一个线程内执行JDBC查询并通过异步回调处理产生的Future对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly Providing Type Information</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145233Z" creationid="esouser" creationdate="20190603T145233Z">
        <seg>显式提供类型信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly providing TypeInformation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022853Z" creationid="xccui" creationdate="20190225T022853Z">
        <seg>显式提供TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exposing Queryable State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151726Z" creationid="xccui" creationdate="20190225T025031Z">
        <seg>对外暴露可查询式状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exposing metrics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T050706Z" creationid="xccui" creationdate="20190804T050706Z">
        <seg>暴露指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>External applications can request the state for a key while the streaming application is running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T163156Z" creationid="xccui" creationdate="20190705T163156Z">
        <seg>外部应用可以在流式应用运行过程中访问某一键值的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Externalized checkpoints do not replace savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T205605Z" creationid="xccui" creationdate="20190731T205605Z">
        <seg>外化检查点不能替代保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extract the archive file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024939Z" creationid="xccui" creationdate="20190329T024915Z">
        <seg>提取归档文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extract the archive file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T040942Z" creationid="xccui" creationdate="20190605T123035Z">
        <seg>解压文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIRE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184406Z" creationid="xccui" creationdate="20190626T184406Z">
        <seg>FIRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIRE_AND_PURGE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184925Z" creationid="xccui" creationdate="20190626T184925Z">
        <seg>FIRE_AND_PURGE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIRE_AND_PURGE: Evaluates the window first (FIRE) and subsequently removes all state and metadata (PURGE).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185109Z" creationid="xccui" creationdate="20190626T185109Z">
        <seg>先进行窗口计算（FIRE），随后删除所有状态及元数据（PURGE）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FLINK_DOCKER_IMAGE_NAME=flink-book-jobs \ FLINK_JOB=io.github.streamingwithflink.chapter1.AverageSensorReadings \ DEFAULT_PARALLELISM=3 \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T035221Z" creationid="xccui" creationdate="20190730T035221Z">
        <seg>FLINK_DOCKER_IMAGE_NAME=flink-book-jobs \ FLINK_JOB=io.github.streamingwithflink.chapter1.AverageSensorReadings \ DEFAULT_PARALLELISM=3 \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fabian Hueske and Vasiliki Kalavri</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T062527Z" creationid="esouser" creationdate="20190603T142832Z">
        <seg>费比安·霍斯克，瓦西里基·卡拉夫里</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fabian Hueske is a committer to and PMC member of the Apache Flink project and has been contributing to Flink since its earliest days.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T040412Z" creationid="xccui" creationdate="20190808T033204Z">
        <seg>作为最早参与Flink建设的几人之一，费比安·霍斯克Apache Flink项目的Committer及PMC成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fabian is cofounder and soft‐ ware engineer at Ververica (formerly data Artisans), a Berlin-based startup that fos‐ ters Flink and its community.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T040434Z" creationid="xccui" creationdate="20190808T034603Z">
        <seg>他同时还是Ververica（前身为data Artisans）的联合创始人和软件工程师。该公司是一家总部位于柏林的创业公司，一直以来都致力于为Flink项目和社区发展提供支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Farnham</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210639Z" creationid="esouser" creationdate="20190603T210639Z">
        <seg>Farnham</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Expressions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145343Z" creationid="esouser" creationdate="20190603T145343Z">
        <seg>字段表达式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Positions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145330Z" creationid="esouser" creationdate="20190603T145330Z">
        <seg>字段位置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field expressions work for tuples, POJOs, and case classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050859Z" creationid="xccui" creationdate="20190618T041522Z">
        <seg>它可用于元组、POJO以及样例类，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T051343Z" creationid="xccui" creationdate="20190226T155724Z">
        <seg>图1-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-2 depicts a microservices architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T063122Z" creationid="esouser" creationdate="20190603T201038Z">
        <seg>图1-2展示了一种微服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T201055Z" creationid="xccui" creationdate="20190228T172811Z">
        <seg>图1-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203636Z" creationid="xccui" creationdate="20190228T194722Z">
        <seg>图1-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210546Z" creationid="xccui" creationdate="20190305T033052Z">
        <seg>图1-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-5 shows a service architecture composed of event-driven streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055536Z" creationid="esouser" creationdate="20190603T213855Z">
        <seg>图1-5粗略展示了一个由事件驱动型应用组成的服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213901Z" creationid="xccui" creationdate="20190307T152532Z">
        <seg>图1-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044636Z" creationid="xccui" creationdate="20190317T061404Z">
        <seg>图1-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051830Z" creationid="xccui" creationdate="20190322T043259Z">
        <seg>图1-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123342Z" creationid="xccui" creationdate="20190329T035536Z">
        <seg>图1-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123747Z" creationid="xccui" creationdate="20190329T041504Z">
        <seg>图1-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 10-1 shows the JobGraph of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T020131Z" creationid="xccui" creationdate="20190731T020131Z">
        <seg>图10-1展示了应用的JobGraph以及它的任务到处理槽的映射关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 10-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T020139Z" creationid="xccui" creationdate="20190731T020139Z">
        <seg>图10-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 10-2 shows an instance of the dashboard home screen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T034213Z" creationid="xccui" creationdate="20190802T034152Z">
        <seg>图10-2展示了一个仪表盘主界面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 10-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T034412Z" creationid="xccui" creationdate="20190802T034412Z">
        <seg>图10-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 10-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T144249Z" creationid="xingcan" creationdate="20190802T144249Z">
        <seg>图10-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 10-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T144536Z" creationid="xingcan" creationdate="20190802T144536Z">
        <seg>图10-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 10-5 shows how selected metrics are shown as continuously updated charts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T145358Z" creationid="xingcan" creationdate="20190802T145358Z">
        <seg>图10-5展示了如何使用连续更新的图表展现所选指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 10-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T145403Z" creationid="xingcan" creationdate="20190802T145403Z">
        <seg>图10-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-1 shows a dataflow program that extracts and counts hashtags from an input stream of tweets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T043916Z" creationid="xccui" creationdate="20190605T224942Z">
        <seg>图2-1展示了一个从推文输入流中提取并统计主题标签的Dataflow程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000821Z" creationid="xccui" creationdate="20190401T000821Z">
        <seg>图2-1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-10 shows a parallel count- based tumbling window of length 2 that is partitioned by event color.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014052Z" creationid="xccui" creationdate="20190606T014052Z">
        <seg>图2-10展示了一个按事件颜色划分、基于数量2的并行滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195852Z" creationid="xccui" creationdate="20190409T195852Z">
        <seg>图2-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-11 illustrates this problem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154903Z" creationid="xccui" creationdate="20190606T015143Z">
        <seg>图2-11说明了这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152133Z" creationid="xccui" creationdate="20190411T152133Z">
        <seg>图2-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145254Z" creationid="xccui" creationdate="20190412T145254Z">
        <seg>图2-12，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-13 shows that an event-time window would correctly place events in a window, reflecting the reality of how things happened, even though some events were delayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024207Z" creationid="xccui" creationdate="20190606T024207Z">
        <seg>如图2-13所示，即便事件有延迟，事件时间窗口也能准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150547Z" creationid="xccui" creationdate="20190412T150547Z">
        <seg>图2-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-2 shows a physical dataflow graph for the logical graph of Figure 2-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044348Z" creationid="xccui" creationdate="20190605T233123Z">
        <seg>图2-2展示了图2-1中逻辑图所对应的物理Dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233204Z" creationid="xccui" creationdate="20190401T021435Z">
        <seg>图2-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233614Z" creationid="xccui" creationdate="20190401T142156Z">
        <seg>图2-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011531Z" creationid="xccui" creationdate="20190405T155233Z">
        <seg>图2-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-5 shows a rolling minimum aggregation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011908Z" creationid="xccui" creationdate="20190606T011908Z">
        <seg>图2-5展示了一个求最小值的滚动聚合，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011935Z" creationid="xccui" creationdate="20190406T035853Z">
        <seg>图2-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-6 shows a count-based tumbling window that discretizes the input stream into buckets of four elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013041Z" creationid="xccui" creationdate="20190606T013033Z">
        <seg>图2-6中基于数量的滚动窗口将输入流按每4个元素一组分配到不同的桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013105Z" creationid="xccui" creationdate="20190407T023535Z">
        <seg>图2-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-7 shows a time-based tumbling window that gathers events into buckets and triggers computation every 10 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013100Z" creationid="xccui" creationdate="20190606T013100Z">
        <seg>图2-7中基于时间的滚动窗口将事件汇集到桶中，每10分钟触发一次计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013116Z" creationid="xccui" creationdate="20190407T023601Z">
        <seg>图2-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013309Z" creationid="xccui" creationdate="20190407T024337Z">
        <seg>图2-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-9 shows a session win‐ dow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013816Z" creationid="xccui" creationdate="20190606T013816Z">
        <seg>图2-9展示了一个会话窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193600Z" creationid="xccui" creationdate="20190409T193600Z">
        <seg>图2-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1 &lt;t0/&gt;visualizes how Flink’s components interact with each other when an applica&lt;t1/&gt;‐&lt;t2/&gt; &lt;t3/&gt;tion is submitted for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024536Z" creationid="xccui" creationdate="20190423T024536Z">
        <seg>图3-1展示了应用提交执行过程中Flink各组件之间的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1 is a high-level sketch to visualize the responsibilities and interactions of the components of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T062545Z" creationid="xccui" creationdate="20190606T143140Z">
        <seg>图3-1仅是一个用于展示各组件职责与交互的高层次框架。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1 shows how Flink’s components interact with each other when an applica‐ tion is submitted for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143119Z" creationid="xccui" creationdate="20190606T143119Z">
        <seg>图3-1展示了应用提交执行过程中Flink各组件之间的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024559Z" creationid="xccui" creationdate="20190423T024553Z">
        <seg>图3-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-10 shows the typical interaction between a task and its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054157Z" creationid="xccui" creationdate="20190607T054157Z">
        <seg>图3-10展示了某个任务和它状态之间的典型交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054241Z" creationid="xccui" creationdate="20190607T054204Z">
        <seg>图3-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-11 shows how tasks access operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061822Z" creationid="xccui" creationdate="20190607T061818Z">
        <seg>图3-11展示了任务访问算子状态的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061850Z" creationid="xccui" creationdate="20190607T061850Z">
        <seg>图3-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-12 shows how tasks interact with keyed state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T191856Z">
        <seg>图3-12展示了任务和键值分区状态的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191916Z" creationid="xccui" creationdate="20190607T191916Z">
        <seg>图3-12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-13 shows how keyed state is repartitioned in key groups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190608T060134Z">
        <seg>图3-13展示了键值分区状态通过键值组进行重新分区的过程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060142Z" creationid="xccui" creationdate="20190608T060142Z">
        <seg>图3-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-14 shows the redistribution of operator list state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060932Z" creationid="xccui" creationdate="20190608T060915Z">
        <seg>图3-14展示了算子列表状态的重分配过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-14.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060955Z" creationid="xccui" creationdate="20190608T060955Z">
        <seg>图3-14，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-15 shows how operator union list state is redistributed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061440Z" creationid="xccui" creationdate="20190608T061440Z">
        <seg>图3-15展示了算子联合列表状态的重分配过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-15.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061453Z" creationid="xccui" creationdate="20190608T061444Z">
        <seg>图3-15，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-16 shows the redistribution of operator broadcast state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062216Z" creationid="xccui" creationdate="20190608T062216Z">
        <seg>图3-16展示了算子广播状态的重分配过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062225Z" creationid="xccui" creationdate="20190608T062224Z">
        <seg>图3-16，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-17 shows a consistent checkpoint of a simple application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T063714Z" creationid="xccui" creationdate="20190608T224942Z">
        <seg>图3-17展示了针对一个简单应用的一致性检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-17.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224957Z" creationid="xccui" creationdate="20190608T224957Z">
        <seg>图3-17，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-18 shows the recovery process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035854Z" creationid="xccui" creationdate="20190609T035854Z">
        <seg>图3-18展示了整个恢复过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-18.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035859Z" creationid="xccui" creationdate="20190609T035859Z">
        <seg>图3-18，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062327Z" creationid="xccui" creationdate="20190609T062327Z">
        <seg>图3-19，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-2 shows the relationships between Task‐ Managers, slots, tasks, and operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144423Z" creationid="xccui" creationdate="20190606T144423Z">
        <seg>图3-2展示了TaskManager、处理槽、任务以及算子之间的关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042935Z" creationid="xccui" creationdate="20190423T042916Z">
        <seg>图3-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-20.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062435Z" creationid="xccui" creationdate="20190609T062435Z">
        <seg>图3-20，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-21 shows the streaming application after both source tasks checkpointed their local state and emit‐ ted checkpoint barriers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155312Z" creationid="xccui" creationdate="20190609T155242Z">
        <seg>图3-21展示了流式应用为数据源任务的本地状态生成检查点并发出检查点分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-21.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155332Z" creationid="xccui" creationdate="20190609T155332Z">
        <seg>图3-21，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T174943Z" creationid="xccui" creationdate="20190609T174943Z">
        <seg>图3-22，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-23.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T191821Z" creationid="xccui" creationdate="20190609T191821Z">
        <seg>图3-23，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-24 shows the application at this point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193413Z" creationid="xccui" creationdate="20190609T193413Z">
        <seg>图3-24展示了此时的应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-24.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193437Z" creationid="xccui" creationdate="20190609T193437Z">
        <seg>图3-24，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-25 shows the final step of the checkpointing algorithm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194328Z" creationid="xccui" creationdate="20190609T194328Z">
        <seg>图3-25展示了检查点算法的最后一步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-25.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194520Z" creationid="xccui" creationdate="20190609T194520Z">
        <seg>图3-25，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-26 shows an application with three operators, each running with two tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T071112Z" creationid="xccui" creationdate="20190609T214829Z">
        <seg>图3-26所展示的应用包含了三个算子，每个算子各有两个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-26.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215058Z" creationid="xccui" creationdate="20190609T215058Z">
        <seg>图3-26，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-3 illustrates this design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T194307Z" creationid="xccui" creationdate="20190606T194307Z">
        <seg>图3-3阐明了这一设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051909Z" creationid="xccui" creationdate="20190502T051909Z">
        <seg>图3-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-4 shows this architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T200550Z" creationid="xccui" creationdate="20190606T200545Z">
        <seg>图3-4展示了这一架构.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T043815Z" creationid="xccui" creationdate="20190504T043815Z">
        <seg>图3-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152413Z" creationid="esouser" creationdate="20190514T152357Z">
        <seg>图3-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-6 &lt;t0/&gt;depicts how the pipeline is executed with task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152448Z" creationid="esouser" creationdate="20190514T152448Z">
        <seg>图3-6展示了流水线如何在任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-6 depicts how the pipeline is executed with task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203516Z" creationid="xccui" creationdate="20190606T203516Z">
        <seg>图3-6展示了流水线如何在任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153047Z" creationid="esouser" creationdate="20190514T153047Z">
        <seg>图3-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-7 shows the same pipeline executed without task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T202003Z" creationid="xccui" creationdate="20190606T203922Z">
        <seg>图3-7展示了相同的流水线在非任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T154741Z" creationid="esouser" creationdate="20190514T154741Z">
        <seg>图3-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042306Z" creationid="xccui" creationdate="20190523T042306Z">
        <seg>图3-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-9 shows how a task with four input partitions and three output partitions receives watermarks, updates its partition watermarks and event-time clock, and emits watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054127Z" creationid="xccui" creationdate="20190607T025519Z">
        <seg>图3-9展示了一个有4个输入分区和3个输出分区的任务在接收到水位线后，是如何更新它的分区水位线和事件时间时钟，并将水位线发出的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025624Z" creationid="xccui" creationdate="20190607T025617Z">
        <seg>图3-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 4-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041603Z" creationid="xccui" creationdate="20190611T041603Z">
        <seg>图4-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 4-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041632Z" creationid="xccui" creationdate="20190611T041632Z">
        <seg>图4-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 4-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041648Z" creationid="xccui" creationdate="20190611T041648Z">
        <seg>图4-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-1 shows a map transformation that converts every square into a circle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045343Z" creationid="xccui" creationdate="20190613T045343Z">
        <seg>图5-1所示的map转换会将每个方形输入转换为圆形。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045347Z" creationid="xccui" creationdate="20190613T045347Z">
        <seg>图5-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-2 shows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052259Z" creationid="xccui" creationdate="20190613T052259Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052306Z" creationid="xccui" creationdate="20190613T052306Z">
        <seg>图5-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-3 shows a flatMap operation that differentiates its output based on the color of the incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054323Z" creationid="xccui" creationdate="20190613T054323Z">
        <seg>图5-3展示的flatMap操作会根据输入事件颜色的不同输出不同的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054545Z" creationid="xccui" creationdate="20190613T054545Z">
        <seg>图5-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051113Z" creationid="xccui" creationdate="20190614T051113Z">
        <seg>图5-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-5 shows a union operation that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064219Z" creationid="xccui" creationdate="20190614T064219Z">
        <seg>图5-5展示的union操作会将黑色和白色的事件合并成一条输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064230Z" creationid="xccui" creationdate="20190614T064230Z">
        <seg>图5-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-6 shows a split operator that routes all white events into a separate stream than the rest.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T054125Z" creationid="xccui" creationdate="20190615T054125Z">
        <seg>图5-6所示的split算子会将所有白色事件和其他事件分别发往不同的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T054131Z" creationid="xccui" creationdate="20190615T054131Z">
        <seg>图5-6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-7 illustrates the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043407Z" creationid="xccui" creationdate="20190616T043407Z">
        <seg>图5-7对该分发转换进行了说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045500Z" creationid="xccui" creationdate="20190616T045500Z">
        <seg>图5-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042158Z" creationid="xccui" creationdate="20190623T042158Z">
        <seg>图6-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054747Z" creationid="xccui" creationdate="20190623T054747Z">
        <seg>图6-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-3 illustrates how elements are assigned to session windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T030317Z" creationid="xccui" creationdate="20190623T061012Z">
        <seg>图6-3解释了如何将元素分配到会话窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061016Z" creationid="xccui" creationdate="20190623T061016Z">
        <seg>图6-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053506Z" creationid="xccui" creationdate="20190625T053506Z">
        <seg>图6-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053955Z" creationid="xccui" creationdate="20190625T053955Z">
        <seg>图6-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-6 depicts this case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054306Z" creationid="xccui" creationdate="20190625T054306Z">
        <seg>图6-6描述了该情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030122Z" creationid="xccui" creationdate="20190625T030122Z">
        <seg>图6-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-7 shows an interval join of two streams, A and B, that joins an event from A with an event from B if the timestamp of the B event is not less than one hour earlier and not more than 15 minutes later than the timestamp of the A event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T214113Z" creationid="xccui" creationdate="20190627T214113Z">
        <seg>图6-7展示了两条流（A和B）上基于间隔的Join，如果B中事件的时间戳相较于A中事件的时间戳不早于1小时且不晚于15分钟，则会将两个事件Join起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025129Z" creationid="xccui" creationdate="20190628T025129Z">
        <seg>图6-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-8 shows how the window join of the DataStream API works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040250Z" creationid="xccui" creationdate="20190628T040250Z">
        <seg>图6-8展示了DataStream API中基于窗口的Join是如何工作的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040255Z" creationid="xccui" creationdate="20190628T040255Z">
        <seg>图6-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 7-1 shows the architecture of the queryable state service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T024159Z" creationid="xccui" creationdate="20190706T024159Z">
        <seg>图7-1展示了可查询式状态服务的架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 7-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T024202Z" creationid="xccui" creationdate="20190706T024202Z">
        <seg>图7-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 8-1 shows the assignment of partitions to source instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T205715Z" creationid="xccui" creationdate="20190708T205715Z">
        <seg>图8-1展示了数据源实例的分区分配情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 8-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T205719Z" creationid="xccui" creationdate="20190708T205719Z">
        <seg>图8-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 9-1 shows a standalone Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T153305Z" creationid="xccui" creationdate="20190717T153239Z">
        <seg>图9-1展示了一个Flink独立集群的搭建过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 9-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T153314Z" creationid="xccui" creationdate="20190717T153314Z">
        <seg>图9-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 9-2 shows how a job is submitted to a standalone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T135635Z" creationid="xccui" creationdate="20190717T153707Z">
        <seg>图9-2展示了向独立集群提交作业的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 9-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T153710Z" creationid="xccui" creationdate="20190717T153710Z">
        <seg>图9-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 9-3 shows how a Flink job is submitted to a YARN cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T212015Z" creationid="xccui" creationdate="20190718T212015Z">
        <seg>图9-3展示了向YARN集群提交Flink作业的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 9-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T212332Z" creationid="xccui" creationdate="20190718T212332Z">
        <seg>图9-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 9-4 shows an idle Flink YARN session setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T214338Z" creationid="xccui" creationdate="20190718T214338Z">
        <seg>图9-4展示了一个空闲Flink YARN会话的设置过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 9-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T214341Z" creationid="xccui" creationdate="20190718T214341Z">
        <seg>图9-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 9-5 shows how a job is executed in Flink’s YARN session mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T232028Z" creationid="xccui" creationdate="20190718T232028Z">
        <seg>图9-5展示了如何以会话模式在YARN中执行Flink作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 9-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T232035Z" creationid="xccui" creationdate="20190718T232035Z">
        <seg>示例9-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figures 4-1 to 4-3 illustrate the import process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041557Z" creationid="xccui" creationdate="20190611T041557Z">
        <seg>图4-1到图4-3展示了导入过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File System Configuration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025511Z" creationid="xccui" creationdate="20190225T025511Z">
        <seg>文件系统配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File System Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025157Z" creationid="xccui" creationdate="20190225T025157Z">
        <seg>文件系统汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File System Source Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025149Z" creationid="xccui" creationdate="20190225T025149Z">
        <seg>文件系统源连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FileInputFormat is a specialized InputFormat to read files from a filesystem.4 A FileInputFormat reads files in two steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T191426Z" creationid="xccui" creationdate="20190710T191426Z">
        <seg>FileInputFormat是一个专门用来从文件系统中读文件的InputFormat。4 它的读取过程分为两步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FileProcessingMode</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185024Z" creationid="xccui" creationdate="20190710T185024Z">
        <seg>FileProcessingMode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem Configuration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152252Z" creationid="esouser" creationdate="20190603T152252Z">
        <seg>文件系统配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem Configuration | 237</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042834Z" creationid="xccui" creationdate="20190725T042834Z">
        <seg>文件系统配置 | 237</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055019Z" creationid="esouser" creationdate="20190603T152052Z">
        <seg>文件系统数据汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem Source Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055009Z" creationid="esouser" creationdate="20190603T152039Z">
        <seg>文件系统数据源连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystems are commonly used to store large amounts of data in a cost-efficient way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T183146Z" creationid="xccui" creationdate="20190710T183005Z">
        <seg>文件系统作为一类常见的存储方法，对于大量数据存储的性价比很高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T051132Z" creationid="xccui" creationdate="20190613T051132Z">
        <seg>Filter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Chapter 11 contains resources you can use to ask questions, attend Flink- related events, and learn how Flink is currently being used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T044127Z" creationid="esouser" creationdate="20190603T162637Z">
        <seg>最后在第11章，我们提供了一些资源，以方便你提问、参与Flink相关活动及了解Flink的现实应用场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Chapter 11 contains resources you can use to ask questions, attend Flink-related events, and learn what people use Flink for.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T190926Z" creationid="xccui" creationdate="20190225T190148Z">
        <seg>最后在第11章，我们提供了一些资源，以方便你提问、参与Flink相关活动和了解Flink的现实应用场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Flink’s Kafka sink can be configured to write message timestamps as sup‐ ported since Kafka 0.10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T041654Z" creationid="xccui" creationdate="20190710T040946Z">
        <seg>最后要说的是，Flink的Kafka数据汇可以通过配置，为0.10之后版本的Kafka写入消息时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, TwoPhaseCommitSinkFunction defines five functions that need to be imple‐ mented:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053027Z" creationid="xccui" creationdate="20190716T052556Z">
        <seg>最后我们介绍TwoPhaseCommitSinkFunction中需要实现的五个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, by leveraging an event log as input source the complete input of an applica&lt;t0/&gt;‐&lt;t1/&gt; tion is reliably stored and can be deterministically replayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190312T212958Z" creationid="xccui" creationdate="20190312T212817Z">
        <seg>以事件日志作为应用的输入，不但完整可靠，而且还支持精准的数据重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, if the operator has an incremental aggregation function and a full window function, the full window function is applied on the aggregated value and the result is emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051447Z" creationid="xccui" creationdate="20190625T054251Z">
        <seg>最后，如果算子同时拥有一个增量聚合函数和一个全量窗口函数，那么后者将作用于前者产生的聚合值上，之后便会发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, processing time windows offer a faithful rep&lt;t0/&gt;‐&lt;t1/&gt; resentation of the streams themselves, might also be a desirable property for some use-cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T044817Z" creationid="xccui" creationdate="20190414T044223Z">
        <seg>最后一点，处理时间窗口能够表示数据流自身的真实情况，这可能是某些用例的理想属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, processing-time windows offer a faithful rep‐ resentation of the streams themselves, which might be a desirable property for some use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181009Z" creationid="xccui" creationdate="20190606T031118Z">
        <seg>最后，处理时间窗口能够表示数据流自身的真实情况，这可能会在某些用例中派上用场。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the JobManager submits the job’s tasks to the TaskManagers for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T213044Z" creationid="xccui" creationdate="20190718T213044Z">
        <seg>最后，JobManager将作业任务提交至TaskManager执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the RocksDB state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043650Z" creationid="xccui" creationdate="20190724T043650Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, under Configuration, you can inspect the configuration properties of checkpoints, such as the interval and the timeout values set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T152038Z" creationid="xingcan" creationdate="20190802T152038Z">
        <seg>最后在Configuration中，你可以查看有关检查点的配置属性，例如设置的检查点间隔和超时值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we apply a user-defined function that computes the average temperature on each window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051325Z" creationid="xccui" creationdate="20190612T053852Z">
        <seg>最后我们使用了一个用户自定义函数（user-defined function）来计算每个窗口的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we apply an onComplete() callback on Future and pass the result (or a possi‐ ble exception) to the ResultFuture handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T212525Z" creationid="xccui" creationdate="20190716T212525Z">
        <seg>最终我们调用了Future的onComplete()回调函数，将结果（也可能是异常）传给ResultFuture处理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we briefly discuss the evolution of open source stream processors and help you run a streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T064839Z" creationid="esouser" creationdate="20190603T163101Z">
        <seg>最后，我们将简要回顾开源流处理引擎的演变过程，并帮助你在本地Flink实例上运行一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we briefly discuss the evolution of open source stream processors and help you to run a first streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014510Z" creationid="xccui" creationdate="20190225T223601Z">
        <seg>章节最后，我们会简要回顾开源流处理引擎的衍变，并帮助你在本地Flink实例上运行第一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we discussed the most important configuration options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042039Z" creationid="xccui" creationdate="20190725T042039Z">
        <seg>最后我们讨论了几个重要的配置选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we explain how Flink’s highly available mode works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T045240Z" creationid="xccui" creationdate="20190606T141208Z">
        <seg>最后，我们将解释Flink高可用模式的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we explain how Flink’s highly-available mode works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033313Z" creationid="xccui" creationdate="20190418T033232Z">
        <seg>最后，我们会解释Flink高可用模式的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we learned why state is important in streaming applications and how to guard it against failures and guarantee correct results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T195048Z" creationid="xccui" creationdate="20190606T040520Z">
        <seg>最后我们了解了状态对流式应用的重要性，以及如何应对故障并确保结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we say a big thank you to all the people at O’Reilly who accompanied us on our two and a half year long journey and helped us to push this project over the fin‐ ish line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063113Z" creationid="xccui" creationdate="20190605T134105Z">
        <seg>最后，我们由衷地感谢O'Reilly的相关工作人员：Alicia Young、Colleen Lobner、Christine Edwards、Katherine Tozer、Marie Beaugureau以及Tim McGovern，感谢你们在这两年半旅途中的陪伴，一起协助我们完成这个项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we show how to bootstrap a Flink Maven project, the starting point for a new application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T071657Z" creationid="xccui" creationdate="20190610T040552Z">
        <seg>本章最后我们会介绍如何创建Flink Maven项目，这通常是任何一个新应用的起点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we show how to configure keyed state as queryable and how to access it from an external application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T034640Z">
        <seg>最后，我们将展示怎样将键值分区状态设置为可查询式的以及如何从外部应用中访问它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we took a look at Apache Flink and the extensive features it offers and showed how to install a local Flink setup and run a first stream processing application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T202148Z" creationid="xccui" creationdate="20190605T125759Z">
        <seg>最后我们简单了解了Apache Flink以及它提供的诸多特性，还展示了如何在本地安装设置Flink并运行第一个流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we will discuss how to join streams on time and strategies to handle late events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151956Z" creationid="xccui" creationdate="20190619T053439Z">
        <seg>最后我们会讨论如何基于时间对数据流进行Join以及处理延迟事件的策略。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T214529Z" creationid="xccui" creationdate="20190716T214529Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you can enable and configure local recovery for a Flink cluster by default.7 To enable local recovery, set the parameter state.backend.local-recovery to true.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T045102Z" creationid="xccui" creationdate="20190724T045102Z">
        <seg>最后，你可以通过将参数state.backend.local-recovery设置true，来让Flink集群默认启用和配置本地恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you have seen why state is important in streaming applications and how you can guard it against failures and guarantee correct results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051729Z" creationid="xccui" creationdate="20190416T051720Z">
        <seg>最后你明白了状态对流式应用的重要性，以及如何在故障时保证结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you might also want to configure what happens if a checkpoint fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T033552Z" creationid="xccui" creationdate="20190731T204022Z">
        <seg>最后，你可能还希望在检查点失败后可以触发些什么。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you should stop the local Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045629Z" creationid="xccui" creationdate="20190329T045629Z">
        <seg>最后别忘了停止本地Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you should stop the local Flink cluster:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124426Z" creationid="xccui" creationdate="20190605T124426Z">
        <seg>最后别忘了停止本地Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Find us on Facebook: http://facebook.com/oreilly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210845Z" creationid="esouser" creationdate="20190603T210845Z">
        <seg>Find us on Facebook: http://facebook.com/oreilly</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First Edition</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210730Z" creationid="esouser" creationdate="20190603T210730Z">
        <seg>First Edition</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First it scans a filesystem path and creates so-called input splits for all matching files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T191629Z" creationid="xccui" creationdate="20190710T191629Z">
        <seg>首先，它会扫描文件系统的路径并为所有满足条件的文件创建一些所谓的输入划分（input split）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First of all, it requires two semantically equivalent implementations of the application logic for two separate processing sys&lt;t2/&gt;‐&lt;t3/&gt; tems with different APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T030941Z" creationid="xccui" creationdate="20190327T030811Z">
        <seg>首先，该架构需要在拥有不同API的两套独立处理系统之上实现两次语义相同的应用逻辑；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First of all, it requires two semantically equivalent implementations of the application logic for two separate processing systems with different APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193959Z" creationid="xccui" creationdate="20190605T052927Z">
        <seg>首先，该架构需要在拥有不同API的两套独立处理系统之上实现两套语义相同的应用逻辑；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First of all, the worker deployment specifies two replicas, which means that two worker containers are started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025955Z" creationid="xccui" creationdate="20190720T025955Z">
        <seg>首先，工作进程的Deployment指定了两个副本，因此会启动两个工作容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First research prototypes and com&lt;t0/&gt;‐&lt;t1/&gt; mercial products date back to the late 1990s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T041319Z" creationid="xccui" creationdate="20190319T041302Z">
        <seg>它最初的原型和商业产品可以追溯到上世纪90年代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, Flink compares the unique operator identifiers of the savepoint and application’s operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T045334Z" creationid="xccui" creationdate="20190727T045334Z">
        <seg>首先，Flink会对保存点中的唯一算子标识和应用算子内的进行比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, a savepoint of a running application is taken and then it is used to restore the state in a starting application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214317Z" creationid="xccui" creationdate="20190609T214237Z">
        <seg>首先为正在运行的应用生成一个保存点，然后在应用启动时用它去初始化状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it means that the regular data processing of the application will always compete for resources with the concurrent checkpoint‐ ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T201223Z" creationid="xccui" creationdate="20190731T200953Z">
        <seg>首先它意味着应用内常规的数据处理将始终和并发的检查点生成争夺资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it needs to restart failed pro&lt;t2/&gt;‐&lt;t3/&gt; cesses and second, it needs to restart the application and recover its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205013Z" creationid="xccui" creationdate="20190428T204413Z">
        <seg>一是需要重启故障进程，二是需要重启应用并恢复其状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it should be clear that there is an optimal latency in the case of no load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T204244Z" creationid="xccui" creationdate="20190402T204244Z">
        <seg>首先需要明确的是，在空负载的情况下延迟会达到最优。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it should be clear that there is optimal latency when there is no load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235030Z" creationid="xccui" creationdate="20190605T235030Z">
        <seg>首先需要明确的是，在空负载的情况下延迟会达到最优。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, let’s discuss the software you need to develop Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T040837Z" creationid="xccui" creationdate="20190610T040837Z">
        <seg>首先我们来讨论一下开发Flink应用所需的软件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, let’s have a look at the data type we will be using to represent sensor readings:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035700Z" creationid="xccui" creationdate="20190612T035700Z">
        <seg>首先来看一下传感器读取数据的数据类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, the sink persistently stores the infor‐ mation that the checkpoint was committed and secondly it removes the records from the WAL.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T052909Z" creationid="xccui" creationdate="20190715T051452Z">
        <seg>首先，数据汇需要将检查点已提交的信息持久化；随后，它会从WAL中删除相应的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, we will learn how to define time characteristics, timestamps, and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T033004Z" creationid="xccui" creationdate="20190619T050417Z">
        <seg>本章，我们将首先讲解如何定义时间特征、时间戳及水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you can extend a function class to explicitly provide the TypeInformation of its return type by implementing the ResultTypeQueryable interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061847Z" creationid="xccui" creationdate="20190617T061847Z">
        <seg>首先你可以通过实现ResultTypeQueryable接口来扩展函数，在其中提供返回类型的TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you can parti&lt;t0/&gt;‐&lt;t1/&gt; tion your input data and have tasks of the same operation execute on the data subsets in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032148Z" creationid="xccui" creationdate="20190401T030434Z">
        <seg>首先，你可以将输入数据分组，让同一操作的多个任务并发执行在不同数据子集上，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you can parti‐ tion your input data and have tasks of the same operation execute on the data subsets in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062642Z" creationid="xccui" creationdate="20190605T233227Z">
        <seg>      首先，你可以将输入数据分组，让同一操作的多个任务并行执行在不同数据子集上，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you need to configure the hosts and ports of all ZooKeeper processes involved in the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T161243Z" creationid="xccui" creationdate="20190720T161243Z">
        <seg>首先，你需要在./conf/zoo.cfg文件里配置集群中全部ZooKeeper进程的主机和端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlatMap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053224Z" creationid="xccui" creationdate="20190613T053224Z">
        <seg>FlatMap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142352Z" creationid="esouser" creationdate="20190603T142352Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink  provides different ways to deal with late records, which are discussed in “Handling Late Data” on page 148.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T042933Z" creationid="xccui" creationdate="20190606T205759Z">
        <seg>为了处理迟到记录，Flink提供了不同的机制，我们将在148页"处理迟到数据"一节讨论它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink 1.7 exposes the first version (v1) of the API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T041305Z" creationid="xccui" creationdate="20190729T041305Z">
        <seg>Flink 1.7中公开的是第一版本（v1）的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink DataStream applications process streams of events that are represented as data objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T062416Z" creationid="xccui" creationdate="20190616T062416Z">
        <seg>Flink DataStream应用所处理的事件会表示为数据对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink Docker image but started with a different argument (args: -taskmanager).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T030138Z" creationid="xccui" creationdate="20190720T030054Z">
        <seg>只是启动参数不一样（args: -taskmanager）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink Docker images are not part of the official Apache Flink release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T042550Z" creationid="xccui" creationdate="20190718T042550Z">
        <seg>因此你也可以使用非官方发布版的Apache Flink Docker镜像来提交应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink SQL follows the ANSI SQL standard and leverages Apache Calcite for query parsing and optimization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T161015Z" creationid="xingcan" creationdate="20190807T161015Z">
        <seg>Flink SQL遵循ANSI SQL标准，并使用Apache Calcite来完成查询解析和优化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink Web UI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030126Z" creationid="xccui" creationdate="20190225T030126Z">
        <seg>Flink Web UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink accepts a class as a POJO if it satisfies the following conditions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T042701Z" creationid="xccui" creationdate="20190617T042701Z">
        <seg>如果一个类满足如下条件，Flink就会将它看做POJO：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink achieves millisecond latencies and is able to process millions of events per second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042644Z" creationid="xccui" creationdate="20190328T042616Z">
        <seg>Flink能够实现毫秒级延迟，同时每秒可处理数百万条事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink allows for updating the application code of jobs and migrating jobs to dif&lt;t0/&gt;‐&lt;t1/&gt; ferent Flink clusters without losing the state of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052335Z" creationid="xccui" creationdate="20190328T052036Z">
        <seg>Flink允许在不丢失应用状态的前提下更新作业的程序代码或进行跨Flink集群的作业迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink also</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211241Z" creationid="xccui" creationdate="20190609T211241Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink also aims to keep its own external dependencies to a minimum and hides most of them (including tran‐ sitive dependencies) from user applications to prevent version conflicts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045122Z" creationid="xccui" creationdate="20190619T045122Z">
        <seg>为了尽可能降低自身的外部依赖，Flink将很多依赖（包括传递依赖）都隐藏起来，对用户应用不可见，以此来避免版本冲突。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink also features a type extraction system that analyzes the input and return types of functions to automatically obtain type information and hence serializers and deserial‐ izers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T064254Z" creationid="xccui" creationdate="20190616T064035Z">
        <seg>此外，Flink中还有一个类型提取系统，它可以通过分析函数的输入、输出类型来自动获取类型信息，继而得到相应的序列化器和反序列化器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink also features version-specific connectors for the Kafka ver‐ sions 0.8, 0.9, 0.10, and 0.11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T204401Z" creationid="xccui" creationdate="20190708T204317Z">
        <seg>同时它还为Kafka 0.8、0.9、0.10以及0.11版本分别提供了专用的连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink also features version-specific con‐ nectors for Kafka versions 0.8, 0.9, 0.10, and 0.11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T043520Z" creationid="xccui" creationdate="20190709T043520Z">
        <seg>同时它还为Kafka 0.8、0.9、0.10以及0.11版本分别提供了专用的连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink analyzes each type that does not fall into any category and checks to see if it can be identified and handled as a POJO type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T025520Z" creationid="xccui" creationdate="20190617T042544Z">
        <seg>Flink会分析那些不属于任何一类的数据类型，并尝试将它们作为POJO类型进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink applications are executed in parallel by parallelizing operators into tasks and distributing these tasks across the worker processes in a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T005554Z" creationid="xccui" creationdate="20190730T160637Z">
        <seg>为了实现并行执行，Flink应用会将算子划分为不同的任务，并将这些任务分配到集群中的不同工作进程上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink applications are executed in parallel in a distributed environment such as a cluster of machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050849Z" creationid="xccui" creationdate="20190616T050849Z">
        <seg>Flink应用可以在分布式环境中（例如机器集群）并行执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink applications can be deployed in two different styles.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025403Z" creationid="xccui" creationdate="20190423T025315Z">
        <seg>Flink应用可以通过两种模式进行部署。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink applications can be scaled to run on thousands of cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042749Z" creationid="xccui" creationdate="20190328T042749Z">
        <seg>基于Flink的应用可以扩展到数千核心之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink appli‐ cations can be scaled to run on thousands of cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T055912Z" creationid="xccui" creationdate="20190605T055912Z">
        <seg>基于Flink的应用可以扩展到数千核心之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink can be deployed in different environments, such as a local machine, a bare- metal cluster, a Hadoop YARN cluster, or a Kubernetes cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T151559Z" creationid="xccui" creationdate="20190717T151559Z">
        <seg>Flink支持多种环境下的部署，例如本地机器、裸机集群、Hadoop YARN集群或Kubernetes集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink can run on YARN in two modes: the job mode and the session mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T211227Z" creationid="xccui" creationdate="20190718T211227Z">
        <seg>Flink能够以两种模式和YARN进行集成：作业模式和会话模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink collects several system and application metrics by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T152717Z" creationid="xingcan" creationdate="20190802T152717Z">
        <seg>Flink在默认情况下会收集很多系统及应用指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink configures the interval to the same value as the akka.ask.timeout parameter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T060603Z" creationid="xccui" creationdate="20190721T060516Z">
        <seg>Flink将这个间隔配置得和./conf/flink-conf.yaml中akka.ask.timeout参数的值（默认10秒）相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink creates a separate (embedded) RocksDB instance for each task of a keyed operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T041511Z" creationid="xccui" creationdate="20190724T041440Z">
        <seg>Flink会为每个键值分区算子的任务创建一个单独的（嵌入式）RocksDB实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not actively limit the amount of CPU resources it consumes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T061158Z" creationid="xccui" creationdate="20190723T061125Z">
        <seg>Flink不会主动限制自身消耗的CPU资源量，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not automatically take a save‐ point, so a user (or external scheduler) has to explicitly trigger its creation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210829Z" creationid="xccui" creationdate="20190609T210829Z">
        <seg>保存点的生成不是由Flink自动完成，而是需要由用户（或外部调度器）显式触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not delay explicitly triggered savepoints due to checkpointing opera‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T203406Z" creationid="xccui" creationdate="20190731T203406Z">
        <seg>Flink不会因为生成检查点而推迟显式触发的保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not guarantee or grant heap memory per task or slot.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T034643Z" creationid="xccui" creationdate="20190724T034600Z">
        <seg>Flink无法实现按任务或处理槽分配堆内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not implement all this functionality by itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T031440Z" creationid="xccui" creationdate="20190418T031424Z">
        <seg>Flink并没有依靠自己实现所有上述功能，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not provide durable, distributed storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032116Z" creationid="xccui" creationdate="20190418T032114Z">
        <seg>Flink没有提供分布式持久化存储，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not provide tooling to restart failed processes when running in a stand-alone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T040150Z" creationid="xccui" creationdate="20190504T035856Z">
        <seg>Flink没有针对独立集群模式提供重启故障进程的工具，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not provide tooling to restart failed processes when running in a standalone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195157Z" creationid="xccui" creationdate="20190606T195157Z">
        <seg>Flink没有针对独立集群模式提供重启故障进程的工具，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink encodes timestamps as 16-byte Long values and attaches them as metadata to records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T064555Z" creationid="xccui" creationdate="20190606T204939Z">
        <seg>Flink内部采用16字节的Long值对时间戳进行编码，并将它们以元数据（metadata）的形式附加在记录上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink encodes timestamps as 16-byte long values and attaches them as metadata to records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040434Z" creationid="xccui" creationdate="20190523T040434Z">
        <seg>Flink内部将时间戳编码为16字节的long类型值并将它们以元数据的形式附加在记录之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink exposes all interfaces for user-defined functions, such as MapFunction, Filter Function, and ProcessFunction, as interfaces or abstract classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040659Z" creationid="xccui" creationdate="20190618T053724Z">
        <seg>Flink中所有用户自定义函数（如MapFunction、FilterFunction及ProcessFunction）的接口都是以接口或抽象类的形式对外暴露，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features Kerberos integration with Hadoop and its components (YARN, HDFS, HBase), ZooKeeper, and Kafka.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T022700Z" creationid="xccui" creationdate="20190725T022534Z">
        <seg>它还支持Kerberos与Hadoop及相关组件（YARN、HDFS、HBase）、ZooKeeper以及Kafka的集成，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features an optimization technique called task chaining that reduces the over‐ head of local communication under certain conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T200205Z" creationid="xccui" creationdate="20190606T203214Z">
        <seg>Flink采用一种名为任务链接的优化技术来降低某些情况下的本地通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features an optimization technique called task chaining which reduces the over&lt;t0/&gt;‐&lt;t1/&gt; head of local communication under certain conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151913Z" creationid="esouser" creationdate="20190514T151904Z">
        <seg>Flink利用一项名为任务链接（task chaining）的优化技术来降低部分情况下本地通信的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features dedicated operators for time-based stream joins, which are discussed in Chapter 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151910Z" creationid="xccui" creationdate="20190615T044956Z">
        <seg>Flink对基于时间的流式Join设有专用算子，相关内容会在第6章讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features different techniques to reduce the communication costs between tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T192536Z" creationid="esouser" creationdate="20190513T192536Z">
        <seg>Flink采用多种技术来降低任务之间的通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features layered APIs with varying tradeoffs for expressiveness and ease-of-use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T044046Z" creationid="xccui" creationdate="20190328T042847Z">
        <seg>Flink提供的层次化API，在表达能力和易用性方面各有权衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features multiple &lt;t0/&gt;ResourceManager&lt;t1/&gt;s for different environments and resource providers such as YARN, Mesos, Kubernetes, and stand-alone deploy&lt;t2/&gt;‐&lt;t3/&gt; ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T050208Z" creationid="xccui" creationdate="20190418T050003Z">
        <seg>针对不同的环境和资源提供者（例如：YARN、Mesos、Kubernetes或独立部署），Flink提供了不同的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features multiple ResourceManagers for different environments and resource providers such as YARN, Mesos, Kubernetes, and standalone deploy‐ ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060817Z" creationid="xccui" creationdate="20190606T142057Z">
        <seg>针对不同的环境和资源提供者（resource provider）（如YARN、Mesos、Kubernetes或独立部署），Flink提供了不同的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features savepoints to maintain applications and their states.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T214017Z" creationid="xccui" creationdate="20190702T212746Z">
        <seg>Flink利用保存点机制来对应用及其状态进行维护，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features three restart strategies to address this problem:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T153919Z" creationid="xingcan" creationdate="20190801T152752Z">
        <seg>为应对该问题，Flink提供了三种重启策略：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink follows a simple and low-overhead approach to provide useful latency metric measurements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T053350Z" creationid="xccui" creationdate="20190806T053350Z">
        <seg>为了提供一个实用的延迟指标测量手段，Flink选取了一个非常简单且开销低的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink for a while without ever needing to worry about TypeInformation for your data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T035434Z" creationid="xccui" creationdate="20190617T052631Z">
        <seg>因此你可以先用上一段时间Flink而无需担心数据类型的TypeInformation问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink gathers a set of predefined metrics during runtime and also provides a frame‐ work that allows you to define and track your own metrics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T032335Z" creationid="xccui" creationdate="20190802T032335Z">
        <seg>Flink在运行时会收集一些预定义的指标，此外还供了一个框架供你定义和追踪自定义指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink guarantees this by periodically writing a consistent checkpoint of the application state to a remote and durable storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073626Z" creationid="xccui" creationdate="20190305T032707Z">
        <seg>为了实现该特性，Flink会定期将应用状态的一致性检查点（checkpoint）写入远程持久化存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink has built-in support for local filesystems, including locally mounted net‐ work filesystems, such as NFS or SAN, and does not require additional configu‐ ration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T041833Z" creationid="xccui" creationdate="20190722T041833Z">
        <seg>Flink内部支持本地文件系统，其中还包括本地挂载的网络文件系统（例如NFS或SAN），你无须对它们进行额外配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements a credit-based flow control mechanism that works as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202657Z" creationid="xccui" creationdate="20190606T202654Z">
        <seg>Flink实现了一个基于信用值的流量控制机制，它的工作原理如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements a credit-based flow control mechanism which works as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151603Z" creationid="esouser" creationdate="20190513T210738Z">
        <seg>Flink实现了一个基于信用度的流量控制机制，它的工作原理如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements tweaks that can alleviate the performance impact under certain conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195937Z" creationid="xccui" creationdate="20190609T195841Z">
        <seg>Flink实现了一些调整策略，从而可以减轻某些条件下对性能的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements watermarks as special records that are received and emitted by operator tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T070353Z" creationid="xccui" creationdate="20190529T040724Z">
        <seg>Flink内部将水位线实现为特殊的记录，它们可以通过算子任务进行接收和发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is a distributed data processing system, and as such, has to deal with failures such as killed processes, failing machines, and interrupted network connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T151730Z" creationid="xccui" creationdate="20190608T062326Z">
        <seg>Flink是一个分布式的数据处理系统，因此必须能够处理一些故障，例如：进程被强制关闭、机器故障以及网络连接中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is a distributed system for stateful parallel data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190417T181954Z" creationid="xccui" creationdate="20190417T181954Z">
        <seg>Flink是一个用于状态化并行流处理的分布式系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is a full-fledged batch processor and can be used to implement use cases requir‐ ing one-off or periodic queries on bounded input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T153249Z" creationid="xingcan" creationdate="20190807T153249Z">
        <seg>Flink其实还是一个成熟的批处理引擎，我们可以用它来实现对有界数据的一次性或定期查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is able to run streaming applications 24/7 with very little downtime due to its highly-available setup (no single point of failure), a tight integration with Kubernetes, YARN, and Apache Mesos, fast recovery from failures, and the abil&lt;t0/&gt;‐&lt;t1/&gt; ity to dynamically scale jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052002Z" creationid="xccui" creationdate="20190328T051545Z">
        <seg>Flink支持高可用性配置（无单点失效），和Kubernetes、YARN、Apache Mesos紧密集成，快速故障恢复，动态扩容作业等。基于上述特点，它可以7*24小时运行流式应用，几乎无须停机。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is preconfigured to run a local setup and start a single master and a single Task‐ Manager on the local machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T135943Z" creationid="xccui" creationdate="20190717T175128Z">
        <seg>Flink中预定义的本地设置模式会在本地机器分别启动一个主进程和一个TaskManager，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is well integrated with cluster resource managers, such as Apache Mesos, YARN, and Kubernetes, but can also be configured to run as a stand- alone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T044510Z" creationid="xccui" creationdate="20190606T140736Z">
        <seg>Flink和很多集群管理器（cluster resource manager）（如Apache Mesos、YARN及Kubernetes）都能很好地集成；同时它也可以通过配置，作为独立集群来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is well integrated with cluster resource managers, such as Apache Mesos, YARN, and Kubernetes, but can also be configured to run as a stand-alone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032041Z" creationid="xccui" creationdate="20190418T032041Z">
        <seg>Flink和很多集群管理器，例如：Apache Mesos、YARN、Kubernetes，都有很好地集成；同时它也可以通过配置以独立集群模式运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink joined the Apache Software Foun&lt;t2/&gt;‐&lt;t3/&gt; dation as an incubating project in April 2014 and became a top-level project in January 2015.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T192355Z" creationid="xccui" creationdate="20190225T192355Z">
        <seg>Flink于2014年4月以孵化项目的形式进入Apache软件基金会，并在次年1月就成为了顶级项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink joined the Apache Software Foun‐ dation as an incubating project in April 2014 and became a top-level project in January 2015.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T045323Z" creationid="esouser" creationdate="20190603T162828Z">
        <seg>Flink于2014年4月以孵化项目的形式进入Apache软件基金会，并在次年一月就成为了顶级项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink knows about Hadoop’s configuration, it can connect to YARN’s ResourceMan‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T145935Z" creationid="xccui" creationdate="20190722T030835Z">
        <seg>一旦取得Hadoop的配置，Flink就可以连接YARN的ResourceManager和HDFS。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink maintains one state instance per key value and parti‐ tions all records with the same key to the operator task that maintains the state for this key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061211Z" creationid="xccui" creationdate="20190607T190646Z">
        <seg>Flink为每个键值都维护了一个状态实例，该实例总是位于那个处理对应键值记录的算子任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink master deployment so that the workers can access the master.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T031626Z" creationid="xccui" creationdate="20190720T031626Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink metrics are registered and accessed through the MetricGroup interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T023625Z" creationid="xccui" creationdate="20190803T023625Z">
        <seg>Flink指标需要通过MetricGroup接口注册和访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink metrics belong to a scope, which can be either the system scope, for system- provided metrics, or the user scope for custom, user-defined metrics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T215424Z" creationid="xccui" creationdate="20190803T215424Z">
        <seg>Flink的指标都有各自所属的域（scope），系统指标所属的域被称为系统域，用户自定义指标所属的域被称为用户域。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink needs to create a suitable serializer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T071403Z" creationid="xccui" creationdate="20190630T071403Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink offers a few options to configure how state backends checkpoint their state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043901Z" creationid="xccui" creationdate="20190724T043901Z">
        <seg>Flink针对状态后端如何将状态写入检查点提供了很多配置项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink offers different strategies to handle such late events, and we discuss those later in “Handling Late Data” on page 148.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T060103Z" creationid="xccui" creationdate="20190620T053636Z">
        <seg>Flink为处理此类迟到事件提供了不同的策略，我们稍后将在148页"处理迟到数据"中对它们进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink offers good answers to all of these requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033243Z" creationid="xccui" creationdate="20190319T033237Z">
        <seg>Flink 能够完美满足上述需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink offers three primitives for operator state:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060419Z" creationid="xccui" creationdate="20190607T061925Z">
        <seg>Flink为算子状态提供了三类原语：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink powers large-scale business-critical applications in many companies and enterprises across different industries and around the globe.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T220902Z" creationid="xccui" creationdate="20190225T220902Z">
        <seg>全球各行各业很多公司和企业的大型核心业务应用都是基于Flink完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink powers large-scale, business-critical applications in many companies and enterprises across different industries and around the globe.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063351Z" creationid="esouser" creationdate="20190603T162927Z">
        <seg>全球很多不同行业的公司和企业都在使用Flink支撑其大规模核心业务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink programs are executed lazily.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T052154Z" creationid="xccui" creationdate="20190613T010906Z">
        <seg>Flink程序都是通过延迟计算（lazily execute）的方式执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides Maven archetypes to generate Maven projects for Java or Scala Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004621Z" creationid="xccui" creationdate="20190612T004239Z">
        <seg>Flink提供了Maven模板来为Java或Scala的Flink应用生成Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides a connector to Swift FS, which is based on Apache Hadoop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T044022Z" creationid="xccui" creationdate="20190722T044022Z">
        <seg>Flink提供了一个基于Apache Hadoop的Swift FS连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides a couple of parameters to tune checkpointing and state backends.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T025614Z" creationid="xccui" creationdate="20190731T025614Z">
        <seg>Flink提供了一系列用于调整检查点和状态后端的参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides a few configuration options in ./conf/flink-conf.yaml to specify a default filesystem and limit the number of filesystem connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T044954Z" creationid="xccui" creationdate="20190722T044954Z">
        <seg>Flink在./conf/flink-conf.yaml中提供了一些配置项，可用来指定默认的文件系统并限制文件系统连接数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides a few predefined settings to improve the performance for com‐ mon hardware setups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030722Z" creationid="xccui" creationdate="20190801T030722Z">
        <seg>为了提高针对常见硬件的性能，Flink提供了一系列预定义设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides a mechanism to avoid such situations by marking source functions as temporarily idle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T043818Z" creationid="xccui" creationdate="20190713T043818Z">
        <seg>为了避免该情况，Flink提供了一个机制，可以将数据源函数标记为暂时空闲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides a sink connector to write data streams to Cassandra.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T201521Z" creationid="xccui" creationdate="20190711T201521Z">
        <seg>Flink提供了一个用于将数据流写入Cassandra的数据汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides a universal Kafka connector that works for all Kafka versions since 0.11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T204323Z" creationid="xccui" creationdate="20190708T204303Z">
        <seg>Flink提供了一个通用的Kafka连接器，可用于Kafka 0.11之后的版本；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides a well-maintained collection of stream sinks that can be used to write data to different systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054203Z" creationid="xccui" creationdate="20190612T054203Z">
        <seg>Flink提供了一组维护良好的流式数据汇，可用来完成上述工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides builds for the most commonly used vanilla Hadoop versions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T010850Z" creationid="xccui" creationdate="20190722T010850Z">
        <seg>Flink为最常使用的Vanilla Hadoop版本都提供了相应的构建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides built-in window assigners for the most common windowing use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T024503Z" creationid="xccui" creationdate="20190623T024503Z">
        <seg>Flink为一些最常见的窗口使用场景提供了内置窗口分配器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides connectors for Apache Kafka, Kinesis, RabbitMQ, Apache Nifi, vari‐ ous filesystems, Cassandra, ElasticSearch, and JDBC.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T195400Z" creationid="xccui" creationdate="20190708T195400Z">
        <seg>Flink为Apache Kafka、Kinesis、RabbitMQ、Apache Nifi、多种文件系统、Apache Cassandra、ElasticSearch以及JDBC都提供了相应的连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides connectors to the most commonly used storage systems such as Apache Kafka, Apache Cassandra, Elasticsearch, JDBC, Kinesis, and (distributed) file systems such as HDFS and S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T045210Z" creationid="xccui" creationdate="20190328T044823Z">
        <seg>Flink提供了一些用于最常见存储系统的连接器，如Apache Kafka、Apache Cassandra、Elasticsearch、JDBC、Kinesis以及（分布式）文件系统（HDFS和S3等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides different mechanisms to deal with late records which are dis&lt;t8/&gt;‐&lt;t9/&gt; cussed in &lt;t10/&gt;Chapter 6&lt;t11/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035634Z" creationid="xccui" creationdate="20190529T035619Z">
        <seg>为了处理迟到记录，Flink提供了不同的机制，我们将在第6章讨论它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides different primitives for keyed state that determine the type of the value stored for each key in this distributed key-value map.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061405Z" creationid="xccui" creationdate="20190607T192242Z">
        <seg>Flink为键值分区状态提供了不同原语，它们的区别在于分布式键值映射中每个键所对应存储值的类型不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides different sink implementations to write data streams of different data types to Cassandra.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210219Z" creationid="xccui" creationdate="20190711T210219Z">
        <seg>Flink为写入Cassandra的不同类型的数据流提供了不同的数据汇实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides efficient implementations of Java tuples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T071300Z" creationid="xccui" creationdate="20190616T071153Z">
        <seg>Flink提供了Java元组的高效实现，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides implementations for the most commonly used filesystems as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T041700Z" creationid="xccui" creationdate="20190722T041700Z">
        <seg>Flink为一些常用的文件系统都提供了对应的实现，具体如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides intuitive and easy-to-use primitives for common event-time process&lt;t0/&gt;‐&lt;t1/&gt; ing operations but also exposes expressive APIs to implement more advanced event-time applications with custom operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T034459Z" creationid="xccui" creationdate="20190523T034002Z">
        <seg>Flink不仅针对常见的事件时间操作提供了直观且易用的原语，还支持一些表达能力很强API，允许使用者以自定义算子的方式实现更高级的事件时间处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides intuitive and easy-to-use primitives for common event-time process‐ ing operations but also exposes expressive APIs to implement more advanced event- time applications with custom operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204453Z" creationid="xccui" creationdate="20190606T204427Z">
        <seg>Flink不仅针对常见的事件时间操作提供了直观易用的原语，还支持一些表达能力很强API，允许使用者以自定义算子的方式实现更高级的事件时间处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides more tuning knobs to configure the checkpointing behavior, such as the choice of consistency guarantees (exactly-once or at-least-once), the number of concurrent checkpoints, and a timeout to cancel long-running checkpoints, as well as several state backend–specific options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T014123Z" creationid="xccui" creationdate="20190702T211038Z">
        <seg>Flink还为检查点行为提供了其它一些可供调节的配置选项，例如：一致性保障（精确一次或至少一次）的选择，检查点的并行数量以及用来取消长时间运行检查点的超时时间，此外还有多个和状态后端相关的选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides multiple interfaces to define stateful functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T213817Z" creationid="xccui" creationdate="20190630T035109Z">
        <seg>Flink为定义状态化函数提供了多个接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides multiple primitives for keyed state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T040825Z">
        <seg>Flink为键值分区状态提供了很多原语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides sink connectors for all Kafka versions since 0.8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T043315Z" creationid="xccui" creationdate="20190709T043315Z">
        <seg>Flink为Kafka 0.8之后的所有版本都提供了数据汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides source connectors for all common Kafka versions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T203041Z" creationid="xccui" creationdate="20190708T203041Z">
        <seg>Flink为所有常见的Kafka版本都提供了数据源连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides state backends that manage keyed state as objects stored in in-memory data structures on the JVM heap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190608T052050Z">
        <seg>Flink提供的一类状态后端会把键值分区状态作为对象，以内存数据结构的形式存在JVM堆里面；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides templates for the YAML files provided in the source distribution or found in the project’s Git repository.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T043757Z" creationid="xccui" creationdate="20190730T043757Z">
        <seg>Flink在源码发行版以及项目Git仓库中提供了YAML文件模板。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides the AssignerWithPunctuatedWatermarks interface for such cases, or when watermarks can be defined based on some other property of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T060215Z" creationid="xccui" creationdate="20190620T054023Z">
        <seg>Flink为此类情形以及可根据输入元素生成水位线的情形提供了AssignerWithPunctuatedWatermarks接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides the TwoPhaseCommitSinkFunction interface to ease the implementa‐ tion of sink functions that provide end-to-end exactly-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T194912Z" creationid="xccui" creationdate="20190715T194552Z">
        <seg>我们可以利用Flink内置的TwoPhaseCommitSinkFunction接口来方便地实现提供端到端精确一次语义保障的数据汇函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides two alternative filesystem connectors to connect to S3, which are based on Apache Hadoop and Presto.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T042715Z" creationid="xccui" creationdate="20190722T042715Z">
        <seg>Flink分别基于Apache Hadoop和Presto实现了两个可选的S3文件系统连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides two building blocks to implement transactional sink connectors—a generic write-ahead-log (WAL) sink and a two-phase-commit (2PC) sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T161602Z" creationid="xccui" creationdate="20190708T074124Z">
        <seg>Flink提供了两个构件来实现事务性的数据汇连接器——通用的WAL（write-ahead-log，写前日志）数据汇以及一个2PC（two-phase-commit，两阶段提交）数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides two utility classes for Java and Scala with static methods to generate a TypeInformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053425Z" creationid="xccui" creationdate="20190617T053425Z">
        <seg>Flink为Java和Scala提供了两个工具类，其中的静态方法可以用来生成TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides unified syntax and semantics for batch and streaming queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T161106Z" creationid="xingcan" creationdate="20190807T161106Z">
        <seg>Flink为批式和流式查询提供了统一的语法和语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink pro‐ vides configuration options to improve the efficiency by preregis‐ tering classes to Kryo.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070043Z" creationid="xccui" creationdate="20190616T065724Z">
        <seg>为了提高效率，Flink提供配置选项可以提前将类在Kryo中注册好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink pro‐ vides parameters to address these situations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T032137Z" creationid="xccui" creationdate="20190731T201805Z">
        <seg>Flink提供了一系列参数来处理此类情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink registers the classes of every job into a separate user-code classloader to ensure the dependencies of the job do not infer with Flink’s runtime dependencies or the dependencies of other jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T045138Z" creationid="xccui" creationdate="20190723T045138Z">
        <seg>Flink会将每个作业的类注册到一个独立的用户代码类加载器中，这样可以保证作业依赖不会对Flink运行时或其他作业的依赖带来干扰。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink requires a sufficient number of network buffers to be able to ship records from one worker process to the other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T035258Z" creationid="xccui" creationdate="20190724T035258Z">
        <seg>为了顺利将记录在工作进程之间传输，Flink需要足够数量的网络缓冲区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink restricts access to timestamps or watermarks through the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T052705Z" creationid="xccui" creationdate="20190607T012506Z">
        <seg>Flink对通过DataStream API访问时间戳和水位线有一定限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink restricts the access to timestamps or watermarks through the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042520Z" creationid="xccui" creationdate="20190529T042453Z">
        <seg>Flink限制通过DataStream API访问时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink serializes all function objects with Java serialization to ship them to the worker processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055202Z" creationid="xccui" creationdate="20190618T055202Z">
        <seg>Flink会利用Java序列化机制将所有函数对象序列化后发送到对应的工作进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink serves the REST API and the Web UI from the same web server, which runs as part of the Dispatcher process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T040748Z" creationid="xccui" creationdate="20190729T040050Z">
        <seg>Flink使用一个Web服务器来同时支持REST API和Web UI，该服务器会作为Dispatcher进程的一部分来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports Scala case classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040631Z" creationid="xccui" creationdate="20190617T040631Z">
        <seg>Flink对Scala样例类也提供了相应支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports a feature called local recovery to significantly speed up recovery if the application can be restarted on the same machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T155729Z" creationid="xingcan" creationdate="20190801T155729Z">
        <seg>Flink支持一种称为本地恢复的特性，能够在应用从相同机器重启时显著提高恢复速度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports a wide variety of filesystems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T150016Z" creationid="xccui" creationdate="20190722T031543Z">
        <seg>Flink支持的文件系统种类很多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports all common data types that are available in Java and Scala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T064957Z" creationid="xccui" creationdate="20190616T064910Z">
        <seg>Flink支持Java和Scala中所有常见数据类型，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports compressed checkpoints and savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T033842Z" creationid="xccui" creationdate="20190731T204526Z">
        <seg>Flink支持对检查点和保存点进行压缩，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports different</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T184715Z" creationid="xccui" creationdate="20190710T184715Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports event-time and processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T041957Z" creationid="xccui" creationdate="20190328T041957Z">
        <seg>Flink同时支持事件时间和处理时间语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports exactly-once state consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042435Z" creationid="xccui" creationdate="20190328T042435Z">
        <seg>Flink提供精确一次的状态一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports four patterns for scaling different types of state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062047Z" creationid="xccui" creationdate="20190608T054918Z">
        <seg>Flink对不同类型的状态提供了四种扩缩容模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports many data types, which we describe in the next section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T050747Z" creationid="xccui" creationdate="20190612T051624Z">
        <seg>Flink支持很多数据类型，我们会在下一节介绍它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports mutual authentication of communication partners and encryption of network communication with SSL for internal and external communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T023545Z" creationid="xccui" creationdate="20190725T023545Z">
        <seg>Flink支持通信伙伴之间的身份验证，还允许对内部或外部的网络通信进行SSL加密。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports several special-purpose types, such as primitive and object Array types; Java’s ArrayList, HashMap, and Enum types; and Hadoop Writable types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T034315Z" creationid="xccui" creationdate="20190617T045914Z">
        <seg>Flink支持多种具有特殊用途的类型，例如：原始或对象类型的数组，Java的ArrayList、HashMap及Enum，Hadoop的Writable类型等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports such updates by taking a savepoint of a running application, stopping it, and starting a new version of the application from the savepoint.5 However, updat‐ ing an application while preserving its state is only possible for certain application changes—the original application and its new version need to be savepoint compati‐ ble.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035413Z" creationid="xccui" creationdate="20190705T022928Z">
        <seg>Flink可以通过为运行的应用生成保存点，停止该应用，重启新版本等三个步骤来实现此类更新。5 然而这种保留状态的应用更新对应用改动也有一些限制——原始应用和新版本应用的检查点必须兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports two authentication modes—keytabs and Hadoop delegation tokens.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T022808Z" creationid="xccui" creationdate="20190725T022633Z">
        <seg>Flink支持两种身份验证模式——keytabs和Hadoop委托令牌（delegation token）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink treats all states—regardless of built-in or user-defined operators—the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055727Z" creationid="xccui" creationdate="20190607T053200Z">
        <seg>无论是内置状态还是用户自定义状态，Flink对它们都一直同仁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink uses ZooKeeper for leader election and as a highly available and durable datastore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072949Z" creationid="xccui" creationdate="20190606T150002Z">
        <seg>它在Flink中主要用于"领导"选举以及持久且高可用的数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink uses ZooKeeper for leader election and as a highly-available and durable data store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T045628Z" creationid="xccui" creationdate="20190502T045316Z">
        <seg>它在Flink中用于"领导"选举以及高可用性数据持久化存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink uses the concept of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T063852Z" creationid="xccui" creationdate="20190616T063852Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink will do all the hard work so you can easily monitor, operate, and reconfigure your jobs with minimal effort while preserving exactly-once state semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T160717Z" creationid="xccui" creationdate="20190725T050842Z">
        <seg>Flink将替你完成全部棘手的工作，你可以在轻松地监控、操纵并重新配置作业的同时享受精确一次状态语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink will exclude stream partitions produced by idle source functions from the watermark computation of subsequent operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034703Z" creationid="xccui" creationdate="20190607T034613Z">
        <seg>Flink会在后续算子计算水位线的时候把那些来自于空闲源函数的流分区排除在外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink will never evaluate empty windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T035219Z" creationid="xccui" creationdate="20190623T033506Z">
        <seg>Flink永远不会对空窗口执行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlinkCEP for Complex Event Processing and Pattern Matching</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152541Z" creationid="esouser" creationdate="20190603T152541Z">
        <seg>用于复杂事件处理和模式匹配的FlinkCEP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlinkCEP is a high-level API and library for complex event pattern detection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T161904Z" creationid="xingcan" creationdate="20190807T161904Z">
        <seg>FlinkCEP是一个用于复杂事件模式检测的高层次的API库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlinkKafkaConsumer.setStartFromEarliest()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040250Z" creationid="xccui" creationdate="20190709T040250Z">
        <seg>FlinkKafkaConsumer.setStartFromEarliest()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlinkKafkaConsumer.setStartFromLatest()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040318Z" creationid="xccui" creationdate="20190709T040318Z">
        <seg>FlinkKafkaConsumer.setStartFromLatest()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlinkKafkaConsumer.setStartFromSpecificOffsets(Map)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040532Z" creationid="xccui" creationdate="20190709T040532Z">
        <seg>FlinkKafkaConsumer.setStartFromSpecificOffsets(Map)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlinkKafkaConsumer.setStartFromTimestamp(long)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040434Z" creationid="xccui" creationdate="20190709T040434Z">
        <seg>FlinkKafkaConsumer.setStartFromTimestamp(long)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlinkKafkaPartitioner can be defined in some con‐ structors of the Flink Kafka sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T034103Z" creationid="xccui" creationdate="20190710T034103Z">
        <seg>它的某些构造函数允许你定义FlinkKafkaPartitioner。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlinkKafkaProducer provides more constructors with different combinations of arguments as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T150414Z" creationid="xingcan" creationdate="20190709T150414Z">
        <seg>FlinkKafkaProducer还提供了很多具有不同参数组合的构造方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s CLI client at ./bin/flink, manage running applications, or request information about the cluster or running applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T140838Z" creationid="xccui" creationdate="20190718T042807Z">
        <seg>Flink的CLI（命令行界面）客户端位于./bin/flink，它可以用来管理当前正在运行的应用，也可以通过请求获取有关集群或当前运行应用的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s CLI client supports many more parameters, such as the ability to control the memory of TaskManager containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T012902Z" creationid="xccui" creationdate="20190719T012541Z">
        <seg>Flink的CLI客户端还支持很多参数，例如用于控制TaskManager容器内存大小的参数等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s Checkpointing Algorithm</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T212839Z" creationid="xccui" creationdate="20190225T022209Z">
        <seg>Flink检查点算法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s DataStream API features two built-in operators to join streams with a temporal condition: the interval join and the window join.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T212016Z" creationid="xccui" creationdate="20190627T210453Z">
        <seg>Flink DataStream API中内置有两个可以根据时间条件对数据流进行Join的算子：基于间隔的Join和基于窗口的Join。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s DataStream API is available for Java and Scala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T072040Z" creationid="xccui" creationdate="20190611T014730Z">
        <seg>Flink DataStream API支持Java和Scala语言，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s Data‐ Stream API offers the ProcessWindowFunction to perform arbitrary computations on the contents of a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T211933Z" creationid="xccui" creationdate="20190624T010127Z">
        <seg>Flink DataStream API提供的ProcessWindowFunction可以对窗口内容执行任意计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s HA mode relies on Apache ZooKeeper, a service for distributed coordination and consistent storage, and a persistent remote storage, such as HDFS, NFS, or S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T043622Z" creationid="xccui" creationdate="20190720T043622Z">
        <seg>Flink的HA模式需要依赖Apache ZooKeeper（一项可用于分布式协调和一致性存储的服务）以及某种持久化远程存储（例如HDFS、NFS或S3）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s JVM</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T044101Z" creationid="xccui" creationdate="20190723T044101Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s Java tuples and Row type and Scala’s built-in tuples and case classes are handled differently than user-defined POJO types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T054336Z" creationid="xccui" creationdate="20190711T210359Z">
        <seg>Java元组、Row类型以及Scala的内置元组和样例类，与用户自定义POJO类型的处理方式有所差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s Java tuples can have up to 25 fields, with each length is implemented as a separate class—Tuple1, Tuple2, up to Tuple25.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T015545Z" creationid="xccui" creationdate="20190616T071356Z">
        <seg>它最多可包含25个字段，每个字段长度都对应一个单独的实现类——Tuple1、Tuple2直到Tuple25。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s JobManager holds metadata about an application and its execution, such as the application JAR file, the JobGraph, and pointers to completed checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T043352Z" creationid="xccui" creationdate="20190720T043352Z">
        <seg>Flink的JobManager中存放了应用以及和它执行有关的元数据，例如应用的JAR文件、JobGraph以及已完成检查点的路径信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s batch processing API, the DataSet API, and the runtime are separate from their corresponding stream&lt;t0/&gt;‐&lt;t1/&gt; ing counterparts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060914Z" creationid="xccui" creationdate="20190328T060503Z">
        <seg>虽然Flink用于批处理的DataSet API以及它的运行时环境都独立于对应的流处理部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s built-in window assigners create windows of type TimeWindow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041448Z" creationid="xccui" creationdate="20190623T041416Z">
        <seg>Flink内置窗口分配器所创建的窗口类型为TimeWindow。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s checkpointing algorithm produces consistent distributed checkpoints from streaming applications without stopping the whole application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195749Z" creationid="xccui" creationdate="20190609T195709Z">
        <seg>虽然Flink的检查点算法能够在不停止整个应用的情况下为流式应用生成一致的分布式检查点，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s checkpointing algorithm uses a special type of record called a checkpoint bar‐ rier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060715Z" creationid="xccui" creationdate="20190609T060148Z">
        <seg>Flink的检查点算法中会用到一类名为检查点分隔符（checkpoint barrier）的特殊记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s checkpointing is enabled and all sources of the application are resettable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T154054Z" creationid="xingcan" creationdate="20190709T154054Z">
        <seg>Flink的检查点功能处于开启状态，应用所有的数据源都是可重置的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s command-line client provides the functionality to start, stop, and manage Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T165610Z" creationid="xccui" creationdate="20190726T021401Z">
        <seg>Flink命令行客户端提供了启动、停止和管理Flink应用的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s connector for HDFS is always in the classpath of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T042126Z" creationid="xccui" creationdate="20190722T042028Z">
        <seg>虽然Flink的HDFS连接器始终存在于Classpath中，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s default configuration for network buffers is sufficient for small to medium-sized setups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045743Z" creationid="xccui" creationdate="20190504T045713Z">
        <seg>Flink默认的网络缓冲区配置足以应对中小型设置场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s default configuration for network buffers is sufficient for small- to medium-sized set‐ ups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193744Z" creationid="xccui" creationdate="20190606T201811Z">
        <seg>Flink默认的网络缓冲区配置足以应对中小型使用场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s default configuration is only suitable for a smaller scale distributed setup and needs to be adjusted for more serious scale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T151640Z" creationid="xccui" creationdate="20190724T035918Z">
        <seg>Flink默认配置仅适用于规模较小的分布式环境，若想在更"真实"的规模下使用则需要一定调整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s default task scheduling strategy assigns a complete slice of a program—up to one task of each operator of an application to a single processing slot.2 Depending on the complexity of the application and the computational costs of the operators, this default strategy can overload a processing slot.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T002208Z" creationid="xccui" creationdate="20190730T205903Z">
        <seg>Flink默认任务调度策略会将一个完整的程序分片（包含每个应用算子最多一个任务）分配到一个处理槽中。2 根据应用的复杂度以及算子的计算成本，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s design aims to reduce synchronization points.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T184448Z" creationid="xccui" creationdate="20190702T163613Z">
        <seg>Flink的设计旨在减少同步点的数量，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s high-availability mode is based on &lt;t0/&gt;Apache ZooKeeper&lt;t1/&gt;, a system for distributed services that require coordination and consensus.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T045126Z" creationid="xccui" creationdate="20190502T045126Z">
        <seg>Flink的高可用模式是基于能够提供分布式协调和共识服务的Apache ZooKeeper系统来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s high-availability mode is based on Apache ZooKeeper, a system for distributed services that require coordination and consensus.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072755Z" creationid="xccui" creationdate="20190606T145941Z">
        <seg>Flink中的高可用模式是基于能够提供分布式协调和共识服务的Apache ZooKeeper来完成的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s high-level APIs and interfaces are well integrated with each other and with the DataStream and DataSet APIs so that you can easily mix them and switch between libraries and APIs in the same program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T163436Z" creationid="xingcan" creationdate="20190807T163436Z">
        <seg>Flink的高层API及接口彼此之间，以及和DataStream、DataSet API都有良好的集成，因此你可以轻松将它们混在一起使用，并在同一个程序对API或库进行自由切换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s histogram is especially implemented for reporting metrics on long values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T032606Z" creationid="xccui" creationdate="20190803T032606Z">
        <seg>Flink的直方图特别适合用来报告Long类型的指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s master and worker processes have different memory requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T062548Z" creationid="xccui" creationdate="20190723T062548Z">
        <seg>Flink的主进程和工作进程对内存有着不同需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s master process is started as a YARN ApplicationMaster.5 YARN automatically restarts a failed ApplicationMaster but tracks and limits the number of restarts to pre‐ vent infinite recovery cycles.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052458Z" creationid="xccui" creationdate="20190721T052210Z">
        <seg>Flink的主进程是作为YARN ApplicationMaster启动的。5 YARN会自动重启故障的ApplicationMaster，但会跟踪并限制重启次数以防出现无限制的恢复循环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s mechanism to manually con‐ trol the assignment of tasks to slots is slot-sharing groups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T011149Z" creationid="xccui" creationdate="20190730T205910Z">
        <seg>Flink提供了处理槽共享组（slot-sharing group）机制，允许用户手工将任务分配到处理槽中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s network stack is based on the Netty library, which allocates network buffers from native (off-heap) memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T035137Z" creationid="xccui" creationdate="20190724T035137Z">
        <seg>Flink的网络栈基于Netty库，它会从本地（堆外）内存分配网络缓冲区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s queryable state service consists of three processes:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T195155Z" creationid="xccui" creationdate="20190705T195155Z">
        <seg>Flink的可查询式状态服务包含三个进程：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s recovery algorithm is based on state checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T065940Z" creationid="xccui" creationdate="20190609T205357Z">
        <seg>Flink的故障恢复算法是基于状态的检查点来完成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s recovery mechanism is based on consistent application checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T064354Z" creationid="xccui" creationdate="20190609T054558Z">
        <seg>Flink的故障恢复机制需要基于应用的一致性检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s recovery mechanism is based on consistent checkpoints of application state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T063405Z" creationid="xccui" creationdate="20190608T154504Z">
        <seg>Flink的故障恢复机制需要基于应用状态的一致性检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s relational APIs, SQL and the LINQ-style Table API, are not discussed in this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195721Z" creationid="xccui" creationdate="20190328T044231Z">
        <seg>而Flink的关系型API——SQL及LINQ风格的Table API，并没有在书中过多涉及。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s state backends (except for MemoryStateBackend) store checkpoints in a remote filesystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154901Z" creationid="xingcan" creationdate="20190801T154901Z">
        <seg>Flink的状态后端（MemoryStateBackend除外）都会将检查点存到远程文件系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s system class loader loads all JAR files in the ./lib folder and the user-code classloaders are derived from the sys‐ tem classloader.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T150934Z" creationid="xccui" creationdate="20190723T050829Z">
        <seg>Flink的系统类加载器会从./lib目录中加载全部JAR文件，同时用户代码类加载器也是由类加载器衍生而出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s type extractor leverages reflection and analyzes function signatures and subclass information to derive the correct output type of a user-defined function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T035716Z" creationid="xccui" creationdate="20190617T060529Z">
        <seg>Flink的类型提取器会利用反射以及分析函数签名和子类信息的方式，从用户自定义函数中提取正确的输出类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s type system will automatically generate serializers that can read previous versions of the data type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T053423Z" creationid="xccui" creationdate="20190705T053423Z">
        <seg>Flink的类型系统将自动生成可以读取之前版本数据类型的序列化器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s watermark-handling and propagation algorithm ensures operator tasks emit properly aligned timestamped records and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T031249Z" creationid="xccui" creationdate="20190607T031249Z">
        <seg>Flink的水位线处理和传播算法保证了算子任务所发出的记录时间戳和水位线一定会对齐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Float)] is written into the “sensors” table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210731Z" creationid="xccui" creationdate="20190711T210731Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Follow the authors on Twitter: @fhueske and @vkalavri</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210848Z" creationid="esouser" creationdate="20190603T210848Z">
        <seg>Follow the authors on Twitter: @fhueske and @vkalavri</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Follow us on Twitter: http://twitter.com/oreillymedia</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210846Z" creationid="esouser" creationdate="20190603T210846Z">
        <seg>Follow us on Twitter: http://twitter.com/oreillymedia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T050329Z" creationid="xccui" creationdate="20190617T050329Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Java, the helper class is org.apache.flink.api.common.type info.Types, and it is used as shown in the following examples:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053757Z" creationid="xccui" creationdate="20190617T053555Z">
        <seg>Java中的这个辅助类是org.apache.flink.api.common.typeInfo.Types，它的用法如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a local Docker setup you have to start two types of containers, a master container that runs the Dispatcher and ResourceManager, and one or more worker containers that run the TaskManagers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T022213Z" creationid="xccui" creationdate="20190718T022213Z">
        <seg>对于本地Docker设置，你需要启动两类容器——一个运行Dispatcher和ResourceManager的主容器（master container）以及多个运行TaskManager的工作容器（worker container）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a sliding window, you have to specify a window size and a slide interval that defines how frequently a new window is started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055016Z" creationid="xccui" creationdate="20190623T055016Z">
        <seg>对于滑动窗口而言，你需要指定窗口大小以及用于定义新窗口开始频率的滑动间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all actions you want to apply to a running job, you need to provide a JobID that identifies the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T032838Z" creationid="xccui" creationdate="20190726T032838Z">
        <seg>为了对正在运行的作业执行任何操作，你都需要提供一个用来指定应用的JobID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For almost 40 years, O’Reilly has provided technology and    business training, knowledge, and insight to help companies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210829Z" creationid="esouser" creationdate="20190603T210829Z">
        <seg>For almost 40 years, O’Reilly has provided technology and    business training, knowledge, and insight to help companies</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an application that computes the average temper‐ ature per sensor and minute, a deterministic key could be the ID of the sensor and the timestamp for each minute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T043343Z" creationid="xccui" creationdate="20190714T043343Z">
        <seg>对于每分钟为每个传感器计算平均温度的应用而言，其确定的键值可以由传感器ID和每分钟的时间戳组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For applications that require very low latency and can tolerate at-least-once state guarantees, Flink can be configured to process all arriving records during buffer alignment instead of buffering those for which the barrier has already arrived.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T065745Z" creationid="xccui" creationdate="20190609T204517Z">
        <seg>对于那些需要极低延迟且能容忍至少一次状态保障的应用，可以通过配置让Flink在分隔符对齐的过程中不缓冲那些已收到分隔符所对应分区的记录，而是直接处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For appli‐ cations with several partitioning steps, this quadratic dependency can quickly sum up to a significant amount of memory that is required for network transfer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T035645Z" creationid="xccui" creationdate="20190724T035645Z">
        <seg>而对于包含多次分区的应用，这样的平方依赖会很快占用大量的网络传输内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For batch applications, we usually care about the total execution time of a job, or how long it takes for our processing engine to read the input, perform the computation, and write back the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050454Z" creationid="xccui" creationdate="20190401T150338Z">
        <seg>对批处理应用而言，我们通常会关心作业的总执行时间，或者说处理引擎读取输入、执行计算、写回结果共需多长时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For both setups—job and session mode—failed TaskManagers will be automatically restarted by Flink’s ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T232333Z" creationid="xccui" creationdate="20190718T232333Z">
        <seg>无论是作业模式还是会话模式，Flink的ResourceManager都会自动对故障的TaskManager进行重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each checkpoint, the sink starts a transaction and appends all received records to the transaction, writing them to the sink system without committing them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T162045Z" creationid="xccui" creationdate="20190708T162045Z">
        <seg>每次生成检查点，数据汇都会开启一次事务并将全部收到的记录附加到该事务中，即将它们写入接收系统但先不提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each distinct value of the key attribute, Flink maintains one state instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T035553Z" creationid="xccui" creationdate="20190630T035553Z">
        <seg>对于每一个键值，Flink都会维护一个状态实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each event in the input stream, a task is a processing step that performs the fol‐ lowing steps: (1) receives the event, storing it in a local buffer; (2) possibly updates internal state; and (3) produces an output record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T190522Z" creationid="xccui" creationdate="20190606T033527Z">
        <seg>对于输入流中的每个事件，任务都需要执行以下步骤：（1）接收事件并将它们存在本地缓冲区；（2）选择性地更新内部状态；（3）产生输出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each event in the input stream, a task performs the following steps: (1) receive the event, i.e. store it in a local buffer, (2) possibly update internal state, and (3) produce an output record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042612Z" creationid="xccui" creationdate="20190415T042352Z">
        <seg>对于输入流中的每个事件，任务都需要执行以下步骤：（1）接收事件（将它们存在本地缓冲）；（2）有可能更新内部状态；（3）产生输出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each expired timer, the task invokes a call-back function that can perform a computation and emit records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042230Z" creationid="xccui" creationdate="20190529T042140Z">
        <seg>对于每个到期的定时器，调用回调函数，利用它来执行计算和发出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each expired timer, the task invokes a callback function that can perform a computation and emit records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190606T212941Z">
        <seg>对于每个到期的计时器，调用回调函数，利用它来执行计算并发出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each incoming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052406Z" creationid="xccui" creationdate="20190614T052406Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each input event, the processElement() method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T211737Z" creationid="xccui" creationdate="20190704T211737Z">
        <seg>对于每个输入事件，都会调用processElement()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each key and timestamp, exactly one timer can be registered, which means each key can have multiple timers but only one for each timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T064209Z">
        <seg>对于每个键值和时间戳只能注册一个计时器。换言之，每个键值可以有多个计时器，但对应每个时间戳只能有一个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each operator, you can explicitly specify its slot-sharing group with the slotSharingGroup(String) method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T021720Z" creationid="xccui" creationdate="20190731T014913Z">
        <seg>对于每个算子，你都可以利用slotSharingGroup(String)方法为其指定处理槽共享组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each received record, the queryable state sink upserts the record into ValueState, so that the latest event per key is always</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T063012Z" creationid="xccui" creationdate="20190706T063012Z">
        <seg>对于每个收到的记录，可查询式状态的数据汇都会用它去更新ValueState的值，这样就能为每个键值保存最新的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For every checkpoint, it starts a new transaction and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T035754Z" creationid="xccui" creationdate="20190715T035754Z">
        <seg>对于每个检查点，它都会开启一个新的事务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For exam&lt;t0/&gt;‐&lt;t1/&gt; ple, the data of an order processing system can be analyzed to obtain sales growth over time, to identify reasons for delayed shipments, or to predict future sales in order to adjust the inventory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T182744Z" creationid="xccui" creationdate="20190228T182744Z">
        <seg>例如：通过分析订单处理系统中的数据来获知销售增长率、分析运输延迟原因、预测销售量以调整库存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example they need to be normalized, joined or enriched with additional data, or pre-aggregated, i.e., transformations that are also commonly performed by ETL processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T013802Z" creationid="xccui" creationdate="20190314T073857Z">
        <seg>例如：标准化，与其他数据连接或丰富数据，预聚合等一系列在ETL过程中的常见变换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T052156Z" creationid="xccui" creationdate="20190705T052156Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, MapState is backed by a Java HashMap object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221941Z" creationid="xccui" creationdate="20190703T221941Z">
        <seg>例如，MapState的后端其实是Java HashMap对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a Kafka source needs to choose the partition offsets from which it consumes a topic if no restored read positions are available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170617Z" creationid="xccui" creationdate="20190726T032721Z">
        <seg>例如：Kafka数据源会在没有可供恢复的读取位置时从它消费的主题中决定分区偏移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a MapFunction does</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T043236Z" creationid="xccui" creationdate="20190621T043236Z">
        <seg>例如，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a sink operator that writes the results and updates of a keyed window operator to a key-value store could do this by overriding inaccu‐ rate results with the latest update using upsert writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T070507Z" creationid="xingcan" creationdate="20190628T163859Z">
        <seg>例如，为了实现此目的，一个用于将键值窗口算子的结果及更新写入键值存储的数据汇算子，可以通过Upsert写入模式将之前的非精确结果替换为最近一次更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a time-window operator assigns records to windows according to their associated timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040311Z" creationid="xccui" creationdate="20190523T040311Z">
        <seg>例如，时间窗口算子会根据记录关联的时间戳将其分配到窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a time-window task finalizes a window computa&lt;t0/&gt;‐&lt;t1/&gt; tion and emits the result when the task event-time passes the window’s end boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T041949Z" creationid="xccui" creationdate="20190523T041914Z">
        <seg>例如：基于时间窗口的任务会在其事件时间超过窗口结束边界时确定最终的窗口进行计算并发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a time-window task finalizes a window computa‐ tion and emits the result when the task event-time passes the window’s end boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T064952Z" creationid="xccui" creationdate="20190606T205223Z">
        <seg>例如：基于时间窗口的任务会在其事件时间超过窗口结束边界时进行最终的窗口计算并发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a window operator can group the events of a stream into windows of 5 minutes and count for each window how many events have been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T023541Z" creationid="xccui" creationdate="20190622T033648Z">
        <seg>举例而言，窗口算子可以将数据流中的事件按照每5分钟的窗口进行分组，并计算每个窗口中收到的事件数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a window operator registers a timer for every active window, which cleans up the window’s state when the event time passes the window’s ending time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190606T211126Z">
        <seg>例如：窗口算子会为每个活动窗口注册一个计时器，它们会在事件时间超过窗口的结束时间时清理窗口状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an application with a sink that upserts into a key-value store must ensure that it deterministically computes the keys that are used to upsert.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T052202Z" creationid="xccui" creationdate="20190708T070500Z">
        <seg>举例而言，如果应用中用到了一个写键值存储的数据汇，那么必须保证每次计算出的用于插入操作的键都相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an assigner with a size of one hour will define windows at 00:00:00, 01:00:00, 02:00:00, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054104Z" creationid="xccui" creationdate="20190623T054104Z">
        <seg>例如，大小为1小时的分配器将会在00:00:00、01:00:00、02:00:00……时间定义窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an average latency value of 10 ms means that events are processed within 10 ms on average.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234026Z" creationid="xccui" creationdate="20190605T234026Z">
        <seg>例如：平均延迟为10毫秒表示平均每条数据会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an average latency value of 10ms means that events&lt;t8/&gt; &lt;t9/&gt;are processed within 10ms on average.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T155133Z" creationid="xccui" creationdate="20190401T154841Z">
        <seg>例如：平均延迟10毫秒表示平均每条数据会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, computing running</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T183351Z" creationid="xccui" creationdate="20190704T183351Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, determining whether a specific event occurs in the input stream can be correctly realized with at-least-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193111Z" creationid="xccui" creationdate="20190416T042315Z">
        <seg>例如：确定某个事件是否在输入流中出现过，就可以利用至少一次保障正确地实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, file:///home/user/data.txt points to a file in the local filesystem and hdfs:///namenode:50010/home/user/data.txt to a file in the specified HDFS cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T032446Z" creationid="xccui" creationdate="20190722T032241Z">
        <seg>例如，file:///home/user/data.txt指向本地文件系统中的文件，hdfs:///namenode:50010/home/user/data.txt指向某HDFS集群中的一个文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given a base path of "/johndoe/demo" and a part prefix of "part", the path "/johndoe/demo/2018-07-22--17/part-4-8" points to the eight file that was written by the fifth (0-indexed) sink task to bucket "2018-07-22--17"—the 5 p.m. bucket of July 22, 2018.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T020100Z" creationid="xccui" creationdate="20190710T214013Z">
        <seg>例如，给定一个基础路径"/johndoe/demo"和分块文件前缀"part"，路径"/johndoe/demo/2018-07-22--17/part-4-8"指向2018年7月22日下午5点的桶内由5号（编号从0开始）数据汇任务写出的第8个文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if all users in a team pop 500 bubbles within one minute, they get a level-up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154431Z" creationid="xccui" creationdate="20190411T145904Z">
        <seg>（例如：如果团队所有成员在一分钟内消除了500个泡泡，他们就会提升一级）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are processing a stream of measurements from a set of sensors, you can use a parti‐ tioned operator state to maintain state for each sensor independently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T184007Z" creationid="xccui" creationdate="20190606T032927Z">
        <seg>举例而言，如果你要处理从一组传感器得到的测量值数据流，则可以用分区算子状态（partitioned operator state）来单独维护每个传感器的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are processing a stream of measurements from a set of sensors, you can use partitioned operator state to maintain state for each sensor inde&lt;t3/&gt;‐&lt;t4/&gt; pendently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T034432Z" creationid="xccui" creationdate="20190415T033859Z">
        <seg>举例而言，如果你要处理从一组传感器得到的测量值数据流，则可以用分组算子状态（partitioned operator state）来独立地维持每个传感器的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are the first customer showing up at the coffee shop right after it opened its doors in the morning, you will be served immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052839Z" creationid="xccui" creationdate="20190605T234700Z">
        <seg>这就如同你是早晨咖啡店开门后的首位顾客，会立即享受服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you have a ValueState[String], Flink’s type system generates a StringSerializer to convert String objects into bytes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T050341Z" creationid="xccui" creationdate="20190705T050213Z">
        <seg>举例而言，如果你有一个ValueState[String]，Flink的类型系统会生成一个StringSerializer来将String对象转换成字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, information for a product that is offered in a webshop can be stored in a transactional database, a web cache, and a search index.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T070514Z" creationid="xccui" creationdate="20190314T065839Z">
        <seg>例如：网店内某产品的信息可能会同时放到事务型型数据库、网站缓存以及搜索索引中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it can make sense to break a long pipeline of chained tasks or break a chain into two tasks to schedule an expensive function to different slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T201955Z" creationid="esouser" creationdate="20190514T154252Z">
        <seg>举例而言，有时候我们需要对过长任务链接进行切分或者将两个计算量大的函数分配到不同的处理槽中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, most operators for Flink’s SQL support are implemented using process functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T044544Z" creationid="xccui" creationdate="20190621T044544Z">
        <seg>例如，大多数Flink SQL所支持的算子都是利用处理函数实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, once data has been emitted to a sink, it is hard to guarantee result correctness, since the sink might not provide transactions to revert results that have been previously written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050731Z" creationid="xccui" creationdate="20190415T050222Z">
        <seg>举例而言，一旦数据从数据汇中写出，结果正确性将难以保障。原因在于，数据汇可能不提供事务来恢复之前写入的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, repeatedly inserting the same key-value pair into a hashmap is an idempotent operation because the first insert operation adds the value for the key into the map and all following insertions will not change the map since it already</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T064612Z" creationid="xccui" creationdate="20190708T064612Z">
        <seg>例如，将相同的键值对插入一个哈希映射就是一个幂等操作。因为在首次将键值对插入映射中后，无论该操作再重复几次都不会改变这个映射，因为目标键值对已经存在了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, sink functions that aim to write data to external systems with exactly-once guarantees must only emit records that were received before a successful checkpoint to ensure the received data will not be recomputed in the case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T193006Z" creationid="xccui" creationdate="20190702T181000Z">
        <seg>例如：数据汇函数为了以精确一次语义将数据写入外部系统，只能发出那些在检查点成功创建前收到的记录。这样做是为了保证在出现故障时不会重复发送接收的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the Cassandra sink connector by default uses a Check pointCommitter that writes to Cassandra.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T060549Z" creationid="xccui" creationdate="20190715T060549Z">
        <seg>举例而言，Cassandra数据汇连接器默认情况下会使用一个将信息写入Cassandra的CheckpointCommitter。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the FileSystem state backend and the RocksDB state backend support asynchronous checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202717Z" creationid="xccui" creationdate="20190609T202658Z">
        <seg>举例而言，文件系统状态后端和RocksDB状态后端支持异步生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the data of an order processing system can be analyzed to obtain sales growth over time, to identify reasons for delayed shipments, or to predict future sales in order to adjust the inventory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T024556Z" creationid="esouser" creationdate="20190603T201909Z">
        <seg>例如：通过分析订单处理系统中的数据来获知销售增长率，通过分析运输延迟原因或预测销售量以调整库存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the default triggers of the pre‐ viously discussed time windows fire when the processing time or the watermark exceed the timestamp of the window’s end boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T182151Z" creationid="xccui" creationdate="20190626T182151Z">
        <seg>对之前讨论的时间窗口而言，其默认触发器会在处理时间或水位线超过了窗口结束边界的时间戳时触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following Java class will be identified as a POJO by Flink:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044720Z" creationid="xccui" creationdate="20190617T044720Z">
        <seg>例如，以下Java类就会被Flink识别为POJO：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the queryable state is only accessible while the application is running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T035858Z" creationid="xccui" creationdate="20190705T165020Z">
        <seg>例如：它只有在应用运行过程中才可以访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the start scripts, such as ./bin/start-cluster.sh, parse the configuration file to extract JVM parameters and heap size settings, and the CLI client (./bin/flink) extracts the connection information to access the master process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T042154Z" creationid="xccui" creationdate="20190723T042001Z">
        <seg>举例而言，启动脚本（如./bin/start-cluster.sh）会解析该配置文件获得JVM参数以及堆大小设置，CLI客户端（./bin/flink）会从中获得连接信息以访问主进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to finalize windows when the event-time passes their end boundaries, a time-window task registers a timer for the ending time of each of its active windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041839Z" creationid="xccui" creationdate="20190529T041558Z">
        <seg>例如：为了在事件时间越过结束边界时最终确定窗口，时间窗口任务会根据当前活动窗口的结束时间注册定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, transactional sinks commit changes to external systems when a savepoint completes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T181640Z" creationid="xccui" creationdate="20190726T181640Z">
        <seg>例如，事务性数据汇在保存点完成后会将修改提交到外部系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, user interactions with a series of news articles one after the other could be considered a session.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025919Z" creationid="xccui" creationdate="20190407T025745Z">
        <seg>例如：用户浏览一连串新闻文章的交互过程可以看作一个会话。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, with RocksDBStateBackend it is more efficient to use MapState[X, Y] instead of ValueState[HashMap[X, Y]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T034135Z" creationid="xccui" creationdate="20190704T034135Z">
        <seg>例如，针对RocksDBStateBackend，使用MapState[X, Y]要比ValueState[HashMap[X, Y]更高效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, writing a program that uses several chunks of code from this book does not require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210818Z" creationid="esouser" creationdate="20190603T210818Z">
        <seg>For example, writing a program that uses several chunks of code from this book does not require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can configure that an applica‐ tion be restarted as long as it did not fail more than three times in the last ten minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154123Z" creationid="xingcan" creationdate="20190801T154123Z">
        <seg>例如，你可以配置应用只要在过去十分钟内失败次数没超过三次，就可以一直重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can configure the maximum number of failed containers until an application is terminated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T141958Z" creationid="xccui" creationdate="20190719T010455Z">
        <seg>例如，可以配置有多少容器发生故障后终止应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can create a partitioner based on a key</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T035650Z" creationid="xccui" creationdate="20190710T035650Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can implement triggering logic to fire when the window receives a certain number of elements, when an ele‐ ment with a specific value is added to the window, or after detecting a pattern on added elements like “two events of the same type within 5 seconds.” A custom trigger can also be used to compute and emit early results from an event-time window, before the watermark reaches the window’s end timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052737Z" creationid="xccui" creationdate="20190626T183807Z">
        <seg>举例而言，你可以在触发器中实现以下触发逻辑：当窗口接收到一定数量的元素，当含有某个特定值的元素加入窗口，或当检测到添加的元素满足某种模式（如5秒内出现了两个相同类型的事件）。自定义触发器还可以用来在水位线到达窗口的结束时间戳以前，为事件时间窗口计算并发出早期结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example: “Stream Processing with Apache Flink by Fabian Hueske and Vasiliki Kalavri (O’Reilly).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210824Z" creationid="esouser" creationdate="20190603T210824Z">
        <seg>For example: “Stream Processing with Apache Flink by Fabian Hueske and Vasiliki Kalavri (O’Reilly).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For filesystems for which Flink does not provide a dedicated connector, Flink can del‐ egate to the Hadoop filesystem connector if it is correctly configured.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T044843Z" creationid="xccui" creationdate="20190722T044533Z">
        <seg>对于那些在Flink中没有提供特定连接器支持的文件系统，如果正确配置，Flink都能以Hadoop文件系统连接器为代理对其进行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, Flink’s</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T061010Z" creationid="xccui" creationdate="20190716T061010Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, Kafka 0.10 added support for record timestamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T203455Z" creationid="xccui" creationdate="20190708T203455Z">
        <seg>例如，Kafka 0.10增加了对记录时间戳的支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a time-window operator task attaches the end time of a window as the timestamp to all records emitted by the window computation before it emits the watermark with the timestamp that triggered the computation of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T053359Z" creationid="xccui" creationdate="20190607T013520Z">
        <seg>举例而言，时间窗口算子任务会在发送触发窗口计算的水位线时间戳之前，将所有经过窗口计算所得结果的时间戳设为窗口的结束时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a window operator collects input records for</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T031720Z" creationid="xccui" creationdate="20190630T031720Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, assume you join two streams with a join operator that is configured with 1-hour tumbling window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T055055Z" creationid="xccui" creationdate="20190628T055055Z">
        <seg>例如，假设你为执行Join操作的算子配置了1小时的滚动窗口，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, event logs like Apache Kafka can provide records from a previous offset of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044504Z" creationid="xccui" creationdate="20190609T044407Z">
        <seg>例如，类似Apache Kafka的事件日志系统就允许从之前的某个偏移读取记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if we are using a dis&lt;t2/&gt;‐&lt;t3/&gt; tributed processing engine, each operator might have several parallel tasks running on different physical machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T003110Z" creationid="xccui" creationdate="20190401T002829Z">
        <seg>例如：当我们使用分布式处理引擎，每个算子可能会在不同物理机器上运行多个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if we are using a distributed processing engine, each operator might have several parallel tasks running on different physical machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044323Z" creationid="xccui" creationdate="20190605T233104Z">
        <seg>例如：当我们使用分布式处理引擎时，每个算子可能会在不同物理机器上运行多个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if we know that the load</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T065829Z" creationid="xccui" creationdate="20190615T065827Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you are receiving meas&lt;t4/&gt;‐&lt;t5/&gt; urements from different sensors, you probably want to group the stream by sensor id before applying a window computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195017Z" creationid="xccui" creationdate="20190409T194251Z">
        <seg>例如，如果你在收集来自不同传感器的测量值，那么可能会想在应用窗口计算前按照传感器id对数据流进行划分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you are receiving measurements from different sensors, you probably want to group the stream by sensor ID before applying a window computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013856Z" creationid="xccui" creationdate="20190606T013849Z">
        <seg>例如，如果你在收集来自不同传感器的测量值，那么可能会想在应用窗口计算前按照传感器ID对数据流进行划分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in a stand-alone setup, i.e., a setup without a resource provider, the ResourceManager can only distribute the slots of available TaskManagers and cannot start new TaskManagers on its own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062146Z" creationid="xccui" creationdate="20190423T025023Z">
        <seg>例如：独立集群设置中没有资源提供者，因此ResourceManager只能分配现有TaskManager中的处理槽而无法自己启动新的TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in a standalone setup—a setup without a resource provider—the ResourceManager can only distribute the slots of available TaskManagers and cannot start new TaskManag‐ ers on its own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T062709Z" creationid="xccui" creationdate="20190606T143258Z">
        <seg>例如：独立集群设置下没有资源提供者，因此ResourceManager只能分配现有TaskManager中的处理槽而无法自己启动新的TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, reducing the overhead of each checkpoint can facilitate a higher checkpointing frequency, leading to faster recovery cycles.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T030953Z" creationid="xccui" creationdate="20190731T025921Z">
        <seg>举例而言，减小每次检查点的生成开销可以促使其频率加快，从而使恢复周期缩短。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the RocksDB state backend supports incremental checkpoints, which can significantly reduce the checkpointing overhead for very large state sizes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062005Z" creationid="xccui" creationdate="20190608T053953Z">
        <seg>例如：RocksDB状态后端支持增量检查点。这对于大规模的状态而言，会显著降低生成检查点的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the following line sets the root logging level to “warning”:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T035203Z" creationid="xccui" creationdate="20190807T034553Z">
        <seg>例如，下面一行配置会将根日志记录级别设置为"warning"：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the name “myCounter,” the user scope “MyMetrics,” and the system scope “localhost.taskmanager.512” would result into the identifier “localhost.task‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T034052Z" creationid="xccui" creationdate="20190804T034052Z">
        <seg>举例而言，指标名称"myCounter"、用户域"MyMetrics"和系统域"localhost.taskmanager.512"将会生成标识"localhost.taskmanager.512.MyMetrics"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you could extract patterns from a Data‐ Stream using the CEP library and later use SQL to analyze extrac‐ ted patterns or you could use the Table API to filter and project tables into graphs before analyzing them with a graph algorithm from the Gelly library.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T163720Z" creationid="xingcan" creationdate="20190807T163720Z">
        <seg>例如，你可以使用CEP从DataStream中提取某一模式，随后用SQL来分析该模式，或者先用Table API对表进行过滤并投影到图中，再使用Gelly库中的图算法对其进行分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you could implement a FlatMapFunction that emits each incoming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T212608Z" creationid="xccui" creationdate="20190713T212608Z">
        <seg>例如，你可以在FlatMapFunction内用HTTP POST请求发出记录，而非自身提供的Collector。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you might be interested in measuring how the stream is observed and count events per second in order to detect possible outages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052851Z" creationid="xccui" creationdate="20190414T045116Z">
        <seg>例如，你可能会有兴趣监测数据流的接入情况或通过计算每秒事件数来发现潜在的数据中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you might be interested in observing the stream and counting the number of events per second to detect outages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181051Z" creationid="xccui" creationdate="20190606T031132Z">
        <seg>例如，你可能想观察数据流的接入情况，通过计算每秒事件数来检测数据中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you might want to know how many vehicles cross an intersection every 5 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T044551Z" creationid="xccui" creationdate="20190406T043731Z">
        <seg>例如，你可能想了解某路口每5分钟的车流量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For internal communication (RPC calls, data transfer, and blob service communication to distribute libraries or other artifacts) all Flink processes (Dispatcher, ResourceMan‐ ager, JobManager, and TaskManager) perform mutual authentication— senders and receivers validate each other via an SSL certificate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T024542Z" creationid="xccui" creationdate="20190725T024315Z">
        <seg>对于内部通信（RPC调用，数据传输，用以分发类库或其他工件（Artifact）的Blob服务通信），所有Flink进程（Dispatcher，ResourceManager，JobManager及TaskManager）都会相互验证身份——发送者和接受者需要利用SSL证书完成验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For larger setups, you need to tune the configuration as described in &lt;t2/&gt;Chapter 9&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045859Z" creationid="xccui" creationdate="20190504T045853Z">
        <seg>而对于大型设置场景，需要根据第9章的介绍调节配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For larger setups, you need to tune the configuration as described in “Main Memory and Network Buffers” on page 240.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193803Z" creationid="xccui" creationdate="20190606T201833Z">
        <seg>而对于大型使用场景，需要根据第240页"内存和网络缓冲"一节所介绍的内容调整配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For leader election in highly available setups, Flink depends on Apache ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T044706Z" creationid="xccui" creationdate="20190606T140816Z">
        <seg>它依赖Apache ZooKeeper来完成高可用性设置中的领导选举工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For leader election in highly-available setups, Flink depends on Apache ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032403Z" creationid="xccui" creationdate="20190418T032403Z">
        <seg>Flink依赖Apache ZooKeeper来完成高可用设置中的领导选举过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For local state management, a state backend stores all keyed states and ensures that all accesses are correctly scoped to the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061641Z" creationid="xccui" creationdate="20190608T051526Z">
        <seg>对于本地状态管理，状态后端会存储所有键值分区状态，并保证能将状态访问范围正确地限制在当前键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For low-level operations on two inputs, the DataStream API also provides the CoProcessFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T012126Z" creationid="xccui" creationdate="20190622T024145Z">
        <seg>针对有两个输入的底层操作，DataStream API还提供了CoProcessFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For many applications, the SinkFunction interface is sufficient to implement an idempotent sink connector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T042935Z" creationid="xccui" creationdate="20190714T042935Z">
        <seg>对于很多应用而言，利用SinkFunction接口足以实现幂等性数据汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about our books, courses, conferences, and news, see our web‐ site at http://www.oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210844Z" creationid="esouser" creationdate="20190603T210844Z">
        <seg>For more information about our books, courses, conferences, and news, see our web‐ site at http://www.oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, contact our corporate/institutional sales department: 800-998-9938 or corporate@oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210718Z" creationid="esouser" creationdate="20190603T210718Z">
        <seg>For more information, contact our corporate/institutional sales department: 800-998-9938 or corporate@oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, please visit http://oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210834Z" creationid="esouser" creationdate="20190603T210834Z">
        <seg>For more information, please visit http://oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some operators it can be important to know whether a checkpoint completed or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025955Z" creationid="xccui" creationdate="20190702T171255Z">
        <seg>对一些算子而言，了解检查点的完成情况非常重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some storage systems, Flink provides sink functions that feature exactly-once output, for example, by committing emitted records on checkpoint completion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054217Z" creationid="xccui" creationdate="20190609T053939Z">
        <seg>对于某些存储系统，Flink提供的数据汇函数支持精确一次输出，例如，在检查点完成后才会把写出的记录正式提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some use cases it might also be necessary to distinguish between the first result and an update due to a late event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T212717Z" creationid="xingcan" creationdate="20190628T164011Z">
        <seg>对大多数用例而言，可能还要对首次结果和由于迟到事件产生的更新结果加以区分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For state backends that de/serialize state objects when reading or writing, such as RocksDBStateBackend, the choice of the state primitive (ValueState, ListState, or MapState) can have a major impact on the performance of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T031531Z" creationid="xccui" creationdate="20190704T031531Z">
        <seg>对于那些在读写状态时涉及对象序列化和反序列化的状态后端（如RocksDBStateBackend），状态原语（ValueState、ListState或MapState）的选择将对应用性能产生决定性的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For such advanced applications, a good understanding of Flink’s internal time handling is often helpful and sometimes required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T063954Z" creationid="xccui" creationdate="20190523T034809Z">
        <seg>在面对这些高级应用时，充分理解Flink内部事件处理机制通常会有所帮助，有时候更是必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For such applications,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010015Z" creationid="xccui" creationdate="20190624T010015Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For such cases, Flink provides the BoundedOutOfOrder nessTimeStampExtractor, which takes the maximum expected lateness as an argu‐ ment:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052854Z" creationid="xccui" creationdate="20190620T052854Z">
        <seg>针对这种情况，Flink提供了BoundedOutOfOrdernessTimeStampExtractor，它接收一个表示最大预期延迟的参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025640Z" creationid="xccui" creationdate="20190801T025640Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the RocksDB state backend you can define one or more paths at which RocksDB stores its local files (state.back end.rocksdb.localdir) and whether timer state is stored on the heap (default) or in RocksDB (state.backend.rocksdb.timer-service.factory).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T044853Z" creationid="xccui" creationdate="20190724T044853Z">
        <seg>对于RocksDB状态后端，你可以定义用于本地文件存储的路径（state.backend.rocksdb.localdir）以及是将计时器存放在堆中（默认配置）还是RocksDB中（state.backedn.rocksdb.timer-service.factory）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the first input, all records with timestamps larger than the current watermark—the upper bound— are buffered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T031701Z" creationid="xccui" creationdate="20190628T031631Z">
        <seg>对第一个输入而言，所有时间戳大于当前水位线减去间隔上界的数据都会被缓冲起来；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the remainder of this section, we focus on the universal connector and refer you to Flink’s documentation for the version-specific connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T043548Z" creationid="xccui" creationdate="20190709T043548Z">
        <seg>在本章其余部分，我们会把关注点放在通用的连接器上面。如果你想了解某个特定版本的连接器，请参阅Flink的相关文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the remainder of this section, we focus on the uni‐ versal connector and for the version-specific connectors, we refer you to Flink’s documentation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T204542Z" creationid="xccui" creationdate="20190708T204542Z">
        <seg>在本章其余部分，我们会把关注点放在通用的连接器上面。如果你想了解某个特定版本的连接器，请参阅Flink的相关文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the second input, all records with timestamps larger than the current watermark + the lower bound are buffered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T031913Z" creationid="xccui" creationdate="20190628T031643Z">
        <seg>对第二个输入而言，所有时间戳大于当前水位线加上间隔下界的数据都会被缓冲起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this example, your system needs Java 8 installed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122651Z" creationid="xccui" creationdate="20190605T122651Z">
        <seg>为此你需要先安装Java 8。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this your system needs to have Java 8 installed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T055409Z" creationid="xccui" creationdate="20190328T055216Z">
        <seg>为此你需要先安装Java 8。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For two operators con‐ nected by a partitioning or broadcasting connection the number of network buffers depends on the product of the sending and receiving operator parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T035510Z" creationid="xccui" creationdate="20190724T035510Z">
        <seg>对于通过分区或广播策略连接的两个算子，其网络缓冲区的需求量取决于发送和接收算子并行度的乘积。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, in many cases, you can partition the state by a key and manage the state of each partition independently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T183735Z" creationid="xccui" creationdate="20190415T033542Z">
        <seg>幸运的是，在很多情况下可以把状态按照键值划分，并独立管理每一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Framework style</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143403Z" creationid="xccui" creationdate="20190606T143403Z">
        <seg>框架模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Framework style&lt;t0/&gt;: In this mode, Flink applications are packaged into a JAR file and&lt;t1/&gt; &lt;t2/&gt;submitted by a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030257Z" creationid="xccui" creationdate="20190423T025356Z">
        <seg>框架模式：在本模式下，Flink应用会打包成一个JAR文件并通过客户端提交到运行的服务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Frequent synchronization is a major reason for performance limitations in dis‐ tributed systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T170725Z" creationid="xccui" creationdate="20190702T163542Z">
        <seg>频繁地同步是分布式系统产生性能瓶颈的主要原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From a savepoint-compatibility point of view this means an application can be evolved in three ways:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035308Z" creationid="xccui" creationdate="20190705T035308Z">
        <seg>从保存点兼容性的角度来看，应用可以通过以下三种方式进行更新：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From there, the late events can be processed or emitted using a regular sink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154751Z" creationid="xingcan" creationdate="20190628T154541Z">
        <seg>这样就可以对它们进行后续处理或利用常规的数据汇函数将其写出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FsStateBackend only requires a path to define the storage location for checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022748Z" creationid="xccui" creationdate="20190801T022748Z">
        <seg>FsStateBackend只需一个用于定义检查点存储位置的路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FsStateBackend stores the local state on the TaskManager’s JVM heap, just like MemoryStateBackend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T021829Z" creationid="xccui" creationdate="20190704T021829Z">
        <seg>FsStateBackend和MemoryStateBackend一样，将本地状态保存在TaskManager的JVM堆内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Full window functions collect all elements of a window and iterate over the list of all collected elements when they are evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T032259Z" creationid="xccui" creationdate="20190623T211046Z">
        <seg>全量窗口函数。它会收集窗口内的所有元素，并在执行计算时对它们进行遍历。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Full window functions usually require more space but allow for more complex logic than incremental aggrega‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211518Z" creationid="xccui" creationdate="20190623T211421Z">
        <seg>虽然全量窗口函数通常需要占用更多空间，但它和增量聚合函数相比，支持更复杂的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022917Z" creationid="xccui" creationdate="20190225T022917Z">
        <seg>函数类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FunctionSnapshotCon text gives access to the unique identifier of the checkpoint and the timestamp when the JobManager initiates the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071501Z" creationid="xccui" creationdate="20190702T071501Z">
        <seg>从FunctionSnapshotContext中，我们可以得到检查点的唯一标识以及JobManager初始化检查点时的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions Must Be Java Serializable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055059Z" creationid="xccui" creationdate="20190618T055059Z">
        <seg>函数必须是Java可序列化的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are called with data objects and emit data objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T062947Z" creationid="xccui" creationdate="20190616T062947Z">
        <seg>函数在调用时会传入数据对象，同时它也可以发出数据对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are not able to read or modify record timestamps and watermarks, except for the &lt;t0/&gt;ProcessFunc&lt;t1/&gt; &lt;t2/&gt;tion &lt;t3/&gt;which can read the timestamp of a currently processed&lt;t4/&gt; &lt;t5/&gt;record, request the current event-time of the operator, and register timers&lt;t6/&gt;4&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T140632Z" creationid="esouser" creationdate="20190603T140632Z">
        <seg>Flink中的普通函数无法读写记录的时间戳或水位线。但有一个例外——ProcessFunction，它可以读取当前正在处理记录的时间戳，请求获取当前算子的事件时间以及注册定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are written by the application programmer and implement custom computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060723Z" creationid="xccui" creationdate="20190606T011456Z">
        <seg>函数由应用开发人员编写，可用来实现某些自定义的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can also be implemented as anonymous classes:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054230Z" creationid="xccui" creationdate="20190618T054230Z">
        <seg>还可以通过匿名类来实现函数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can receive parameters through their constructor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054311Z" creationid="xccui" creationdate="20190618T054311Z">
        <seg>函数可以通过其构造函数接收参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can reuse Java tuples in order to reduce the pressure on the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T025418Z" creationid="xccui" creationdate="20190617T040423Z">
        <seg>函数中可以对Java元组进行重用，以减轻垃圾回收器的压力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions cannot read or modify record time‐ stamps and watermarks, except for the process functions, which  can read the timestamp of a currently processed record, request the current event time of the operator, and register timers.3 None of the functions exposes an API to set the timestamps of emitted records, manipulate the event-time clock of a task, or emit watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T053045Z" creationid="xccui" creationdate="20190607T012544Z">
        <seg>普通函数无法读写记录的时间戳或水位线，但一系列处理函数（process function）除外。它们可以读取当前正在处理记录的时间戳，获得当前算子的事件时间，还能注册计时器。3 所有函数的API都无法支持设置发出记录的时间戳、调整任务的事件时间时钟或发出水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions, such as</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020745Z" creationid="xccui" creationdate="20190613T020745Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fundamentals, Implementation, and Operation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041340Z" creationid="esouser" creationdate="20190603T142422Z">
        <seg>流式应用基础、实现及操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further options to configure the checkpointing behavior are provided by the Check pointConfig, which can be obtained from the StreamExecutionEnvironment:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T030820Z" creationid="xccui" creationdate="20190731T030820Z">
        <seg>你还可以利用从StreamExecutionEnvironment中获取的CheckpointConfig对检查点进行更多配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further, Flink offers domain-specific libraries and APIs for relational queries, complex event processing (CEP), and graph processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T053647Z" creationid="xccui" creationdate="20190807T053647Z">
        <seg>此外，Flink为关系查询、CEP（complex event processing复杂事件处理）和图计算都提供了领域相关的库和API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further, it includes methods for accessing partitioned state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033725Z" creationid="xccui" creationdate="20190619T033527Z">
        <seg>另外它还提供了访问分区状态的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, Flink can reset the state of an application to a previous savepoint, making it possible to evolve or rescale an application without losing its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T053249Z" creationid="xccui" creationdate="20190604T052208Z">
        <seg>此外，Flink可以将应用状态重置到之前的某个检查点，从而允许应用在不丢失状态的前提下更新或扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future[String] holds the result of the JDBC query.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T060204Z" creationid="xccui" creationdate="20190716T212359Z">
        <seg>Future[String]保存了JDBC的查询结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GET /jars</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045752Z" creationid="xccui" creationdate="20190729T045752Z">
        <seg>GET /jars</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GET /jobmanager/metrics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044326Z" creationid="xccui" creationdate="20190729T044326Z">
        <seg>GET /jobmanager/metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GET /jobs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T152721Z" creationid="xccui" creationdate="20190729T152721Z">
        <seg>GET /jobs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GET /jobs/&lt;jobId&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T152914Z" creationid="xccui" creationdate="20190729T152914Z">
        <seg>GET /jobs/&lt;jobId&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GET /taskmanagers/&lt;tmId&gt;/metrics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044655Z" creationid="xccui" creationdate="20190729T044655Z">
        <seg>GET /taskmanagers/&lt;tmId&gt;/metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gauge</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T025138Z" creationid="xccui" creationdate="20190803T025138Z">
        <seg>Gauge</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gelly for Graph Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152554Z" creationid="esouser" creationdate="20190603T152554Z">
        <seg>用于图计算的Gelly</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gelly is Flink’s graph processing API and library.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T162101Z" creationid="xingcan" creationdate="20190807T162101Z">
        <seg>Gelly是Flink的图计算API库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gelly provides high-level program‐ ming abstractions in both Java and Scala to perform graph transformations, aggrega‐ tions, and iterative processing such as vertex-centric and gather-sum-apply.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T163048Z" creationid="xingcan" creationdate="20190807T162701Z">
        <seg>Gelly为执行图转换、聚合及迭代（如vertex-centric和gather-sum-apply）提供了用于Java和Scala高层次的编程抽象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GenericWriteAheadSink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T040330Z" creationid="xccui" creationdate="20190715T040330Z">
        <seg>GenericWriteAheadSink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GenericWriteAheadSink eases the implementation of sink operators with improved consistency properties.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T042419Z" creationid="xccui" creationdate="20190715T041448Z">
        <seg>GenericWriteAheadSink简化了那些具有更佳一致性属性的数据汇算子的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GenericWriteAheadSink relies on a pluggable component called CheckpointCommit ter to store and look up information about committed checkpoints in an external persistent storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T053425Z" creationid="xccui" creationdate="20190715T053403Z">
        <seg>而实际上，GenericWriteAheadSink依赖一个名为CheckpointCommitter的可插拔组件来控制外部持久化系统存储和查找已提交的检查点信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GenericWriteAheadSink works by appending all received records to a write-ahead log that is segmented by checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T043443Z" creationid="xccui" creationdate="20190715T043443Z">
        <seg>GenericWriteAheadSink的工作原理是将经各个检查点"分段"后的接收记录以追加形式写如WAL中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Give your project a name and click Finish</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041704Z" creationid="xccui" creationdate="20190611T041704Z">
        <seg>为项目命名，然后单击Finish</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a Flink setup with four TaskManagers that provide two slots each, a streaming application can be executed with a maximum par&lt;t0/&gt;‐&lt;t1/&gt; allelism of eight.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205754Z" creationid="xccui" creationdate="20190428T205630Z">
        <seg>假设一个Flink设置包含4个TaskManager，每个TaskManager有2个处理槽，那么一个流式应用最多运行以并行度8来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a Flink setup with four TaskManagers that provide two slots each, a streaming application can be executed with a maximum par‐ allelism of eight.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145448Z" creationid="xccui" creationdate="20190606T145448Z">
        <seg>假设一个Flink设置包含4个TaskManager，每个TaskManager有2个处理槽，那么一个流式应用最多运行以并行度8来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a Kubernetes cluster and an application that is packaged into a container image, you can create a deployment of the application that tells Kubernetes how many instances of the application to start.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T142719Z" creationid="xccui" creationdate="20190719T015502Z">
        <seg>给定一个Kubernetes集群以和一个打包到容器镜像中的应用，你可以通过创建应用Deployment的方式告诉Kubernetes启动多少个应用实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a running ZooKeeper cluster and properly configured YARN and Flink setups, you can start a Flink cluster in job mode or session mode as if HA were not enabled—</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T145313Z" creationid="xccui" creationdate="20190721T061117Z">
        <seg>如果已经基于一个运行的ZooKeeper集群经配置好YARN和Flink，你就可以和非HA模式一样，通过./bin/flink run -m yarn-cluster和./bin/yarn-session.sh分别在作业模式和会话模式下启动Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a working and well-configured YARN and HDFS setup, a Flink job can be sub‐ mitted to be executed on YARN using Flink’s command-line client with the following command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T142119Z" creationid="xccui" creationdate="20190719T012233Z">
        <seg>在YARN和HDFS都搭建完成且能够正常工作的前提下，就可以使用Flink CLI客户端运行以下命令将作业提交到YARN上执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an application and a compatible savepoint, you can start the application from the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T070312Z" creationid="xccui" creationdate="20190609T211347Z">
        <seg>给定一个应用和一个兼容的保存点，我们可以从该保存点启动应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the case of a source function operator that runs with a parallelism of two and that reads data from a Kafka topic with six parti‐ tions, each parallel instance of the source function will read records from three Kafka topic partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T040640Z" creationid="xccui" creationdate="20190713T040640Z">
        <seg>假设我们数据源函数算子的并行度为2，且需要从Kafka某主题的6个分区中读取数据，那么每个数据源函数的并行实例需要从3个分区读取记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the unpredictable reality of distributed systems and arbitrary delays that might be caused by external components, there are no categorically cor‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025236Z" creationid="xccui" creationdate="20190606T025236Z">
        <seg>鉴于分布式系统现实的不确定性以及外部组件可能引发任意延迟，这些问题没有绝对正确的答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the unpredictable reality of distributed systems and arbitrary delays that might be caused by external components, there is no categorically correct answer to these questions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T204356Z" creationid="xccui" creationdate="20190412T203922Z">
        <seg>鉴于分布式系统现实的不确定性以及外部组件可能引发任意延迟，这些问题没有绝对正确的答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given two TaskManag&lt;t0/&gt;‐&lt;t1/&gt; ers with two processing slots each, this requirement is fulfilled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T163329Z" creationid="xccui" creationdate="20190423T043703Z">
        <seg>给定两个TaskManager，每个TaskManager内都有两个处理槽，即可满足该需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given two TaskManagers with two processing slots each, this requirement is fulfilled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071124Z" creationid="xccui" creationdate="20190606T144546Z">
        <seg>如果每个TaskManager内有两个处理槽，则给定两个TaskManager即可满足该需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045801Z" creationid="xccui" creationdate="20190616T045801Z">
        <seg>全局</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global state can be used to share</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024915Z" creationid="xccui" creationdate="20190624T024915Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global state refers to the keyed state that is not scoped to any window, while per-window state refers to the window instance that is currently being evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190624T012655Z">
        <seg>其中单个窗口的状态指的是当前正在计算的窗口实例的状态，而全局状态指的是不属于任何一个窗口的键值分区状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go to the Apache Flink webpage &lt;t0/&gt;flink.apache.org&lt;t1/&gt; &lt;t2/&gt;and download the Hadoop-free binary distribution of Apache Flink 1.7.1 for Scala 2.12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024852Z" creationid="xccui" creationdate="20190329T024852Z">
        <seg>从Apache Flink官网flink.apache.org下载支持Scala 2.12的Apache Flink 1.7.1无Hadoop二进制发行版。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go to the Apache Flink webpage and download the Hadoop-free binary distribu‐ tion of Apache Flink 1.7.1 for Scala 2.12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201150Z" creationid="xccui" creationdate="20190605T123020Z">
        <seg>从Apache Flink官网flink.apache.org下载支持Scala 2.12的Apache Flink 1.7.1 Hadoop-free二进制发行版。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Graphite</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055505Z" creationid="xccui" creationdate="20190804T055505Z">
        <seg>Graphite</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gravenstein Highway North Sebastopol, CA 95472</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210839Z" creationid="esouser" creationdate="20190603T210839Z">
        <seg>Gravenstein Highway North Sebastopol, CA 95472</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HA Kubernetes Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152240Z" creationid="esouser" creationdate="20190603T152240Z">
        <seg>Kubernetes的HA设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HA Standalone Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152203Z" creationid="esouser" creationdate="20190603T152203Z">
        <seg>独立集群的HA设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HA YARN Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152218Z" creationid="esouser" creationdate="20190603T152218Z">
        <seg>YARN上的HA设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HADOOP_CONF_DIR (preferred) or HADOOP_CONF_PATH environment variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T030748Z" creationid="xccui" creationdate="20190722T030748Z">
        <seg>该工作可以通过导出HADOOP_CONF_DIR（建议选项）或HADOOP_CONF_PATH环境变量的方式来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HDFS paths are prefixed with the hdfs:// scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T042626Z" creationid="xccui" creationdate="20190722T042353Z">
        <seg>HDFS路径会以hdfs://协议开头。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hadoop HDFS</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T041903Z" creationid="xccui" creationdate="20190722T041903Z">
        <seg>Hadoop HDFS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hadoop configuration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T012524Z" creationid="xccui" creationdate="20190719T012524Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Late Data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150755Z" creationid="xccui" creationdate="20190225T023322Z">
        <seg>处理迟到数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Late Data | 149</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042128Z" creationid="xccui" creationdate="20190629T042128Z">
        <seg>处理迟到数据 | 149</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Late Data | 151</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042139Z" creationid="xccui" creationdate="20190629T042139Z">
        <seg>处理迟到数据 | 151</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling delayed events is only one of the challenges that you can overcome with event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160251Z" creationid="xccui" creationdate="20190412T151554Z">
        <seg>使用事件时间要克服的挑战之一是如何处理延迟事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Have a look at the Kafka documentation for a comprehensive list of parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T151647Z" creationid="xingcan" creationdate="20190709T151647Z">
        <seg>完整属性列表请查看Kafka相关文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having no guaran&lt;t0/&gt;‐&lt;t1/&gt; tees whatsoever sounds like a terrible idea, but it might be fine, if you can live with approximate results and all you care about is providing the lowest latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041743Z" creationid="xccui" creationdate="20190415T184946Z">
        <seg>无论如何，没有保障听上去都不是个好主意。但如果你能接受近似结果并且只关心提供尽可能低的延迟，这种保障可能没多大问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having no guarantees whatsoever sounds like a terrible idea, but it might be fine if you can live with approximate results and all you care about is providing the lowest latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T192756Z" creationid="xccui" creationdate="20190606T034436Z">
        <seg>无论如何，没有保障听上去都像是个馊主意。但如果你能接受近似结果并且一门心思地关注怎样降低延迟，这种保障似乎也可以接受。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>He holds a PhD in computer science from TU Berlin.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T034818Z" creationid="xccui" creationdate="20190808T034818Z">
        <seg>费比安在柏林工业大学取得了计算机科学博士学位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hello, Flink!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035709Z" creationid="xccui" creationdate="20190418T035709Z">
        <seg>Hello, Flink!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T212752Z" creationid="xccui" creationdate="20190709T212752Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, FsStateBackend provides in-memory speed for local</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T030632Z" creationid="xccui" creationdate="20190704T022405Z">
        <seg>因此，FsStateBackend既让本地访问享有内存的速度，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, Hadoop HDFS, S3, and NFS are commonly used filesys‐ tems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T150438Z" creationid="xccui" creationdate="20190722T032006Z">
        <seg>因此诸如Hadoop HDFS、S3以及NFS等都是常用的文件系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a GenericWriteAheadSink does not provide bullet‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T043107Z" creationid="xccui" creationdate="20190715T042933Z">
        <seg>因此，GenericWriteAheadSink并不能百分之百提供精确一次保障，而只能做到至少一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a Java JDK is required to implement Flink DataStream applications—Java JDK 8 (or higher).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T072136Z" creationid="xccui" creationdate="20190611T014959Z">
        <seg>因此在写DataStream应用前需要安装Java JDK 8或更高版本（只有Java JRE是不够的）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a late arriving ele‐ ment will not create a new window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T205322Z" creationid="xingcan" creationdate="20190628T153654Z">
        <seg>因此，迟到的元素将不会创建新的窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a single misbehaving task can kill a whole TaskManager process and all tasks that run on it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071442Z" creationid="xccui" creationdate="20190606T144925Z">
        <seg>因此只要有一个任务运行异常，就会终止整个TaskManager进程，导致它上面运行的所有任务都停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a single misbehaving task can kill a whole TaskManager process and all tasks which run on the TaskManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063433Z" creationid="xccui" creationdate="20190424T063420Z">
        <seg>因此只要有一个任务运行异常，就会终止整个TaskManager进程，它上面运行的所有任务都会随之停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a slot-sharing group requires as many processing slots as the maximum parallelism of its operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T011819Z" creationid="xccui" creationdate="20190731T014658Z">
        <seg>因此，一个处理槽共享组所需的处理槽数等于它内部算子的最大并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a trigger must clear all of its state in the Trigger.clear() method to prevent</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040852Z" creationid="xccui" creationdate="20190626T040750Z">
        <seg>所以说，为了避免状态泄露，触发器需要在Trigger.clear()方法中清除自身所有状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a typical application consists of multiple states that are distributed across multiple operator tasks that can run on different TaskManager processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214735Z" creationid="xccui" creationdate="20190609T214705Z">
        <seg>因此一个典型的应用会包含多个状态，它们分布在不同TaskManager进程内的算子任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a window object</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033855Z" creationid="xccui" creationdate="20190626T033855Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, all data that is required to recover from a Job&lt;t2/&gt;‐&lt;t3/&gt; Manager failure is stored in the remote storage and ZooKeeper holds pointers to the storage locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051205Z" creationid="xccui" creationdate="20190502T051143Z">
        <seg>因此所有用于JobManager故障恢复的数据都在远程存储上面，而ZooKeeper持有指向这些存储位置的指针。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, all data that is required to recover from a JobManager failure is stored in the remote storage and ZooKeeper holds pointers to the storage locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073351Z" creationid="xccui" creationdate="20190606T194220Z">
        <seg>因此所有用于JobManager故障恢复的数据都在远程存储上面，而ZooKeeper持有这些存储位置的路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, an application that con‐ sumes the output of the recovering application might witness a jump back in time, e.g., read a smaller count than before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T072043Z" creationid="xccui" creationdate="20190708T072043Z">
        <seg>因此消费故障恢复过程中所产生的结果可能会使应用"回到过去"，例如，读到一个比之前小的计数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, changing the data type of a state is only supported</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T052710Z" creationid="xccui" creationdate="20190705T052646Z">
        <seg>所以说，修改状态的数据类型仅限于某些特定情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, credit-based flow control is an important building block for Flink to achieve high throughput and low latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T195939Z" creationid="esouser" creationdate="20190514T151545Z">
        <seg>不难看出，基于信用值的流量控制是Flink实现高吞吐低延迟的重要一环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, data transfer between tasks that run on the same TaskManager does not cause network communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194344Z" creationid="xccui" creationdate="20190606T202123Z">
        <seg>这意味着同一个TaskManager内不同任务之间的数据传输不会引起网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it can be useful to run stand-by JobManagers and TaskManagers that can take over the work of failed processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T040555Z" creationid="xccui" creationdate="20190504T040147Z">
        <seg>因此运行一些后备JobManager及TaskManager来接管故障进程的工作会很有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it can be useful to run standby JobManagers and TaskManagers that can take over the work of failed processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T074242Z" creationid="xccui" creationdate="20190606T195220Z">
        <seg>因此有必要运行一些后备JobManager及TaskManager来接管故障进程的工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it is important for data processors like Flink to provide a well-equipped library of connectors to read data from and write data to external systems as well as an API to implement custom connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T044904Z" creationid="xccui" creationdate="20190708T050417Z">
        <seg>因此对于Flink这样的数据处理引擎而言，很关键的一方面是能提供一套齐全的用于外部系统读写的连接器库，以及一组用于实现自定义连接器的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it is important that their execution does not stop even if an involved process fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072033Z" creationid="xccui" creationdate="20190424T064522Z">
        <seg>因此对于它很重要的一点是即便内部进程发生故障时也不能终止运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it is not difficult to update an application by removing stateful operators or state from an existing operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043616Z" creationid="xccui" creationdate="20190705T043616Z">
        <seg>因此，通过删除状态化算子或其中的状态来更新应用其实并不困难。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it is not uncommon for a checkpoint to take more time than the config‐ ured checkpointing interval.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T031849Z" creationid="xccui" creationdate="20190731T031542Z">
        <seg>因此，检查点实际生成间隔长于配置间隔这种现象并不少见。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it should be ignored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T061338Z" creationid="xccui" creationdate="20190618T061338Z">
        <seg>因此需要将其忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it will not be able to evict the state for the key because it might receive another record for the key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T182804Z" creationid="xccui" creationdate="20190704T170508Z">
        <seg>因此它根本无法准确移除某一键值的状态（因为不确定将来是否还有该键值的记录到来）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, its processing slows down and it might not be able to make enough pro‐ gress to keep up with the incoming data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T201213Z" creationid="xccui" creationdate="20190731T201213Z">
        <seg>因此，数据处理可能会变慢，导致跟不上数据接入的速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, its storage must be considered volatile.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061854Z" creationid="xccui" creationdate="20190608T053557Z">
        <seg>因此它们的存储只能看做是易失的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, keyed state is very similar to a distributed key-value map.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T035948Z">
        <seg>因此，键值分区状态看上去就像一个分布式键值映射（distributed key-value map）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, no events are lost and the state is completely built up from scratch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T191304Z" creationid="xccui" creationdate="20190606T034000Z">
        <seg>所以不会有任何事件丢失，状态也可以完全从最初开始构建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, no network communication is involved for a TaskManager-local connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T192436Z" creationid="esouser" creationdate="20190513T192419Z">
        <seg>因此对于TaskManager本地连接而言无须网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, only the JobManager can determine whether a check‐ point is successful or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T201942Z" creationid="xccui" creationdate="20190702T201832Z">
        <seg>因此，只有JobManager才能对此作出判断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, simply relying on watermarks might not always be a good idea.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025830Z" creationid="xccui" creationdate="20190414T031243Z">
        <seg>因此简单地依赖水位线并不总是可以高枕无忧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, split can also be used to filter or replicate events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053954Z" creationid="xccui" creationdate="20190615T053954Z">
        <seg>因此，split也可以用来过滤或复制事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the JobManager needs to acquire at least as many slots as the application’s maximum operator parallelism.6 Tasks are executed as threads within the worker (TaskManager) process and take as much CPU resources as they need.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T062029Z" creationid="xccui" creationdate="20190723T062029Z">
        <seg>因此，JobManager至少需要获取和应用算子最大并行度等量的处理槽。6 任务会在工作进程（TaskManager）中以线程方式执行，它们可以按需获取足够的CPU资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the callback method has full access to the key’s state and can also clear it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T204118Z" creationid="xccui" creationdate="20190704T204118Z">
        <seg>因此在回调方法内你可以获得当前键值状态的完整访问权限并将其清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the choice and configuration of the application’s state backend has a large impact on the performance of the checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T212448Z" creationid="xccui" creationdate="20190731T212448Z">
        <seg>因此，应用状态后端的选择和配置对检查点相关操作的性能有很大影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the client can send out multi‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035215Z" creationid="xccui" creationdate="20190707T035215Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the elements of both input streams can be jointly processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T063435Z" creationid="xccui" creationdate="20190615T052207Z">
        <seg>这样一来，我们就可以联合处理两个输入流的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the identifier of an operator changes when one of its predecessors changes, for example, when an operator is added or removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T071307Z" creationid="xccui" creationdate="20190610T023325Z">
        <seg>这意味着任何一个前置算子发生改变（例如添加或删除某个算子）都会导致该标识发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the image cannot be used to set up a HA Flink cluster on Kubernetes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190722T005127Z">
        <seg>所以说该镜像无法直接用在Kubernetes上设置Flink HA集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the sink should be able to write to the sink system, but the written data must not be made visible to the outside before it is committed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T024605Z" creationid="xccui" creationdate="20190715T213707Z">
        <seg>如果是后者，数据汇需要能向外部系统写入数据，但在正式提交之前，这些数据不能对外可见。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the total state of an application must fit into</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T020451Z" creationid="xccui" creationdate="20190704T020451Z">
        <seg>因此JobManager的内存需要装得下应用的全部状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, there are basically no serialization and communication costs for pass&lt;t3/&gt;‐&lt;t4/&gt; ing records between functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153042Z" creationid="esouser" creationdate="20190514T153042Z">
        <seg>因此函数之间的记录传输基本上不存在序列化及通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, there are basically no serialization and communication costs for passing records between functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203739Z" creationid="xccui" creationdate="20190606T203739Z">
        <seg>因此函数之间的记录传输基本上不存在序列化及通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, they are as powerful as process functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T182328Z" creationid="xccui" creationdate="20190626T182328Z">
        <seg>因此它其实和处理函数一样强大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, they are sufficient to restart an application after it failed but provide less flexibility than savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T205806Z" creationid="xccui" creationdate="20190731T205806Z">
        <seg>因此它们虽然足以让应用在失败后重启，但无法提供保存点那样的灵活性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, they can to some extent mitigate the effect of replayed results as caused by Flink’s checkpointing mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T070235Z" creationid="xccui" creationdate="20190708T070058Z">
        <seg>所以说，它们可以在一定程度上减轻Flink检查点机制所带来的重复结果的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, they clean up when a job stops running, either due to a failure or explicit cancellation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T205204Z" creationid="xccui" creationdate="20190731T205129Z">
        <seg>因此它们会在作业停止运行时（无论由于故障还是显式取消）被清理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you can also submit applications using</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T042552Z" creationid="xccui" creationdate="20190718T042552Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you can fix bugs in your application logic and reprocess as many events as your streaming source can provide in order to repair your results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T070440Z" creationid="xccui" creationdate="20190609T212214Z">
        <seg>这意味着你可以修复应用的一些逻辑Bug，然后在数据流来源的支持范围内下尽可能多地重新处理输入事件，以此来修复结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you cannot access the master con‐ tainer to submit an application or access the Web UI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T035153Z" creationid="xccui" creationdate="20190720T035153Z">
        <seg>因此你无法连接主进程容器来提交应用或访问Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you do not need to add a dependency to your build file to use it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T204756Z" creationid="xccui" creationdate="20190710T204756Z">
        <seg>因此在使用它时无需向构建文件中添加额外的依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you do not need to add any other dependency to use this feature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T184121Z" creationid="xccui" creationdate="20190710T184121Z">
        <seg>因此你在用它的时候无需添加任何其他依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you do not need to run standby processes in a YARN setup to achieve HA.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T051731Z" creationid="xccui" creationdate="20190721T051731Z">
        <seg>因此你无须在YARN中设置后备进程就能实现HA。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you might need to explicitly provide TypeInformation objects to Flink for some of the data types used in your application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T035813Z" creationid="xccui" creationdate="20190617T061243Z">
        <seg>因此对于应用中的部分数据类型，可能需要你向Flink显式提供TypeInformation对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you might use</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T052635Z" creationid="xccui" creationdate="20190617T052635Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you should be aware that you might debug a multithreaded program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T093740Z" creationid="xccui" creationdate="20190611T054146Z">
        <seg>所以你应该做好调试多线程程序的准备。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are a few resources you can use to ask questions, attend Flink-related events, and learn what people use Flink for:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T163944Z" creationid="xingcan" creationdate="20190807T163944Z">
        <seg>下面列出的一些资源可供你提问问题，参与Flink相关的活动，并了解Flink的使用情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example that processes a stream of Long values and increments each element:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T025144Z" creationid="xccui" creationdate="20190616T070438Z">
        <seg>下面的示例展示了如何处理一条Long值组成的数据流，对每个元素加一：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is the structure of a savepoint:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T165512Z" creationid="xccui" creationdate="20190726T020437Z">
        <seg>下方是一个保存点的目录结构：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here we describe some of the most commonly used metrics and refer you to Flink’s documentation for a full list of available metrics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T152833Z" creationid="xingcan" creationdate="20190802T152833Z">
        <seg>接下来我们将向你介绍一些最长用到的指标。有关可用指标的完整列表请参阅Flink文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here we explain how to do this with a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T021444Z" creationid="xccui" creationdate="20190620T021444Z">
        <seg>此处我们只介绍使用用户自定义函数的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we briefly review some common data exchange strate&lt;t2/&gt;‐&lt;t3/&gt; gies, as shown in &lt;t4/&gt;Figure 2-3&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034906Z" creationid="xccui" creationdate="20190401T034747Z">
        <seg>下面我们结合图2-3来简单回顾一下常见的数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we briefly review some common data exchange strate‐ gies, as shown in Figure 2-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045024Z" creationid="xccui" creationdate="20190605T233351Z">
        <seg>接下来，我们结合图2-3来简单回顾一下常见的数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we use a Scala case class as the data type that we defined before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051901Z" creationid="xccui" creationdate="20190612T051901Z">
        <seg>在这里我们使用事先定义好的Scala样例类作为数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly Available Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144306Z" creationid="esouser" creationdate="20190603T144306Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly Available Setups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152146Z" creationid="esouser" creationdate="20190603T152146Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly Available Setups | 233</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042826Z" creationid="xccui" creationdate="20190725T042826Z">
        <seg>高可用设置 | 233</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Kubernetes Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025452Z" creationid="xccui" creationdate="20190225T025452Z">
        <seg>基于Kubernetes 的高可用设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021800Z" creationid="xccui" creationdate="20190225T021800Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Setups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025425Z" creationid="xccui" creationdate="20190225T025425Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Stand-Alone Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025438Z" creationid="xccui" creationdate="20190225T025438Z">
        <seg>基于独立集群的高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available YARN Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025441Z" creationid="xccui" creationdate="20190225T025441Z">
        <seg>基于YARN的高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Histogram</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031907Z" creationid="xccui" creationdate="20190803T031907Z">
        <seg>Histogram</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How can you ensure that such failures are handled transparently so that your streaming job can continue to run?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185857Z" creationid="xccui" creationdate="20190415T041907Z">
        <seg>如何确保能够透明地处理这些故障，让流式作业得以继续运行？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How do you apply a reconfiguration with low effort while guaranteeing correctness?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T045605Z" creationid="xccui" creationdate="20190725T045605Z">
        <seg>如何在保证正确的同时以低成本应用新的配置？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How exactly the state is stored, accessed, and maintained is determined by a pluggable component</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061553Z" creationid="xccui" creationdate="20190608T051306Z">
        <seg>至于状态具体的存储、访问和维护，则是由一个名为状态后端的可插拔组件来决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How exactly the state of a task is copied depends on the implementation of the state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T065621Z" creationid="xccui" creationdate="20190609T202643Z">
        <seg>因此任务的状态的具体拷贝过程完全取决于状态后端的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How this operator works, including the role of the CheckpointCommitter, and which consistency guarantees it provides, is described in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T224246Z" creationid="xccui" creationdate="20190711T224217Z">
        <seg>有关该算子的工作原理，包括CheckpointCommitter的作用以及送提供的一致性保障，我们会在209页"事务性数据汇连接器"一节详细介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to Contact Us</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210835Z" creationid="esouser" creationdate="20190603T210835Z">
        <seg>How to Contact Us</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How&lt;t6/&gt;‐&lt;t7/&gt; ever, too many co-located tasks can also overload a TaskManager and result in bad performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062808Z" creationid="xccui" creationdate="20190424T062808Z">
        <seg>然而，任务过于集中也会使TaskManager负载变高，继而导致性能下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T194758Z" creationid="xccui" creationdate="20190715T194758Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Apache Flink has many features to significantly ease the maintenance of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T160853Z" creationid="xccui" creationdate="20190726T005910Z">
        <seg>好在Flink自身提供的很多功能可以极大简化流式应用的维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Flink currently does not support changing the primitive (or structure) of a state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T044641Z" creationid="xccui" creationdate="20190705T044641Z">
        <seg>但是目前Flink还不支持改变状态的原语（或结构）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, ProcessWindowFunction’s Context object also offers unique features.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011712Z" creationid="xccui" creationdate="20190624T011712Z">
        <seg>而ProcessWindowFunction的Context对象还提供了一些特有的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, UNIX-based setups enjoy the richest tooling support because this environment is preferred by most Flink developers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T054143Z" creationid="xccui" creationdate="20190610T041004Z">
        <seg>但基于类UNIX系统的设置会享有最丰富的工具支持，因为大多数Flink开发人员都偏爱这类环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a function with keyed state can only access the state of a key if it received a record with that key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T142046Z" creationid="xccui" creationdate="20190704T142046Z">
        <seg>然而，具有键值分区状态的函数只有在收到某键值的记录时才能访问该键值的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, adding a single value to ListState—appending it to the end of the list—is a cheap operation because only the appended value is serialized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T032817Z" creationid="xccui" creationdate="20190704T032817Z">
        <seg>但向ListState中添加一个值（将其附加到列表最后）的操作会相对轻量级一些，因为它只会序列化新添加的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, also with storage systems and execution engines of the Hadoop ecosystem the overall mode of operation of the infrastructure remains basically the same as the traditional data warehouse architec&lt;t2/&gt;‐&lt;t3/&gt; ture, i.e., data is periodically extracted and loaded into to a data store and processed by periodic or ad-hoc queries in a batch fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T040639Z" creationid="xccui" creationdate="20190301T034022Z">
        <seg>虽说如此，但对Hadoop生态中的存储系统和执行引擎而言，其基础工作模式仍和传统数据仓库的架构保持一致，即周期性地将数据提取加载到数据存储系统，随后以批处理的方式执行定期或ad-hoc查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, another implication is that the state of an application is never in a consis‐ tent state except for the logical points in time when a checkpoint is taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T184547Z" creationid="xccui" creationdate="20190702T164144Z">
        <seg>但这也意味着除了生成检查点的几个逻辑时间点外，应用程序的状态无法做到强一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, applications can freely choose the meaning of the time&lt;t0/&gt;‐&lt;t1/&gt; stamps as long as the timestamps of the stream records are roughly ascending as the stream is advancing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035947Z" creationid="xccui" creationdate="20190523T035924Z">
        <seg>但实际上应用可以自由选择时间戳的含义，只要保证流记录的时间戳会随着数据流的前进大致递增即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, applications can freely choose the meaning of the timestamps as long as the timestamps of the stream records are roughly ascending as the stream is advancing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204846Z" creationid="xccui" creationdate="20190606T204846Z">
        <seg>但实际上应用可以自由选择时间戳的含义，只要保证流记录的时间戳会随着数据流的前进大致递增即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as you start writing more advanced streaming applica‐ tions, you might find yourself needing to implement more complex windowing logic, such as windows that emit early results and update their results if late elements are encountered, or windows that start and end when specific records are received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T050913Z" creationid="xccui" creationdate="20190625T050956Z">
        <seg>然而，当你要着手实现一些高级的流式应用时，可能会发现自己需要完成更为复杂的窗口逻辑，例如：窗口需要提前发出结果并在之后遇到迟到元素时对结果进行更新，或者窗口需要以特定记录作为开始或结束的边界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, being able to reset the state of an application to a consistent point is not sufficient to achieve satisfying processing guarantees for an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T045330Z" creationid="xccui" creationdate="20190708T053022Z">
        <seg>虽然如此，但像这样把应用状态重置到某个一致性的点所提供的应用处理保障还无法令人满意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, certain applications might not benefit from task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T191407Z" creationid="xccui" creationdate="20190730T191407Z">
        <seg>然而，也有特定的应用可能无法从中受益。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, counting how many times a specific event occurs in the input stream might return the wrong result under at-least-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T042923Z" creationid="xccui" creationdate="20190416T042900Z">
        <seg>但如果要计算某个事件在输入流中出现的次数，至少一次保障可能就会返回错误的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, custom operators can have their own interpretation and may, for example, adjust the preci‐ sion to microseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T064814Z" creationid="xccui" creationdate="20190606T205029Z">
        <seg>但自定义算子可以有自己的时间戳解析机制，如将精度调整为微秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, custom operators can have their own interpretation and, for example, adjust the precision to microseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040846Z" creationid="xccui" creationdate="20190523T040820Z">
        <seg>但自定义算子可以有自己的解析机制，例如，将精度调整为微秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, during busy times, customers will have to wait in line and latency will increase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054122Z" creationid="xccui" creationdate="20190402T205216Z">
        <seg>然而，在高峰时段，顾客必须要排队，此时延迟将增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, even with continuous ETL there will always be a certain delay until an event is processed by a query.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032305Z" creationid="xccui" creationdate="20190317T032305Z">
        <seg>但即便使用持续ETL，事件在被查询处理到之前总会有一定延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, even with continuous ETL there will always be a delay until an event is processed by a query.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155201Z" creationid="xccui" creationdate="20190605T043619Z">
        <seg>但即便持续地进行ETL操作，事件在被查询和处理到之前总会有一定延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, event-time applications require additional configuration com‐ pared to applications with processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204315Z" creationid="xccui" creationdate="20190606T204315Z">
        <seg>但和基于处理时间语义的应用相比，基于事件时间的应用需要一些额外的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, event-time applications require some additional configuration compared to applications with processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T160953Z" creationid="esouser" creationdate="20190514T160953Z">
        <seg>但和基于处理时间语义的应用相比，基于事件时间的应用需要一些额外的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, guaranteeing exactly-once delivery of results to external systems is very challenging.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050212Z" creationid="xccui" creationdate="20190415T045640Z">
        <seg>至于保证将结果精确一次地传递到外部系统，则难度很大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the restarted application is not identical to the application from which the savepoint was taken, there are three cases to consider:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T051000Z" creationid="xccui" creationdate="20190727T050708Z">
        <seg>然而，如果要重启的应用和之前生成保存点时的应用有所不同，那么就会有三种结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you hardcoded the parallelism on the StreamExecutionEnvironment or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T210240Z" creationid="xccui" creationdate="20190728T043331Z">
        <seg>但你如果是以硬编码的方式为StreamExecutionEnvironment或部分算子设置的并行度，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in certain situations, such as lambda functions or generic types, it is necessary to explicitly provide type information to make an application work or improve its performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055918Z" creationid="xccui" creationdate="20190616T064538Z">
        <seg>但在某些情况下，例如使用了Lambda函数或泛型类型，则必须显式指定类型信息才能启动应用或提高其性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in the context of Flink, the protocol is only run once for every</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T195959Z" creationid="xccui" creationdate="20190715T195711Z">
        <seg>但具体到Flink环境下，该协议只需针对每个检查点运行一次，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, instead of checkpointing the state to the JobMa‐ nager’s volatile memory, FsStateBackend writes the state to a remote and persis‐ tent file system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T022121Z" creationid="xccui" creationdate="20190704T022121Z">
        <seg>但它不会在创建检查点时将状态存到JobManager的易失内存中，而是会将它们写入远程持久化文件系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it adds latency because results only become visible when a check‐ point completes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T073602Z" creationid="xccui" creationdate="20190708T073500Z">
        <seg>但它会增加一定延迟，因为结果只有在检查点完成后才对外可见。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it also increases the amount of data a job needs to reprocess after recovering from a failure before it catches up to the tail of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T025626Z" creationid="xccui" creationdate="20190731T025506Z">
        <seg>但它同时会使作业在故障恢复过程中需要重新处理更多数据，才能"赶得上"流中的最新数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it can</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195737Z" creationid="xccui" creationdate="20190609T195737Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it can also be configured to provide at-least-once guarantees:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T031221Z" creationid="xccui" creationdate="20190731T030953Z">
        <seg>你也可以将该保障调整为至少一次：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it cannot provide bulletproof exactly-once guarantees,2 adds to the state size of an application, and the sink system has to deal with a spiky writing pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T075100Z" creationid="xccui" creationdate="20190708T074739Z">
        <seg>然而，WAL数据汇无法100%提供精确一次保障，2 它还会导致应用状态大小增加以及接收系统需要处理一次次的"波峰式"写入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it has a few notable drawbacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193935Z" creationid="xccui" creationdate="20190605T052900Z">
        <seg>然而自身却有很多明显的缺点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is limited by the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T022926Z" creationid="xccui" creationdate="20190704T022926Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is possible to disable this safety check as described in “Running and Managing Streaming Appli‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043530Z" creationid="xccui" creationdate="20190705T043509Z">
        <seg>但你可以禁用这一安全检查（相关内容会在第245页"运行和管理流式应用"中介绍）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is typically much smaller than keyed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T025410Z" creationid="xccui" creationdate="20190802T025332Z">
        <seg>但它通常要比键值分区状态小得多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it makes many applications much easier to realize, such as real-time dashboards or other monitoring applica‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T170437Z" creationid="xccui" creationdate="20190705T170437Z">
        <seg>反过来说，可查询式状态的确让很多应用变得容易实现，例如实时仪表盘或其他监控应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it relies on the fact that all partitions continuously provide increasing watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T072135Z" creationid="xccui" creationdate="20190607T031937Z">
        <seg>然而，这依赖于一个事实——所有分区都会持续提供自增的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it requires Hadoop dependencies on the classpath in order to work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T042300Z" creationid="xccui" creationdate="20190722T042106Z">
        <seg>但为了让它工作，还必须在Classpath里加入Hadoop依赖，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it requires that all stateful operators of the initial version of an application specify two parameters to ensure the application can be properly maintained in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T015342Z" creationid="xccui" creationdate="20190702T214012Z">
        <seg>但它需要初始版本应用的全部状态化算子都指定好两个参数，才可以在未来正常工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it serves well for locally developing Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T034637Z" creationid="xccui" creationdate="20190801T021824Z">
        <seg>但它对于本地开发Flink应用而言是一个很好的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it uses processing slots (see “Task Execution” on page 40 for a detailed discussion) to control the number of tasks that can be assigned to a worker process (TaskManager).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T151131Z" creationid="xccui" creationdate="20190723T061155Z">
        <seg>但会采用处理槽（详细信息请参阅第40页"任务执行"一节）来控制可以分配给工作进程（TaskManager）的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it uses the more general AggregateFunction to aggregate values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T033848Z" creationid="xccui" creationdate="20190630T060806Z">
        <seg>但它使用了更加通用的AggregateFunction来聚合内部的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, just being able to read or write data to external datastores is not sufficient for a stream processor that wants to provide meaningful consistency guarantees in the case of fail‐ ure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T044954Z" creationid="xccui" creationdate="20190708T050905Z">
        <seg>然而，对于流处理引擎而言，仅能读写外部数据存储是不够的，因为它还需要在故障时提供重要的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, most real-world applications combine charac&lt;t0/&gt;‐&lt;t1/&gt; teristics of more than one class which again shows the flexibility of this application design pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T072733Z" creationid="xccui" creationdate="20190305T160041Z">
        <seg>而现实中绝大多数应用都同时兼有多种类别模式的特征，这也印证了状态化流处理的灵活性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, once we reach a rate of incoming events such that the system resources are fully used, we will have to start buffering events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T201505Z" creationid="xccui" creationdate="20190401T210044Z">
        <seg>但现实中，一旦事件到达速率过高致使系统没有空闲资源，我们将被迫开始缓冲事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, once we reach a rate of incoming events such that the sys‐ tem resources are fully used, we will have to start buffering events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053028Z" creationid="xccui" creationdate="20190605T234718Z">
        <seg>但现实中，一旦事件到达速率过高致使系统没有空闲资源，系统就会被迫开始缓冲事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, reading and writing data to disk and the over‐ head of de/serializing objects result in lower read and write performance com‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025404Z" creationid="xccui" creationdate="20190704T025404Z">
        <seg>然而，对于磁盘的读写和序列化反序列化对象的开销使得它和在内存中维护状态比起来，读写性能会偏低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, reading state from remote storage during recovery is not very efficient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T155326Z" creationid="xingcan" creationdate="20190801T155326Z">
        <seg>然而在恢复期间从远程存储读取状态效率并不高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, recovering from master failures requires additional configuration as dis‐ cussed before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T062018Z" creationid="xccui" creationdate="20190721T062018Z">
        <seg>但同样如前所述，主进程的故障恢复需要一些额外的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, some improvements such as higher throughput and better failure guarantees came at the cost of increasing processing latencies from milliseconds to seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T194316Z" creationid="xccui" creationdate="20190327T035003Z">
        <seg>但它们的部分改进（例如更高的吞吐和更完善的故障处理保障）是以增加处理延迟（从毫秒级到秒级）为代价的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, some operations must collect and buffer records to compute their result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061737Z" creationid="xccui" creationdate="20190406T040646Z">
        <seg>然而，有些操作必须收集并缓冲记录才能计算结果，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, sometimes the type extractor fails or you might want to define your</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053221Z" creationid="xccui" creationdate="20190617T052957Z">
        <seg>但有时候类型提取器会失灵，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, sometimes we need access to all elements of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005942Z" creationid="xccui" creationdate="20190624T005942Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the Flink community is already working on unifying the two, and providing a single API for analysis of boun‐ ded and unbounded data streams in the same program is a priority in Flink’s future roadmap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T160413Z" creationid="xingcan" creationdate="20190807T160413Z">
        <seg>但Flink社区正着力于将二者统一，并在未来规划中会优先提供一套API，使同一个程序能同时分析有界和无界的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the Kuber‐ netes project provides Minikube, an environment to run a single- node Kubernetes cluster locally on a single machine for testing or daily development.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T023646Z" creationid="xccui" creationdate="20190720T023512Z">
        <seg>但它的项目内提供了一个可以在一台机器上本地运行单节点Kubernetes集群的环境——MiniKube，该环境可用于测试或日常开发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the application might emit results twice because all results that have been emitted after the last successful checkpoint (the one to which the application falls back in the case of a recovery) will be emitted again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T062101Z" creationid="xccui" creationdate="20190708T062101Z">
        <seg>但由于在前一次成功的检查点（故障恢复时的回退位置）后发出的数据会被再次发送，所以应用可能会发出两次结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the applications for ReduceFunction are limited and usually restricted to simple aggregations since the input and output type must be the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002147Z" creationid="xccui" creationdate="20190624T002147Z">
        <seg>然而ReduceFunction的应用场景存在一定局限，由于输入、输出类型必须一致，所以通常仅限于一些简单的聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the approach had a few notable drawbacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T015901Z" creationid="xccui" creationdate="20190327T015901Z">
        <seg>但它有很多不足之处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the broadcast state handle that is returned in the processElement()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T051404Z" creationid="xccui" creationdate="20190702T051348Z">
        <seg>但processElement()方法返回的句柄对广播状态是只读的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the complexity and consistency guarantees of an implementation depend on, among other things, the features and capabilities of the sink system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T060820Z" creationid="xccui" creationdate="20190716T060547Z">
        <seg>但具体实现的复杂度以及能够提供的一致性保障会取决于数据汇系统的特性及功能等因素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the growing adoption of stream processing technology in the recent past has been driven to a large extent by the availability of mature open source stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160136Z" creationid="xccui" creationdate="20190605T050109Z">
        <seg>而近期流处理技术的普及在很大程度上还要归功于很多开源界成熟的流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the growing adoption of stream processing technology in the recent past is driven to a large extent by the availability of mature open source stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014756Z" creationid="xccui" creationdate="20190319T041536Z">
        <seg>然而近期流处理技术的普及还要归功于开源界很多成熟的流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the identifier of an operator is deterministically generated based on the identifiers of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T023205Z" creationid="xccui" creationdate="20190610T021226Z">
        <seg>但该标识是根据前置算子的标识按照某种确定规则生成的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the infrastructure remains basically the same as a traditional data ware‐ house architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T064902Z" creationid="esouser" creationdate="20190603T204255Z">
        <seg>然而，这些基础设施所用的架构只是和传统数据仓库大同小异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the lifecycles of checkpoints and save‐ points differ.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T014459Z" creationid="xccui" creationdate="20190726T014459Z">
        <seg>但他们的生命周期有所差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the reality is that we can never have perfect watermarks because that would mean we are always certain there are no delayed records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T060631Z" creationid="xccui" creationdate="20190621T031325Z">
        <seg>然而现实中永远不会有完美的水位线，因为总会存在迟到的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the recommended approach is setting up and configuring a dedicated proxy service that controls access to the REST endpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T035551Z" creationid="xccui" creationdate="20190725T035551Z">
        <seg>但我们建议的方法是搭建和配置专用的代理服务来控制对于REST端点的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the state of a window that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034348Z" creationid="xccui" creationdate="20190625T034215Z">
        <seg>但和执行增量聚合的窗口相比，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the vision of the Flink community is to treat batch processing as a special case of stream processing, i.e., the processing of bounded streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060757Z" creationid="xccui" creationdate="20190328T060625Z">
        <seg>但Flink社区的视角是把批处理看做流处理的一个特例，即处理有界的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the vision of the Flink community is to treat batch processing as a special case of stream processing—the processing of bounded streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122214Z" creationid="xccui" creationdate="20190605T122214Z">
        <seg>但Flink社区的视角是把批处理看做流处理的一个特例，即处理有界的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are a few issues that need to be taken into account in order to be able to recompute and update results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T160700Z" creationid="xingcan" creationdate="20190628T160640Z">
        <seg>如果想重新计算和更新结果，就必需考虑几个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are a few things to consider when debugging a Flink application in an IDE:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T212952Z" creationid="xccui" creationdate="20190611T053805Z">
        <seg>但在调试时需要注意以下几点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are a few things to consider.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T055328Z" creationid="xccui" creationdate="20190727T055328Z">
        <seg>虽然容易，但扩缩容过程中还是有一些需要考虑的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are constructors that take parameters to enable or disable asynchronous checkpointing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022604Z" creationid="xccui" creationdate="20190801T022556Z">
        <seg>但它有一些构造函数，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is also a mode in which the call of the execute() method starts a Job‐ Manager and a TaskManager (by default with as many slots as available CPU threads) as separate threads within the same JVM. Consequently, the whole Flink application is multithreaded and executed within the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T093215Z" creationid="xccui" creationdate="20190611T052546Z">
        <seg>但除此之外还有一种执行模式：当程序的execute()方法被调用时，会在同一个JVM中以独立线程的方式启动一个JobManager线程和一个TaskManager（默认的处理槽数等于CPU的线程数）。这样，整个Flink应用会以多线程的方式在同一个JVM进程中执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, these files are not automatically cleaned up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T191638Z" creationid="xccui" creationdate="20190711T191141Z">
        <seg>但这些文件不会被自动清理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, these paths can also be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043036Z" creationid="xccui" creationdate="20190724T042932Z">
        <seg>但这些组件各自的路径也可以分别设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they do not measure the time it takes for records to be processed or the time that records wait in state until they are processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T062842Z" creationid="xccui" creationdate="20190806T062842Z">
        <seg>然而，它们无法测量记录处理所需的时间或记录在状态中等待处理的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they do not meet the latency requirements for many of today’s use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T153957Z" creationid="xccui" creationdate="20190604T055430Z">
        <seg>但这对于现如今很多用例场景而言无法满足延迟方面的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they have a very similar feature set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T052107Z" creationid="xccui" creationdate="20190621T052107Z">
        <seg>但是它们的功能都很相似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this has dramatically changed in the last decade.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T051715Z" creationid="xccui" creationdate="20190317T033023Z">
        <seg>然而，这在过去十年里发生了巨大的变化，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this will</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T161505Z" creationid="xingcan" creationdate="20190709T161505Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, to improve the efficiency of the necessary state transfer between tasks, Flink does not redistribute individual keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062145Z" creationid="xccui" creationdate="20190608T055302Z">
        <seg>但为了降低状态在不同任务之间迁移的必要成本，Flink不会对单独的键值实施再分配，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, transactional data is often distributed across several disconnected database systems and becomes more valuable when it can be jointly analyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192024Z" creationid="xccui" creationdate="20190228T183532Z">
        <seg>虽然如此，但事务数据通常存储于互不相连的数据库系统之中，如能将它们联结分析必能创造更大价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, transactional data is often distributed across several discon‐ nected database systems and is more valuable when it can be jointly analyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T072143Z" creationid="esouser" creationdate="20190603T201929Z">
        <seg>然而用于存储事务性数据的多个数据库系统通常都是相互隔离的，如能将它们联合分析必然会创造更高的价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, we have not yet discussed where they originate from.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033616Z" creationid="xccui" creationdate="20190607T033558Z">
        <seg>但一直没涉及它们的来源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, with the given configuration, Kubernetes does not export any port to external environments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T035035Z" creationid="xccui" creationdate="20190720T035035Z">
        <seg>然而使用上述给定的设置，Kubernetes不会向外部环境暴露任何端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, with the growing popularity of Hadoop, companies realized that a lot of valuable data was excluded from their data analytics process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T205940Z" creationid="xccui" creationdate="20190228T203747Z">
        <seg>但随着Hadoop的流行，不少公司开始意识到他们现有的数据分析流程会遗漏很多有价值的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can also enable a feature called externalized checkpoints to retain checkpoints after the application has stopped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T205305Z" creationid="xccui" creationdate="20190731T205305Z">
        <seg>但你可以启用一个名为外化检查点（externalized checkpoint）的功能，在应用停止后保留检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can also invert the lookup order with the classloader.resolve-order configuration key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T151046Z" creationid="xccui" creationdate="20190723T060603Z">
        <seg>但你也可以使用classloader.resolve-order配置项反转这一顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can also provide default set‐ tings for a Flink cluster through Flink’s configuration file, which are applied if job- specific options are not declared.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T044128Z" creationid="xccui" creationdate="20190724T044128Z">
        <seg>但你也可以通过Flink配置文件为整个Flink集群提供默认设置，它们会在作业未显式声明时起到作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can be quite cer‐ tain all relevant data is available when you perform a computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T061142Z" creationid="xccui" creationdate="20190621T040233Z">
        <seg>但这样的好处是在执行计算时你能确保全部相关数据都已收集完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can configure Docker to deploy its images to Mini‐ kube’s own registry by running the following command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T045102Z" creationid="xccui" creationdate="20190730T045102Z">
        <seg>为此，你可以使用以下命令配置Docker，让它将镜像部署到Minikube自己的注册表中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can configure the RocksDB state backend to also store the timers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063206Z" creationid="xccui" creationdate="20190621T065154Z">
        <seg>同时你也可以配置RocksDB状态后端来存计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you should also know how to create a new Flink project from scratch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004140Z" creationid="xccui" creationdate="20190612T004101Z">
        <seg>但同时你也要掌握如何从头开始创建一个新的Flink项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you should be aware that failure scenarios exist in which a write-ahead log sink emits</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T042955Z" creationid="xccui" creationdate="20190715T042845Z">
        <seg>然而你要明白，WAL所支撑的数据汇在某些极端情况下可能会将记录写出多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How‐ ever, as of Flink 1.7 no such tool exists.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T034951Z" creationid="xccui" creationdate="20190705T045217Z">
        <seg>但它们还没有在Flink 1.7版本中提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How‐ ever, efficient and reliable management of state is more challenging.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055302Z" creationid="xccui" creationdate="20190607T055225Z">
        <seg>而难点在于如何高效、可靠地管理状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How‐ ever, since it is typically not possible for an operator to retain all state forever, it needs to purge state at some point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T162447Z" creationid="xingcan" creationdate="20190628T162447Z">
        <seg>然而通常算子无法永久保留所有状态，最终还是需要在某个时间点将其清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How‐ ever, too many colocated tasks can also overload a TaskManager and result in bad performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144821Z" creationid="xccui" creationdate="20190606T144803Z">
        <seg>然而，任务过于集中也会使TaskManager负载变高，继而可能导致性能下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IDs of Committed Files May Not Be Consecutive</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T020153Z" creationid="xccui" creationdate="20190711T020153Z">
        <seg>提交文件的ID不一定连续</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IN specifies the type of the input records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T043911Z" creationid="xccui" creationdate="20190716T043911Z">
        <seg>IN用于指定输入记录的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ideally, you would like this latency to remain constant and independent of the rate of the incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052913Z" creationid="xccui" creationdate="20190401T205449Z">
        <seg>理想情况下，你会希望延迟保持平稳，不受事件到来速率的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idempotent Sink Connectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055053Z" creationid="xccui" creationdate="20190225T025308Z">
        <seg>幂等性数据汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idempotent Writes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152026Z" creationid="esouser" creationdate="20190603T151856Z">
        <seg>幂等性写</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idempotent write operations are interesting for streaming applications because they can be performed multiple times without changing the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T070017Z" creationid="xccui" creationdate="20190708T065128Z">
        <seg>幂等性写操作对于流式应用而言很有意义，因为它们可以在不改变结果的前提下多次执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T175532Z" creationid="xccui" creationdate="20190717T175532Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If Java is not on the PATH or if you want to use a different Java version you can specify the root folder of a Java installation via the JAVA_HOME envi‐ ronment variable or the env.java.home key in the configuration file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T043919Z" creationid="xccui" creationdate="20190723T043919Z">
        <seg>如果PATH中没有配置Java或者想要使用其他Java版本，你可以利用配置文件中的JAVA_HOME环境变量或env.java.home键对应的参数来指定Java安装目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195137Z" creationid="xccui" creationdate="20190626T195137Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a modified application is started from a savepoint, a state in the savepoint can only be mapped to the application if it contains an operator with a corresponding identi‐ fier and state name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023155Z" creationid="xccui" creationdate="20190609T220228Z">
        <seg>如果应用在从保存点启动的时候发生过改动，那么保存点中的状态只有在应用还保留着那些含有对应标识和状态名称的算子时才可以成功映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a savepoint path is provided, the application state is initialized from the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T050547Z" creationid="xccui" creationdate="20190729T050547Z">
        <seg>如果提供了保存点路径，会使用该保存点初始化应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a source function (temporarily) does not emit anymore watermarks, it can declare itself idle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054734Z" creationid="xccui" creationdate="20190607T034439Z">
        <seg>如果源函数（临时性地）不再发出水位线，可以把自己声明成空闲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a sys‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T200622Z" creationid="xccui" creationdate="20190716T200622Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a timestamp assigner is used, any existing timestamps and water‐ marks will be overwritten.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T025618Z" creationid="xccui" creationdate="20190620T025618Z">
        <seg>一旦使用时间戳分配器，已有的时间戳和水位线都将被覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a trigger is applied together with a MergingWindowAssigner, it needs to be able to handle the case when two windows are merged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194900Z" creationid="xccui" creationdate="20190626T194900Z">
        <seg>如果某个触发器和MergingWindowAssigner一起使用，则需要处理两个窗口合并的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a win‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052117Z" creationid="xccui" creationdate="20190625T052117Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an application ingests data from a source connector that is not able to store and reset a reading position, it might suffer from data loss in the case of a failure and only provide at-most-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T061539Z" creationid="xccui" creationdate="20190708T061539Z">
        <seg>如果应用使用的数据源连接器无法存储和重置读取位置，那么在出现故障时它就可能要丢失部分数据，从而只能提供最多一次保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an application is updated without removing or changing existing state, it is always savepoint compatible and can be started from a savepoint of an earlier version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T040244Z" creationid="xccui" creationdate="20190705T040244Z">
        <seg>如果应用在更新时不会删除或改变已有状态，那么它一定是保存点兼容的，并且能够从旧版本的保存点启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an application needs to recover from a failure, all processing-time timers that expired while the application was restarting will fire immediately when the application resumes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T065349Z">
        <seg>如果应用需要从故障中恢复，那么所有在应用重启过程中过期的处理时间计时器会在应用恢复后立即触发，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210742Z" creationid="esouser" creationdate="20190603T210742Z">
        <seg>If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both tasks are located on the same physical machine (which is often ensured by task schedu&lt;t2/&gt;‐&lt;t3/&gt; lers), this exchange strategy avoids network communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T134825Z" creationid="xccui" creationdate="20190401T134633Z">
        <seg>如果两端任务运行在同一物理机器上（通常由任务调度器保障），该交换策略可以避免网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both tasks are located on the same physical machine (which is often ensured by task schedu‐ lers), this exchange strategy avoids network communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233415Z" creationid="xccui" creationdate="20190605T233415Z">
        <seg>如果两端任务运行在同一物理机器上（通常由任务调度器保障），该交换策略可以避免网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If configured for HA, all Dispatchers of a standalone setup register at ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T034617Z" creationid="xccui" creationdate="20190721T034617Z">
        <seg>如果进行了HA配置，则所有独立集群设置下的Dispatcher都会在ZooKeeper中注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If events take a long time to travel in the data processing pipeline, we cannot easily ensure high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053856Z" creationid="xccui" creationdate="20190605T234945Z">
        <seg>如果事件在数据处理管道中传输时间太久，我们将难以确保高吞吐；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If events take long to travel in the data processing pipeline, we cannot easily ensure high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T203457Z" creationid="xccui" creationdate="20190402T203213Z">
        <seg>如果事件在数据处理管道中的传输时间太久，我们将难以确保高吞吐；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it fails after it has updated its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033627Z" creationid="xccui" creationdate="20190606T033627Z">
        <seg>如果在更新内部状态后发生故障，系统恢复后是否会重复更新？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it fails after it has updated its internal state, will it update it again after it recovers?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043148Z" creationid="xccui" creationdate="20190415T043141Z">
        <seg>如果在更新内部状态后发生故障，系统恢复后是否会重复更新？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it refers to a directory, FileInputFormat scans the directory for files to read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T200916Z" creationid="xccui" creationdate="20190710T185555Z">
        <seg>如果路径指向一个目录，则FileInputFormat会扫描并读取该目录中满足条件的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If many or all checkpoints take longer than the checkpointing interval, this behavior might not be optimal for two reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T032201Z" creationid="xccui" creationdate="20190731T200634Z">
        <seg>如果很多或全部检查点的生成时间都长于生成间隔，那么可能需要对此进行调优，具体原因有二。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If multiple copies of the same job are run concurrently, metrics might become inaccurate, due to string conflicts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043855Z" creationid="xccui" creationdate="20190804T043855Z">
        <seg>如果相同作业同时运行了多个副本，那么由于字符串冲突，度量标准可能会不准确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no BucketAssigner is explicitly specified, it uses a DateTimeBucketAssigner that assigns records to hourly buckets based on the pro‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T213030Z" creationid="xccui" creationdate="20190710T212826Z">
        <seg>如果没有显式指定BucketAssigner，数据汇将使用DateTimeBucketAssigner，按照记录写出时的处理时间将它们分到每小时一个的桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no CheckpointCommitter is configured, the information is written into a specific Cassandra table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T224027Z" creationid="xccui" creationdate="20190711T223913Z">
        <seg>如果该参数没有配置，数据汇会将相关信息写入一个特定的Cassandra表中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no port is configured, Cassandra’s default port 9042 is used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T222059Z" creationid="xccui" creationdate="20190711T222059Z">
        <seg>如果不指定端口，则它会使用Cassandra的默认端口9042。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no such timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060625Z" creationid="xccui" creationdate="20190621T060625Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no such timer exists, the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060716Z">
        <seg>如果该计时器不存在，则方法不会有任何作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not enough slots are available, Flink’s ResourceManager requests additional containers from the YARN Resource‐ Manager to start TaskManager processes, which register themselves at the Flink ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T141852Z" creationid="xccui" creationdate="20190718T214623Z">
        <seg>如果处理槽数量不足，Flink的ResourceManager会向YARN的ResourceManager申请更多容器来启动TaskManager进程，这些进程在启动后会把自己注册到Flink的ResourceManager中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not specified, the default partitioner maps each</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T034438Z" creationid="xccui" creationdate="20190710T034438Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one of the TaskManagers fails, the number of available slots drops to six.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205758Z" creationid="xccui" creationdate="20190428T205742Z">
        <seg>如果有一个TaskManager出现故障，则可用处理槽的数量就降到了6个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If set to the keyword</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T012422Z" creationid="xccui" creationdate="20190719T012422Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If started in session mode, Flink connects to YARN’s ResourceManager to start an application master that runs a Dispatcher thread and a Flink ResourceManager thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T214246Z" creationid="xccui" creationdate="20190718T214246Z">
        <seg>如果在会话模式下启动，Flink会连接YARN的ResourceManager来启动包含一个Dispatcher线程和一个ResourceManager线程的ApplicationMaster。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If state gets lost during a failure, results will be incorrect after recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T184931Z" creationid="xccui" creationdate="20190415T035644Z">
        <seg>如果状态在故障期间丢失，那恢复后的结果就会不正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that suc‐ ceeds, the tasks first try to load the checkpoint data from the local disk.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T162616Z" creationid="xingcan" creationdate="20190801T162616Z">
        <seg>如果成功，则任务会优先尝试从本地磁盘加载检查点数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the JobManager runs remotely, the JobGraph must be shipped together with a JAR file that contains all classes and required dependencies of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T052351Z" creationid="xccui" creationdate="20190613T012656Z">
        <seg>如果是远程JobManager的情况，除了JobGraph之外，我们还要同时提供包含应用所需全部类和依赖的JAR包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the ResourceManager does not have enough slots to fulfill the JobManager’s request, the ResourceManager can talk to a resource provider to provision containers in which TaskManager processes are started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060937Z" creationid="xccui" creationdate="20190418T050826Z">
        <seg>如果ResourceManager的处理槽数无法满足JobManager的请求，则ResourceManager可以和资源提供者通信，让它们提供额外容器来启动更多TaskManager进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application is explicitly canceled, the checkpoint is deleted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T205554Z" creationid="xccui" creationdate="20190731T205554Z">
        <seg>如果应用被显式取消，则检查点会删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application is not started from a checkpoint or savepoint, the state will be initially empty.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071046Z" creationid="xccui" creationdate="20190702T071046Z">
        <seg>如果应用不是从检查点或保存点启动，那状态就会初始化为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application is started without existing state, the reading offsets must be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T162543Z" creationid="xccui" creationdate="20190712T162543Z">
        <seg>如果应用在没有状态的情况下启动，则读取偏移需要被设置成默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application runs in a local execution environment the parallelism is set to match the number of CPU cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T052859Z" creationid="xccui" creationdate="20190616T052859Z">
        <seg>如果应用是在一个本地执行环境中运行，并行度会设置为CPU的核心数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application was submitted to a Dispatcher or YARN Resource&lt;t5/&gt;‐&lt;t6/&gt; Manager, it will spin up a JobManager, hand over the application, and the Job&lt;t7/&gt;‐&lt;t8/&gt; Manager continues to execute the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030049Z" creationid="xccui" creationdate="20190423T030049Z">
        <seg>如果应用提交到Dispatcher或YARN ResourceManager，它们会启动一个JobManager并将应用转交给它，随后由JobManager负责继续执行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application was submitted to a Dispatcher or YARN ResourceManager, it will spin up a JobManager and hand over the application, and the JobManager will start to execute the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T062914Z" creationid="xccui" creationdate="20190606T143514Z">
        <seg>如果应用提交到Dispatcher或YARN ResourceManager，它们会启动一个JobManager并将应用转交给它，随后由JobManager负责执行该应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application was submitted to a JobManager, it immediately starts to execute the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025910Z" creationid="xccui" creationdate="20190423T025902Z">
        <seg>如果应用提交到JobManager，会立即开始执行；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the barista runs out of milk right before preparing your cappuccino, you will have to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051209Z" creationid="xccui" creationdate="20190605T234059Z">
        <seg>如果咖啡师在给你准备卡布奇诺（译者注：一种需要牛奶和奶泡的咖啡）前刚好把牛奶用光了，那么你必须等他从供应间再拿一些出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the barista runs out of milk right before preparing your cappuccino, you will have to wait until they bring some from the supply room.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T160202Z" creationid="xccui" creationdate="20190401T155651Z">
        <seg>如果咖啡师在给你准备卡布奇诺（译者注：一种需要牛奶和奶泡的咖啡）前刚好把牛奶用光了，则你必须等他从补给室再拿一些出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the command completed successfully, you will find a new target folder in your project folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010337Z" creationid="xccui" creationdate="20190612T010337Z">
        <seg>如果命令成功完成，你会在项目目录里看到一个新的target文件夹。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the consumer is configured to read_committed, it stops consuming from a partition once it encoun‐ ters an uncommitted message and resumes when the message is committed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T212745Z" creationid="xccui" creationdate="20190709T212745Z">
        <seg>如果将一个消费者配置为read_committed，那么它一旦遇到一条未提交的消息，就会停止对该分区消费，直到消息被提交为止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the data type is a tuple, keys can be defined by simply using the field position of the corresponding tuple element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040135Z" creationid="xccui" creationdate="20190618T033121Z">
        <seg>针对元组数据类型，你可以简单地使用元组相应元素的字段位置来定义键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the event-time clock advances, the task processes all triggered timers and finally broadcasts its new event time to all downstream tasks by emitting a corresponding watermark to all con‐ nected output partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054036Z" creationid="xccui" creationdate="20190607T025043Z">
        <seg>如果事件时间时钟向前推动，任务会先处理因此而触发的所有计时器，之后才会把对应的水位线发往所有连接的输出分区，以实现事件时间到全部下游任务的广播。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the exter‐ nal sink system cannot atomically write multiple records—either all or none—</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065321Z" creationid="xccui" creationdate="20190715T065321Z">
        <seg>如果外部数据汇系统不支持原子性地写入多个记录（全写或全不写），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the input is a white square, it outputs the event unmodified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054414Z" creationid="xccui" creationdate="20190613T054359Z">
        <seg>如果输入是白色方块，则不加改动直接输出；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the input operators are in different groups, the operator is in the "default" group.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015113Z" creationid="xccui" creationdate="20190731T015113Z">
        <seg>如果输入算子属于不同的处理槽共享组，那么该算子则会被加入"default"组中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the key domain is continuously growing—for example, because the key is a unique transaction ID—you have to clean up state for keys that are no longer active to avoid memory problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060910Z" creationid="xccui" creationdate="20190614T045513Z">
        <seg>如果键值域（key domain）会持续增长（例如将唯一的事务ID作为键值），则必须对那些不再活跃的键值进行清理，以避免出现内存问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the manifest file of your application JAR file does not specify an entry class, you can specify the class using the -c parameter:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T031651Z" creationid="xccui" creationdate="20190726T031651Z">
        <seg>如果应用JAR包的manifest文件没有指定入口类，则你可以使用-c参数指定它：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the master process needs to manage several applications or an application with many operators, you might need to increase the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T063059Z" creationid="xccui" creationdate="20190723T063059Z">
        <seg>但如果主进程需要管理多个应用或某个应用具有很多算子，你可能需要利用jobmanager.heap.size配置项来增加JVM堆的容量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the master process that runs the active Dispatcher and JobManager fails, ZooKeeper elects a new Dispatcher as the leader.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T144740Z" creationid="xccui" creationdate="20190721T050133Z">
        <seg>如果当前运行Dispatcher和JobManager的主进程出现故障，ZooKeeper就会选出一个新的Dispatcher作为领导者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the method is invoked from a submission cli‐ ent with a connection to a remote cluster, a remote execution environment is returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045413Z" creationid="xccui" creationdate="20190612T045413Z">
        <seg>如果是一个连接远程集群的提交客户端调用了该方法，则会返回一个远程执行环境；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the method returns a nonnull value with a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T050009Z" creationid="xccui" creationdate="20190620T050009Z">
        <seg>如果该方法的返回值非空，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the number of buffers is not appropri‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T040047Z" creationid="xccui" creationdate="20190724T040047Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the number of partitions is larger than the number of subtasks, the default configuration results in empty parti‐ tions, which can cause problems for Flink applications consuming the topic in event- time mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T035237Z" creationid="xccui" creationdate="20190710T035040Z">
        <seg>而如果分区数多于任务数，则默认配置会导致有些分区为空，此时若恰好有使用事件时间的Flink应用消费了该主题，那么可能会导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operator is configured just with an incremental aggregation func‐ tion, the current aggregation result is emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053430Z" creationid="xccui" creationdate="20190625T053430Z">
        <seg>如果算子只是配置了一个增量聚合函数，就会发出当前聚合结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operator only has a full window function, the function is applied on all ele‐ ments of the window and the result is emitted as shown in Figure 6-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053951Z" creationid="xccui" creationdate="20190625T053710Z">
        <seg>如果算子只包含一个全量窗口函数，那么该函数将一次性作用于窗口内的所有元素上，之后便会发出结果。该情况如图6-5所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operator’s parallelism is larger than 128, the maximum parallelism is com‐ puted as the minimum of nextPowerOfTwo(parallelism + (parallelism / 2)) and 2^15.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025539Z" creationid="xccui" creationdate="20190703T025539Z">
        <seg>如果算子并行度大于128，那么最大并行度会取nextPowerOfTwo(parallelism + (parallelism / 2))和2^15之中的较小值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the parallelism is less than or equal to 128, the maximum parallelism is 128.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025409Z" creationid="xccui" creationdate="20190703T025409Z">
        <seg>如果并行度小于或等于128，则最大并行度会设置成128；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the parallelism of your application depends on the environment’s default parallel‐ ism, Flink provides an atomic rescale command that takes a savepoint, cancels the application, and restarts it with a new default parallelism:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T210425Z" creationid="xccui" creationdate="20190728T044517Z">
        <seg>针对应用程序并行度依赖环境默认并行度的情况，Flink提供了一个原子性的扩缩容命令，它可以生成一个保存点，取消应用，随后再以新的并行度将应用重启：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the path refers to a file, the single file is read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185450Z" creationid="xccui" creationdate="20190710T185450Z">
        <seg>如果路径指向一个文件，则读取该文件；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the sender and receiver tasks run in separate Task&lt;t0/&gt;‐&lt;t1/&gt; Manager processes, they communicate via the network stack of the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042532Z" creationid="xccui" creationdate="20190504T042532Z">
        <seg>如果发送端和接收端的任务运行在不同的TaskManager进程中，就需要利用操作系统的网络栈进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the sender and receiver tasks run in separate TaskManager pro‐ cesses, they communicate via the network stack of the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T191535Z" creationid="xccui" creationdate="20190606T195843Z">
        <seg>如果发送端和接收端的任务运行在不同的TaskManager进程中，它们就要用到操作系统的网络栈进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the sink system closes a transaction (e.g., with a timeout), the not committed data will be lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T030657Z" creationid="xccui" creationdate="20190716T030657Z">
        <seg>此时如果数据汇系统因为超时等原因将事务关闭，那么所有未提交的数据都将丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the slide is larger than the window size, some elements might not be assigned to any window and hence may be dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T030036Z" creationid="xccui" creationdate="20190623T055207Z">
        <seg>如果滑动间隔大于窗口大小，则一些元素可能不会分配给任何窗口，因此可能会被丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the state backend does not contain state for the given descriptor, the state that is linked to the handle is initialized as empty.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T035233Z" creationid="xccui" creationdate="20190701T022350Z">
        <seg>如果状态后端没包含给定描述符的对应状态，那么系统就会以空值来初始化句柄所关联的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the state of a task instance grows too large, the JVM and all task instances running on it can be killed due to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T222738Z" creationid="xccui" creationdate="20190703T222738Z">
        <seg>如果某个任务实例的状态变得很大，那么它所在的JVM连同所有运行在该JVM之上的任务实例都可能由于OutOfMemoryError而终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the state of an application is continuously increasing, it will at some point grow too large and kill the application unless action is taken to scale the application to more resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T140136Z" creationid="xccui" creationdate="20190704T130702Z">
        <seg>应用状态如果不断增加，总有一天会变得过大并"杀死"应用，除非我们有什么办法能为应用不断扩充资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the storage directory is not explicitly configured, RocksDB uses the value of the io.tmp.dirs parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043812Z" creationid="xccui" creationdate="20190724T043812Z">
        <seg>如果没有显式指定该配置参数，RocksDB会使用io.tmp.dirs的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the system continues to receive data at a higher rate than it can handle, buffers might become unavailable and data might get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T202331Z" creationid="xccui" creationdate="20190402T201609Z">
        <seg>如果系统持续以难以应对的高速率接收数据，缓冲区可能会用尽，继而可能导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the system continues to receive data at a higher rate than it can handle, buf‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053602Z" creationid="xccui" creationdate="20190605T234746Z">
        <seg>如果系统持续以力不能及的高速率接收数据，那么缓冲区可能会用尽，继而可能导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the task fails during the first step, will the event get lost?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043111Z" creationid="xccui" creationdate="20190415T043111Z">
        <seg>如果故障发生在第一步，事件是否会丢失？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the task is restarted due to a failure or from a save‐ point, the state will be initialized from the saved data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T155717Z" creationid="xccui" creationdate="20190702T065621Z">
        <seg>如果是重启任务（无论由于故障还是从保存点恢复）的情况，Flink就会用保存的数据初始化状态；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the transaction cannot be com‐ mitted, the sink loses data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T212916Z" creationid="xccui" creationdate="20190715T212916Z">
        <seg>事务提交失败将导致数据汇丢失数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the variable is not configured,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T030159Z" creationid="xccui" creationdate="20190722T025817Z">
        <seg>如果该变量没有配置，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the window only has an incremetal aggregation function (ReduceFunction or AggregateFunction) the current aggregation result is emit‐ ted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184600Z" creationid="xccui" creationdate="20190626T184537Z">
        <seg>如果窗口只包含一个增量聚合函数（ReduceFunction或AggregateFunction），则直接发出当前聚合结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the window operator has a ProcessWindowFunction, the function is called and the result is emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184543Z" creationid="xccui" creationdate="20190626T184449Z">
        <seg>如果窗口算子配置了ProcessWindowFunction，就会调用该函数并发出结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the window operator is configured with an incremental aggregation function, such as a ReduceFunction or AggregateFunction, the newly added element is immediately aggregated and the result is stored as the contents of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051152Z" creationid="xccui" creationdate="20190625T052346Z">
        <seg>如果为窗口算子配置的是增量聚合函数（如ReduceFunction或AggregateFunction），那么新加入的元素会立即执行聚合，其结果会存为窗口内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the window oper‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052518Z" creationid="xccui" creationdate="20190625T052518Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are fewer list entries than the new parallelism of an operator, some tasks will start with empty state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062438Z" creationid="xccui" creationdate="20190608T060655Z">
        <seg>如果列表条目的数量小于算子新设置的并行度，部分任务在启动时的状态就可能为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are more parallel subtasks than state objects, some subtasks are started with no state, and the restoreState() method is called with an empty list.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061347Z" creationid="xccui" creationdate="20190701T061347Z">
        <seg>如果并行子任务的数量多于状态对象，那么有些子任务在启动时就会获取不到状态，此时传入restoreState()方法的就会是一个空列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is not possible, for example because the application runs in a stand-alone cluster, the JobManager is not able to restart the application until enough slots become available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210324Z" creationid="xccui" creationdate="20190428T210135Z">
        <seg>若无法完成（例如应用运行在一个独立集群上），JobManager将无法重启应用，直至有足够数量的可用处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is not possible—for example, because the application runs in a standalone cluster—the JobManager can not restart the application until enough slots become available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145517Z" creationid="xccui" creationdate="20190606T145517Z">
        <seg>若无法完成（例如应用运行在一个独立集群上），JobManager将无法重启应用，直至有足够数量的可用处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061843Z" creationid="xccui" creationdate="20190701T061843Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we only consider how much data we receive within one minute, our results will vary and depend on the speed of the network connection or the speed of the processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143249Z" creationid="xccui" creationdate="20190412T142831Z">
        <seg>如果我们仅考虑现实时间一分钟内收到多少数据，那结果可能会随网络连接速度或处理速度而改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we want to reference a person’s ZIP code, we can use a field expression:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050107Z" creationid="xccui" creationdate="20190618T050107Z">
        <seg>如果我们想引用某人的邮政编码，可以使用字段表达式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you add a new stateful operator to the application or a new state to an existing operator, the state will be initialized as empty when the application is started from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T040408Z" creationid="xccui" creationdate="20190705T040408Z">
        <seg>如果你向应用中添加了新的状态化算子或为已有算子增加了状态，那么在应用从保存点启动时，这些状态都会被初始化为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you added a new state to the application or changed the unique identifier of a stateful operator, Flink will not find a corresponding state snapshot in the save‐ point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T053545Z" creationid="xccui" creationdate="20190727T050721Z">
        <seg>如果你向应用中添加了新的状态或改变了某个状态化算子的唯一标识，导致Flink无法在保存点中找到相应的状态快照，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are a Windows user, we recommend using the regular command-line client and running it on WSL or Cygwin.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T165829Z" creationid="xccui" creationdate="20190726T025112Z">
        <seg>如果你是一名Windows用户，我们建议你在WSL或Cygwin下使用常规的命令行客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are familiar with batch data processing APIs, functional programming languages, or SQL you will find the API concepts very easy to grasp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024103Z" creationid="xccui" creationdate="20190613T024059Z">
        <seg>如果你熟悉批处理API、函数式编程语言或SQL，将会发现这里的API概念都很容易掌握。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are interested in learning more about real-world use cases and deployments, check out Apache Flink’s &lt;t0/&gt;Powered By&lt;t1/&gt; &lt;t2/&gt;page and the talk recordings and slide decks of &lt;t3/&gt;Flink For&lt;t4/&gt;‐&lt;t5/&gt; &lt;t6/&gt;ward &lt;t7/&gt;presentations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T155324Z" creationid="xccui" creationdate="20190305T154924Z">
        <seg>如果还想了解更多的用例和部署方案，请查看Apache Flink的Powered By页面或Flink Forward的演讲录像及幻灯片。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are interested in learning more about real-world use cases and deployments, check out Apache Flink’s Powered By page and the talk recordings and slide decks of Flink Forward presentations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T212615Z" creationid="esouser" creationdate="20190603T212449Z">
        <seg>如果想了解更多真实用例和部署方案，请查看Apache Flink的用户页面或Flink Forward的演讲录像及幻灯片。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are not using an automatic clock synchronization service such as NTP, your machines' clocks might suffer from clock skew.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T032811Z" creationid="xccui" creationdate="20190807T032811Z">
        <seg>如果你没有使用类似NTP的自动时钟同步服务，那么你机器的时钟可能会受到时钟偏差的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are running Windows, we recom&lt;t2/&gt;‐&lt;t3/&gt; mend to set up a virtual machine with Linux, Cygwin (a Linux environment for Win&lt;t4/&gt;‐&lt;t5/&gt; dows), or the Windows Subsystem for Linux, which was introduced with Windows 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060249Z" creationid="xccui" creationdate="20190328T055732Z">
        <seg>如果你的系统是Windows，我们建议你配置一个Linux虚拟机，或安装Cygwin（一个Windows下的Linux环境），或设置Linux子系统（Win10中新加的功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are the first customer showing up at the coffee shop right after it opened its doors in the morning, you will be served immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T205517Z" creationid="xccui" creationdate="20190401T205243Z">
        <seg>如果你是早晨咖啡店开门后第一个顾客，将立即得到服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using Flink, you have nothing to worry about.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T160644Z" creationid="xccui" creationdate="20190725T045826Z">
        <seg>如果你在使用Flink，那一切都无需担心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T065824Z" creationid="xccui" creationdate="20190621T065824Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you cannot express your required join semantics using Flink’s built-in join opera‐ tors, you can implement custom join logic as a CoProcessFunction, BroadcastPro cessFunction, or KeyedBroadcastProcessFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210857Z" creationid="xccui" creationdate="20190627T210857Z">
        <seg>如果Flink内置的Join算子无法表达所需的Join语义，那么你可以通过CoProcessFunction、BroadcastProcessFunction或KeyedBroadcastProcessFunction实现自定义的Join逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you changed a state in the application—changed the state primitive or modified the data type of the state—the application fails to start.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T054254Z" creationid="xccui" creationdate="20190727T054254Z">
        <seg>如果你对应用中的状态进行了修改，无论是改变了状态原语还是状态类型，都将导致应用无法启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you click on a row, you trigger back-pressure sampling and you will see the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T152228Z" creationid="xingcan" creationdate="20190802T152228Z">
        <seg>点击某一行可以触发背压采样，你将看到持续约5秒钟的Sampling in progress...信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you click on a running job, you can get a quick glimpse of running statistics per task or subtask as shown in Figure 10-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T034734Z" creationid="xccui" creationdate="20190802T034734Z">
        <seg>如果点击一个正在运行的作业，你就可以打开像图10-3中所示的界面，继而快速了解每个任务或子任务的运行统计信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you click on that job you will see the data flow and live metrics about the opera&lt;t0/&gt;‐&lt;t1/&gt; tors of the running job similar to the screenshot in &lt;t2/&gt;Figure 1-9&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042154Z" creationid="xccui" creationdate="20190329T041245Z">
        <seg>点击那个作业，你会看到和图1-9中的截图类似的数据流程及运行作业中算子的实时指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you click on the History view, you can retrieve more fine-grained information, such as the status, trig‐ ger time, state size, and how many bytes were buffered during the checkpoint’s align‐ ment phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T151751Z" creationid="xingcan" creationdate="20190802T151751Z">
        <seg>点击History视图可以获取更多细粒度的信息，例如任务状态、触发时间、状态大小以及在检查点对齐阶段缓冲的字节数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you click on the Task Metrics tab, you can select more metrics from a dropdown menu, as shown in Figure 10-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T144425Z" creationid="xingcan" creationdate="20190802T144425Z">
        <seg>如果点击Task Metrics选项卡，你可以从下拉菜单中选择更多指标，具体如图10-4所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you configure the minimum pause to be 30 seconds, then no new checkpoint will be started within the first 30 seconds after a checkpoint completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T202444Z" creationid="xccui" creationdate="20190731T202329Z">
        <seg>如果你配置了30秒的最小暂停时间，那么在检查点完成后的30秒内不会开始生成新的检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not assign unique IDs to your operators with the uid()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T045952Z" creationid="xccui" creationdate="20190727T045809Z">
        <seg>如果你没有使用uid()方法为算子分配唯一ID，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not explicitly set unique identifiers to the operators of your stateful applica‐ tion, you will face significant limitations when you have to evolve the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023250Z" creationid="xccui" creationdate="20190703T023053Z">
        <seg>如果你没有为状态化应用的算子显式指定标识，那么在更新应用时就会受到诸多限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not specify a savepointPath, the default savepoint directory as configured in the ./conf/flink-conf.yaml file is used (see “System Configuration”).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170955Z" creationid="xccui" creationdate="20190726T183450Z">
        <seg>如果没有指定savepointPath，系统会使用./conf/flink-conf.yaml文件中配置的默认保存点目录（请参阅"系统配置"一节）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you explic‐ itly specify a savepoint path, it is stored in the provided directory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033505Z" creationid="xccui" creationdate="20190726T033505Z">
        <seg>如果你显式指定了保存点路径，它就会存到你所提供的目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210827Z" creationid="esouser" creationdate="20190603T210827Z">
        <seg>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you generate loose watermarks—where the watermarks are far behind the time‐ stamps of the processed records—you increase the latency of the produced results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T034216Z" creationid="xccui" creationdate="20190621T033944Z">
        <seg>如果生成的水位线过于宽松，即水位线远落后于已处理记录的时间戳，那么将导致产生结果的延迟增大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a ZooKeeper quorum running and Flink properly configured, you can use the regular ./bin/start-cluster.sh script to start a HA standalone cluster by adding addi‐ tional hostnames and ports to the ./conf/masters file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T051606Z" creationid="xccui" creationdate="20190721T051606Z">
        <seg>你如果有一个正在运行的ZooKeeper Quorum且已经配置好Flink，就可以通过向./conf/masters文件中添加额外的主机名和端口号的方式，使用常规的./bin/start-cluster.sh脚本来启动HA的独立集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have incremental aggregation logic but also need access to window metadata, you can combine a ReduceFunction or AggregateFunction, which perform incre‐ mental aggregation, with a ProcessWindowFunction, which provides access to more</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T045759Z" creationid="xccui" creationdate="20190625T035513Z">
        <seg>如果可用增量聚合表示逻辑且还需要访问窗口元数据，则可以将ReduceFunction或AggregateFunction与功能更强的ProcessWindowFunction组合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you implement the application such that the parallelism of its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190728T042255Z" creationid="xccui" creationdate="20190728T042255Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you look at how Flink propagates and updates watermarks (see “Watermark Propagation and Event Time”), you can see that a single operator that does not advance watermarks can grind all watermarks of an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T043657Z" creationid="xccui" creationdate="20190713T043037Z">
        <seg>你如果了解了Flink的水位线传播和更新原理就会发现，一旦应用中引入了Shuffle操作（keyBy()和rebalance()等），那么单个算子水位线的停滞就将导致整个应用都停止工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to work with different credentials, you should start a new cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T023330Z" creationid="xccui" creationdate="20190725T023330Z">
        <seg>如果你需要使用不同的证书，请启动一个新的集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you removed a state from the application or changed the unique identifier of a stateful operator, there is state in the savepoint that cannot be matched to the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T053630Z" creationid="xccui" creationdate="20190727T053418Z">
        <seg>如果你从应用中删除了某个状态或改变了某个状态化算子的唯一标识，导致保存点中存在无法和应用匹配的状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you require exactly-once results, you should take the savepoint and stop the appli‐ cation with the integrated savepoint-and-cancel command.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T205710Z" creationid="xccui" creationdate="20190727T055550Z">
        <seg>你如果需要精确一次的结果，则应该使用复合命令savepoint-and-cancel来生成保存点并停止应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run Hadoop YARN version 2.6 or later, Flink automat‐ ically configures an attempt failure’s validity interval.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T060205Z" creationid="xccui" creationdate="20190721T053353Z">
        <seg>如果你使用的是Hadoop YARN 2.6或之后的版本，Flink会自动配置尝试失败的有效时间间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run applications with many dependencies, the JVM’s nonheap memory can also grow significantly because it stores all TaskManager and user-code classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T034954Z" creationid="xccui" creationdate="20190724T034954Z">
        <seg>如果你运行的应用有很多依赖，则JVM的堆外内存也会增长比较严重，因为它需要存储所有TaskManager和用户代码类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run the application in a local environ‐ ment—or example, from your IDE—on a machine with 8 cores, the source task will run with 8 tasks, the mapper with 16 tasks, and the sink with 2 tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T062232Z" creationid="xccui" creationdate="20190616T062221Z">
        <seg>如果你在一台8核的机器上以本地环境中运行（例如在IDE里），那么数据源将会运行8个任务，map将运行16个任务，数据汇将运行2个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run the docker images command after the build script finishes, you should see a new Docker image called flink-book-apps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034823Z" creationid="xccui" creationdate="20190730T034812Z">
        <seg>如果在构建脚本完成后运行docker images命令，你应该能看到一个名为flink-book-apps的新的Docker镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run the following command, the example application from “A Quick Look at Flink” on page 12 is deployed on one master and three worker containers to Docker:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T035218Z" creationid="xccui" creationdate="20190730T035218Z">
        <seg>如果运行以下命令，就可以将第12页"Flink快览"中的示例应用部署在Docker的一个主容器和三个工作容器上：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you take a step back and read the introductory example once more, you hopefully have a better idea about what is going on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041726Z" creationid="xccui" creationdate="20190619T044357Z">
        <seg>此时回头再看一次开篇示例，希望你能对它的行为有一个更好的理解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use a filesystem source connector in an event-time application, you should be aware that it can be challenging to generate watermarks since input splits are generated in a single process and round-robin distributed to all parallel readers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T203104Z" creationid="xccui" creationdate="20190710T202902Z">
        <seg>当你想在一个基于事件时间的应用中使用文件系统数据源连接器时需要注意，生成水位线的工作可能并不好做。因为输入划分是在单个进程中生成的，且会被循环发送至所有并行读取器，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use a metrics backend that is not included in the above list, you can also define your own reporter by implementing the org.apache.flink.met‐ rics.reporter.MetricReporter interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055722Z" creationid="xccui" creationdate="20190804T055722Z">
        <seg>如果你想使用的指标后端没有在上表中列出，则可以通过实现org.apache.flink.metrics.reporter.MetricReporter接口来自定义汇报器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you would like to customize the handling the latency marker at opera‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T063411Z" creationid="xccui" creationdate="20190806T063411Z">
        <seg>如果你想在算子中自定义延迟标记处理逻辑，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you, for example, specify fs.default-scheme: hdfs://nnode1:9000, the path /result will be extended to hdfs://nnode1:9000/result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T045346Z" creationid="xccui" creationdate="20190722T045346Z">
        <seg>举例而言，如果指定了fs.default-scheme:hdfs://nnode1:9000，则/result路径将自动被扩充为hdfs://nnode1:9000/result。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your application requires keyed state for a moving key domain, it should ensure the state of keys is cleared when it is not needed anymore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T033706Z" creationid="xccui" creationdate="20190704T201452Z">
        <seg>如果你的应用需要用到键值域不断变化的键值分区状态，那么必须要确保能够对那些无用的状态进行清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your applica‐ tion is a batch job, you can easily fix the bug offline and then redeploy the new application code once the current job instance finishes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T160527Z" creationid="xccui" creationdate="20190725T045340Z">
        <seg>如果应用是一个批处理作业，则你可以很轻松地离线修复Bug，然后等当前作业实例结束后部署新的应用代码即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your function requires a nonserializable object instance, you can either implement it as a rich function and initialize the nonserializ‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040934Z" creationid="xccui" creationdate="20190618T055329Z">
        <seg>如何你有函数需要一个无法序列化的对象实例，可以选择使用富函数（rich function）在open()方法中将其初始化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your input elements have timestamps that are</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051515Z" creationid="xccui" creationdate="20190620T051433Z">
        <seg>如果你输入元素的时间戳是单调增加的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If—according to the configured checkpointing interval—a checkpoint needs to be started, but there is another checkpoint in progress, the sec‐ ond checkpoint will be put on hold until the first checkpoint completes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T031941Z" creationid="xccui" creationdate="20190731T031941Z">
        <seg>如果（根据配置的检查点生成间隔）需要生成一个检查点时，另一个检查点正在生成过程中，则后一个检查点会延后，直至前一个完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine that during Christmas holiday season, baristas have to draw a Santa Claus on the cup of each coffee they serve.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T205829Z" creationid="xccui" creationdate="20190402T205727Z">
        <seg>假设正值圣诞假期，咖啡师要在他们端出的每一杯咖啡上面画一个圣诞老人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine that during the Christmas holiday season, baristas have to draw a Santa Claus on the cup of each coffee they serve.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054351Z" creationid="xccui" creationdate="20190605T235108Z">
        <seg>假设现在正值圣诞假期，咖啡师要在他们完成的每杯咖啡的杯子上画一个圣诞老人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implement</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063640Z" creationid="xccui" creationdate="20190701T063640Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implement Your Applications With Evolution in Mind</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T024734Z" creationid="xccui" creationdate="20190705T024319Z">
        <seg>实现应用时须长远考虑</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055442Z" creationid="xccui" creationdate="20190804T055442Z">
        <seg>实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation of a CoProcessFunction that dynamically filters a stream of sensor readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032022Z" creationid="xccui" creationdate="20190622T032022Z">
        <seg>动态过滤传感器读数流的CoProcessFunction实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation of a ProcessWindowFunction that assigns the window end timestamp to an incrementally computed result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T050131Z" creationid="xccui" creationdate="20190625T045132Z">
        <seg>用于将窗口结束时间戳和递增计算结果组合的ProcessWindowFunction实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation of a WatermarkGauge metric that exposes the current watermark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031839Z" creationid="xccui" creationdate="20190803T031839Z">
        <seg>对外提供当前水位线的WatermarkGauge指标的实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022910Z" creationid="xccui" creationdate="20190225T022910Z">
        <seg>实现函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Functions | 105</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045347Z" creationid="xccui" creationdate="20190619T045347Z">
        <seg>实现函数 | 105</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Operator List State with the ListCheckpointed Interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T041010Z" creationid="xccui" creationdate="20190225T024556Z">
        <seg>通过ListCheckpointed接口实现算子列表状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Stateful Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030643Z" creationid="xccui" creationdate="20190225T024522Z">
        <seg>实现状态化函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Stateful Functions | 155</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052507Z" creationid="xccui" creationdate="20190707T052507Z">
        <seg>实现状态化函数 | 155</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Stateful Functions | 161</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052701Z" creationid="xccui" creationdate="20190707T052701Z">
        <seg>实现状态化函数 | 161</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Stateful Functions | 163</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052519Z" creationid="xccui" creationdate="20190707T052519Z">
        <seg>实现状态化函数 | 163</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a Custom Sink Function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055048Z" creationid="xccui" creationdate="20190225T025258Z">
        <seg>实现自定义数据汇函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a Custom Sink Function | 207</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023303Z" creationid="xccui" creationdate="20190717T023303Z">
        <seg>实现自定义数据汇函数 | 207</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a Custom Sink Function | 211</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023308Z" creationid="xccui" creationdate="20190717T023308Z">
        <seg>实现自定义数据汇函数 | 211</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a Custom Sink Function | 213</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023311Z" creationid="xccui" creationdate="20190717T023311Z">
        <seg>实现自定义数据汇函数 | 213</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a Custom Source Function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055031Z" creationid="xccui" creationdate="20190225T025229Z">
        <seg>实现自定义数据源函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a Custom Source Function | 203</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023248Z" creationid="xccui" creationdate="20190717T023248Z">
        <seg>实现自定义数据源函数 | 203</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a FlatMapFunction with a keyed ValueState</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064202Z" creationid="xccui" creationdate="20190630T064202Z">
        <seg>实现带有键值分区ValueState的FlatMapFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a KeyedBroadcastProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041324Z" creationid="xccui" creationdate="20190702T041324Z">
        <seg>实现KeyedBroadcastProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a streaming application with queryable state is easy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T060048Z" creationid="xccui" creationdate="20190706T060048Z">
        <seg>实现一个支持可查询式状态的流式应用非常简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the Book’s Examples in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054951Z" creationid="esouser" creationdate="20190603T144859Z">
        <seg>在IDE中导入书中示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the book examples repository into IntelliJ</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041629Z" creationid="xccui" creationdate="20190611T041629Z">
        <seg>将书中示例仓库导入IntelliJ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the book’s examples in your IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022322Z" creationid="xccui" creationdate="20190225T022322Z">
        <seg>将书中示例导入你的IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Importing the examples-scala repository into your IDE to experiment with Flink is a good first step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T094052Z" creationid="xccui" creationdate="20190612T004022Z">
        <seg>将examples-scala库导入IDE来体验Flink是一个良好的开端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improving on the first generation, the next generation of distributed open source stream processors (2013) provided better failure guarantees and ensured that in case of a failure each input record affects the result exactly once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T194051Z" creationid="xccui" creationdate="20190605T053117Z">
        <seg>和第一代开源分布式流处理引擎相比，第二代引擎（2013年）提供了更加完善的故障处理机制——即便出现故障，也能保证每条记录仅参与一次结果运算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improving on the first generation, the next generation of distributed open source stream processors (2013) provided better failure guarantees and ensured that in case of a failure each record contributes exactly once to the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T034733Z" creationid="xccui" creationdate="20190327T034557Z">
        <seg>和第一代开源分布式流处理引擎相比，第二代引擎（2013年）提供了更加完善的故障处理机制，可以保证在出错的情况下每条记录也仅参与一次结果运算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T211324Z" creationid="xccui" creationdate="20190711T211324Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In ./conf/flink-conf.yaml you need to set a cluster identifier for each running cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T050643Z" creationid="xccui" creationdate="20190721T050643Z">
        <seg>在./conf/flink-conf.yaml中为每个运行的集群设置集群标识符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t0/&gt;Chapter 10&lt;t1/&gt;, we show how to disable task chaining for an application and how to control the chaining behavior of individual opera&lt;t2/&gt;‐&lt;t3/&gt; tors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155735Z" creationid="esouser" creationdate="20190514T155247Z">
        <seg>在第10章中，我们会展示如何对某一应用内禁用任务链接以及如何单独控制每个算子的链接行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t0/&gt;Chapter 2&lt;t1/&gt;, we highlighted the importance of time semantics for stream processing applications and explained the differences between processing-time and event-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155850Z" creationid="esouser" creationdate="20190514T155850Z">
        <seg>在第二章里，我们强调了时间语义对于流处理应用的重要性并解释了处理时间和事件时间的不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t2/&gt;Chapter 9&lt;t3/&gt;, we will discuss how to setup and configure Flink for different environments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025244Z" creationid="xccui" creationdate="20190423T025119Z">
        <seg>在第9章里，我们会讨论如何针对不同环境搭建及配置Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t2/&gt;Figure 2-2&lt;t3/&gt;, the output of the “Extract hashtags” operator is partitioned by key (the hashtag), so that the count operator tasks can correctly compute the occurrences of each hashtag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135717Z" creationid="xccui" creationdate="20190401T135653Z">
        <seg>图2-2中，"Extract hashtags"算子的输出就是按照键值（主题标签）划分的，因此下游的计数算子可以正确计算出每个主题标签的出现次数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Alice’s game example, the streaming application could operate with two different notions of time, Processing time or Event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143526Z" creationid="xccui" creationdate="20190412T143355Z">
        <seg>在爱丽丝游戏的例子中，流式应用可以使用两个不同概念的时间，即处理时间和事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Alice’s game example, the streaming application could operate with two different notions of time: processing time or event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155450Z" creationid="xccui" creationdate="20190606T023542Z">
        <seg>在爱丽丝游戏的例子中，流式应用可以使用两个不同概念的时间，即处理时间（processing time）和事件时间（event time）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter 1, you learned that streaming applications have different operational requirements than traditional batch programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050310Z" creationid="xccui" creationdate="20190605T233716Z">
        <seg>在第一章，你已经了解到流式应用和传统批处理程序在操作的需求上有所差异，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter 2 we pointed out that most streaming applications are stateful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055528Z" creationid="xccui" creationdate="20190607T041304Z">
        <seg>在第2章我们指出，大部分的流式应用都是状态化的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter 6, things are going to get even more interesting—we will learn how to enrich our programs with window operators and time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T065415Z" creationid="xccui" creationdate="20190619T044618Z">
        <seg>在第6章，我们将会接触到一些更加有意义的内容——学习如何利用窗口算子和时间语义来进一步丰富我们的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Example 10-2 two chained tasks are created: one task for Filter1 and Map1 and another task for Map2 and Filter2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T204505Z" creationid="xccui" creationdate="20190730T204505Z">
        <seg>示例10-2中会创建两个链接任务：一个由Filter1和Map1组成，另一个由Map2和Filter2组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Example 8-15, this is a Tuple2 with a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T043949Z" creationid="xccui" creationdate="20190716T043949Z">
        <seg>示例8-15中用到的是一个由String和Double字段组成的Tuple2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Example 8-15, this is a string holding the name of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052155Z" creationid="xccui" creationdate="20190716T052155Z">
        <seg>在示例8-15中，标识符是一个字符串类型的事务文件名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Example 8-15, we check if the transaction file still exists and move it to the target directory if that is the case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053443Z" creationid="xccui" creationdate="20190716T053443Z">
        <seg>示例8-15中，我们会检查事务文件是否存在，如果存在则将它移动到目标目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Example 8-16, we show how to apply</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201658Z" creationid="xccui" creationdate="20190716T201658Z">
        <seg>示例8-16中，我们展示了如何在DataStream上应用AsyncFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Example 8-4, we use a Sim pleStringEncoder, which calls the toString() method of the record and writes the String representation of the record to the file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T024309Z" creationid="xccui" creationdate="20190711T024309Z">
        <seg>该示例中用到了一个SimpleStringEncoder，它会调用记录的toString()方法，从而让我们可以将记录以String形式写入文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Example 8-5 we use a Parquet writer for Avro files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T182703Z" creationid="xccui" creationdate="20190711T182603Z">
        <seg>在示例8-5中，我们选用了Avro类型的Parquet写入器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Figure 2-2, the output of the “Extract hashtags” operator is partitioned by the key (the hashtag), so that the count operator tasks can correctly compute the occurrences of each hashtag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233520Z" creationid="xccui" creationdate="20190605T233520Z">
        <seg>图2-2中，"Extract hashtags"算子的输出就是按照键值（主题标签）划分的，因此下游的计数算子可以正确计算出每个主题标签的出现次数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Figure 3-17, Flink took a checkpoint when the input offset was 5, and the sums were 6 and 9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T031758Z" creationid="xccui" creationdate="20190609T031739Z">
        <seg>在图3-17中，Flink会在输入偏移到达5的时候生成一个检查点，此时两个和值分别为6和9。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink 1.7, changing the data type of a state is supported if the data type was defined as an Apache Avro type and if the new data type is also an Avro type that was evolved from the original type according to Avro’s schema evolution rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T035436Z" creationid="xccui" creationdate="20190705T053352Z">
        <seg>在Flink 1.7版本，如果数据类型为Apache Avro类型，并且新的数据类型也是一个遵循Avro的Schema演变规则、从原类型演变而来的Avro类型，那么此时就可以支持改变状态数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, any keyed state can be exposed to exter‐ nal applications as queryable state and act as a read-only key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T162701Z" creationid="xccui" creationdate="20190705T162701Z">
        <seg>在Flink中，任何键值分区状态都可以作为可查询式状态暴露给外部应用，就像一个只读的键值存储一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, keys are not predefined in the input types like in systems that work with key-value pairs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T063113Z" creationid="xccui" creationdate="20190617T062643Z">
        <seg>和某些使用键值对的系统不同，Flink不是在输入类型中提前定义好键值，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, state is always associated with a specific operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055854Z" creationid="xccui" creationdate="20190607T055833Z">
        <seg>在Flink中，状态都是和特定算子相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, such a state is called a broadcast state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T203707Z" creationid="xccui" creationdate="20190701T203626Z">
        <seg>在Flink中，这种状态称为广播状态（broadcast state），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, watermarks are implemented as special records holding a timestamp as a Long value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205301Z" creationid="xccui" creationdate="20190606T205232Z">
        <seg>在Flink中，水位线是利用一些包含Long值时间戳的特殊记录来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, watermarks are implemented as special records holding a timestamp long value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042055Z" creationid="xccui" creationdate="20190523T042038Z">
        <seg>在Flink中，水位线是利用一些包含时间戳long值的特殊记录来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink’s DataStream API, any operator or function can send data to an external sys‐ tem or application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T212128Z" creationid="xccui" creationdate="20190713T211908Z">
        <seg>Flink DataStream API中的任何算子或函数都可以向外部系统或应用发送数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink’s design it is the responsibility of the state backend to perform a checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202614Z" creationid="xccui" creationdate="20190609T202559Z">
        <seg>按照Flink的设计，是由状态后端负责生成检查点，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In PRO CESS_CONTINUOUSLY, the path is periodically scanned (after an initial scan) and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T191140Z" creationid="xccui" creationdate="20190710T191054Z">
        <seg>而在PROCESS_CONTINUOUSLY模式下，数据源会（在首次扫描后）对路径进行周期性扫描，所有新添加的或是修改过的文件都会被持续读入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In PROCESS_CONTINUOUSLY mode, the filesystem source connector identifies new files based on their modification timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T200124Z" creationid="xccui" creationdate="20190710T200124Z">
        <seg>在PROCESS_CONTINUOUSLY模式下，文件系统数据源连接器会根据文件的修改时间来识别新文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In PROCESS_ONCE mode, the read path is scanned once when the job is started and all matching files are read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T190940Z" creationid="xccui" creationdate="20190710T190940Z">
        <seg>在PROCESS_ONCE模式下，目标路径只会在作业启动被扫描一次，随后数据源就会读取所有满足条件的文件；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a batch processing scenario, all these questions are answered because a batch job can be simply restarted from the beginning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T191246Z" creationid="xccui" creationdate="20190606T033840Z">
        <seg>在批处理场景下，上面提到的都不算问题。由于批处理任务可以轻易"从头再来"，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a batch processing scenario, you can solve all these problems easily since all the input data is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044030Z" creationid="xccui" creationdate="20190415T044017Z">
        <seg>在批处理场景下，由于可以得到所有输入数据，上述问题都能轻松解决。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a nutshell, Kafka’s transactions work by appending all messages to the log of a partition and marking messages of open transactions as uncommitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T211725Z" creationid="xccui" creationdate="20190709T211504Z">
        <seg>简而言之，Kafka的事务的实现原理是把全部消息都追加到分区日志中，并将未完成事务的消息标记为未提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a real-word streaming architecture however, it is common to have several connected components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045315Z" creationid="xccui" creationdate="20190416T045214Z">
        <seg>但在现实世界的流处理架构中，有多个连接组件是很稀松平常的事儿。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a real-world streaming application however, there will be at least one source and one sink apart from the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194630Z" creationid="xccui" creationdate="20190606T035056Z">
        <seg>在实际流处理应用中，除了流处理引擎也至少还要有一个数据来源组件和一个数据终点组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a standalone deployment, the master and workers are not automatically restarted in the case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T160706Z" creationid="xccui" creationdate="20190717T160706Z">
        <seg>在独立集群部署模式下，主进程和工作进程不会因为故障而重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a true streaming model, events can be processed as soon as they arrive in the system and latency more closely reflects the actual work that has to performed on each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195212Z" creationid="xccui" creationdate="20190401T194838Z">
        <seg>在该模型中，事件一到达系统就可以进行处理，延迟会更真实地反映出每个事件都要经历的实际执行工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a true stream‐ ing model, events can be processed as soon as they arrive in the system and latency more closely reflects the actual work that has to be performed on each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052022Z" creationid="xccui" creationdate="20190605T234331Z">
        <seg>在真正的流模型中，事件一到达系统就可以进行处理，延迟会更加真实地反映出每个事件都要经历的实际处理工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to built-in operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T032021Z" creationid="xccui" creationdate="20190630T032021Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to configuring the Hadoop dependencies, you need to provide the loca‐ tion of Hadoop’s configuration directory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T030453Z" creationid="xccui" creationdate="20190722T030348Z">
        <seg>除了配置Hadoop依赖，你还需要提供Hadoop配置目录的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to disabling chaining for the whole application, you can also control the chaining behavior of individual operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T010818Z" creationid="xccui" creationdate="20190730T203106Z">
        <seg>除了对整个应用禁用任务链接，你还可以控制单个算子的链接行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to joining two streams, it is also possible to cogroup two streams on a window by starting the operator definition with coGroup() instead of join().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T053729Z" creationid="xccui" creationdate="20190628T053610Z">
        <seg>除了对窗口中的两条流进行Join，还可以对它们进行Cogroup。只需将算子定义开始位置的join()改为coGroup()即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to keeping state around, the downstream operators or external systems that follow an operator, which updates previously emitted results, need to be able to handle these updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T163101Z" creationid="xingcan" creationdate="20190628T163101Z">
        <seg>除了在算子中保持状态，受结果更新影响下游算子或外部系统还得能够处理这些更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to record timestamps, a Flink event-time application must also provide watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040914Z" creationid="xccui" creationdate="20190523T040914Z">
        <seg>除了记录的时间戳，Flink基于事件时间的应用还必须提供水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the JVM, there are two other major memory consumers, Flink’s net‐ work stack and RocksDB, when it is used as a state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T151347Z" creationid="xccui" creationdate="20190724T035054Z">
        <seg>除了JVM，还有两个组件同样会消耗很多内存——Flink的网络栈和RocksDB（如果选它作为状态后端）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the WindowAssigner interface there is also the MergingWindowAssigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045234Z" creationid="xccui" creationdate="20190626T045234Z">
        <seg>除了WindowAssigner接口外，还有一个继承自它的MergingWindowAssigner接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the configuration options in Figures 8-7 and 8-8, a Cassandra sink builder provides a few more methods to configure the sink connector:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220751Z" creationid="xccui" creationdate="20190711T220751Z">
        <seg>除了示例8-7和8-8中所展示的配置项，Cassandra数据汇构建器还提供了其他一些配置方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the generic way of enabling queries on any type of keyed state, Flink also offers shortcuts to define stream sinks that store the events of a stream in a queryable state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062029Z" creationid="xccui" creationdate="20190706T062029Z">
        <seg>除了这种将任意类型的键值分区状态设置为可查询式的通用方法外，Flink还提供了一种简便方法，支持利用数据汇将流中所有事件都存到可查询式状态中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the previously discussed configuration, an HA standalone deployment requires the following configuration changes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T050615Z" creationid="xccui" creationdate="20190721T050615Z">
        <seg>除了上面讨论的配置外，独立集群模式的HA设置还需要修改以下配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the system properties discussed so far, such as failure tolerance, perfor&lt;t0/&gt;‐&lt;t1/&gt; mance, and result accuracy, stream processors also continuously added new opera&lt;t2/&gt;‐&lt;t3/&gt; tional features.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T140909Z" creationid="xccui" creationdate="20190327T135929Z">
        <seg>除了已经讨论过的如：容错、性能、结果精确性等系统属性，流处理引擎还在不断添加新的操作功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the system properties discussed so far, such as failure tolerance, perfor‐ mance, and result accuracy, stream processors have also continuously added new operational features such as highly available setups, tight integration with resource managers, such as YARN or Kubernetes, and the ability to dynamically scale stream‐ ing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T053300Z" creationid="xccui" creationdate="20190605T053708Z">
        <seg>除了已经讨论过的容错、性能及结果精确性等系统属性，流处理引擎还在不断添加新的操纵功能（operational feature），例如：高可用设置，和资源管理器（YARN、Kubernetes等）的紧密集成以及支持流式应用动态扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to these features, Flink is a very developer-friendly framework due to its easy-to-use APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T200442Z" creationid="xccui" creationdate="20190328T052954Z">
        <seg>除了上述特性，Flink还是一个对开发者非常友好的框架，这得益于它十分易用的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to time-based windows, Flink also supports count- based windows—windows that group a fixed number of elements in the order in which they arrive at the window operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T035632Z" creationid="xccui" creationdate="20190623T035632Z">
        <seg>Flink除了支持基于时间的窗口，还支持基于数量的窗口。后者会按照元素到达窗口算子的顺序以固定数量对其进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, Flink provides implementations for Apache Avro and text-based JSON encodings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T213621Z" creationid="xccui" creationdate="20190708T213621Z">
        <seg>除此之外，Flink还为Apache Avro和基于文本的JSON编码提供了相应的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, both context objects also provide access to the event-time timestamp, the current watermark, the current processing time, and the side outputs, similar to the context objects of other process functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T062135Z" creationid="xccui" creationdate="20190702T053527Z">
        <seg>此外，和其他处理函数的上下文对象类似，此处的两个上下文对象也支持访问状态时间戳、当前水位线、当前处理时间以及副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, it is important to ensure that the SourceFunction.run() method, which runs in a separate thread, does not advance the reading offset and emit data while a checkpoint is taken; in other words, while the CheckpointedFunction.snapshot</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T174058Z" creationid="xccui" creationdate="20190712T174058Z">
        <seg>此外，我们必须确保由单独线程运行的SourceFunction.run()方法不会在检查点生成过程中（即CheckpointedFunction.snapshotState()调用期间）向前推进偏移和发出数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, program&lt;t0/&gt;‐&lt;t1/&gt; ming APIs evolved from rather low-level operator interfaces to high-level APIs with more built-in primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T035008Z" creationid="xccui" creationdate="20190327T034928Z">
        <seg>此外，编程API也从低层基于算子的接口进化为拥有更多内置操作原语的高层API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, program‐ ming APIs evolved from rather low-level operator interfaces to high-level APIs with more built-in primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T062918Z" creationid="xccui" creationdate="20190605T053242Z">
        <seg>此外，编程API也从底层基于算子的接口进化为拥有更多内置操作原语的高层API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the Apache Bahir project provides additional Flink connectors for ActiveMQ, Akka, Flume, Netty, and Redis.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T195907Z" creationid="xccui" creationdate="20190708T195907Z">
        <seg>此外，Apache Bahir项目中还额外提供了针对ActiveMQ、Akka、Flume、Influxdb、Kudu、Netty以及Redis的连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the JobManager writes a pointer to the storage location into ZooKeeper’s data store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051712Z" creationid="xccui" creationdate="20190502T045820Z">
        <seg>此外，它还会将存储位置的指针写入ZooKeeper的数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the JobManager writes a pointer to the storage location into ZooKeeper’s datastore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073253Z" creationid="xccui" creationdate="20190606T150105Z">
        <seg>此外，JobManager还会将存储位置的路径地址写入ZooKeeper的数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the RocksDB state backend also features incremental checkpointing, which reduces the amount of data to transfer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203905Z" creationid="xccui" creationdate="20190609T203841Z">
        <seg>除此之外，RocksDB状态后端还支持增量生成检查点，这可以降低需要传输的数据量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the method getRuntimeContext() provides access to the function’s Run timeContext.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041303Z" creationid="xccui" creationdate="20190619T033317Z">
        <seg>此外，你可以利用getRuntimeContext()方法访问函数的RuntimeContext。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, you can use the CLI client to submit detached queries that directly write their results into external storage systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T161705Z" creationid="xingcan" creationdate="20190807T161705Z">
        <seg>此外，你还可以使用CLI客户端提交分离式查询，让其直接将结果写入外部存储系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, you need to provide a JSON object with the path to the savepoint folder and a flag telling whether or not to terminate the application with the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T181108Z" creationid="xccui" creationdate="20190729T181027Z">
        <seg>此外，你需要提供一个包含了保存点文件夹路径的JSON对象和一个是否在生成保存点后终止应用的标志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, you need to provide the new parallelism of the application as an URL parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201538Z" creationid="xccui" creationdate="20190729T201538Z">
        <seg>此外，你还需要以URL参数的形式提供一个新的应用并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all of these cases, Flink requires Hadoop dependencies on its classpath.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T145633Z" creationid="xccui" creationdate="20190722T010039Z">
        <seg>无论集成什么你都需要将Hadoop依赖加入Flink的Classpath中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, there is a service running that accepts the Flink application and ensures it is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143501Z" creationid="xccui" creationdate="20190606T143501Z">
        <seg>无论哪种情况，运行的服务都会接收Flink应用并确保其执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In batch processing you first need to gather the events in batches and only then you are able to process them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T193255Z" creationid="xccui" creationdate="20190401T193141Z">
        <seg>在批处理中，你先要批量收集事件，然后才能处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In batch processing, you first need to gather the events in batches and only then can you pro‐ cess them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234259Z" creationid="xccui" creationdate="20190605T234259Z">
        <seg>在批处理中，你先要批量收集事件，然后才能处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In batch processing- dominated environments, data streams are also often ingested by monitoring a file‐ system directory and reading files as they appear.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T171038Z" creationid="xccui" creationdate="20190708T171038Z">
        <seg>在以批处理为主的环境中，我们还经常通过监视文件系统目录并读取其中新加文件的方式来读取数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In big data architectures they often serve as data source and data sink for batch pro‐ cessing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T183257Z" creationid="xccui" creationdate="20190710T183257Z">
        <seg>在大数据架构中，它常被用作批处理应用的数据源和数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, Flink links the newly registered state handle object to the existing state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T035146Z" creationid="xccui" creationdate="20190701T021819Z">
        <seg>无论原因如何，Flink都会将新注册的状态句柄对象和已有状态建立关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In bulk encoding, records are collected and written in batches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T023357Z" creationid="xccui" creationdate="20190711T023217Z">
        <seg>而在批量编码模式下，记录会被攒成批，然后一次性写入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, Flink recovers a stateful streaming application by restoring its state from a previous checkpoint and resetting the read position on the event log.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T065426Z" creationid="esouser" creationdate="20190603T211702Z">
        <seg>一旦出现故障，Flink会利用之前的检查点恢复状态并重置事件日志的读取位置，以此来使状态化流处理应用恢复正常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, Flink restores a stateful streaming application by recovering its state from a previously taken checkpoint and resets the read position on the event log.The application will replay (and fast forward) the input events from the event log until it reaches the tail of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T144620Z" creationid="xccui" creationdate="20190305T062150Z">
        <seg>一旦计算失败，Flink会利用之前的checkpoint恢复状态和重置事件日志的读取指针，以此来使状态化流处理应用恢复正常。随后应用会从事件日志中读取并（快速）重放输入事件，直到数据流末尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, Flink uses the latest check‐ point  to  consistently  restore  the  application’s   state   and   restarts   the   processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T063843Z" creationid="xccui" creationdate="20190609T033338Z">
        <seg>一旦发生故障，Flink会利用最新的检查点将应用状态恢复到一个一致性的点并重启处理进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, a new JobManager looks up the pointer from ZooKeeper and loads the metadata from the persistent storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T045210Z" creationid="xccui" creationdate="20190720T045210Z">
        <seg>一旦发生故障，新的JobManager就可以从ZooKeeper中查找相关路径并根据它从持久化存储中加载元数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, the state of the application is restored from the latest completed checkpoint and processing continues.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T052008Z" creationid="xccui" creationdate="20190708T052008Z">
        <seg>一旦发生故障，应用会从最近一次完成的检查点中恢复状态并继续处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a fail‐ ure, these records will be processed again, which means the checkpoint provides at- least-once instead of exactly-once consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T205249Z" creationid="xccui" creationdate="20190609T205203Z">
        <seg>一旦出现故障，这些记录会被重复处理，而这意味着检查点只能提供至少一次而非精确一次的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a shuffle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045224Z" creationid="xccui" creationdate="20190504T044946Z">
        <seg>在shuffle或broadcast连接的情况下，每个发送任务都需要针对每个接收任务提供一个缓冲区，因此所需的缓冲区数量是相关算子并发度的平方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a shuffle connection pattern, each sender task needs to be able to send data to each receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T043112Z" creationid="xccui" creationdate="20190504T043112Z">
        <seg>在shuffle连接模式下，每个发送端的任务都需要能够向每个接受任务发送数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of any problem, they fall back to the remote storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T163032Z" creationid="xingcan" creationdate="20190801T163032Z">
        <seg>如果出现任何问题，则会回到使用远程存储进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In certain situations you might want to ensure that checkpoints are taken in the con‐ figured checkpointing interval even though a checkpoint takes longer than the inter‐ val.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T032457Z" creationid="xccui" creationdate="20190731T202851Z">
        <seg>在某些情况下，你可能希望即使检查点的生成时间长于间隔，也要保证检查点严格按照配置的间隔生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In combination with advanced file formats, such as Apache Par‐ quet or Apache ORC, filesystems can efficiently serve analytical query engines such as Apache Hive, Apache Impala, or Presto.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T183533Z" creationid="xccui" creationdate="20190710T183533Z">
        <seg>结合一些高级的文件格式（如Apache Parquet或Apache ORC），文件系统可以有效地服务于很多分析查询引擎（如Apache Hive、Apache Impala或Presto）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In combination with exactly-once checkpointing, resettable sources, and deterministic application logic, upsert writes yield eventually exactly-once output consistency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T201859Z" creationid="xccui" creationdate="20190711T201859Z">
        <seg>结合精确一次的检查点、可重置的数据源以及确定的应用逻辑，Upsert写操作可以保证输出结果满足最终一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In combination with exactly-once failure semantics, systems of this generation are the first open source stream processors capable of computing consistent and accurate results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T163220Z" creationid="xccui" creationdate="20190605T053340Z">
        <seg>结合精确一次故障恢复语义，这一代系统才称得上第一批能够计算精确一致结果的开源流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In combination with exactly-once failure semantics, systems of this generation are the first open source stream processors that are capable of computing consistent and accurate results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T051821Z" creationid="xccui" creationdate="20190327T050854Z">
        <seg>结合精确一次故障恢复语义，这一代系统才称得上第一批能够计算精确、一致结果的开源流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to SQL INSERT statements, CQL INSERT statements behave like upsert queries—they override existing rows with the same primary key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T213127Z" creationid="xccui" creationdate="20190711T213127Z">
        <seg>和SQL INSERT不同，CQL INSERT语句的行为类似于Upsert查询，它们会覆盖主键相同的已有行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to WAL sinks, 2PC sinks can achieve exactly-once output depending on the sink system and the sink’s implementa‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T201012Z" creationid="xccui" creationdate="20190708T165445Z">
        <seg>和WAL数据汇不同，2PC数据汇可依赖数据汇系统和数据汇的实现来完成精确一次的结果输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to batch processors that guarantee accurate results, the first open source stream processors traded result accuracy for much better latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T044942Z" creationid="xccui" creationdate="20190322T043015Z">
        <seg>和提供精确结果的批处理引擎相比，第一代开源流处理引擎通过牺牲结果的准确度换取更低的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to executing a Flink program by sending it to a remote JobManager, the program is executed in a single JVM. Therefore, certain issues, such as class‐ loading issues, cannot be properly debugged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T093814Z" creationid="xccui" creationdate="20190611T054526Z">
        <seg>与把Flink程序发送到远程JobManager执行相比，将程序放在单个JVM进程中执行可能会导致某些问题（例如类加载）无法正确调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to the AssignerWithPeriodicWatermarks function, this function can—but does not need to—extract a watermark from each record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040244Z" creationid="xccui" creationdate="20190607T040224Z">
        <seg>和AssignerWithPeriodicWatermarks函数不同，这个函数不会强制你从每条记录中都提取一个时间戳（虽然这样也行）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to the JDBC query Future, the onComplete() callback is processed by DirectExecutor because passing the result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T212620Z" creationid="xccui" creationdate="20190716T212620Z">
        <seg>和JDBC查询使用Future不同，onComplete()回调是通过DirectExecutor来处理的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to the ReduceFunction, the intermediate data type and the output type do not depend on the input type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T035957Z" creationid="xccui" creationdate="20190624T005140Z">
        <seg>它和ReduceFunction不同的是中间数据类型以及结果类型不再依赖输入类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to their Scala counterparts, Flink’s Java tuples are mutable, so the val‐ ues of fields can be reassigned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040328Z" creationid="xccui" creationdate="20190617T040328Z">
        <seg>和Scala不同的是，Java元组是可变的，因此可以为其字段重新赋值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, a stream consumed from a socket cannot be reset because sockets discard data once it has been consumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T064018Z" creationid="xccui" creationdate="20190609T044943Z">
        <seg>相反，如果数据流是从套接字（socket）消费而来则无法重置，因为套接字会在数据被取走后将它们丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, a stream processor that runs a stateful streaming application takes care of all processing steps, including event ingestion, continuous computation including state maintenance, and updating the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014657Z" creationid="xccui" creationdate="20190317T063132Z">
        <seg>相较之下，运行状态化流处理应用的流处理引擎会负责事件获取、维护状态的持续计算、更新结果等所有处理步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, a stream pro‐ cessor that runs a stateful streaming application takes care of all these processing steps, including event ingestion, continuous computation including state mainte‐ nance, and updating the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T162231Z" creationid="xccui" creationdate="20190605T044848Z">
        <seg>相比之下，运行状态化流处理应用的流处理引擎会全面负责事件获取、维护状态的持续计算以及更新结果等所有处理步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, event-time semantics yield reproducible and consis&lt;t2/&gt;‐&lt;t3/&gt; tent results which is a hard requirement for many stream processing use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T160831Z" creationid="esouser" creationdate="20190514T160831Z">
        <seg>而事件时间语义恰恰相反，它会生成可重现、一致性的结果，这也是很多流处理场景中的刚性需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, event-time semantics yield reprodu‐ cible and consistent results, which is a hard requirement for many stream processing use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T063613Z" creationid="xccui" creationdate="20190606T204233Z">
        <seg>相反，事件时间语义会生成可重现且一致性的结果，这也是很多流处理用例的刚性需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, in continuously running streaming jobs, state is durable across events and we can expose it as a first-class citi‐ zen in the programming model.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182441Z" creationid="xccui" creationdate="20190606T032132Z">
        <seg>反之，在持续运行的流式作业中，每次处理事件所用到的状态都是持久化的，我们完全可以将其作为编程模型中的一等公民。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, savepoints must be manually triggered by a user or an external service and are never automati‐ cally removed by Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T014821Z" creationid="xccui" creationdate="20190726T014821Z">
        <seg>而保存点则与之相反，它们需要由用户或外部服务手动触发，且永远不会被Flink自动删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, stateful operators may main‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235838Z" creationid="xccui" creationdate="20190605T235838Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the 2PC sink requires a sink system that offers transactional support or exposes building blocks to emulate transactions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T055614Z" creationid="xccui" creationdate="20190708T161548Z">
        <seg>相反，2PC数据汇需要数据汇系统支持事务或提供可用来模拟事务的构件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, traditional batch processing latencies typically range from a few minutes to several hours.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T193105Z" creationid="xccui" creationdate="20190401T193105Z">
        <seg>相反，传统批处理的延迟可能从几分钟到几小时不等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In con‐ trast to batch processors, the first open source stream processors traded result accu‐ racy for better latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051716Z" creationid="xccui" creationdate="20190605T051623Z">
        <seg>和批处理引擎相比，第一代开源流处理引擎通过牺牲结果的准确度来换取低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In data streaming, latency is measured in units of time, such as milliseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051003Z" creationid="xccui" creationdate="20190401T154502Z">
        <seg>在流处理中，延迟是以时间片（例如毫秒）为单位测量的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, there is a ser&lt;t3/&gt;‐&lt;t4/&gt; vice running that accepts the Flink application and ensures it is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025733Z" creationid="xccui" creationdate="20190423T025658Z">
        <seg>无论哪种情况，运行的服务都会接收Flink应用并确保其执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, exactly-once guarantees mean that our application will provide the correct result, as if a failure never happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045641Z" creationid="xccui" creationdate="20190416T044057Z">
        <seg>本质上，精确一次保障意味着应用总会提供正确的结果，就如同故障从未发生过一般。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, exactly-once guarantees mean that our application will provide the correct result, as though a failure never happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034827Z" creationid="xccui" creationdate="20190606T034827Z">
        <seg>本质上，精确一次保障意味着应用总会提供正确的结果，就如同故障从未发生过一般。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, the rescale partitioning strategy offers a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043856Z" creationid="xccui" creationdate="20190616T043856Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, watermarks pro&lt;t0/&gt;‐&lt;t1/&gt; vide a logical clock which informs the system about the current event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205344Z" creationid="xccui" creationdate="20190412T205344Z">
        <seg>本质上，水位线提供了一个逻辑时钟，通知系统当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, watermarks provide a logical clock that informs the system about the current event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T161005Z" creationid="xccui" creationdate="20190606T025413Z">
        <seg>本质上，水位线提供了一个逻辑时钟，用来通知系统当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, if you want to compute anything interesting in a streaming application, even a simple count, you need to maintain state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T065255Z" creationid="xccui" creationdate="20190409T204144Z">
        <seg>实际上，如果你想在流式应用中计算任何有意义的结果（即便是简单的计数），都需要维护状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it is difficult to find</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T040711Z" creationid="xccui" creationdate="20190301T035808Z">
        <seg>事实上，很难从现实世界找到那种瞬间就生成完整数据集的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it is difficult to find examples of finite, complete datasets that are generated all at once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T030309Z" creationid="esouser" creationdate="20190603T204824Z">
        <seg>事实上，现实世界中很难找到那种瞬间就生成完整数据集的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, most nontrivial operations need to memorize records or par‐ tial results because data is streamed and arrives over time.1 Many of Flink’s built-in DataStream operators, sources, and sinks are stateful and buffer records or maintain partial results or metadata.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T213211Z" creationid="xccui" creationdate="20190630T030651Z">
        <seg>事实上，由于数据会随时间以流式到来，但凡稍复杂点的操作大部分都需要对数据本身或中间结果进行记录。1 很多Flink内置的DataStream算子、数据源以及数据汇都是状态化的，它们需要对数据记录进行缓冲或者对中间结果及元数据加以维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, that is what you achieve by exploiting parallelism in a stream processing pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T212158Z" creationid="xccui" creationdate="20190402T212052Z">
        <seg>事实上这就是在流处理管道中利用并行性实现的效果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, that’s what happens when you exploit parallelism in a stream processing pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235716Z" creationid="xccui" creationdate="20190605T235716Z">
        <seg>事实上这就是在流处理管道中利用并行性实现的效果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, the flatMap transformation is a gener‐ alization of filter and map and can be used to implement both those operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060228Z" creationid="xccui" creationdate="20190613T053755Z">
        <seg>事实上，flatMap转换可以看做是filter和map的泛化，它能够实现后两者的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, this has been a common implementation choice before the rise of modern stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053346Z" creationid="xccui" creationdate="20190414T053223Z">
        <seg>事实上，在现代流处理引擎兴起之前，状态就是一个常见的实现选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, you would like your stream processor to not only continue processing in the case of task failures, but also provide correctness guarantees about the result and operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T190419Z" creationid="xccui" creationdate="20190606T033501Z">
        <seg>事实上，你不仅需要流处理引擎在出现任务故障时可以继续运行，还需要它能保证结果和算子状态的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, you would like your stream processor to not only continue the processing in the case of task failures, but also provide correctness guarantees about the result and operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042203Z" creationid="xccui" creationdate="20190415T042023Z">
        <seg>事实上，你不仅需要流处理引擎在任务故障时可以继续运行，还需要它保证结果和算子状态的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, 2PCs are an expensive approach to ensuring consistency in a distributed system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T195645Z" creationid="xccui" creationdate="20190715T195645Z">
        <seg>总的来说，2PC对分布式系统的一致性保障而言是一种非常昂贵的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, all data maintained by a task and used to compute the results of a function belong to the state of the task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055927Z" creationid="xccui" creationdate="20190607T053933Z">
        <seg>通常意义上，函数里所有需要任务去维护并用来计算结果的数据都属于任务的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, if example code is offered with this book, you may use it in your programs and documentation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210816Z" creationid="esouser" creationdate="20190603T210816Z">
        <seg>In general, if example code is offered with this book, you may use it in your programs and documentation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, it is a good idea to define the parallelism of your operators relative to the default parallelism of the environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T053829Z" creationid="xccui" creationdate="20190616T053603Z">
        <seg>一般情况下，最好将算子并行度设置为随环境默认并行度变化的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, using processing time for window operations results in nondeterministic results</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T045304Z" creationid="xccui" creationdate="20190619T065807Z">
        <seg>通常情况下，在窗口算子中使用处理时间会导致不确定的结果，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In job mode, a Flink cluster is started to run a single job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T211823Z" creationid="xccui" creationdate="20190718T211823Z">
        <seg>在作业模式下，Flink集群启动后只会运行单个作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In library mode, the application is bundled into a Docker image that also includes the required Flink binaries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190729T210717Z">
        <seg>在库模式下，绑定的应用和所需的Flink二进制文件会一起放入Docker镜像中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In long-running, streaming jobs, each of these tasks can fail at any time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185813Z" creationid="xccui" creationdate="20190415T041755Z">
        <seg>对于长期运行的流式作业而言，每个任务都随时有可能出现故障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many cases, a function does not know if a record will be the last one for a key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T182628Z" creationid="xccui" creationdate="20190704T142252Z">
        <seg>很多情况下，函数不会知道某条记录是否是该键值所对应的最后一条。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many real-world applications, the system does not have enough knowledge to per&lt;t0/&gt;‐&lt;t1/&gt; fectly determine watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T211450Z" creationid="xccui" creationdate="20190412T211024Z">
        <seg>在很多现实应用中，系统必须知道足够多的信息才能完美地设置水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many real-world applications, the system does not have enough knowledge to per‐ fectly determine watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T161917Z" creationid="xccui" creationdate="20190606T025733Z">
        <seg>在很多现实应用中，系统无法得知足够多的信息来完美地确定水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, Flink can automatically infer types and generate the correct TypeInfor mation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T055139Z" creationid="xccui" creationdate="20190617T055139Z">
        <seg>大多数情况下，Flink可以自动推断类型并生成正确的TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most real-world applications, the expectation is that events should not get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034559Z" creationid="xccui" creationdate="20190606T034519Z">
        <seg>对大多数现实应用而言，用户期望是不丢事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most real-world applications, the minimum requirement is that events do not get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041926Z" creationid="xccui" creationdate="20190416T041813Z">
        <seg>对大多数现实应用而言，最低要求是不丢失事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order for this to work, the POJO class and its fields need to be annotated with Cassandra annotations and provide setters and getters for all fields as shown in Example 8-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T215915Z" creationid="xccui" creationdate="20190711T213709Z">
        <seg>为了让映射器能正常工作，我们需要像示例8-9那样，为POJO类和它的字段添加Cassandra注解，并针对所有字段提供setter和getter方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to achieve better state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062306Z" creationid="xccui" creationdate="20190701T062306Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to achieve deterministic transformations on ConnectedStreams, connect() can be combined with keyBy() or broadcast().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045948Z" creationid="xccui" creationdate="20190615T045948Z">
        <seg>为了在ConnectedStreams上实现确定性的转换，connect()可以与keyBy()和broadcast()结合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to achieve end-to-end exactly-once seman‐ tics, an application requires either idempotent or transactional sink connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T042459Z" creationid="xccui" creationdate="20190714T025051Z">
        <seg>为了实现端到端的精确一次语义，应用的连接器需要是幂等性的或支持事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to be able to delete the currently registered timer, its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T212811Z" creationid="xccui" creationdate="20190704T212811Z">
        <seg>为了删除当前已经注册的计时器，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to build Flink for a specific Hadoop version, you need Flink’s source code, which can be obtained by downloading the source distribution from the website or cloning a stable release branch from the project’s Git repository, a Java JDK of at least version 8, and Apache Maven 3.2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T145730Z" creationid="xccui" creationdate="20190722T024253Z">
        <seg>为了针对特定Hadoop版本构建Flink，你需要Flink源代码（可以从官网下载源代码发布版或从项目Git仓库中克隆一个稳定版本分支），Java JDK（8以上版本）以及Apache Maven 3.2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to clean up all state when a window is deleted, the clear() method of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194446Z" creationid="xccui" creationdate="20190626T194350Z">
        <seg>为了在删除窗口时彻底清理状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to do this efficiently, Flink requires detailed knowledge of the types of data the application processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T024805Z" creationid="xccui" creationdate="20190616T063647Z">
        <seg>为了提高上述过程的效率，Flink需要详细了解应用处理的数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to ease the implementation of transactional sinks, Flink’s DataStream API provides two templates that can be extended to implement custom sink operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T034710Z" creationid="xccui" creationdate="20190715T034710Z">
        <seg>为了简化事务性数据汇的实现，Flink DataStream API提供了两个模板，可供其他类继承以实现自定义数据汇算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to enable Flink’s HA mode, you need to adjust Flink’s configuration and pro‐ vide information such as the hostnames of the ZooKeeper quorum nodes, a path to a persistent storage, and a cluster ID for Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T062222Z" creationid="xccui" creationdate="20190721T062222Z">
        <seg>为了启用Flink HA模式，你需要调整Flink的配置并提供一些信息。例如：ZooKeeper Quorum节点的主机名，持久化存储路径以及Flink集群ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to enable a smooth pipelined data exchange, a TaskManager must be able to provide enough buf&lt;t2/&gt;‐&lt;t3/&gt; fers to serve all outgoing and incoming connections concurrently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044648Z" creationid="xccui" creationdate="20190504T044648Z">
        <seg>为了使流水线式的数据交换平滑进行，TaskManager必须提供足够多的缓冲区来同时服务全部进出连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to enable a smooth pipe‐ lined data exchange, a TaskManager must be able to provide enough buffers to serve all outgoing and incoming connections concurrently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193207Z" creationid="xccui" creationdate="20190606T201341Z">
        <seg>为了使流水线式的数据交换平滑进行，TaskManager必须提供足够多的缓冲区来同时服务所有进出连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to enable the queryable state service in a Flink setup—to start client proxy and server threads within the TaskManagers—you need to add the flink-queryable- state-runtime JAR file to the classpath of the TaskManager process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T052843Z" creationid="xccui" creationdate="20190706T052645Z">
        <seg>为了在Flink设置中启用可查询式状态服务（即在TaskManager中启动客户端代理和服务器线程），你需要将flink-queryable-state-runtime JAR文件放到TaskManager进程的Classpath中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to ensure at-least-once result correctness, you need to have a mechanism to replay events, either from the source or from some buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T043259Z" creationid="xccui" creationdate="20190416T042957Z">
        <seg>为了确保至少一次结果的正确，需要一些机制从源头或缓冲中重放事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to ensure at-least-once result correctness, you need to have a way to replay events—either from the source or from some buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193640Z" creationid="xccui" creationdate="20190606T034644Z">
        <seg>为了确保至少一次结果语义的正确性，需要想办法从源头或缓冲区中重放事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to evaluate such operations effi&lt;t4/&gt;‐&lt;t5/&gt; ciently on unbounded streams, you need to limit the amount of data these operations maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041628Z" creationid="xccui" creationdate="20190406T041619Z">
        <seg>为了在无限数据流上高效地执行这些操作，必须限制操作所维持的数据量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to evaluate such operations efficiently on unbounded streams, you need to limit the amount of data these operations maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061921Z" creationid="xccui" creationdate="20190606T012044Z">
        <seg>为了在无限数据流上高效地执行这些操作，必须对操作所维持的数据量加以限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to execute a Flink application, all classes in the application’s JAR file must be loaded by a classloader.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T044358Z" creationid="xccui" creationdate="20190723T044358Z">
        <seg>为了执行Flink应用，所有应用JAR包中的类都需要由一个类加载器进行加载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to execute a dataflow program, its logical graph is converted into a physical dataflow graph, which includes details about how the computation is going to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T003156Z" creationid="xccui" creationdate="20190401T002442Z">
        <seg>为了执行dataflow程序，需要将逻辑图转化为物理dataflow图，它们包含了计算执行的细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to execute a dataflow program, its logical graph is converted into a physical dataflow graph, which specifies in detail how the program is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044306Z" creationid="xccui" creationdate="20190605T233054Z">
        <seg>为了执行Dataflow程序，需要将逻辑图转化为物理Dataflow图，后者指定了程序的执行细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to extract event-time timestamps and generate watermarks, you can provide an AssignerWithPeriodicWatermark or an AssignerWithPunctuatedWatermark to a Kafka consumer by calling a FlinkKafkaConsumer.assignTimestampsAndWater mark().3 An assigner is applied to each partition to leverage the per partition order‐ ing guarantees, and the source instance merges the partition watermarks according to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T041549Z" creationid="xccui" creationdate="20190709T021836Z">
        <seg>为了提取事件时间的时间戳并生成水位线，你可以通过调用FlinkKafkaConsumer.assignTimestampsAndWatermark()方法向Kafka消费者提供一个AssignerWithPeriodicWatermark或AssignerWithPunctuatedWatermark对象。3 为了利用Kafka分区内部保序特性，分配器会作用在每个分区上，随后数据源实例会根据水位线传播协议（参照"水位线穿过和事件时间"一节）对各分区的水位线进行合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to gen‐ erate satisfying watermarks you need to reason about the smallest timestamp of a record that is included in a split later processed by the task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T203656Z" creationid="xccui" creationdate="20190710T203656Z">
        <seg>为了生成满足需求的水位线，你需要根据稍后由任务处理的输入划分中的记录，推断最小时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to grasp the problem of modifying the data type of a state, we have to under‐ stand how state data is represented within a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T035045Z" creationid="xccui" creationdate="20190705T045812Z">
        <seg>为了弄清状态数据类型的修改问题，我们需要理解状态数据在保存点中的表示形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to increase or decrease the parallelism of a function with operator state, the operator state needs to be redistributed to a larger or smaller number of task instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T055222Z" creationid="xccui" creationdate="20190701T055222Z">
        <seg>为了达到该目的，Flink需要将算子状态重新分配到更多或更少的任务实例上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to keep the data of the data warehouse up-to-date, ETL processes need to run periodically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192243Z" creationid="xccui" creationdate="20190228T191319Z">
        <seg>同时为了保证数据仓库中数据的实效，ETL流程需要定期重复执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to make Flink’s runtime aware of the state of an operator, the operator needs to register its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060300Z" creationid="xccui" creationdate="20190607T055945Z">
        <seg>为了让Flink的运行层知道算子有哪些状态，算子需要自己对其进行注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to perform a graceful shutdown, the run() method, which runs in a separate thread, should terminate as soon as the cancel() method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152228Z" creationid="xccui" creationdate="20190712T152228Z">
        <seg>为了关闭过程可以顺利完成，运行在单独线程内的run()方法需要在cancel()方法调用后立即终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to populate a data ware&lt;t2/&gt;‐&lt;t3/&gt; house, the data managed by the transactional database systems needs to be copied to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T191750Z" creationid="xccui" creationdate="20190228T184446Z">
        <seg>为了填充它，需要将事务型数据库系统中的数据拷贝过去，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to populate a data warehouse, the data managed by the transac‐ tional database systems needs to be copied to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T202712Z" creationid="esouser" creationdate="20190603T202712Z">
        <seg>为了填充数据仓库，需要将事务型数据库系统中的数据拷贝过去，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to prevent increasing resource consumption of an application over time, it is important that the size of the operator state be controlled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T033103Z" creationid="xccui" creationdate="20190704T135607Z">
        <seg>为了防止应用资源逐渐耗尽，关键要控制算子状态大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to prevent temporal inconsistencies during recovery and provide exactly- once output guarantees for applications with nondeterministic application logic, Flink’s Cassandra connector can be configured to leverage a WAL.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T203126Z" creationid="xccui" creationdate="20190711T202431Z">
        <seg>为了避免在恢复期间出现短暂的不一致现象，并为逻辑不确定的应用提供精确一次的输出保障，Flink的Cassandra连接器可以通过配置启用WAL。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to provide a concise window operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T024653Z" creationid="xccui" creationdate="20190626T015035Z">
        <seg>为了使窗口算子的API保持简洁，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to provide exactly-once state consistency for an application,1 each source connector of the application needs to be able to set its read positions to a previously checkpointed position.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T051449Z" creationid="xccui" creationdate="20190708T053841Z">
        <seg>为了在应用中实现精确一次的状态一致性保障，1 应用的每个数据源连接器都需要支持将读取位置设为过去某个检查点中的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to provide fault tolerance for an application, the JobManager initiates checkpoints at regular intervals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T013958Z" creationid="xccui" creationdate="20190702T204550Z">
        <seg>为了支持应用容错，JobManager会以固定间隔创建检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to read</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T023659Z" creationid="xccui" creationdate="20190704T023659Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to recover from a master pod failure, you need to configure a highly available setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T144022Z" creationid="xccui" creationdate="20190720T040135Z">
        <seg>为了从主进程Pod的故障中恢复，需要进行一些高可用设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to recover from master failures, a highly available setup needs to be configured as described in a later section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T010759Z" creationid="xccui" creationdate="20190719T010759Z">
        <seg>为了在主进程发生故障时可以恢复，我们需要对它进行高可用性配置，有关内容会在下节讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to remove the savepoint we triggered before, call the command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035159Z" creationid="xccui" creationdate="20190726T035159Z">
        <seg>为了删除之前生成的保存点，我们可以使用以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to retrieve one or more JobManager metrics, add the get query parameter with all the requested metrics to the request:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T212602Z" creationid="xccui" creationdate="20190729T044531Z">
        <seg>为了得到一个或多个JobManager指标，可以将它们以get查询参数的方式加入到请求中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to run Flink on Windows, you can use a provided bat script or you can use the regular bash scripts on the Windows Subsystem for Linux (WSL) or Cygwin.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T214611Z" creationid="xccui" creationdate="20190717T214611Z">
        <seg>为了在Windows上运行Flink，你可以使用项目提供的bat脚本，或者基于WSL或Cygwin运行常规的bash脚本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to run the example, you have to start the streaming application with the queryable state first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T045429Z" creationid="xccui" creationdate="20190707T045429Z">
        <seg>为了运行这个示例，你需要先将配置了可查询式状态的应用启动起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to satisfy the requirements for task chaining, two or more operators must be configured with the same parallelism and be connected by local forward channels.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152052Z" creationid="esouser" creationdate="20190514T152010Z">
        <seg>为了满足任务链接的条件，多个算子必须有相同的并发度且通过本地转发通道连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to satisfy the requirements for task chaining, two or more operators must be configured with the same parallelism and connected by local forward channels.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062657Z" creationid="xccui" creationdate="20190606T203255Z">
        <seg>任务链接的前提条件是，多个算子必须有相同的并行度且通过本地转发通道连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to scale writing to and reading from a topic, it can be split into partitions that are dis‐ tributed across a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T202149Z" creationid="xccui" creationdate="20190708T202149Z">
        <seg>为了实现主题读写的伸缩性，Kafka允许将主题拆分为多个分布在集群之上的分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to set up a standalone Flink cluster, download a binary distribution from the Apache Flink website and extract the tar archive with the command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T195012Z" creationid="xccui" creationdate="20190717T162625Z">
        <seg>为了搭建一个Flink独立集群，你可以从Apache Flink的官网下载它的二进制发行版，然后利用以下命令对tar文件进行解压：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to start a distributed Flink cluster that runs on multiple machines, you need to adjust the default configuration and complete a few more steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T140157Z" creationid="xccui" creationdate="20190717T193734Z">
        <seg>为了在多台机器上搭建Flink集群，你需要调整一下默认的配置并完成一些额外步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to successfully run applications on a Flink cluster that is deployed on Minikube, you need to run the following command</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024235Z" creationid="xccui" creationdate="20190720T024235Z">
        <seg>为了在基于Minukube的Flink集群上运行应用，你需要在部署Flink前执行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to take a savepoint before canceling a running application add the -s flag to the cancel command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T183431Z" creationid="xccui" creationdate="20190726T183431Z">
        <seg>如果要在取消当前运行的应用之前生成一个保存点，请在cancel命令后面加上-s参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to take advantage of AsyncFunction, the external system should provide a client that supports asynchronous calls, which is the case for many systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T200425Z" creationid="xccui" creationdate="20190716T200425Z">
        <seg>为了充分利用AsyncFunction，外部系统最好能够提供一个支持异步调用的客户端，很多现有系统都可以做到这点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to use a provided connector in your application, you need to add its depend‐ ency to the build file of your project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T200339Z" creationid="xccui" creationdate="20190708T200339Z">
        <seg>为了在应用中使用这些连接器，你需要把相应的依赖添加到项目的构建文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to use processing time, replace TimeCharacteristic.EventTime with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T073049Z" creationid="xccui" creationdate="20190619T073049Z">
        <seg>如果需要使用处理时间，请将TimeCharacteristic.EventTime替换为TimeCharacteristic.ProcessingTime。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, events can be simply dropped and nothing is done to ensure result correctness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034357Z" creationid="xccui" creationdate="20190606T034357Z">
        <seg>换句话说，事件可以随意丢弃，没有任何机制来保证结果的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, events can be simply dropped and there is no mechanism to ensure result correctness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T184510Z" creationid="xccui" creationdate="20190415T184441Z">
        <seg>换句话说，事件可以随意丢弃，没有任何机制来保证结果的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our discussion about event-time windows so far, we have overlooked one very important aspect: &lt;t0/&gt;how do we decide when to trigger an event-time window&lt;t1/&gt;?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T160625Z" creationid="xccui" creationdate="20190412T160108Z">
        <seg>在到目前为止有关事件时间窗口的讨论中，我们一直忽略了一个非常重要的方面：如何决定触发事件时间窗口的时间？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our discussion about event-time windows so far, we have overlooked one very important aspect: how do we decide when to trigger an event-time window?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025229Z" creationid="xccui" creationdate="20190606T025229Z">
        <seg>在到目前为止有关事件时间窗口的讨论中，我们一直忽略了一个非常重要的方面：如何决定触发事件时间窗口的时间？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, the result is a DataStream[SensorReading] record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051745Z" creationid="xccui" creationdate="20190612T054549Z">
        <seg>在所给示例中，输出结果是DataStream[SensorReading]中的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we define the AverageSensorReadings object and include most of the application logic inside main().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043342Z" creationid="xccui" creationdate="20190612T043342Z">
        <seg>在示例中，我们定义了AverageSensorReadings对象，并将大部分应用逻辑都放到了main()方法里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we first apply a map() transformation that converts the temperature of each sensor reading to Celsius.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053231Z" creationid="xccui" creationdate="20190612T053231Z">
        <seg>在示例中，我们首先利用map()转换将每个传感器读取的温度都转换为摄氏度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we retrieve the execution environment by calling the static getExecutionEnvironment() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045057Z" creationid="xccui" creationdate="20190612T045057Z">
        <seg>在示例中，我们通过调用静态的getExecutionEnvironment()方法来获取执行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we use:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T052055Z" creationid="xccui" creationdate="20190612T051404Z">
        <seg>在示例中，我们通过：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In parallel windows, each partition applies the window policies independently of other partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195229Z" creationid="xccui" creationdate="20190409T194934Z">
        <seg>并行窗口中，每个数据分区都会都会各自应用独立于其他分区的窗口策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In parallel windows, each partition applies the win‐ dow policies independently of other partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014028Z" creationid="xccui" creationdate="20190606T013916Z">
        <seg>并行窗口中，每个数据分区所应用的窗口策略都相互独立。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular the following features let it stand out:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042143Z" creationid="xccui" creationdate="20190328T041315Z">
        <seg>尤其是以下功能使其在同类系统中脱颖而出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the following features make Flink stand out:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054030Z" creationid="xccui" creationdate="20190605T054030Z">
        <seg>尤其是以下功能使其在同类系统中脱颖而出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, we explain Flink’s distributed architecture, show how Flink handles time and state in streaming applications, and discuss its fault tolerance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T054253Z" creationid="xccui" creationdate="20190416T054235Z">
        <seg>我们将重点解释Flink的分布式架构，展示它如何在流式应用中处理时间和状态并讨论它的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, we explain Flink’s distributed architecture, show how it handles time and state in streaming applications, and discuss its fault- tolerance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T043016Z" creationid="xccui" creationdate="20190606T140115Z">
        <seg>我们会重点解释Flink的分布式架构，展示它如何在流式应用中处理时间和状态，并讨论它的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice though you might want to partition a stream into multiple logical streams and define &lt;t2/&gt;parallel&lt;t3/&gt; windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193928Z" creationid="xccui" creationdate="20190409T193840Z">
        <seg>但在实际应用中，你可能会想将数据流划分为多条逻辑流并定义一些并行窗口（parallel window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, you need to make an educated guess and use heuristics to generate watermarks in your applica‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T060706Z" creationid="xccui" creationdate="20190621T031744Z">
        <seg>在实践中，你需要一些有依据的猜测并使用启发式方法为应用生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In principle, save‐ points are created using the same algorithm as checkpoints and hence are basically checkpoints with some additional metadata.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210719Z" creationid="xccui" creationdate="20190609T210541Z">
        <seg>原则上，保存点的生成算法和检查点完全一样，因此可以把保存点看做包含一些额外元数据的检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In principle, state can be stored and accessed in many different places including pro&lt;t0/&gt;‐&lt;t1/&gt; gram variables, local files, or embedded or external databases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T031704Z" creationid="xccui" creationdate="20190305T031345Z">
        <seg>原则上，可以在很多不同的位置存储并访问状态，例如：应用程序变量、本地文件、嵌入式或外部数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In principle, state can be stored and accessed in many different places including pro‐ gram variables, local files, or embedded or external databases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T031625Z" creationid="esouser" creationdate="20190603T205858Z">
        <seg>原则上，需要在应用中访问的状态有多种可选的存储位置，例如：程序变量、本地文件、嵌入式或外部数据库等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In principle, you only need to adjust the YAML files that describe your deployments to use an image that contains the job code and configure it to automatically start the job when the container is started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T035910Z" creationid="xccui" creationdate="20190730T035910Z">
        <seg>原则上，你只需要调整YAML文件把Deployment设置为使用包含作业代码的镜像，并将它配置为在容器启动时自动启动作业即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In row encoding mode, every record is individually encoded</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T022736Z" creationid="xccui" creationdate="20190711T022725Z">
        <seg>在行编码模式下，每条记录都会被单独编码并添加到分块文件里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some situations, a pending file is never committed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T191631Z" creationid="xccui" creationdate="20190711T190956Z">
        <seg>在一些情况下，处于等待阶段的文件可能永远都无法提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In streaming systems you usually want to ensure that your system can handle the maximum expected rate of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052415Z" creationid="xccui" creationdate="20190401T203251Z">
        <seg>在流处理系统中，你通常希望系统有能力应对以最大期望速率到来的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a case, a function with keyed state would accumulate state for more and more</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T141436Z" creationid="xccui" creationdate="20190704T141354Z">
        <seg>此时，具有键值分区状态的函数就会积累越来越多的键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a case, a job is executed repeatedly over batches of incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053531Z" creationid="xccui" creationdate="20190414T053446Z">
        <seg>在以往的场景中，作业会在批量传入的事件上重复执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a situation, an application would end up in an infinite recovery cycle consuming lots of resources without a chance of ever get‐ ting back into regular processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T152719Z" creationid="xingcan" creationdate="20190801T152719Z">
        <seg>在该情况下，应用将陷入无休止的恢复周期，虽然消耗大量资源但无法恢复常规处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such applications, we would like to group together events that origin from the same period of user activity or &lt;t5/&gt;session&lt;t6/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025410Z" creationid="xccui" creationdate="20190407T025207Z">
        <seg>在该应用中我们要把事件按照用户的同一活动或会话来源进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such applications, we would like to group together events that originate from the same period of user activity or session.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013602Z" creationid="xccui" creationdate="20190606T013602Z">
        <seg>在该应用中我们要把事件按照用户的同一活动或会话来源进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, you need to generate a TypeInformation for a specific data type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053326Z" creationid="xccui" creationdate="20190617T053326Z">
        <seg>这些情况下，你就需要为特定数据类型生成TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, it is recom‐ mended to not use timers excessively, to avoid long checkpointing times.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063301Z" creationid="xccui" creationdate="20190621T070042Z">
        <seg>在这种情况下，建议不要使用太多计时器，以避免检查点生成时间过久。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the DataStream API this is done by providing a ProcessWindowFunction as a sec‐ ond parameter to the reduce() or aggregate() methods as shown in the following code:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T045901Z" creationid="xccui" creationdate="20190625T040327Z">
        <seg>在DataStream API中，实现上述过程的途径是将ProcessWindowFunction作为reduce()或aggregate()方法的第二个参数，如以下代码所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the DataStream API, the execution environment of an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T052348Z" creationid="xccui" creationdate="20190612T044948Z">
        <seg>DataStream API的执行环境由StreamExecutionEnvironment来表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Data‐ Stream API, you can use the time characteristic to tell Flink how to define time when you are creating windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T033253Z" creationid="xccui" creationdate="20190619T055236Z">
        <seg>在DataStream API中，你可以使用时间特性告知Flink在创建窗口时如何定义时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Java DataStream API, you can also use the returns() method to explicitly specify the return type of an operator when defining the dataflow as shown in the fol‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T035846Z" creationid="xccui" creationdate="20190617T062203Z">
        <seg>你还可以像下面这样，在定义Dataflow时使用Java DataStream API中的returns()方法来显式指定某算子的返回类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Scala API, Flink uses Scala compiler macros that generate TypeInformation objects for all data types at compile time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054714Z" creationid="xccui" creationdate="20190617T054714Z">
        <seg>在Scala API中，Flink利用Scala编译器的宏功能在编译时为所有数据类型生成TypeInformation对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the beginning of this chapter, you saw how you can model streaming programs as dataflow graphs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185224Z" creationid="xccui" creationdate="20190415T041033Z">
        <seg>在本章开头，你学到了如何将流处理程序建模成Dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of a failure, a sink task needs to reset its current in-progress file to its writ‐ ing offset at the last successful checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T192346Z" creationid="xccui" creationdate="20190711T192103Z">
        <seg>在发生故障的情况下，数据汇任务需要将它当前正在写入文件的写入偏移重置到上一次成功的检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of a mobile game, consequences can be as bad as Alice and her team getting disappointed and never playing again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155144Z" creationid="xccui" creationdate="20190411T153935Z">
        <seg>在这个手游例子中，后果可能非常糟糕，以至于爱丽丝和她团队的其他玩家失望透顶，再也不想碰这个游戏。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of a recovery cycle, this may take some time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T030710Z" creationid="xccui" creationdate="20190716T025945Z">
        <seg>若恰好赶上恢复周期，等待时间可能会比较久。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of a recovery or when starting from a savepoint, an application will start reading from the offsets stored in the check‐ point or savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040830Z" creationid="xccui" creationdate="20190709T040830Z">
        <seg>在进行故障恢复或从保存点开始启动的情况下，应用将从存储在检查点或保存点中的偏移开始读取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of downscaling, the surplus tasks are simply canceled since state is already replicated and will not be lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062154Z" creationid="xccui" creationdate="20190608T061946Z">
        <seg>在缩容的情况下，由于状态经过复制不会丢失，我们可以简单地停掉多出的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the coffee shop example, you will probably see this happening right after lunch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053151Z" creationid="xccui" creationdate="20190401T210715Z">
        <seg>在咖啡店的例子中，你很有可能在午餐后见到这种情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of Flink’s Kafka sink, this is important because transactions that time out—due to long recovery cycles, for example—lead to data loss.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T223102Z" creationid="xccui" creationdate="20190709T222923Z">
        <seg>该配置属性对Flink的Kafka数据汇而言非常重要，因为事务超时（例如由于长时间的故障恢复周期而引起）会导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of an event- time window operator, an event is late if it arrives at the operator and the window assigner maps it to a window that has already been computed because the operator’s watermark passed the end timestamp of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T204854Z" creationid="xingcan" creationdate="20190628T152848Z">
        <seg>在事件时间窗口算子的环境下，如果事件到达算子时窗口分配器为其分配的窗口已经因为算子水位线超过了它的结束时间而计算完毕，那么该事件就被认为是迟到的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of stream processing, one disadvantage of buffering is that it adds latency because records are collected in a buffer instead of being immediately shipped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194650Z" creationid="esouser" creationdate="20190513T210715Z">
        <seg>在流处理环境下，缓冲的一个明显缺点是会增加延迟，因为记录首先要收集到缓冲区中而不会立即发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, MyAssigner can either be of type AssignerWithPeriodicWater marks or AssignerWithPunctuatedWatermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055204Z" creationid="xccui" creationdate="20190620T044801Z">
        <seg>在上面的例子中，MyAssigner既可以是AssignerWithPeriodicWatermarks，也可以是AssignerWithPunctuatedWatermarks。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the stream is keyed by language and the result is a continuously updated list of words per language:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T054520Z" creationid="xccui" creationdate="20190614T062107Z">
        <seg>在下面的示例中，数据流会以语言字段（译者注：第一个字段）为键值进行分区，最终结果是针对每种语言产生一个不断更新的单词列表：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following example, the source operator will be executed with the default parallel‐ ism of the environment, the map transformation has double as many tasks as the source, and the sink operation will always be executed by two parallel tasks:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061542Z" creationid="xccui" creationdate="20190616T061542Z">
        <seg>下面的示例中，数据源算子会以环境默认并行度执行，map转换的任务数是数据源的两倍，数据汇操作固定以两个并行任务执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following example, we implement a FilterFunction that filters for strings that contain the word "flink":</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T053958Z" creationid="xccui" creationdate="20190618T053958Z">
        <seg>下面的例子中，我们实现了一个FilterFunction，用来过滤出所有包含"flink"一词的字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following section, we discuss the connectors for Apache Kafka, file-based sour‐ ces and sinks, and Apache Cassandra.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T200602Z" creationid="xccui" creationdate="20190708T200602Z">
        <seg>下一节，我们将讨论针对以下系统的连接器：Apache Kafka、文件系统以及Apache Cassandra。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, we briefly discuss credit-based flow control and task chain&lt;t0/&gt;‐&lt;t1/&gt; ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T205548Z" creationid="esouser" creationdate="20190513T192619Z">
        <seg>在接下来的几节，我们简要讨论一下基于信任度的流量控制以及任务链接（task chaining）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, we briefly discuss credit-based flow control and task chain‐ ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194425Z" creationid="xccui" creationdate="20190606T202141Z">
        <seg>在接下来的几节，我们简要讨论一下基于信用值（credit-based）的流量控制以及任务链接（task chaining）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, we discuss the lifecycle of windows and introduce the inter‐ faces to define custom window assigners, triggers, and evictors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T030123Z" creationid="xccui" creationdate="20190626T030123Z">
        <seg>下面几节我们将讨论窗口的生命周期并介绍用于自定义分配器、触发器以及移除器的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, we discuss these three cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035945Z" creationid="xccui" creationdate="20190705T035945Z">
        <seg>接下来的几节我们就来详细讨论一下这三种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, you will learn how to implement idempotent or transactional sink connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T055416Z" creationid="xccui" creationdate="20190714T042808Z">
        <seg>下面几节将向你介绍如何实现幂等性或事务性的数据汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following we describe how to set these parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015318Z" creationid="xccui" creationdate="20190703T013429Z">
        <seg>下面我们来介绍如何设置它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following we focus on changing the data type of a state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T045556Z" creationid="xccui" creationdate="20190705T045556Z">
        <seg>所以说，接下来我们将重点关注更改状态的数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following we present three classes of applications that are commonly implemented using stateful stream processing, 1) event-driven applications, 2) data pipeline applications, and 3) data analytics applications and give examples of real-world applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T153749Z" creationid="xccui" creationdate="20190305T153717Z">
        <seg>接下来我们结合例子，介绍三类常见的状态化流处理应用：1）事件驱动型应用；2）数据管道应用；3）数据分析应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following we will describe how Flink internally implements and handles timestamps and water&lt;t4/&gt;‐&lt;t5/&gt; marks to support streaming applications with event-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035243Z" creationid="xccui" creationdate="20190523T035101Z">
        <seg>接下面我们会介绍Flink内部如何实现和处理时间戳及水位线以支持事件时间语义的流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, the KeySelector function returns the maximum of the tuple fields as the key:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052138Z" creationid="xccui" creationdate="20190618T052138Z">
        <seg>下面的示例中，KeySelector函数会返回元组中最大的字段作为键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we briefly describe the contents and style of each chapter, so you can directly jump to the part that interests you most.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T163452Z" creationid="xccui" creationdate="20190225T163433Z">
        <seg>接下来我们简要介绍一下每个章节的内容和特点，以便于你直接跳到最感兴趣的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we briefly describe the contents of each chapter, so you can directly jump to those chapters that interest you most.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041630Z" creationid="esouser" creationdate="20190603T153658Z">
        <seg>接下来我们会简要介绍一下每个章节的内容，便于你直接跳到最感兴趣的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we define a case class Person with two fields: name and age.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040740Z" creationid="xccui" creationdate="20190617T040740Z">
        <seg>下方我们定义了一个样例类Person，它有两个字段：name和age。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we describe both interfaces and their consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T040328Z" creationid="xccui" creationdate="20190715T040058Z">
        <seg>接下来，我们将介绍上述两个接口以及它们的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we describe how Flink internally implements and handles timestamps and watermarks to support streaming applications with event-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204715Z" creationid="xccui" creationdate="20190606T204617Z">
        <seg>接下面我们会介绍Flink内部如何实现和处理时间戳及水位线以支持事件时间语义的流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we describe how to obtain the code examples we use here, how to import them into IntelliJ, how to run an example application, and how to debug it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T091043Z" creationid="xccui" creationdate="20190611T035122Z">
        <seg>下文我们会介绍如何获取书中的示例代码，如何将它们导入IntelliJ以及如何运行和调试它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we describe in detail how a task emits watermarks to multiple output tasks and how it advances its event-time clock from the watermarks it receives from its input tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T053723Z" creationid="xccui" creationdate="20190607T015241Z">
        <seg>下面我们将详细介绍一个任务如何将水位线发送至多个输出任务，以及它从多个输入任务获取水位线后如何推动事件时间时钟前进。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we discuss different methods to reference fields and define keys on data types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T064316Z" creationid="xccui" creationdate="20190617T064316Z">
        <seg>接下来我们将讨论基于数据类型定义引用字段和键值的几种方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we discuss the DataStream API transformations that process multiple input streams or emit multiple output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T060747Z" creationid="xccui" creationdate="20190614T063511Z">
        <seg>接下来我们将讨论那些能同时处理多条输入流或产生多条结果流的DataStream API转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we discuss the architecture of Flink’s queryable state service and explain how streaming applications can expose queryable state and external applica‐ tions can query it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T035920Z" creationid="xccui" creationdate="20190705T195133Z">
        <seg>接下来我们将讨论Flink可查询式状态服务的架构，并解释流式应用如何对外提供可查询式状态以及外部应用怎么才能查询到它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we discuss these options in detail and show how they are applied for process functions and window operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T153228Z" creationid="xingcan" creationdate="20190628T153228Z">
        <seg>下面我们将详细讨论这些选项，看一看它们如何用于处理函数和窗口算子中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we explain how applications can be evolved while preserving savepoint compatibility.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="xccui" creationdate="20190705T023232Z">
        <seg>接下来我们将介绍如何在保持检查点兼容的前提下更新应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we explain how this algorithm works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060033Z" creationid="xccui" creationdate="20190609T060033Z">
        <seg>接下来我们解释一下这个算法的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we explain this step in detail for IntelliJ.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041041Z" creationid="xccui" creationdate="20190611T040830Z">
        <seg>下文我们会以IntelliJ为例对该步骤进行详细解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we list and briefly describe the most important REST calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T211942Z" creationid="xccui" creationdate="20190729T042522Z">
        <seg>接下来我们将列举几个最为重要的REST调用，并它们做一个简要介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we present three classes of applications that are commonly implemented using stateful stream processing: (1) event-driven applications, (2) data pipeline applications, and (3) data analytics applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T212222Z" creationid="esouser" creationdate="20190603T212154Z">
        <seg>接下来我们介绍三类常见的状态化流处理应用：1）事件驱动型应用；2）数据管道应用；3）数据分析应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we show the different built-in window assigners of the DataStream API and how to use them to define window operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T025539Z" creationid="xccui" creationdate="20190623T041952Z">
        <seg>接下来我们将介绍DataStream API中的多种内置窗口分配器以及如何用它们来定义窗口算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we will guide you through the process of starting a local cluster and executing a streaming application to give you a first look at Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T065047Z" creationid="xccui" creationdate="20190605T122436Z">
        <seg>为了让你对Flink有一个初步印象，接下来我们将一步步指导你启动本地集群并运行一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we will use a keyBy transformation to convert a DataStream into a KeyedStream and keyed transformations such as rolling aggrega‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060955Z" creationid="xccui" creationdate="20190614T050124Z">
        <seg>下面我们将使用keyBy转换将一个DataStream转化为KeyedStream，然后对它进行滚动聚合以及reduce操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the introductory example of this chapter, we defined the following case class:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051654Z" creationid="xccui" creationdate="20190618T042328Z">
        <seg>在本章的开篇示例中，我们定义了如下样例类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the library mode, there is no Flink ser&lt;t0/&gt;‐&lt;t1/&gt; vice continuously running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041017Z" creationid="xccui" creationdate="20190423T040707Z">
        <seg>而在库模式中，Flink服务不是一直运行，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the library style, there is no Flink service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144231Z" creationid="xccui" creationdate="20190606T144151Z">
        <seg>而在库模式中，Flink不是作为服务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the mobile gaming case for example, it is practically impossible to know for how long a user might remain disconnected; they could be going through a tunnel, boarding a plane, or never playing again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T030410Z" creationid="xccui" creationdate="20190414T030248Z">
        <seg>以手游场景为例，现实中根本无法得知用户离线多久，他们可能正在过隧道，可能正在上飞机，也可能直接退坑不玩了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the mobile gaming example, it is practically impossi‐ ble to know how long a user might remain disconnected; they could be going through a tunnel, boarding a plane, or never playing again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T161937Z" creationid="xccui" creationdate="20190606T025740Z">
        <seg>以手游场景为例，现实中根本无法得知用户会离线多久。他们可能正在过隧道，可能正在上飞机，也可能直接退坑不玩了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the next section, we discuss task failures and result guarantees in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033049Z" creationid="xccui" creationdate="20190606T033021Z">
        <seg>在下一节，我们会讨论有关任务故障和结果保障的详情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the next section, you will learn about task failures and result guarantees in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035719Z" creationid="xccui" creationdate="20190415T035232Z">
        <seg>在下一节，你将了解任务故障和结果保障的详细信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the past, analyzing data with a few hours or even days delay was often</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032918Z" creationid="xccui" creationdate="20190317T032601Z">
        <seg>在过去，由于对最新结果或见解的快速反应并不会产生显著优势，因此人们完全可以接受分析数据存在几小时甚至几天的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the preceding code, elements are allowed to be late up to 10 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T053005Z" creationid="xccui" creationdate="20190620T053005Z">
        <seg>以上代码中，元素最多允许延迟10秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the preceding example, you instruct the program to emit watermarks every 5 sec‐ onds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055412Z" creationid="xccui" creationdate="20190620T045838Z">
        <seg>在上方示例中，我们指示程序每隔5秒发出一次水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the previous chapter, you saw how streaming applications have different opera&lt;t0/&gt;‐&lt;t1/&gt; tional requirements from traditional batch programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150245Z" creationid="xccui" creationdate="20190401T150006Z">
        <seg>在上一章，你已经了解了流式应用在操作需求方面和传统批处理程序有所不同，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the remainder of the chapter we focus on keyed windows only.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041511Z" creationid="xccui" creationdate="20190622T041511Z">
        <seg>在本章剩余部分，我们将只关注键值分区窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this book, we are going to see how Flink actually implements these concepts and how you can use its DataStream API to write applications that use all of the features we have introduced so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T195509Z" creationid="xccui" creationdate="20190606T041244Z">
        <seg>在本书的剩余部分，我们会介绍Flink是如何实现这些概念的，以及怎样利用它的DataStream API来编写一些涵盖了目前为止所讲特性的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this book, we are going to see how Flink actually implements these concepts and how you can use its DataStream APIs to write applications that use all of the features that we have introduced so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052330Z" creationid="xccui" creationdate="20190416T051935Z">
        <seg>在本书的其余部分，我们会介绍Flink是如何实现这些概念的，以及怎样利用它的DataStream API来编写那些涵盖目前所介绍的所有特性的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, we are going to look deeper into the concepts of time and state guarantees under failures in data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T205822Z" creationid="xccui" creationdate="20190409T205616Z">
        <seg>在本章剩余部分，我们将深入研究流处理发生故障时的时间和状态保障相关概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, we are going to look deeper into the concepts of time and state guarantees under failures in data stream process‐ ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064752Z" creationid="xccui" creationdate="20190606T014614Z">
        <seg>在本章剩余部分，我们将深入研究流处理中的时间以及在发生故障时和状态保障相关概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, when we talk about “result guarantees” we mean the consistency of the internal state of the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034209Z" creationid="xccui" creationdate="20190606T034209Z">
        <seg>在本章剩余部分，当提到"结果保障"，我们指的是流处理引擎内部状态的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, when we talk about “result guarantees” we refer to the consistency of the internal state of the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T045234Z" creationid="xccui" creationdate="20190415T044920Z">
        <seg>在本章剩余部分，当提到"结果保障"，我们指的是流处理引擎内部状态的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the streaming world, however, dealing with failures is not a trivial problem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044227Z" creationid="xccui" creationdate="20190415T044227Z">
        <seg>然而在流式场景中，处理故障就没那么容易了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the streaming world, however, dealing with fail‐ ures is not a trivial problem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034123Z" creationid="xccui" creationdate="20190606T034123Z">
        <seg>然而在流式场景中，处理故障就没那么容易了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the very simple case, there will be at least one source and one sink apart from the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045446Z" creationid="xccui" creationdate="20190416T045403Z">
        <seg>即便是最简单的情形，除了流处理引擎也至少要有一个数据源和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the worst case, you will locate the event more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193329Z" creationid="xccui" creationdate="20190416T042615Z">
        <seg>它最坏的情况也无非就是多几次定位到目标事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this architecture the event log acts as a source of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T060836Z" creationid="xccui" creationdate="20190305T060746Z">
        <seg>在该架构下，事件日志扮演了真实数据源的角色，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this architecture the event log persists the input events and can replay them in deterministic order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T032438Z" creationid="esouser" creationdate="20190603T211452Z">
        <seg>在该架构下，事件日志系统可以持久化输入事件并以确定的顺序将其重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case you can configure the maximum number of concurrent check‐ points.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T203131Z" creationid="xccui" creationdate="20190731T203131Z">
        <seg>在该情况下，你可以为生成检查点配置最大并发数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T031806Z" creationid="xccui" creationdate="20190709T031806Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, Flink does not start the application to avoid losing the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T053706Z" creationid="xccui" creationdate="20190727T053706Z">
        <seg>那么Flink将不会启动应用，以防保存点中的状态丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, any custom states of the triggers also need to be merged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194925Z" creationid="xccui" creationdate="20190626T194925Z">
        <seg>在该情况下所有触发器的自定义状态同样需要合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, late events might arrive after the watermark, and we should provide some code to handle them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025649Z" creationid="xccui" creationdate="20190606T025649Z">
        <seg>该情况下，延迟事件可能会在水位线之后到来，我们必须额外加一些代码来处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, late&lt;t2/&gt; &lt;t3/&gt;events might arrive after the watermark and we should provide some code to handle them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210653Z" creationid="xccui" creationdate="20190412T210653Z">
        <seg>该情况下，延迟事件可能会在水位线之后到来，我们必须额外加一些代码来处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, latency-tracking estimation will not be reliable, as its current implementation assumes synchronized clocks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T032936Z" creationid="xccui" creationdate="20190807T032936Z">
        <seg>在该情况下，延迟追踪的估计值将变得不可靠，因为目前的实现是以时钟同步为前提。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, some stateful operators run special logic to initialize their state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T032536Z" creationid="xccui" creationdate="20190726T032536Z">
        <seg>在该情况下，部分状态化算子会运行一些特殊逻辑来对状态进行初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the dependencies are loaded into the classpath when Flink processes are started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T010114Z" creationid="xccui" creationdate="20190619T041732Z">
        <seg>这样在Flink进程启动时就会将依赖加载到Classpath中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the new state is initialized as empty.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T053538Z" creationid="xccui" creationdate="20190727T053330Z">
        <seg>那么在该情况下，新的状态会被初始化为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the positions are provided as a list, one after the other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T040655Z" creationid="xccui" creationdate="20190618T033756Z">
        <seg>只需将所有位置以列表的形式逐一提供即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, you can ach&lt;t2/&gt;‐&lt;t3/&gt; ieve exactly-once semantics with at-least-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050315Z" creationid="xccui" creationdate="20190416T050315Z">
        <seg>该情况下，你可以利用至少一次保障去实现精确一次的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, you can achieve exactly-once semantics with at-least-once guar‐ antees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194838Z" creationid="xccui" creationdate="20190606T035403Z">
        <seg>该情况下，你可以用至少一次保障来实现精确一次的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, you should provide more memory to the network stack.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T040203Z" creationid="xccui" creationdate="20190724T040203Z">
        <seg>在该情况下，你就需要给网络栈分配更多内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we discuss why stateful stream processing is becoming so popular and assess its potential.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T222743Z" creationid="xccui" creationdate="20190225T222138Z">
        <seg>本章我们将讨论为何状态化流处理会变得流行，并进一步评估它的发展潜力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we discussed Flink’s high-level architecture and the internals of its net‐ working stack, event-time processing mode, state management, and failure recovery mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T031909Z" creationid="xccui" creationdate="20190610T030858Z">
        <seg>本章我们主要讨论了Flink的高层次设计架构以及内部的网络栈、事件时间处理模式、状态管理以及故障恢复机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we discussed how Flink is set up in different environments and how to configure HA setups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042013Z" creationid="xccui" creationdate="20190725T041510Z">
        <seg>本章我们首先讨论了如何针对不同环境搭建Flink集群以及如何进行HA设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we give a high-level introduc&lt;t0/&gt;‐&lt;t1/&gt; tion to Flink’s architecture and describe how Flink addresses the aspects of stream processing that we discussed before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T054045Z" creationid="xccui" creationdate="20190416T053847Z">
        <seg>本章中我们将从一个较高的层次来讲解Flink的架构，并介绍Flink是如何解决之前讨论的流处理相关问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we introduced the basics of Flink’s DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T043534Z" creationid="xccui" creationdate="20190619T043534Z">
        <seg>本章我们介绍了Flink DataStream API的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter you learned how Flink DataStream applications can read data from and write data to external systems and the requirements for an application to achieve different end-to-end consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T213824Z" creationid="xccui" creationdate="20190716T213824Z">
        <seg>本章你学到了Flink DataStream应用如何读写外部系统的数据，以及应用实现不同端到端一致性保障的相关需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter you learned how to implement streaming applications that operate on time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041419Z" creationid="xccui" creationdate="20190629T041419Z">
        <seg>在本章中，你学到了如何实现对时间进行操作的流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter you learned how to set up an environment to develop and debug Flink DataStream applications and how to generate a Maven project using Flink’s Maven archetype.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T094950Z" creationid="xccui" creationdate="20190612T010845Z">
        <seg>本章你学到了如何搭建一个用于开发和调试Flink DataStream应用的环境，以及如何使用Flink的Maven模板生成Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we discuss how source and sink connectors affect the consistency guarantees of Flink streaming applications and present Flink’s most popular connec‐ tors to read and write data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T051028Z" creationid="xccui" creationdate="20190708T051028Z">
        <seg>在本章中，我们将讨论数据源和数据汇连接器如何影响Flink流式应用的一致性保障，并介绍Flink中最常用的数据读写连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we discuss the different ways to deploy Flink clusters and how to con‐ figure them securely and make them highly available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T135351Z" creationid="xccui" creationdate="20190717T031932Z">
        <seg>本章我们将讨论Flink集群的多种部署方式以及如何对它进行安全和高可用配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we discuss why stateful stream processing is becoming so popular and assess its poten‐ tial.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063642Z" creationid="esouser" creationdate="20190603T163008Z">
        <seg>本章我们会讨论为何状态化流处理会变得如此流行，并进一步评估其发展潜力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we discussed how to run, manage, and monitor Flink applications in production.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T035730Z" creationid="xccui" creationdate="20190807T035730Z">
        <seg>本章我们讨论了如何在生产环境中运行、管理和监控Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we give a high-level introduction to Flink’s architecture and describe how Flink addresses the aspects of stream processing we discussed earlier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T042917Z" creationid="xccui" creationdate="20190606T140002Z">
        <seg>本章我们将从一个较高的层次来讲解Flink的架构，并介绍它如何解决我们之前讨论的流处理相关问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we introduced stateful stream processing, discussed its use cases, and had a first look at Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124639Z" creationid="xccui" creationdate="20190605T124639Z">
        <seg>本章我们介绍了状态化流处理，讨论了它的几个用例并对Apache Flink进行了初步介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we present the tools Flink offers for operating and maintaining continuously running streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T160726Z" creationid="xccui" creationdate="20190725T051116Z">
        <seg>本章我们将介绍Flink所提供的用于持续运行流式应用的运维工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we will cover DataStream API methods for time handling and time- based operators, like windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T031808Z" creationid="xccui" creationdate="20190619T050036Z">
        <seg>本章我们将介绍DataStream API中用于处理时间的方法和基于时间的算子（如窗口）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you have learned the fundamental concepts and ideas of data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051435Z" creationid="xccui" creationdate="20190416T050432Z">
        <seg>本章中你主要学习了数据流处理的基本概念和思想。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you learned the fundamentals of data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194856Z" creationid="xccui" creationdate="20190606T035408Z">
        <seg>本章主要教给你数据流处理相关的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you will enter the streaming world for good and you will get the necessary background for the rest of this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T053424Z" creationid="xccui" creationdate="20190329T053246Z">
        <seg>在本章中，你将踏入流处理的世界并从中获得本书其余部分所需的背景知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you will enter the streaming world for good.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T042452Z" creationid="xccui" creationdate="20190605T224655Z">
        <seg>本章将正式引领你踏入流处理的世界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you will learn how to set up an environment to develop, run, and debug Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012943Z" creationid="xccui" creationdate="20190610T040115Z">
        <seg>本章你将学到如何搭建一个用于开发、运行和调试Flink应用的环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example the tuple input stream is keyed by the first field and the rolling sum is computed on the second field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T062144Z" creationid="xccui" creationdate="20190614T054950Z">
        <seg>该示例中，输入流的元组按照第一个字段进行分区，然后滚动计算第二个字段的总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, a DataStream[(String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210729Z" creationid="xccui" creationdate="20190711T210729Z">
        <seg>该示例会将DataStream[(String, Float)]写入"sensors"表中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, after reading the stream, we first apply a filter transformation and then call the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044508Z" creationid="xccui" creationdate="20190620T044508Z">
        <seg>在这个例子中，我们首先使用了一个过滤转换，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the JobID is bc0b2ad61ecd4a615d92ce25390f61ad.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033120Z" creationid="xccui" creationdate="20190726T033120Z">
        <seg>上述例子中，JobID是bc0b2ad61ecd4a615d92ce25390f61ad。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this mode, Flink applications are packaged into a JAR file and submitted by a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143428Z" creationid="xccui" creationdate="20190606T143415Z">
        <seg>在该模式下，Flink应用会打包成一个JAR文件，通过客户端提交到运行的服务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this mode, the Flink application is bundled in an application-specific con‐ tainer image, such as a Docker image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190606T143646Z">
        <seg>在该模式下，Flink应用会绑定到一个特定应用的容器镜像（如Docker镜像）中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this scenario, a stateful function receives records with keys that are only active for a cer‐ tain period of time and are never received after that.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052147Z" creationid="xccui" creationdate="20190704T141006Z">
        <seg>在该场景下，状态化函数所接收记录的键值只有一段特定时间的活跃期，此后就再也不会收到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this scenario, you want to know if there has been an accident in a certain location within the last few minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043257Z" creationid="xccui" creationdate="20190406T043238Z">
        <seg>在该场景下，你想知道在最近几分钟内某个特定位置有没有发生交通事故。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section we describe the different components that a Flink setup consists of and discuss their responsibilities and how they interact with each other to execute an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033253Z" creationid="xccui" creationdate="20190418T032751Z">
        <seg>在本节，我们将首先介绍Flink设置中的不同组件，讨论它们的职责以及在运行应用时如何交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section we give an overview of the basic transformations of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T053443Z" creationid="xccui" creationdate="20190613T012853Z">
        <seg>本节我们将对DataStream API中的基本转换做一个概述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070259Z" creationid="xccui" creationdate="20190615T070259Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe both operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T203334Z" creationid="xccui" creationdate="20190627T210559Z">
        <seg>本节我们会对它们进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe how Flink initializes the state of an application started from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T070941Z" creationid="xccui" creationdate="20190609T214356Z">
        <seg>本节我们将介绍Flink在从保存点启动时如何去初始化应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe how to build a job-specific Docker image and how to deploy a library-style bundled application on Kubernetes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190730T030634Z">
        <seg>在本节中，我们将介绍如何针对特定作业构建Docker镜像，以及如何在Kubernetes上以库模式部署绑定的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe the different components of a Flink setup and how they interact with each other to execute an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T045129Z" creationid="xccui" creationdate="20190606T140844Z">
        <seg>本节我们将介绍搭建Flink时所涉及的不同组件并讨论它们在应用运行时的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe the most common streaming operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235815Z" creationid="xccui" creationdate="20190402T213018Z">
        <seg>在本节中，我们来介绍最常见的流式操作，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe the parameters used to control checkpointing and recovery of applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T030316Z" creationid="xccui" creationdate="20190731T030316Z">
        <seg>本节我们将介绍一些用于控制生成检查点和应用恢复的参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe the semantics of common window types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T050438Z" creationid="xccui" creationdate="20190406T050413Z">
        <seg>本节我们会介绍常见窗口类型的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss aspects that need to be taken into account to ensure robust execution behavior and consistent performance of long- running applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T025137Z" creationid="xccui" creationdate="20190703T211557Z">
        <seg>本节我们将重点讨论几个方面，它们可以为长期运行应用的健壮执行和一致性能提供保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss both types and how they manage and process data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T023126Z" creationid="esouser" creationdate="20190603T194239Z">
        <seg>在本节中，我们将讨论这两类处理模型以及它们如何管理和处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss different aspects that typically need to be config‐ ured when setting up a Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T043234Z" creationid="xccui" creationdate="20190723T043234Z">
        <seg>本节我们将讨论搭建Flink集群时针对不同方面的典型配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss how operators process watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T070333Z" creationid="xccui" creationdate="20190529T040632Z">
        <seg>本节我们主要讨论算子对水位线的处理方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss the different types of functions that can be applied on a window to perform aggregations or arbitrary computations on the window’s con‐ tents.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T033628Z" creationid="xccui" creationdate="20190623T211733Z">
        <seg>本节我们将讨论一些可用在窗口上的不同函数，它们支持对窗口内容执行聚合或任意计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss the different types of states Flink supports.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055800Z" creationid="xccui" creationdate="20190607T053343Z">
        <seg>本节我们会对Flink支持的不同类别的状态进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss the lifecycle of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032353Z" creationid="xccui" creationdate="20190626T032353Z">
        <seg>本节我们将讨论窗口的生命周期，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss the types supported by Flink, how to create type informa‐ tion for a data type, and how to help Flink’s type system with hints if it cannot auto‐ matically infer the return type of a function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T064849Z" creationid="xccui" creationdate="20190616T064849Z">
        <seg>本节我们会讨论Flink支持的类型，如何为数据类型创建类型信息，以及当Flink无法自动推断函数的返回类型时如何以提示的方式帮助类型系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss window operations, which provide such a mech&lt;t6/&gt;‐&lt;t7/&gt; anism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041719Z" creationid="xccui" creationdate="20190406T041719Z">
        <seg>在本章中，我们以窗口操作为例讨论这个机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss window operations, which pro‐ vide this service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T062107Z" creationid="xccui" creationdate="20190606T012050Z">
        <seg>在本节中，我们将讨论提供了此项功能的窗口操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we dis‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T161325Z" creationid="xccui" creationdate="20190730T161325Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we explain how to configure and start Flink in different environments—including standalone clusters, Docker, Apache Hadoop YARN, and Kubernetes—and how Flink’s compo‐ nents are assembled in each setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T135537Z" creationid="xccui" creationdate="20190717T152301Z">
        <seg>本节我们将向你介绍如何在不同环境下（独立集群，Docker，Apache Hadoop YARN以及Kubernetes）配置并启动Flink，以及在每种部署模式下它的组件是如何组装到一起的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we explain the different ways in which you can define and para‐ metrize functions in the DataStream API in more detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T053322Z" creationid="xccui" creationdate="20190618T052914Z">
        <seg>本节我们会对在DataStream API中定义和参数化函数的各种方式进行一个更加详细的解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we explain the practical aspects of savepoints and discuss how to start, stop, pause and resume, scale, and upgrade stateful streaming applications using Flink’s command-line client and Flink’s REST API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T014322Z" creationid="xccui" creationdate="20190726T014322Z">
        <seg>本节我们将解释保存点的实际应用场景，并讨论如何使用Flink命令行客户端和REST API来完成对于状态化流式应用的启动、停止、暂停、恢复、扩缩容和升级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we introduce time semantics and describe the different notions of time in streaming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T152542Z" creationid="xccui" creationdate="20190409T205917Z">
        <seg>本节我们将介绍流式场景中时间语义和不同的时间概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we present Flink’s checkpointing and recovery mechanism to guaran‐ tee exactly-once state consistency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T063311Z" creationid="xccui" creationdate="20190608T153948Z">
        <seg>本节我们将介绍Flink的检查点（checkpoint）及故障恢复机制，看一下它们如何提供精确一次的状态一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we show how functions with keyed and operator state are implemented.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T014958Z" creationid="xccui" creationdate="20190630T035207Z">
        <seg>本节我们将展示如何实现带有键值分区状态及算子状态的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we show you how to define window operators, present the built- in window types of the DataStream API, discuss the functions that can be applied on a window, and finally explain how to define custom windowing logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T034040Z" creationid="xccui" creationdate="20190622T034040Z">
        <seg>本节我们将向你展示如何定义窗口算子，介绍DataStream API的内置窗口类型，讨论可用于窗口的函数并说明如何自定义窗口逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we will configure this mode for different deployment options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T144243Z" creationid="xccui" creationdate="20190720T045453Z">
        <seg>本节我们将介绍如何针对不同部署选择来配置该模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we will see how to use watermarks to configure event-time window behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160859Z" creationid="xccui" creationdate="20190606T025254Z">
        <seg>在本节中，我们将了解如何利用水位线来设定事件时间窗口的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we will see how we can use the concept of &lt;t2/&gt;watermarks &lt;t3/&gt;to configure event-time window behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T204619Z" creationid="xccui" creationdate="20190412T204508Z">
        <seg>在本节中，我们来看一下如何利用水位线概念来设定事件窗口的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, you are going to learn how to process infinite streams in parallel, using the dataflow programming paradigm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045834Z" creationid="xccui" creationdate="20190605T233704Z">
        <seg>本节你将学到如何利用Dataflow编程范式并行处理无限数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, you are going to learn the concepts of processing infinite streams in parallel, using the dataflow programming paradigm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T145933Z" creationid="xccui" creationdate="20190401T143350Z">
        <seg>本节中你将学到用dataflow编程范式去并行处理无限数据流的相关概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, you will learn how Flink restarts failed processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072142Z" creationid="xccui" creationdate="20190428T205043Z">
        <seg>本节你将学到Flink如何重启故障进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this situation, the JobManager will ask the ResourceManager to provide</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210310Z" creationid="xccui" creationdate="20190428T205838Z">
        <seg>这时候JobManager就会向ResourceManager申请更多的处理槽，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this situation, the JobManager will ask the ResourceManager to provide more processing slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145522Z" creationid="xccui" creationdate="20190606T145500Z">
        <seg>这时候JobManager就会向ResourceManager申请更多的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In version 1.7, Flink provides a few classes that extend FileInputFormat and imple‐ ment CheckpointableInputFormat.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T195719Z" creationid="xccui" creationdate="20190710T195719Z">
        <seg>在1.7版本中，Flink提供了一些继承自FileInputFormat并实现了CheckpointableInputFormat的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Application Deploy‐ ment” on page 39, we briefly explained an alternative—the library mode that does not require a running Flink cluster to submit a job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T213512Z" creationid="xccui" creationdate="20190729T210600Z">
        <seg>在第39页"应用部署"一节，我们还简要介绍了另一种部署形式——库模式，它无需一个已运行的Flink集群来接收提交作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Checkpointing and State Backends” on page 243, we discussed the configuration options for state backends.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025405Z" creationid="xccui" creationdate="20190801T025405Z">
        <seg>在第243页"检查点和状态后端"一节，我们讨论了不同状态后端的配置选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Checkpoints, Savepoints, and State Recovery”, we explained Flink’s mechanism to create consistent checkpoints of a stateful application, a snapshot of the state of all built-in and user-defined stateful functions at a point in time when all operators pro‐ cessed all events up to a specific position in the application’s input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052137Z" creationid="xccui" creationdate="20190702T204418Z">
        <seg>在"检查点、保存点即状态恢复"一节，我们解释了Flink为状态化应用创建一致性检查点的机制——在所有算子都处理到应用输入流的某一特定位置时，为全部内置或用户定义的状态化函数基于该时间点创建一个状态快照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Checkpoints, Savepoints, and State Recovery”, you learned that Flink’s check‐ pointing and recovery mechanism periodically takes consistent checkpoints of an application’s state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T045039Z" creationid="xccui" creationdate="20190708T051855Z">
        <seg>在"检查点、保存点及状态恢复"一节，你了解到Flink的检查点和恢复机制会周期性地为应用状态创建一致性检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Components of a Flink Setup”, we introduced the different components of a Flink setup: the JobMan‐ ager, TaskManager, ResourceManager, and Dispatcher.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T151727Z" creationid="xccui" creationdate="20190717T151727Z">
        <seg>在"搭建Flink所需组件"一节，我们介绍了Flink搭建过程中所涉及的不同组件：JobManager、TaskManager、ResourceManager及Dispatcher。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Controlling Task Chaining” on page 261, we show how to disable task chaining for an application and how to control the chaining behavior of individual operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T202250Z" creationid="xccui" creationdate="20190606T204112Z">
        <seg>在第261页的"控制任务链接"一节，我们会展示如何针对某一应用禁用任务链接以及如何单独控制单个算子的链接行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Controlling Task Scheduling” on page 260 we discuss how to con‐ trol the scheduling of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144841Z" creationid="xccui" creationdate="20190606T144841Z">
        <seg>我们将在260页"控制任务调度"一节讨论如何控制任务调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Deployment Modes” on page 221, we will dis‐ cuss how to set up and configure Flink for different environments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143345Z" creationid="xccui" creationdate="20190606T143345Z">
        <seg>在第221页"部署模式"一节，我们会讨论如何针对不同环境搭建及配置Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Emitting to Side Outputs” on page 119, we present the side-output feature of the process functions, which can emit multiple streams of different types from a function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T061737Z" creationid="xccui" creationdate="20190615T064512Z">
        <seg>在119页"向副输出（side output）发送数据"一节，我们会介绍针对处理函数的副输出功能，它可以从函数中发出多条类型不同的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Latency” on page 20, we defined latency broadly as the time it takes to process an event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T050546Z" creationid="xccui" creationdate="20190806T050546Z">
        <seg>在第20页的"延迟"一节中，我们宽泛地将延迟定义为处理事件所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Savepoints”, we explained that each state in a savepoint can be addressed by a composite identifier consisting of a unique operator identifier and the state name declared by the state descriptor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T023759Z" creationid="xccui" creationdate="20190705T023759Z">
        <seg>在"保存点"一节，我们说明了保存点中的每个状态都可以利用一个复合标识进行定位，该标识包含了一个唯一算子标识和一个由状态描述符声明的状态名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “State Backends” on page 55, we explained that Flink maintains application state in a state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T213538Z" creationid="xccui" creationdate="20190703T213538Z">
        <seg>在第55页"状态后端"一节，我们介绍了Flink使用状态后端来维护应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “State Management” on page 53, we discussed that Flink supports three types of operator state: list state, list union state, and broadcast state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T035936Z" creationid="xccui" creationdate="20190701T035832Z">
        <seg>在53页"状态管理"一节，我们讨论了Flink支持的三种算子状态：列表状态、联合列表状态以及广播状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “State Management”, we explained that functions can have two types of state, keyed state and operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T213754Z" creationid="xccui" creationdate="20190630T035002Z">
        <seg>在"状态管理"一节，我们提到了函数的状态类型有两种——键值分区状态和算子状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Task Execution”, we described how Flink assigns tasks to slots and how it lever‐ ages task chaining to reduce the cost of local data exchange.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T005832Z" creationid="xccui" creationdate="20190730T161047Z">
        <seg>在"任务执行"一节，我们介绍了Flink如何将任务分配到处理槽以及如何利用任务链接来降低本地数据交换成本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Time Semantics” on page 27, we highlighted the importance of time semantics for stream processing applications and explained the differences between processing time and event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T063507Z" creationid="xccui" creationdate="20190606T204144Z">
        <seg>在第27页的"时间语义"一节，我们强调了时间语义对于流处理应用的重要性并解释了处理时间和事件时间的差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Including External and Flink Dependencies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022940Z" creationid="xccui" creationdate="20190225T022940Z">
        <seg>导入外部和Flink依赖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Including External and Flink Dependencies | 107</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035424Z" creationid="xccui" creationdate="20190619T035424Z">
        <seg>导入外部和Flink依赖 | 107</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incorporating a signifi‐ cant amount of example code from this book into your product’s documentation does require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210821Z" creationid="esouser" creationdate="20190603T210821Z">
        <seg>Incorporating a signifi‐ cant amount of example code from this book into your product’s documentation does require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Increasing the checkpointing interval reduces the overhead of fault tolerance during regular pro‐ cessing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T024641Z" creationid="xccui" creationdate="20190731T025215Z">
        <seg>增大检查点的生成间隔可以降低常规处理过程中容错的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incremental aggregation and ProcessWindowFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034430Z" creationid="xccui" creationdate="20190625T034430Z">
        <seg>增量聚合与ProcessWindowFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incremental aggregation functions are directly applied when an element is added to a window and hold and update a single value as window state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T032146Z" creationid="xccui" creationdate="20190623T210654Z">
        <seg>增量聚合函数。它的应用场景是窗口内以状态形式存储某个值且需要根据每个加入窗口的元素对该值进行更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Index.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031120Z" creationid="xccui" creationdate="20190418T040551Z">
        <seg>索引</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexer: Judith McConville</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210722Z" creationid="esouser" creationdate="20190603T210722Z">
        <seg>Indexer: Judith McConville</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indicates new terms, URLs, email addresses, filenames, and file extensions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210801Z" creationid="esouser" creationdate="20190603T210801Z">
        <seg>Indicates new terms, URLs, email addresses, filenames, and file extensions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ingesting, transforming, and inserting data with low latency is another common use case for stateful stream processing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154504Z" creationid="xccui" creationdate="20190317T013857Z">
        <seg>状态化流处理应用的另一个日常用例是以低延迟的方式获取、转换并插入数据，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ingestion time does not offer much practical value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071917Z" creationid="xccui" creationdate="20190619T071917Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IngestionTime</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071453Z" creationid="xccui" creationdate="20190619T071453Z">
        <seg>IngestionTime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>InputFormat is Flink’s interface to define data sources in the DataSet API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T203014Z" creationid="xccui" creationdate="20190710T203014Z">
        <seg>InputFormat是Flink在DataSet API中定义数据源的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inspect the web dashboard.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201421Z" creationid="xccui" creationdate="20190329T040028Z">
        <seg>检查一下Web UI，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead a common approach is to write all changes into an event log that serves as source of truth.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T072031Z" creationid="xccui" creationdate="20190314T071923Z">
        <seg>一种常见的替代方法是把所有改动写入事件日志系统中，并以它为事实来源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead it takes advantage of distributed file systems like HDFS or object stores such as S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032244Z" creationid="xccui" creationdate="20190418T032212Z">
        <seg>而是利用了现有的分布式文件系统（如：HDFS）或对象存储（如：S3）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of adding new states to an application, you might also want to adjust an appli‐ cation by removing state—either by removing a complete stateful operator or just a state from a function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T042812Z" creationid="xccui" creationdate="20190705T042812Z">
        <seg>除了向应用中添加状态，你可能还想在修改应用的同时从中删除一些状态。这些删除操作所针对的可以是一个完整的状态化算子，也可以是函数中的某个状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of dropping or redirecting late events, another strategy is to recompute an incomplete result and emit an update.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T160522Z" creationid="xingcan" creationdate="20190628T160522Z">
        <seg>除了将迟到事件丢弃或重定向外，另一种策略是对不完整的结果进行重新计算并发出更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of inserting all data into a relational database system, significant amounts of data, such as, log files, social media, or web click logs, are written into Hadoop’s distributed file system (HDFS) or other bulk data stores, like Apache HBase, which provide massive storage capacity at small cost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T032702Z" creationid="xccui" creationdate="20190301T030218Z">
        <seg>海量日志文件、社交媒体、网页点击日志等数据已不再使用关系数据库系统存储，而是会写入Hadoop分布式文件系统（HDFS）或其他诸如Apache HBase的批量数据存储系统。这些系统以低廉的成本提供庞大的存储容量，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of inserting all data into a relational data‐ base system, significant amounts of data, such as log files, social media, or web click logs, are written into Hadoop’s distributed filesystem (HDFS), S3, or other bulk data‐ stores, like Apache HBase, which provide massive storage capacity at a small cost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T065204Z" creationid="esouser" creationdate="20190603T203758Z">
        <seg>海量日志文件、社交媒体、网页点击日志等数据已不再使用关系数据库系统存储，而是会写入Hadoop分布式文件系统（HDFS）、S3或其他诸如Apache HBase的批量数据存储系统。这些系统以低廉的成本提供庞大的存储容量，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of manually starting two (or more) containers, you can also create a Docker Compose configuration script, which automatically starts and configures a Flink clus‐ ter running in Docker containers and possibly other services such as ZooKeeper and Kafka.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T043514Z" creationid="xccui" creationdate="20190718T043514Z">
        <seg>除了手工启用两个（或更多）容器之外，你还可以创建一个Docker Compose配置脚本。它支持自动启动和配置运行在Docker容器内的Flink集群，还可以顺带启用诸如ZooKeeper和Kafka等其他服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of running analytical queries directly on the transactional databases, a com&lt;t0/&gt;‐&lt;t1/&gt; mon component in IT systems is a data warehouse.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192036Z" creationid="xccui" creationdate="20190228T184103Z">
        <seg>IT系统中一般会选用的数据仓库，而非事务型数据库来执行分析类查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of running analytical queries directly on the transactional databases, the data is typically replicated to a data warehouse, a dedicated datastore for analytical query workloads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T064724Z" creationid="esouser" creationdate="20190603T202102Z">
        <seg>对于分析类查询，我们通常不会直接在事务型数据库上执行，而是将数据复制到一个专门用来处理分析类查询工作的数据仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of trying to strictly measure latency for each and every event, it approximates latency by periodically emitting a special record at the sources and allowing users to track how long it takes for this record to arrive at the sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T054442Z" creationid="xccui" creationdate="20190806T054442Z">
        <seg>它没有严格测量每个事件的延迟，而是通过在数据源周期性地发出一些特殊记录并允许用户跟踪它们到达数据汇的时间来近似估计延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of using a SerializationSchema to convert records into byte arrays, you can also specify a KeyedSerializationSchema, which serializes a record into two byte arrays—one for the key and one for the value of a Kafka message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T152718Z" creationid="xingcan" creationdate="20190709T152718Z">
        <seg>除了使用SerializationSchema将记录转换成字节数组，你还可以选用KeyedSerializationSchema，它会将一条记录序列化成两个字节数组，分别作为kafka消息的键和值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of waiting for the application to terminate, the client returns and prints the JobID of the submitted job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T030953Z" creationid="xccui" creationdate="20190726T030953Z">
        <seg>此时客户端不会再等应用结束，而会立即返回并打印提交作业的JobID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of waiting to be periodically trig&lt;t0/&gt;‐&lt;t1/&gt; gered, a streaming analytics application continuously ingests streams of events and maintains an updating result by incorporating the latest events with low latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062449Z" creationid="xccui" creationdate="20190317T055651Z">
        <seg>流式分析应用不再需要等待周期性地触发。相反，它们会一直获取事件流，以极低的延迟整合最新事件，从而可以维护不断更新的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of waiting to be periodically triggered, a streaming analytics application con‐ tinuously ingests streams of events and updates its result by incorporating the latest events with low latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155248Z" creationid="xccui" creationdate="20190605T043757Z">
        <seg>流式分析应用不再需要等待周期性地触发。相反，它会持续获取事件流，以极低的延迟整合最新事件，从而可以不断更新结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T053406Z" creationid="xccui" creationdate="20190715T053406Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink implements checkpointing based on the Chandy–Lamport algorithm for distributed snapshots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T055721Z" creationid="xccui" creationdate="20190609T055529Z">
        <seg>而Flink的检查点是基于Chandy-Lamport分布式快照算法来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink is bundled as a library together with the application in a container image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190423T040832Z">
        <seg>而是以库的形式绑定在应用所在的容器镜像中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink organizes keys in so-called key groups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T055556Z" creationid="xccui" creationdate="20190608T055448Z">
        <seg>而是会把所有键值分为不同的键值组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink uses a lightweight snapshotting mechanism to achieve exactly-once result guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194239Z" creationid="xccui" creationdate="20190416T045008Z">
        <seg>Flink采用了轻量级检查点机制来实现精确一次结果保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, POJOs are handed to Cassandra’s Object Mapper, which automatically maps POJO fields to fields of a Cassandra table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T213401Z" creationid="xccui" creationdate="20190711T213247Z">
        <seg>事实上，POJO对象会交给Cassandra的Object Mapper来处理，它会自动把POJO字段映射到Cassandra表中的字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, a 95th-percentile latency value of 10ms means that 95% of events are processed within 10ms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T155314Z" creationid="xccui" creationdate="20190401T155221Z">
        <seg>而第95百分位延迟在10毫秒意味着95%的事件会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, a method is called as soon as an event has arrived via the corre‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T062156Z" creationid="xccui" creationdate="20190615T043711Z">
        <seg>一旦对应流中有事件到来，系统就需要调用相应的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, all stateful operators must control the size of their state and have to ensure it is not infinitely growing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T140020Z" creationid="xccui" creationdate="20190704T140020Z">
        <seg>所有状态化算子都要控制自身状态大小，确保他们不会无限制增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, every system features its own connector library with a proprietary protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T194244Z" creationid="xccui" creationdate="20190708T194244Z">
        <seg>它们每一个都要用到自己专有协议的连接器库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, functions implement operator state as regular member variables and interact with the state backend via callback functions of the ListCheckpointed interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T040529Z" creationid="xccui" creationdate="20190701T040529Z">
        <seg>而需要将算子状态实现为成员变量并通过接口提供的回调函数和状态后端进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it focuses on its core function - distributed data stream processing - and leverages existing cluster infra&lt;t0/&gt;‐&lt;t1/&gt; structure and services.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T031834Z" creationid="xccui" creationdate="20190418T031709Z">
        <seg>而是在已有集群基础设施和服务之上专注于它的核心功能——分布式数据流处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it focuses on its core function—distributed data stream processing—and leverages existing cluster infra‐ structure and services.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140707Z" creationid="xccui" creationdate="20190606T140707Z">
        <seg>而是在已有集群基础设施和服务之上专注于它的核心功能——分布式数据流处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it is crucial that the stream processing system provides some mechanism to deal with events that might arrive after the watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T032537Z" creationid="xccui" creationdate="20190414T031709Z">
        <seg>而流处理系统至关重要的一点是能提供一些机制来处理那些可能晚于流水线的落后事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it is crucial that the stream pro‐ cessing system provide some mechanism to deal with events that might arrive after the watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T162223Z" creationid="xccui" creationdate="20190606T030316Z">
        <seg>而流处理系统很关键的一点是能提供某些机制来处理那些可能晚于水位线的落后事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it takes advantage of distributed filesystems like HDFS or object stores such as S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140811Z" creationid="xccui" creationdate="20190606T140758Z">
        <seg>而是利用了现有的分布式文件系统（如HDFS）或对象存储（如S3）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, keys are defined as functions over the input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040016Z" creationid="xccui" creationdate="20190617T062909Z">
        <seg>而是将它定义为输入数据上的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, streaming applications must provide results for incoming data &lt;t0/&gt;as fast as possible&lt;t1/&gt; while being able to handle high &lt;t2/&gt;ingest rates&lt;t3/&gt; of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151236Z" creationid="xccui" creationdate="20190401T150934Z">
        <seg>取而代之的是，流式应用必须尽可能快地针对到来数据计算结果，且需要应对较高的事件接入速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, streaming applications must provide results for incoming data as fast as possible while being able to handle high ingest rates of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233757Z" creationid="xccui" creationdate="20190605T233757Z">
        <seg>取而代之的是，流式应用需要针对到来数据尽可能快地计算结果，同时还要应对很高的事件接入速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the API calls construct an execution plan in the execution environment, which consists of the stream sources created from the environment and all transformations that were tran‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053222Z" creationid="xccui" creationdate="20190613T011810Z">
        <seg>而只会在执行环境中构建一个执行计划。计划中包含了从环境创建的流式数据源以及应用于这些数据源之上的一系列转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the SessionWindows assigner initially maps each incoming element into its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T062146Z" creationid="xccui" creationdate="20190623T062005Z">
        <seg>事实上，SessionWindows分配器会将每个到来的元素映射到一个它自己的窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the context of the KeyedBroadcastProcessFunction.processBroad castElement() method provides a method applyToKeyed State(StateDescriptor,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054747Z" creationid="xccui" creationdate="20190702T054435Z">
        <seg>作为替代，该方法的上下文提供了一个applyToKeyedState(StateDescriptor, KeyedStateFunction)方法，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the operator continues to maintain the complete window for the allowed lateness period.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164709Z" creationid="xingcan" creationdate="20190628T164559Z">
        <seg>而是会将窗口继续保留该延迟容忍度的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the source and sink connectors of an application need to be integrated with Flink’s checkpointing and recovery mecha‐ nism and provide certain properties to be able to give meaningful guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T051741Z" creationid="xccui" creationdate="20190708T053103Z">
        <seg>进一步，应用的数据源和数据汇连接器需要和Flink的检查点及恢复策略集成，并能提供某些特定的属性以支持各类有意义的保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, time-based DataStream operator tasks configure the time‐ stamps of emitted records to ensure they are properly aligned with the emitted watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T071221Z" creationid="xccui" creationdate="20190607T013124Z">
        <seg>为发出记录配置时间戳的工作需要由基于时间的DataStream算子任务来完成，这样才能确保时间戳和发出的水位线对齐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, we need a window operation that assigns events belonging to the same session in the same bucket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013758Z" creationid="xccui" creationdate="20190409T192442Z">
        <seg>而我们需要一个窗口操作，能将属于同一会话的事件分配到相同桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, what really defines the amount of events in one minute is the time of the data itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143725Z" creationid="xccui" creationdate="20190412T143109Z">
        <seg>而事实上每分钟收到事件数目的是由数据本身的时间来定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you can implement the necessary logic using the building blocks of record timestamps, watermarks, and timers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T212850Z" creationid="xccui" creationdate="20190629T041248Z">
        <seg>虽然如此，你仍可以利用记录时间戳、水位线和定时器等功能来实现必要的迟到数据处理逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you need to build a cus‐ tom image that either “hardcodes” the required parameters or is flexible enough to adjust the configuration dynamically through parameters or environment variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T145529Z" creationid="xccui" creationdate="20190722T005201Z">
        <seg>为此，你需要构建一个自定义镜像，要么就把所需参数"硬编码"进去，要么就灵活一些，允许通过参数或环境变量动态调整配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integration with Hadoop Components</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025502Z" creationid="xccui" creationdate="20190225T025502Z">
        <seg>集成Hadoop组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Rebecca Demarest</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210725Z" creationid="esouser" creationdate="20190603T210725Z">
        <seg>Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Rebecca Demarest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, Flink needs to be able to handle these objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T063149Z" creationid="xccui" creationdate="20190616T063048Z">
        <seg>因此Flink在内部需要对这些数据对象进行一些处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, a window that is evaluated by ProcessWindowFunction stores all assigned events in a ListState.1 By collecting all events and providing access to window meta‐ data and other features, ProcessWindowFunction can address many more use cases than ReduceFunction or AggregateFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T045409Z" creationid="xccui" creationdate="20190625T034118Z">
        <seg>在系统内部，由ProcessWindowFunction处理的窗口会将所有已分配的事件存储在ListState中。1 通过将所有事件收集起来且提供对于窗口元数据及其他一些特性的访问和使用，ProcessWindowFunction的应用场景比ReduceFunction和AggregateFunction更加广泛。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interval Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151640Z" creationid="esouser" creationdate="20190603T150359Z">
        <seg>基于间隔的Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Dataflow Programming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143756Z" creationid="esouser" creationdate="20190603T143543Z">
        <seg>Dataflow编程介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Dataflow Programming | 19</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041328Z" creationid="xccui" creationdate="20190606T041328Z">
        <seg>Dataflow编程介绍 | 19</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191716Z" creationid="xccui" creationdate="20190225T191716Z">
        <seg>状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Stateful Stream Processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014519Z" creationid="xccui" creationdate="20190225T014519Z">
        <seg>状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to dataflow programming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014938Z" creationid="xccui" creationdate="20190225T014938Z">
        <seg>dataflow模型介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inversely, very conservative water&lt;t0/&gt;‐&lt;t1/&gt; marks increase processing latency but improve result completeness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040618Z" creationid="xccui" creationdate="20190529T040556Z">
        <seg>相反，非常宽松的水位线会增加处理延迟，但同时结果的完整性也会有所提升。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inversely, very conservative water‐ marks increase processing latency but improve result completeness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T052409Z" creationid="xccui" creationdate="20190606T210205Z">
        <seg>相反，非常"保守"的水位线会增加处理延迟，但同时结果的完整性也会有所提升。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also gives you a brief look at what it is like to run your first streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031427Z" creationid="esouser" creationdate="20190603T155806Z">
        <seg>此外还简要介绍了如何在本地Flink实例上运行你的第一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also gives you a brief taste of what it is like to run a your first streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T164237Z" creationid="xccui" creationdate="20190225T164237Z">
        <seg>此外还简要介绍了如何在本地Flink实例上运行你的第一个流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also includes a set of common graph algorithms ready to use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T163123Z" creationid="xingcan" creationdate="20190807T163123Z">
        <seg>它还涵盖了一组方便使用的常见图算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also needs to provide a default trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042147Z" creationid="xccui" creationdate="20190626T042141Z">
        <seg>它还需要一个默认触发器，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also offers basic functionality to submit and manage applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T014043Z" creationid="xccui" creationdate="20190726T014043Z">
        <seg>它同时提供了基本的应用提交和管理功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also shows how to use Flink’s queryable state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162155Z" creationid="esouser" creationdate="20190603T162155Z">
        <seg>同时本章还会展示如何使用Flink的可查询式状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also supports connecting a keyed and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T063622Z" creationid="xccui" creationdate="20190615T053018Z">
        <seg>它不仅支持联结一个按键值分好区的流和一个广播流，还能将广播后的事件存到一个托管状态（managed state）中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It applies a ReduceFunction on a KeyedStream, which combines each incoming event with the current reduced value, and produces a DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T054031Z" creationid="xccui" creationdate="20190614T061430Z">
        <seg>它将一个ReduceFunction应用在一个KeyedStream上，每个到来事件都会和reduce结果进行一次组合，从而产生一个新的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It builds on top of the DataSet API and Flink’s support for efficient batch iterations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T162215Z" creationid="xingcan" creationdate="20190807T162215Z">
        <seg>它建立在DataSet API和Flink的高效批量迭代支持之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be accessed by users and scripts and provides access to all system and application metrics as well as endpoints to submit and manage appli‐ cations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T162420Z" creationid="xccui" creationdate="20190726T013818Z">
        <seg>它可以供用户或脚本访问，还可用于获取所有系统及应用指标并作为提交和管理应用的端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be configured to preserve the order of records (requests might</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T193552Z" creationid="xccui" creationdate="20190716T192600Z">
        <seg>它可以通过配置选择对记录进行保序（请求结果的返回顺序可能和请求发出的顺序不同），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used to generate watermarks that are encoded in special input records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040000Z" creationid="xccui" creationdate="20190607T035846Z">
        <seg>它可用于需要根据特殊输入记录生成水位线的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can remove elements from a window before or after the window function is evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201531Z" creationid="xccui" creationdate="20190626T201531Z">
        <seg>它可以用于在窗口执行计算前或后从窗口中删除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of 11 chapters that hopefully tell a coherent story.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152645Z" creationid="esouser" creationdate="20190603T152631Z">
        <seg>它总共包含了11个章节，我们希望通过这些章节讲述一个完整的故事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of 11 chapters which hopefully tell a coherent story.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T042123Z" creationid="xccui" creationdate="20190225T042123Z">
        <seg>它包含了11个章节，我们希望通过这些章节讲述一个完整的故事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of a subdirectory that holds the data files containing the states of all tasks and a binary metadata file that includes absolute paths to all data files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T165442Z" creationid="xccui" creationdate="20190726T020228Z">
        <seg>它由一个包含了所有任务状态数据文件的子目录和一个包含了全部数据文件绝对路径的二进制元数据文件组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of three operators that are all configured for a task parallelism of two and are connected with local forward connec&lt;t2/&gt;‐&lt;t3/&gt; tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152332Z" creationid="esouser" creationdate="20190514T152332Z">
        <seg>它包含了3个算子，每个算子的任务并发度都为2且通过本地转发方式连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of three operators that are all configured for a task parallelism of two and connected with local forward connec‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062703Z" creationid="xccui" creationdate="20190606T203412Z">
        <seg>它包含了3个算子，每个算子的任务并行度都为2且通过本地转发方式连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It defines the checkAndGetNextWatermark() method, which is called for each event right after extractTimestamp().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054250Z" creationid="xccui" creationdate="20190620T054250Z">
        <seg>该接口中的checkAndGetNextWatermark()方法会在针对每个事件的extractTimestamp()方法后立即调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It defines the map() method that trans‐ forms an input event into exactly one output event:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055329Z" creationid="xccui" creationdate="20190613T050318Z">
        <seg>该接口的map()方法将每个输入事件转换为一个输出事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It determines how much the operator’s process‐ ing effort can be distributed and also how much data it can process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T024356Z" creationid="xccui" creationdate="20190616T051504Z">
        <seg>它决定了算子处理的并行化程度以及能够处理的数据规模。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It discusses Flink’s approach to end-to-end application consistency and how to implement custom connectors to ingest data from and emit data to external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T062703Z" creationid="esouser" creationdate="20190603T162455Z">
        <seg>其中会讨论Flink中解决端到端应用一致性的方案以及如何实现自定义连接器来读写外部系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It discusses distributed architecture, time and state handling in streaming applications, and Flink’s fault toler&lt;t0/&gt;‐&lt;t1/&gt; ance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T165047Z" creationid="xccui" creationdate="20190225T165047Z">
        <seg>其中讨论了分布式架构、流式应用中的时间和状态处理问题、Flink的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It discusses dis‐ tributed architecture, time and state handling in streaming applications, and Flink’s fault-tolerance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031452Z" creationid="esouser" creationdate="20190603T160106Z">
        <seg>其中讨论了分布式架构、流式应用中的时间和状态处理问题以及Flink的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It divides an input stream into two or more output streams of the same type as the input stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053847Z" creationid="xccui" creationdate="20190615T053847Z">
        <seg>它将输入流分割成两条或多条类型和输入流相同的输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It efficiently runs such applica&lt;t0/&gt;‐&lt;t1/&gt; tions at large scale in a fault-tolerant manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T215719Z" creationid="xccui" creationdate="20190225T192215Z">
        <seg>且支持在容错的前提下高效运行大规模的此类应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It efficiently runs such applica‐ tions at large scale in a fault-tolerant manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T064033Z" creationid="esouser" creationdate="20190603T162716Z">
        <seg>并且支持在容错的前提下高效、大规模地运行此类应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It emits one record for each window consisting of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030449Z" creationid="xccui" creationdate="20190625T030449Z">
        <seg>每个窗口都会发出一条记录，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It exposes methods to retrieve the window boundaries, to check whether windows intersect, and to merge overlapping windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041758Z" creationid="xccui" creationdate="20190623T041758Z">
        <seg>它对外提供了获取窗口边界、检查窗口是否相交以及合并重叠窗口等方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It gives access to the timestamp and the key of the current record and to a TimerService.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062552Z" creationid="xccui" creationdate="20190621T054048Z">
        <seg>你可以通过它访问时间戳、当前记录的键值以及TimerService。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has a public constructor without any arguments—a default constructor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T042929Z" creationid="xccui" creationdate="20190617T042929Z">
        <seg>有一个公有的无参默认构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has been a long journey and you have made it to the end of this book!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T041543Z" creationid="xccui" creationdate="20190807T040935Z">
        <seg>漫长的旅途过后，你已到达本书的尾章！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a hybrid of EventTime and ProcessingTime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T050019Z" creationid="xccui" creationdate="20190619T071529Z">
        <seg>IngestionTime是EventTime和ProcessingTime的混合体，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a public class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T042846Z" creationid="xccui" creationdate="20190617T042846Z">
        <seg>是一个公有类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054227Z" creationid="xccui" creationdate="20190612T054227Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to configure an application to retain its last checkpoint when it is canceled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211232Z" creationid="xccui" creationdate="20190609T211232Z">
        <seg>可以通过配置让应用在取消的时候保留最近一次检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to explicitly create local or remote execution environments as fol‐ lows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T052452Z" creationid="xccui" creationdate="20190612T045513Z">
        <seg>同时你也可以像下面这样显式指定本地或远程执行环境：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to nest expressions on mixed types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040441Z" creationid="xccui" creationdate="20190618T050242Z">
        <seg>你还能够在混合类型上嵌套表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to specify a custom trigger and evictor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T053227Z" creationid="xccui" creationdate="20190628T053227Z">
        <seg>同时你也可以自定义触发器或移除器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to start a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T014326Z" creationid="xccui" creationdate="20190719T014326Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to start a new chain with an operator by calling its startNewChain()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203931Z" creationid="xccui" creationdate="20190730T203915Z">
        <seg>你还可以调用startNewChain()方法为算子开启一个新的链接（示例10-2）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is best practice to assign timestamps and generate watermarks as close to the sour‐ ces as possible or even within the SourceFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T054800Z" creationid="xccui" creationdate="20190620T031544Z">
        <seg>最佳做法就是在尽可能靠近数据源的地方，甚至是SourceFunction内部，分配时间戳并生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is called once per task before a transformation method like filter or map is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041141Z" creationid="xccui" creationdate="20190618T061044Z">
        <seg>它在每个任务调用正式的转换方法（如filter或map）前调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is common that companies store the same data in multiple different systems to improve the performance of data accesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T161551Z" creationid="xccui" creationdate="20190604T053931Z">
        <seg>公司为了提高数据访问性能把相同数据存储到多个系统中已然非常普遍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is crucial to understand how to deliver accu‐ rate and deterministic results under such conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014411Z" creationid="xccui" creationdate="20190606T014330Z">
        <seg>了解如何在这种情况下提供精准、确定的结果就变得至关重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is crucial to understand how you can deliver accurate and deterministic results under such conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T201950Z" creationid="xccui" creationdate="20190409T201839Z">
        <seg>了解如何在这种情况下提供精准、确定的结果就变得至关重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is implemented on top of the DataStream API and lets you specify patterns you want to detect in your stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T161958Z" creationid="xingcan" creationdate="20190807T161958Z">
        <seg>它基于DataStream API实现，允许你指定在数据流中期望检测到的模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that a window is created when the first element is assigned to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T024344Z" creationid="xccui" creationdate="20190623T033439Z">
        <seg>请注意，窗口会随着系统首次为其分配元素而创建，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that sometimes you can</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050336Z" creationid="xccui" creationdate="20190416T050038Z">
        <seg>注意，有时候可以通过弱保障实现强语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that sometimes you can get stronger semantics with weaker guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194759Z" creationid="xccui" creationdate="20190606T035348Z">
        <seg>注意，有时候你可以通过弱保障来实现强语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that the rate of processing depends on the rate of arrival; low throughput does not necessarily indicate bad performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052350Z" creationid="xccui" creationdate="20190401T200707Z">
        <seg>但要注意，处理速率取决于数据到来速率，因此吞吐低不一定意味着性能差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to point out that an AsyncFunction instance is sequentially called for each of its input records—a function instance is not called in a multithreaded fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T213112Z" creationid="xccui" creationdate="20190716T213112Z">
        <seg>需要指出的一点是，AsyncFunction实例会按照它输入记录的顺序被串行调用。换句话说，对于函数实例本身的调用不涉及任何多线程操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to understand that the initial design of an applica‐ tion determines if and how it can be modified later on in a savepoint-compatible way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T034441Z" creationid="xccui" creationdate="20190705T024630Z">
        <seg>请谨记，应用的初始设计决定了它日后能否、或以何种方式进行保存点兼容的修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is installed by moving the swift-connector JAR file from the ./opt to the ./lib folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T044209Z" creationid="xccui" creationdate="20190722T044209Z">
        <seg>你可以通过将swift-connector JAR文件从./opt中移动到./lib目录来安装它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not accessible while the application is restarted due to an error, for rescaling the application, or to migrate it to another cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T170238Z" creationid="xccui" creationdate="20190705T170238Z">
        <seg>如果应用正在因为错误而重启、正在进行扩缩容或正在迁移至其他集群，那么可查询式状态将无法访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not part of Flink’s binary distributions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T030854Z" creationid="xccui" creationdate="20190730T030839Z">
        <seg>但该脚本没有包含在Flink的二进制发行版中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to clean up state in a timer callback method, since these methods are not called after a window is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T053131Z" creationid="xccui" creationdate="20190626T194739Z">
        <seg>由于在删除窗口后不会调用计时器回调方法，所以无法在其中清理状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to combine multiple rolling aggregation methods—only a single roll‐ ing aggregate can be computed at a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T062053Z" creationid="xccui" creationdate="20190614T054037Z">
        <seg>注意，你无法将多个滚动聚合方法组合使用，每次只能计算一个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to control the order in which the methods of a CoMapFunction or CoFlatMapFunction are called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T043751Z" creationid="xccui" creationdate="20190615T043633Z">
        <seg>CoMapFunction和CoFlatMapFunction内方法的调用顺序无法控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to customize the configuration of the Flink deployment with the Flink Docker images we used in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190720T042214Z">
        <seg>本节中使用的Flink Docker镜像是无法进行自定义部署配置的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to request key ranges or even run more complex queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T163817Z" creationid="xccui" creationdate="20190705T163422Z">
        <seg>而不支持键值范围或更复杂的条件查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to start an application from a previously taken savepoint if the identi‐ fiers or the maximum parallelism of operators were changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T015500Z" creationid="xccui" creationdate="20190703T014722Z">
        <seg>如果新应用中这两个参数发生了变化，则无法从之前生成的保存点启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to store the commit information in Flink’s application state because it is not persistent and would be reset in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T053441Z" creationid="xccui" creationdate="20190715T053102Z">
        <seg>检查点已提交的信息无法存储在Flink的应用状态中，因为状态本身并不具有持久性，并且会在发生故障时重置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not pos‐ sible to remove individual elements from ListState, but the list can be updated by calling ListState.update(values: java.util.List[T]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T021337Z" creationid="xccui" creationdate="20190630T054329Z">
        <seg>虽然ListState不支持删除单个元素，但你可以调用ListState.update(values: java.util.List[T])来更新整个列表，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not surprising that using a DoubleSer ializer to deserialize the binary data generated by serializing a String with a StringSerializer will fail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T052606Z" creationid="xccui" creationdate="20190705T052606Z">
        <seg>毫无疑问，使用DoubleSerializer去反序列化一个由StringSerializer序列化的二进制String数据一定会失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not uncommon for a streaming job to be continuously running for months, so its operational needs are quite different than those of short-lived batch jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T044306Z" creationid="xccui" creationdate="20190725T043830Z">
        <seg>流式作业长年累月运行的情况并不少见，因此其运维需求和短期批处理作业大不相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is often necessary to fix a bug or to evolve the business logic of a long-running stateful streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T214053Z" creationid="xccui" creationdate="20190704T214053Z">
        <seg>很多时候我们需要对一个长时间运行的状态化流式应用进行Bug修复或业务逻辑调整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to assign operators to different slot-sharing groups and thus assign their tasks to distinct slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T063300Z" creationid="xccui" creationdate="20190723T063300Z">
        <seg>也可以将算子分配到不同的处理槽共享组（slot-sharing group），从而实现将其任务分配到不同处理槽上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is pos‐ sible that a task misses the notification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T202947Z" creationid="xccui" creationdate="20190702T202947Z">
        <seg>所以说任务可能会错过一些通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is required by any non-trivial computa&lt;t0/&gt;‐&lt;t1/&gt; tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T051626Z" creationid="xccui" creationdate="20190414T050639Z">
        <seg>任何稍麻烦点的计算都用得到它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is required by any nontrivial computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181230Z" creationid="xccui" creationdate="20190606T031411Z">
        <seg>任何一个稍复杂的计算都要用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It manages compute resources of a cluster environment—CPU and memory of the cluster’s machines— and provides them to applications that request resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T210529Z" creationid="xccui" creationdate="20190718T210529Z">
        <seg>它负责管理集群环境下的计算资源——集群机器的CPU和内存，并将它们提供给请求资源的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It offers com‐ mon operators to write relational queries including selection, projection, aggrega‐ tions, and joins and further has IDE support for autocompletion and syntax validation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T160918Z" creationid="xingcan" creationdate="20190807T160918Z">
        <seg>它提供了通用的算子来完成关系型查询，包括选择、投影、聚合及连接，此外还支持IDE自动补全和语法验证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It offers different types of state primitives and supports pluggable state backends.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T050343Z" creationid="xccui" creationdate="20190707T050343Z">
        <seg>它提供了多种类型的状态原语，还支持可插拔的状态后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It passes each incoming event to a user-defined mapper</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055148Z" creationid="xccui" creationdate="20190613T042926Z">
        <seg>该转换将每个到来的事件传给一个用户自定义的映射器（user-defined mapper），后者针对每个输入只会返回一个（可能类型发生改变的）输出事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides accurate stream processing with high throughput and low latency at scale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195227Z" creationid="xccui" creationdate="20190328T041119Z">
        <seg>它支持精确的流处理，能同时满足各种规模下对高吞吐和低延迟的要求，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides hooks to register and maintain keyed state and operator state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T063401Z" creationid="xccui" creationdate="20190702T060057Z">
        <seg>它为键值分区状态和算子状态分别提供了用于注册及维护的钩子函数（hook），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides the system with the necessary information it needs to generate serialiazers and comparators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T035256Z" creationid="xccui" creationdate="20190617T050322Z">
        <seg>它为系统生成序列化器和比较器提供了必要的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It reads its configuration from the ./conf/flink-conf.yaml file (see “System Configuration”).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T021549Z" creationid="xccui" creationdate="20190726T021452Z">
        <seg>它会从./conf/flink-conf.yaml文件中（见"系统配置"一节）读取配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It remembers the rules in an operator state in order to apply them to all events of the event stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T203350Z" creationid="xccui" creationdate="20190701T203350Z">
        <seg>它会将规则存为算子状态然后将它们应用到事件流中的全部事件上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It requests processing slots from the ResourceManager to continue executing the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190503T192045Z" creationid="xccui" creationdate="20190503T192045Z">
        <seg>向ResourceManager申请处理槽来继续执行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It requests the storage locations from ZooKeeper to fetch the JobGraph, the JAR file, and the state handles of the last checkpoint of the application from the remote storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073917Z" creationid="xccui" creationdate="20190503T192017Z">
        <seg>向ZooKeeper请求存储位置，以获取JobGraph、JAR文件及应用最新检查点在远程存储的状态句柄。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It restarts the application and resets the state of all its tasks to the last completed checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T190616Z" creationid="xccui" creationdate="20190503T192125Z">
        <seg>重启应用并利用最近一次检查点重置任务状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should be noted an application that relies on idempotent sinks to achieve exactly- once results must guarantee that it overrides previously written results while it replays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T070423Z" creationid="xccui" creationdate="20190708T070423Z">
        <seg>注意，依赖于幂等性数据汇的应用为了实现精确一次的结果，需要保证在重放时可以覆盖之前写出的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should be noted that joining windowed streams can have unex‐ pected semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T204741Z" creationid="xccui" creationdate="20190628T054846Z">
        <seg>注意，对划分窗口后的数据流进行Join可能会产生意料之外的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should only be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045111Z" creationid="xccui" creationdate="20190626T045111Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It starts the same application with the same configuration on the same cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T070408Z" creationid="xccui" creationdate="20190609T211715Z">
        <seg>它会在完全相同的集群上，以完全相同的配置，运行完全相同的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It takes care of updating the routing when a pod is started on a different node in the cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T024052Z" creationid="xccui" creationdate="20190719T024052Z">
        <seg>它在Pod从集群内另一个节点启动时负责更新路由。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then starts to consume and process all data that was processed between the checkpoint and the failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T064213Z" creationid="xccui" creationdate="20190609T051830Z">
        <seg>随后应用就会重新消费并处理那些从之前检查点完成开始，到发生系统故障之间已经处理过的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It uses FileCheckpointCommitter, which we do not discuss here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T063645Z" creationid="xccui" creationdate="20190715T063645Z">
        <seg>它用到的FileCheckpointCommitter我们不在此讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will help you to understand Flink’s internals and to reason about the performance and behavior of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T054615Z" creationid="xccui" creationdate="20190416T054457Z">
        <seg>这将帮助你理解Flink的内部原理，评估流式应用的性能及行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will help you to understand Flink’s internals and to reason about the perfor‐ mance and behavior of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T043728Z" creationid="xccui" creationdate="20190606T140523Z">
        <seg>这将帮助你在理解Flink内部原理的同时，评估流式应用的性能及行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will show that a single Task Manager (Flink’s worker processes) is connected and that a single Task Slot (resource units provided by a Task Manager) is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035532Z" creationid="xccui" creationdate="20190329T035513Z">
        <seg>它表示已经连接上一个Task Manager（Flink的工作进程），且有一个可用的Task Slot（Task Manager所提供的资源单元）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will show that a single TaskManager (Flink’s worker processes) is connected and that a single task slot (resource units provided by a TaskManager) is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123338Z" creationid="xccui" creationdate="20190605T123258Z">
        <seg>它表示已经连接上一个TaskManager（Flink的工作进程），且有一个可用的任务槽（TaskManager所提供的资源单元）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Italic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210800Z" creationid="esouser" creationdate="20190603T210800Z">
        <seg>Italic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterable over all records of a checkpoint, the ID of the checkpoint, and the time‐ stamp of when the checkpoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T063205Z" creationid="xccui" creationdate="20190715T063042Z">
        <seg>该方法接收的参数为针对检查点对应全部记录的Iterable对象，检查点ID，以及检查点的生成时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its built-in operators interpret the Long value as a Unix timestamp with millisecond pre‐ cision—the number of milliseconds since 1970-01-01-00:00:00.000.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T051201Z" creationid="xccui" creationdate="20190606T204948Z">
        <seg>内置算子会将这个Long值解析为毫秒精度的Unix时间戳（自1970-01-01-00:00:00.000以来的毫秒数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its built-in operators interpret the long value as a Unix timestamp with millisecond precision, i.e., the number of milliseconds since 1970-01-01-00:00:00.000.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040728Z" creationid="xccui" creationdate="20190523T040511Z">
        <seg>它的内置算子会将这个long类型值解析为毫秒精度的Unix时间戳（自1970-01-01-00:00:00.000以来的毫秒数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its core is a distributed publish- subscribe messaging system that is widely adopted to ingest and distribute event streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T201654Z" creationid="xccui" creationdate="20190708T201605Z">
        <seg>它的核心是一个分布式的发布/订阅消息系统，该系统被广泛用于获取和分发事件流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its default trigger is the NeverTrigger that, as the name suggests, never fires.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044404Z" creationid="xccui" creationdate="20190626T044404Z">
        <seg>它默认的触发器是NeverTrigger，顾名思义，该触发器永远不会触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its goal is to introduce the funda&lt;t0/&gt;‐&lt;t1/&gt; mental concepts of stream processing and discuss the requirements of stream pro&lt;t2/&gt;‐&lt;t3/&gt; cessing frameworks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T053802Z" creationid="xccui" creationdate="20190329T053732Z">
        <seg>其目的在于介绍流处理的基础概念，讨论流处理框架的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its new parallelism is 16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190728T071925Z" creationid="xccui" creationdate="20190728T071925Z">
        <seg>Its new parallelism is 16.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JMX</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055459Z" creationid="xccui" creationdate="20190804T055459Z">
        <seg>JMX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JVM heap size with the jobmanager.heap.size configuration key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T063101Z" creationid="xccui" creationdate="20190723T063101Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Java and Classloading</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025533Z" creationid="xccui" creationdate="20190225T025533Z">
        <seg>Java和类加载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Java and Scala tuples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065007Z" creationid="xccui" creationdate="20190616T065007Z">
        <seg>Java和Scala元组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Job has been submitted with JobID cfde9dbe315ce162444c475a08cf93d9</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040020Z" creationid="xccui" creationdate="20190329T040020Z">
        <seg>Job has been submitted with JobID cfde9dbe315ce162444c475a08cf93d9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Job recovery from a master failure requires a highly available setup as dis‐ cussed later in this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T162414Z" creationid="xccui" creationdate="20190717T162414Z">
        <seg>从主进程中的故障中恢复作业需要进行高可用设置，我们会在本章后面讨论它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Job:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043720Z" creationid="xccui" creationdate="20190804T043720Z">
        <seg>作业：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JobManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043024Z" creationid="xccui" creationdate="20190804T043024Z">
        <seg>JobManager</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JobManager and job</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043049Z" creationid="xccui" creationdate="20190804T043049Z">
        <seg>JobManager及作业</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JobManager failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T222247Z" creationid="xccui" creationdate="20190428T222247Z">
        <seg>JobManager故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JobManager initiates a checkpoint by sending a message to all sources</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T065052Z" creationid="xccui" creationdate="20190608T063329Z">
        <seg>JobManager通过向所有数据源发送消息来启动检查点生成流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JobManager:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043709Z" creationid="xccui" creationdate="20190804T043709Z">
        <seg>JobManager：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joining Streams on Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151633Z" creationid="xccui" creationdate="20190225T023252Z">
        <seg>基于时间的双流Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joining Streams on Time | 145</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042118Z" creationid="xccui" creationdate="20190629T042118Z">
        <seg>基于时间的双流Join | 145</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joining two windowed streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T035947Z" creationid="xccui" creationdate="20190628T035947Z">
        <seg>对划分窗口后的两条流进行Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joint processing of two streams usually requires that events of both streams are deter‐ ministically routed based on some condition to be processed by the same parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T062331Z" creationid="xccui" creationdate="20190615T044638Z">
        <seg>对双流进行Join的场景通常需要对两条流中的事件基于某些条件进行确定性路由，以便它们能够发往算子的同一并行实例上处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just about every nontrivial streaming application is stateful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T050221Z" creationid="xccui" creationdate="20190707T050221Z">
        <seg>几乎所有复杂一点的流式应用都是状态化的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like in many other distributed systems, the performance of a Flink application depends a lot on how the tasks are scheduled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T160751Z" creationid="xccui" creationdate="20190730T160751Z">
        <seg>和很多其他分布式系统一样，Flink应用的性能在很大程度上取决于任务的调度方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like many DataStream applications, the source, sink, and opera‐ tors of the program are assembled in the main() method of the AverageSensorRead ings class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T092019Z" creationid="xccui" creationdate="20190611T042751Z">
        <seg>和大多数DataStream应用一样，该程序的数据源、数据汇以及其他算子都是在AverageSensorReadings类的main()方法中进行组装的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like the rich variants of processing functions,6 subclasses of RichSourceFunction and RichParallelSourceFunction can override the open() and close() methods and access a RuntimeContext that provides the number of parallel task instances and the index of the current instance, among other things.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T150837Z" creationid="xccui" creationdate="20190712T150653Z">
        <seg>就像一系列处理函数的变种一样，RichSourceFunction和RichParallelSourceFunction允许它们的子类覆盖open()和close()方法，并提供RuntimeContext用以访问当前并行任务实例的数量以及当前实例的索引号等信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEY key, Context ctx, Iterable&lt;IN&gt; vals, Collector&lt;OUT&gt; out) throws Exception;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010520Z" creationid="xccui" creationdate="20190624T010520Z">
        <seg>KEY key, Context ctx, Iterable&lt;IN&gt; vals, Collector&lt;OUT&gt; out) throws Exception;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kafka 0.11 introduced support for transactional writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T161808Z" creationid="xingcan" creationdate="20190709T161808Z">
        <seg>Kafka从0.11版本开始支持事务性写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kafka guards against this by rejecting and closing transactions after a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T222531Z" creationid="xccui" creationdate="20190709T213045Z">
        <seg>Kafka通过在一定时间间隔后（可以通过transaction.timeout.ms属性进行配置）拒绝并关闭事务来防止这种情况发生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kafka messages are stored as raw byte messages and need to be deserialized into Java or Scala objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T213417Z" creationid="xccui" creationdate="20190708T213417Z">
        <seg>Kafka中的消息是以原始字节的方式存储，因此需要被反序列化成Java或Scala对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kafka organizes event streams as so-called topics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T202807Z" creationid="xccui" creationdate="20190708T201834Z">
        <seg>Kafka将事件流组织为不同的主题（topic）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kafka producer implements the TwoPhaseCommitSinkFunction interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T061007Z" creationid="xccui" creationdate="20190716T061007Z">
        <seg>举例而言，Flink的Kafka生产者实现就继承了TwoPhaseCommitSinkFunction类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keep in mind that some resource managers, such as YARN, will immediately kill a container if it exceeds its memory budget.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T151914Z" creationid="xccui" creationdate="20190724T042209Z">
        <seg>最后请谨记，某些资源管理器（如YARN）会在容器超过内存限制时立即将其终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Selectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145630Z" creationid="esouser" creationdate="20190603T145630Z">
        <seg>键值选择器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key groups are discussed in Chapter 3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T054516Z" creationid="xccui" creationdate="20190706T054516Z">
        <seg>键值组的相关内容已经在第3章讨论过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keyed State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061023Z" creationid="xccui" creationdate="20190418T035556Z">
        <seg>键值分区状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keyed state can only be used by functions that are applied on a KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T020202Z" creationid="xccui" creationdate="20190630T040154Z">
        <seg>键值分区状态只能由作用在KeyedStream上面的函数使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keyed state is maintained and accessed with respect to a key defined in the records of an operator’s input stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061049Z" creationid="xccui" creationdate="20190607T185829Z">
        <seg>键值分区状态会按照算子输入记录所定义的键值来进行维护或访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedProcessFunction holds the timestamps of all timers in a priority queue on the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T064250Z">
        <seg>默认情况下，KeyedProcessFunction会将全部计时器的时间戳放到堆中的一个优先队列里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedSerializationSchema also exposes more Kafka-specific functionality, such as overriding the target topic to write to multiple topics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T153758Z" creationid="xingcan" creationdate="20190709T153741Z">
        <seg>此外，KeyedSerializationSchema还支持其他一些Kafka特定的功能，例如覆盖目标主题配置、将记录写入多个主题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStateFunction to the value of each key in the keyed state ref‐ erenced by the StateDescriptor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T055151Z" creationid="xccui" creationdate="20190702T054650Z">
        <seg>可以对StateDescriptor所引用的键值分区状态内每个键值所对应的状态值应用KeyedStateFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStateFunction)  to   apply  a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054819Z" creationid="xccui" creationdate="20190702T054819Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStream Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022735Z" creationid="xccui" creationdate="20190225T022735Z">
        <seg>基于KeyedStream的转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStream transformations are transformations that are applied to events in the context of a key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T054651Z" creationid="xccui" creationdate="20190613T024408Z">
        <seg>作用于同一键值上下文内事件的KeyedStream转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStream, which is a DataStream that has been logically partitioned into disjoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044002Z" creationid="xccui" creationdate="20190614T044002Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keytabs are the preferred approach because tokens expire after some time, which can cause problems for long-running stream processing appli‐ cations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T022943Z" creationid="xccui" creationdate="20190725T022943Z">
        <seg>其中Keytabs应该是首选方法，因为令牌会在一段时间后过期，这可能会为长时间运行的流处理应用带来问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kubernetes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040325Z" creationid="xccui" creationdate="20190418T040325Z">
        <seg>Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kubernetes also supports pods consisting of multiple tightly linked containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T023033Z" creationid="xccui" creationdate="20190719T023033Z">
        <seg>Kubernetes还支持由多个紧密相连的容器组成的Pod。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kubernetes can also take care of opening net‐ work ports for internal and external communication and can provide services for process discovery and load balancing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T020212Z" creationid="xccui" creationdate="20190719T020212Z">
        <seg>Kubernetes还负责为内外网络通信打开端口，并可以提供进程发现及负载均衡服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kubernetes is an open source platform that enables users to deploy and scale contain‐ erized applications in a distributed environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T015346Z" creationid="xccui" creationdate="20190719T015346Z">
        <seg>Kubernetes是一个开源平台，它允许用户在分布式环境下部署容器化应用，并对其进行扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kubernetes is designed for cluster operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T023117Z" creationid="xccui" creationdate="20190719T024158Z">
        <seg>虽然Kubernetes是为操纵集群而设计的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kubernetes may run a pod anywhere on its cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T023545Z" creationid="xccui" creationdate="20190719T023545Z">
        <seg>Kubernetes可能会在其集群的任意位置运行Pod。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kubernetes runs on-premise, in cloud environ‐ ments, or on hybrid infrastructure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T020335Z" creationid="xccui" creationdate="20190719T020335Z">
        <seg>它能够运行在内部部署（on-premise）、云环境或混合基础架构之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kubernetes will run the requested number of containers anywhere on its resources and restart them in the case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T015800Z" creationid="xccui" creationdate="20190719T015800Z">
        <seg>Kubernetes会利用任意位置的资源运行所需数量的容器，并在出现故障时重启它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kuber‐ netes ensures the requested number of pods is continuously running, and auto‐ matically restarts failed pods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T023447Z" creationid="xccui" creationdate="20190719T023447Z">
        <seg>Kubernetes能够确保所需数目的Pod可以持续运行，并在故障时自动重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kuber‐ netes provides services to overcome the issue.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T023820Z" creationid="xccui" creationdate="20190719T023820Z">
        <seg>为此，Kubernetes提供了Service。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LOG.info("Converting value {} to string.", value)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034121Z" creationid="xccui" creationdate="20190807T034121Z">
        <seg>LOG.info("Converting value {} to string.", value)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lambda Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022924Z" creationid="xccui" creationdate="20190225T022924Z">
        <seg>Lambda函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lambda functions are avail‐ able for Scala and Java and offer a simple and concise way to implement application logic when no advanced operations such as accessing state and configuration are required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041004Z" creationid="xccui" creationdate="20190618T055802Z">
        <seg>Lambda函数可用于Scala或Java，它在不需要进行高级操作（如访问状态或配置）的情况下提供了一种简洁明了的方式来实现应用逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last but not least, Flink is also a full-fledged batch processor.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195932Z" creationid="xccui" creationdate="20190605T121712Z">
        <seg>最后要强调的一点：Flink同时也是一个成熟的批处理引擎。1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last but not least, Flink is also a full-fledged batch processor&lt;t0/&gt;1&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052128Z" creationid="xccui" creationdate="20190328T052128Z">
        <seg>最后要强调的一点，Flink同时也是一个成熟的批处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Late events arrive at an operator after a computation to which they should have con‐ tributed was completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T160649Z" creationid="xingcan" creationdate="20190628T160255Z">
        <seg>迟到事件抵达算子后，它们本应参与贡献的计算可能已经执行完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Late events can also be redirected into another DataStream using the side-output fea‐ ture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154745Z" creationid="xingcan" creationdate="20190628T154212Z">
        <seg>我们还能利用副输出将迟到事件重定向到另一个DataStream，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Late events can be redirected into a separate stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T205223Z" creationid="xingcan" creationdate="20190628T152958Z">
        <seg>将迟到事件重定向到单独的数据流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Late events can be simply dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T205220Z" creationid="xingcan" creationdate="20190628T152931Z">
        <seg>简单地将其丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151529Z" creationid="xccui" creationdate="20190401T151529Z">
        <seg>延迟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency Versus Throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234912Z" creationid="xccui" creationdate="20190605T234912Z">
        <seg>延迟 vs. 吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency and Throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143930Z" creationid="esouser" creationdate="20190603T143930Z">
        <seg>延迟和吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency and throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015312Z" creationid="xccui" creationdate="20190225T015312Z">
        <seg>延迟和吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency indicates how long it takes for an event to be processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151602Z" creationid="xccui" creationdate="20190401T151602Z">
        <seg>延迟表示处理一个事件所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency is probably one of the first metrics you want to monitor to assess the perfor‐ mance characteristics of your streaming job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T050020Z" creationid="xccui" creationdate="20190806T050020Z">
        <seg>延迟可能是你用于评估流式作业性能的首要指标之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency markers use the same dataflow channels and queues as normal stream records, thus their tracked latency reflects the time records wait to be processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T062630Z" creationid="xccui" creationdate="20190806T062630Z">
        <seg>延迟标记和普通流记录共享Dataflow通道和队列，因此它们所追踪的延迟能够反映出记录等待处理的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency vs. throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T202243Z" creationid="xccui" creationdate="20190402T202238Z">
        <seg>延迟 vs. 吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Layered APIs with varying tradeoffs for expressiveness and ease of use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195445Z" creationid="xccui" creationdate="20190605T055937Z">
        <seg>层次化的API在表达能力和易用性方面各有权衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let us revisit the coffee shop example to clarify how latency and throughput affect each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210220Z" creationid="xccui" creationdate="20190402T204057Z">
        <seg>我们再通过咖啡店的示例来解释一下延迟和吞吐如何相互影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s assume you want to compute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T153428Z" creationid="xccui" creationdate="20190606T014646Z">
        <seg>假如你想持续计算结果，比如每分钟计算一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s assume you want to compute results continuously, for example every one minute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T144504Z" creationid="xccui" creationdate="20190409T211020Z">
        <seg>假设你想持续计算结果，比如每分钟计算一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s look at each type category.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070104Z" creationid="xccui" creationdate="20190616T070104Z">
        <seg>我们分别来看一下每种类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s now explain in more detail how a task emits watermarks and updates its event- time clock when receiving a new watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T053438Z" creationid="xccui" creationdate="20190607T014310Z">
        <seg>接下来我们详细解释一下任务在收到一个新的水位线之后，将如何发送水位线和更新其内部事件时间时钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s revisit the coffee shop example to clarify how latency and throughput affect each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053948Z" creationid="xccui" creationdate="20190605T235018Z">
        <seg>我们再通过咖啡店的例子来解释一下延迟和吞吐如何相互影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s start with a simple example to get a first impression of what it is like to write streaming applications with the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T040743Z" creationid="xccui" creationdate="20190612T035028Z">
        <seg>让我们从一个简单的示例开始，体验一下使用DataStream API编写流式应用的感觉。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s summarize the requirements for the external sink system:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T213128Z" creationid="xccui" creationdate="20190715T213128Z">
        <seg>下面我们来总结一下对于外部数据汇系统的要求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Library style</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143638Z" creationid="xccui" creationdate="20190606T143638Z">
        <seg>库模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Library style&lt;t0/&gt;: In this mode, the Flink application is bundled in an application-specific container image, such as a Docker image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030252Z" creationid="xccui" creationdate="20190423T030236Z">
        <seg>库模式：在该模式下，Flink应用会绑定到一个应用相关的容器映像中（如Docker映像）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the filesystem source connector, Flink’s StreamingFileSink connector is con‐ tained in the flink-streaming-java module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T204722Z" creationid="xccui" creationdate="20190710T204722Z">
        <seg>和文件系统数据源连接器类似，Flink的StreamingFileSink连接器也是包含在flink-streaming-java模块中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List of available metrics reporters</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055454Z" creationid="xccui" creationdate="20190804T055454Z">
        <seg>指标汇报器列表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060531Z" creationid="xccui" creationdate="20190607T184048Z">
        <seg>列表状态（list state）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List.fill(10 - mod)(new java.lang.Long(div))).asJava</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062853Z" creationid="xccui" creationdate="20190701T062853Z">
        <seg>List.fill(10 - mod)(new java.lang.Long(div))).asJava</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ListCheckpointed Interface Uses Java Serialization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063556Z" creationid="xccui" creationdate="20190701T062935Z">
        <seg>ListCheckpointed接口使用了Java序列化机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ListState[T] holds a list of elements of type T. New elements can be appended to the list by calling ListState.add(value: T) or ListState.addAll(values: java.util.List[T]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T054342Z" creationid="xccui" creationdate="20190630T053549Z">
        <seg>ListState[T]用于保存类型为T的元素列表。你可以调用ListState.add(value: T)或ListState.addAll(values: java.util.List[T])将新元素附加到列表中,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ListState[X] has an advantage over Value State[List[X]] if elements are frequently appended to the list and the elements of the list are less frequently accessed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T034541Z" creationid="xccui" creationdate="20190704T034541Z">
        <seg>如果经常要在列表后面添加元素且列表元素的访问频率很低，那么ListState[X]会比ValueState[List[X]]更有优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Listing running applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T031832Z" creationid="xccui" creationdate="20190726T031832Z">
        <seg>列出正在运行的应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local filesystem</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T041001Z" creationid="xccui" creationdate="20190722T041001Z">
        <seg>本地文件系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local filesystems are referenced by the file:// URI scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T042623Z" creationid="xccui" creationdate="20190722T041900Z">
        <seg>本地文件系统的URI协议是file://。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154711Z" creationid="xingcan" creationdate="20190801T154711Z">
        <seg>本地恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local recovery can be enabled and configured for a cluster in the flink-conf.yaml file or per application by including the following in the state backend configuration:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T022037Z" creationid="xccui" creationdate="20190802T022037Z">
        <seg>你可以通过在flink-conf.yaml文件中加入以下内容为集群开启和配置本地恢复，也可以在状态后端配置中加入以下内容为每个应用单独开启和配置本地恢复：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local recovery is implemented so that the state copy in the remote system is the source of truth.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T163705Z" creationid="xingcan" creationdate="20190801T163510Z">
        <seg>本地恢复的实现使得远程系统中的状态副本成为用于参照的真实数据（the source of truth）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local recovery only affects keyed state, which is always partitioned and usually accounts for most of the state size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T025538Z" creationid="xccui" creationdate="20190802T025254Z">
        <seg>本地恢复只会影响键值分区状态，此类状态总是会被分区且通常在状态中占据的比例非常高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local state access provides very good performance compared to reading and writing queries against remote datastores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T034032Z" creationid="xccui" creationdate="20190604T023347Z">
        <seg>访问本地状态的性能要比读写远程数据存储系统更好；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local state accesses, i.e., reading from or writing to memory or local disk, provide very good performance compared to read and write queries against remote data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190312T212225Z" creationid="xccui" creationdate="20190308T074008Z">
        <seg>只需要访问本地状态。和查询远程数据存储系统相比，读写本地内存或磁盘性能会更好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logging is another essential tool for debugging and understanding the behavior of your applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T033020Z" creationid="xccui" creationdate="20190807T033020Z">
        <seg>日志是你调试和理解应用行为的另一个重要工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking again at the HighTempCounter function in Example 7-4, we see that each par‐ allel instance of the operator exposes its state as a list with a single entry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061533Z" creationid="xccui" creationdate="20190701T061533Z">
        <seg>回顾一下示例7-4中的HighTempCounter函数，每个算子并行实例所提供的状态列表都只包含了一个项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking at the example, you might wonder why operator state is handled as a list of state objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T045729Z" creationid="xccui" creationdate="20190701T054512Z">
        <seg>看完上述例子，你可能会好奇为什么要将算子状态作为状态对象列表来处理？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Low latency is a key characteristic of stream processing and it enables what we call &lt;t2/&gt;real-time&lt;t3/&gt; applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T192514Z" creationid="xccui" creationdate="20190401T191707Z">
        <seg>低延迟是流处理的一个关键特性，它滋生了所谓的实时应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Low latency is a key characteristic of stream processing and it enables what we call real-time applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051538Z" creationid="xccui" creationdate="20190605T234240Z">
        <seg>低延迟是流处理的一个关键特性，它滋生出了所谓的实时应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mailing lists</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040413Z" creationid="xccui" creationdate="20190807T040413Z">
        <seg>邮件列表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Main Memory and Network Buffers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025555Z" creationid="xccui" creationdate="20190225T025555Z">
        <seg>内存和网络缓冲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure that “Import project from external model” and “Maven” are selected and click Next.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041318Z" creationid="xccui" creationdate="20190611T041318Z">
        <seg>确保勾上"Import project from external model"以及"Maven"两个选项，然后点击Next。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure to disable this behavior or configure a differ‐ ent directory if you plan to run continuous Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043250Z" creationid="xccui" creationdate="20190724T043250Z">
        <seg>如果你的应用需要长时间地持续运行，请确保上述行为已被禁用或选择一个其他目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Manager is passed to the containers via the JOB_MANAGER_RPC_ADDRESS variable,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T034033Z" creationid="xccui" creationdate="20190718T033935Z">
        <seg>Docker内部JobManager的主机名会通过JOB_MANAGER_RPC_ADDRESS变量传给容器，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Managing Applications with the Command-Line Client</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025929Z" creationid="xccui" creationdate="20190225T025929Z">
        <seg>通过命令行客户端管理应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Managing Applications with the REST API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025932Z" creationid="xccui" creationdate="20190225T025932Z">
        <seg>通过REST API管理应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Managing and monitoring a Flink cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T043033Z" creationid="xccui" creationdate="20190729T043033Z">
        <seg>管理和监控Flink集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Managing and montioring Flink applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045225Z" creationid="xccui" creationdate="20190729T045225Z">
        <seg>管理和监控Flink应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many applications ingest multiple streams that need to be jointly processed or split a stream in order to apply different logic to different substreams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T060719Z" creationid="xccui" creationdate="20190614T063301Z">
        <seg>很多应用需要将多条输入流联合起来处理，或将一条流分割成多条子流以应用不同逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many changes will not be possible if the original version was not designed with updates in mind.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T025211Z" creationid="xccui" creationdate="20190705T025211Z">
        <seg>如果原始版本在设计时没有考虑到日后的更新，则很难对其进行较大改动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators continuously read and update some kind of state such as records collected in a window, reading positions of an input source, or custom, application-specific operator states like machine learning models.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055640Z" creationid="xccui" creationdate="20190607T052753Z">
        <seg>很多算子都会不断地读取并更新某些状态，例如：窗口内收集的记录，输入源的读取位置或是一些定制的，诸如机器学习模型之类的特定应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many people show up at the same time and have to wait in line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053206Z" creationid="xccui" creationdate="20190605T234727Z">
        <seg>店内突然间涌入大量顾客，点单的人排起了长队。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many people show up at the same time and you have to wait in line to place your order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T211059Z" creationid="xccui" creationdate="20190401T211059Z">
        <seg>突然间涌入大量顾客，你必须排队点单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many problems originate from incompatibili‐ ties among different versions of the same library that are pulled in from different connectors or directly from the user application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041008Z" creationid="xccui" creationdate="20190619T041008Z">
        <seg>连接器或用户程序使用的类库一多就容易出现使用了同一库的多个版本，很多问题都是源于这些版本之间相互不兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many stream processing applications need to share their results with other applica‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T141808Z" creationid="xccui" creationdate="20190705T141808Z">
        <seg>很多处理应用需要将它们的结果与其他应用分享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T044721Z" creationid="xccui" creationdate="20190613T044721Z">
        <seg>Map</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061452Z" creationid="xccui" creationdate="20190607T220057Z">
        <seg>映射状态（map state）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MapFunction in  the  following,  are  defined  as  classes  that  implement  a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053404Z" creationid="xccui" creationdate="20190613T020742Z">
        <seg>函数可以通过实现某个特定转换的接口类来定义，例如下面的MapFunction：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MapState of RocksDBStateBackend</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T033040Z" creationid="xccui" creationdate="20190704T033040Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MapState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221602Z" creationid="xccui" creationdate="20190703T221602Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MapState[K, V] holds a map of keys and values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T055646Z" creationid="xccui" creationdate="20190630T055646Z">
        <seg>MapState[K, V]用于保存一组键到值的映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Master and worker containers are started from the same Docker image with different parameters as shown in Example 9-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190718T032331Z">
        <seg>如示例9-1所示，主容器和工作容器可以从同一个Docker镜像启动，只不过二者的参数不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Meetups and conferences</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040556Z" creationid="xccui" creationdate="20190807T040556Z">
        <seg>聚会及会议</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Members of the Flink community configure and build Docker images for Apache Flink and upload them to Docker Hub, a public repository for Docker images.2 The repository hosts Docker images for the most recent Flink versions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T140502Z" creationid="xccui" creationdate="20190718T021136Z">
        <seg>Flink社区成员已经为Apache Flink配置和构建了Docker镜像，并把它们上传到了Docker Hub（一个用于存放Docker镜像的公共仓库）上面。仓库内包含了Flink最近几个版本的Docker镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MemoryStateBackend does not require any parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022322Z" creationid="xccui" creationdate="20190801T022322Z">
        <seg>MemoryStateBackend无需任何参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MemoryStateBackend stores state as regular objects on the heap of the TaskMan‐ ager JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T025915Z" creationid="xccui" creationdate="20190703T221848Z">
        <seg>MemoryStateBackend将状态以常规对象的方式存储在TaskManager进程的JVM堆里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Merging of windows is discussed in more detail in the next section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T050333Z" creationid="xccui" creationdate="20190626T050333Z">
        <seg>有关窗口合并的内容会在下一节详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message queues and event logs, such as Apache Kafka, Kinesis, or RabbitMQ, are common sources to ingest data streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170739Z" creationid="xccui" creationdate="20190708T170739Z">
        <seg>消息队列（例如Apache Kafka、Kinesis或RabbitMQ）是一类常见的数据流消息来源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Meter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033705Z" creationid="xccui" creationdate="20190803T033705Z">
        <seg>Meter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metric System</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030134Z" creationid="xccui" creationdate="20190225T030134Z">
        <seg>指标系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metric groups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T023556Z" creationid="xccui" creationdate="20190803T023556Z">
        <seg>指标组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metric reporters will turn the Gauge value into a String, so make sure you provide a meaningful toString() implementation if it is not provided by the type you use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T032456Z" creationid="xccui" creationdate="20190803T032156Z">
        <seg>指标报告器会将Gauge值转换为String，因此如果你用到的类型没有提供有意义的toString()实现，请将它加上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MetricGroup, as shown in Example 10-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T044731Z" creationid="xccui" creationdate="20190804T044731Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metrics Reported as Strings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T032202Z" creationid="xccui" creationdate="20190803T032122Z">
        <seg>指标是作为字符串对外报告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metrics are gathered per operator, TaskManager, or JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T152749Z" creationid="xingcan" creationdate="20190802T152749Z">
        <seg>指标的收集时按照每个算子、每个TaskManager或JobManager来进行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metrics are ref‐ erenced by a unique identifier that contains up to three parts:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T033550Z" creationid="xccui" creationdate="20190803T220222Z">
        <seg>用于引用指标的唯一标识最多包含三个部分：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metrics can be scoped to the JobManager, a TaskManager, a job, an operator, or a task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T034421Z" creationid="xccui" creationdate="20190804T034421Z">
        <seg>它的范围可以是JobManager、某个TaskManager、某个作业、某个算子或任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metrics.reporter.my_jmx_reporter.class: org.apache.flink.metrics.jmx.JMXReporter metrics.reporter.my_jmx_reporter.port: 9020-9040</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055908Z" creationid="xccui" creationdate="20190804T055908Z">
        <seg>Metrics.reporter.my_jmx_reporter.class: org.apache.flink.metrics.jmx.JMXReporter metrics.reporter.my_jmx_reporter.port: 9020-9040</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metzger, Sebastian Schelter, Shaoxuan Wang, Shuyi Chen, Stefan Richter, Stephan Ewen, Theodore Vasiloudis, Thomas Weise, Till Rohrmann, Timo Walther, Tzu-Li (Gordon) Tai, Ufuk Celebi, Xiaogang Shi, Xiaowei Jiang, Xingcan Cui.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T025914Z" creationid="xccui" creationdate="20190605T132801Z">
        <seg>Metzger、Sebastian Schelter、Shaoxuan Wang（王绍翾）、Shuyi Chen（陈舒毅）、Stefan Richter、Stephan Ewen、Theodore Vasiloudis、Thomas Weise、 Till Rohrmann、Timo Walther、Tzu-Li (Gordon) Tai（戴资力）、Ufuk Celebi、Xiaogang Shi（施晓罡）、Xiaowei Jiang（蒋晓伟）、Xingcan Cui（崔星灿）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Microservices and all required software and services are typically bundled and deployed in independent containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172622Z" creationid="xccui" creationdate="20190228T172041Z">
        <seg>通常，微服务连同必须的软件及服务会打包部署到独立的容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Microservices are designed as small, self-contained, and independent applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172159Z" creationid="xccui" creationdate="20190227T042155Z">
        <seg>微服务由很多微型、完备、独立的应用组成，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Microser‐ vices and all the required software and services are typically bundled and deployed in independent containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T024114Z" creationid="esouser" creationdate="20190603T201022Z">
        <seg>通常情况下，微服务会和所有必须的软件及服务一起打包部署到独立的容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Millisecond latencies while processing millions of events per second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195359Z" creationid="xccui" creationdate="20190605T055840Z">
        <seg>在每秒处理数百万条事件的同时保持毫秒级延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Minikube needs to be running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T045240Z" creationid="xccui" creationdate="20190730T045240Z">
        <seg>但前提是Minikube需要处在运行状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modern stream processors, like Apache Flink, can offer latencies as low as a few milliseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T193037Z" creationid="xccui" creationdate="20190401T192945Z">
        <seg>像Apache Flink这样的现代流处理引擎可以提供低至几毫秒的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modified applica‐ tions can also be used to run A/B tests or what-if scenarios with different busi‐ ness logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212424Z" creationid="xccui" creationdate="20190609T212336Z">
        <seg>应用修改还可用于A/B测试或需要不同业务逻辑的假想场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying the State of an Operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043955Z" creationid="xccui" creationdate="20190225T024924Z">
        <seg>修改算子的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying the state of an existing operator by changing the state primitive or data type of the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035834Z" creationid="xccui" creationdate="20190705T035834Z">
        <seg>通过改变状态原语或数据类型来修改已有算子的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring Flink Clusters and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030117Z" creationid="xccui" creationdate="20190225T030117Z">
        <seg>监控Flink集群及应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring Flink Clusters and Applications | 271</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040302Z" creationid="xccui" creationdate="20190807T040302Z">
        <seg>监控Flink集群及应用 | 271</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring Flink Clusters and Applications | 273</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040315Z" creationid="xccui" creationdate="20190807T040315Z">
        <seg>监控Flink集群及应用 | 273</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring Latency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030141Z" creationid="xccui" creationdate="20190225T030141Z">
        <seg>延迟监控</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring ingested files by tracking the modification timestamp also has implications if you read from file stores with eventually consistent list operations, such as S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T201522Z" creationid="xccui" creationdate="20190710T200848Z">
        <seg>如果要从列表操作具有最终一致性的文件存储中（如S3）读取数据，则通过跟踪修改时间来监视要读取的文件同样会有影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring the quality of cellphone networks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045418Z" creationid="xccui" creationdate="20190605T045418Z">
        <seg>手机网络质量监控</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring the quality of cellphone networks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033619Z" creationid="xccui" creationdate="20190319T033357Z">
        <seg>手机网络质量监控，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring your streaming job is essential to ensure its healthy operation and to detect potential symptoms of misconfigurations, underprovisioning, or unexpected behavior early.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T030002Z" creationid="xccui" creationdate="20190802T030002Z">
        <seg>监控流式作业对于保证它的健康运行和尽早发现由于配置错误、资源不足或其他异常行为所导致的潜在症状十分关键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More complex applications are built by connecting several microservices with each other that only communicate over stand&lt;t2/&gt;‐&lt;t3/&gt; ardized interfaces such as RESTful HTTP connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190227T233910Z" creationid="xccui" creationdate="20190227T233910Z">
        <seg>通过将多个微服务相互连接可以构建出更加复杂的应用，而微服务之间只通过标准化接口（如RESTful HTTP连接）进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More complex applica‐ tions are built by connecting several microservices with each other that only commu‐ nicate over standardized interfaces such as RESTful HTTP connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151017Z" creationid="esouser" creationdate="20190603T200705Z">
        <seg>通过将多个微服务相互连接可以构建出更加复杂的应用，而微服务间只会通过标准化接口（如RESTful HTTP连接）进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover the state size typically increases because the application needs to buffer more data until it can perform a computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T034347Z" creationid="xccui" creationdate="20190621T034203Z">
        <seg>此外，由于应用需要在计算之前缓冲更多的数据，所以通常会导致状态大小也随之增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T153744Z" creationid="xingcan" creationdate="20190709T153744Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover,  each  parallel instance chunks its output into multiple part files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T015102Z" creationid="xccui" creationdate="20190710T213843Z">
        <seg>每个并行实例会把自己的输出写到多个分块文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover,  you  can  enable  asynchronous  checkpointing (state.backend.async) and incremental checkpointing (state.backend.incremen tal).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T044427Z" creationid="xccui" creationdate="20190724T044427Z">
        <seg>此外，还可以启用异步检查点（state.backend.async）和增量检查点（state.backend.incremental）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, AsyncFunction properly works with event-time pro‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T195828Z" creationid="xccui" creationdate="20190716T194643Z">
        <seg>此外，AsyncFunction可以在事件时间处理模式下正确地工作，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, Flink provides Maven archetypes to bootstrap new Flink Maven projects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T090928Z" creationid="xccui" creationdate="20190611T020723Z">
        <seg>此外，Flink还提供了用于创建Flink Maven新项目的Maven模板（maven archetypes）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, FlinkKafkaProducer pro‐ vides a constructor with a Semantic parameter that controls the consistency guarantees provided by the sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T164606Z" creationid="xingcan" creationdate="20190709T164606Z">
        <seg>此外，FlinkKafkaProducer还提供了一个带有Semantic参数的构造函数，用来控制数据汇提供的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, Kryo does not provide a good migration path to evolve data types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T025012Z" creationid="xccui" creationdate="20190616T070032Z">
        <seg>此外，对于数据类型发生改变的情况，Kryo没有提供很好的迁移路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, a 2PC sink continuously writes records to the sink system compared to the spiky writing pattern of a WAL sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T165654Z" creationid="xccui" creationdate="20190708T165646Z">
        <seg>此外，2PC数据汇可以持续平稳地将记录写入接收系统，而不会像WAL数据汇那样经历周期性的"波峰式"写入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, checkpoints are automatically deleted when an application is canceled, unless the application explicitly enabled checkpoint retention.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T165355Z" creationid="xccui" creationdate="20190726T014727Z">
        <seg>此外，除非应用显式指定要保留检查点，否则它们会在应用取消时自动被删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, even though events were not lost, they could be processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051608Z" creationid="xccui" creationdate="20190605T051608Z">
        <seg>此外，虽然数据在出错时不会丢失，但可能会被处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, even though events would not be lost in case of a failure, they could be processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T042844Z" creationid="xccui" creationdate="20190322T042844Z">
        <seg>此外，虽然数据在出错时不会丢失，但可能会被处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, exactly-once state consistency and the ability to scale an application are fundamental requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T064049Z" creationid="xccui" creationdate="20190314T062307Z">
        <seg>此外，作为基本需求，系统要提供精确一次的状态一致性保障和应用扩容能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, in some cases Flink might not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061122Z" creationid="xccui" creationdate="20190617T061122Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, in the case of a failure, a stateless operator can be simply restarted and continue processing from where it left off.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T055150Z" creationid="xccui" creationdate="20190405T040033Z">
        <seg>此外，如果发生故障，无状态的算子可以很容易地重启，并从中断处继续工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it is an effective mecha&lt;t0/&gt;‐&lt;t1/&gt; nism to distribute network resources in case of skewed data distributions because credit is granted depending on the size of the senders’ backlog.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151301Z" creationid="esouser" creationdate="20190514T151123Z">
        <seg>此外，授予信用度是依据发送端的积压量来完成，因此该机制还会在出现数据倾斜时有效地分配网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it is an effective mechanism to distribute network resources in the case of skewed data distributions because credit is granted based on the size of the senders’ backlog.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T200120Z" creationid="xccui" creationdate="20190606T203116Z">
        <seg>此外，信用值的授予是根据各发送端的数据积压量来完成的，因此该机制还能在出现数据倾斜（data skew）时有效地分配网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it is common to organize records into so-called buckets, so that consuming applica‐ tions have more control over which data to read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T212830Z" creationid="xccui" creationdate="20190710T204415Z">
        <seg>此外，我们还经常会将记录组织到不同的桶中，以便消费应用更好地控制要读取的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it is often required to transform the data into a common format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T183803Z" creationid="xccui" creationdate="20190228T183803Z">
        <seg>此外，我们经常需要将数据转换为某种通用格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it provides type information for Scala’s Either, Option, and Try types, and Flink’s Java version of the Either type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T050116Z" creationid="xccui" creationdate="20190617T050116Z">
        <seg>此外，它还为Scala的Either、Option、Try类型以及Flink内部Java版本的Either类型提供了相应的类型信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, local recovery is not supported by the MemorySta teBackend, which does not support large state anyway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T025653Z" creationid="xccui" creationdate="20190802T025653Z">
        <seg>此外，不支持大状态的MemoryStateBackend无法进行本地恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, most Flink applications depend on one or more of Flink’s connectors to ingest data from or emit data to external sys‐ tems, like Apache Kafka, filesystems, or Apache Cassandra.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035050Z" creationid="xccui" creationdate="20190619T035050Z">
        <seg>此外，大多数Flink应用都会依赖一个或多个Flink的连接器来读写外部系统（例如：Apache Kafka、文件系统或Apache Cassandra）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, on recovery, it might be possible to restart an application on the same workers it was running before the failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T155506Z" creationid="xingcan" creationdate="20190801T155506Z">
        <seg>此外，恢复时还可能让应用重新运行在故障发生之前的工作节点上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, process functions feature side outputs to emit records to multiple output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T043918Z" creationid="xccui" creationdate="20190621T043918Z">
        <seg>此外，处理函数的副输出功能还允许将记录发送到多个输出流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, results were still dependent on timing and order of arriving events, i.e., the results did not depend solely on the data but also on exter&lt;t2/&gt;‐&lt;t3/&gt; nal conditions such as the hardware utilization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T050519Z" creationid="xccui" creationdate="20190327T050502Z">
        <seg>此外，结果仍然依赖于到来事件的时间和顺序，换言之，结果的生成不仅依赖于数据本身，还和外部条件（如：硬件使用率）有关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, results were still dependent on timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T194319Z" creationid="xccui" creationdate="20190605T053311Z">
        <seg>并且其处理结果仍依赖于事件到来的时间和顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the Context can emit records to side outputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T054138Z" creationid="xccui" creationdate="20190621T054138Z">
        <seg>此外，Context还支持将结果发送到副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the deployment also opens a few ports and passes the service name of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T143655Z" creationid="xccui" creationdate="20190720T031624Z">
        <seg>此外，该Deployment也会开启几个端口，并传入Flink主进程Deployment的信息，以便工作进程对主进程进行访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the method has a Context parameter similar to other process methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011223Z" creationid="xccui" creationdate="20190624T011223Z">
        <seg>此外，该方法和其他处理方法一样都有一个Context参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the protocol of TwoPhaseCommitSinkFunction piggybacks on Flink’s regular checkpointing mechanism and thus adds little overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T055449Z" creationid="xccui" creationdate="20190715T195951Z">
        <seg>再加上TwoPhaseCommitSinkFunction的协议本就是建立在Flink常规的检查点机制之上，因此它并没有带来很多额外开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the size of the state can grow and shrink over time, perhaps due to long-running win‐ dows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T031808Z" creationid="xccui" creationdate="20190731T031312Z">
        <seg>此外，状态大小可能会随时间推移而增大或缩小，这可能是长期运行的窗口所致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the state of a window operator with an AggregateFunction also consists of a single value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T003406Z" creationid="xccui" creationdate="20190624T003406Z">
        <seg>此外，使用了AggregateFunction的窗口算子，其状态也只有一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the stream processor can recover from failures with exactly-once state consistency guarantees and can adjust the compute resources of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045057Z" creationid="xccui" creationdate="20190605T044916Z">
        <seg>此外，它还能以精确一次的状态一致性保障进行故障恢复，调节应用计算资源等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the stream processor is respon&lt;t0/&gt;‐&lt;t1/&gt; sible to recover from failures with exactly-once state consistency guarantees and should be capable of adjusting the parallelism of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033138Z" creationid="xccui" creationdate="20190317T063754Z">
        <seg>此外，它还要负责以精确一次的状态一致性保障进行故障恢复，调节应用并发度等工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the union operator does not perform duplication elimina‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064716Z" creationid="xccui" creationdate="20190614T064619Z">
        <seg>此外，union算子不会对数据进行去重，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the visibility of committed messages depends on</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T031102Z" creationid="xccui" creationdate="20190710T031048Z">
        <seg>此外，已提交消息的可见性会取决于Flink应用生成检查点的间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the write-ahead operator needs to implement a single method:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T062756Z" creationid="xccui" creationdate="20190715T062756Z">
        <seg>此外，算子还需要实现一个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, they are isolated and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T014846Z" creationid="xccui" creationdate="20190718T014846Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, they can cause issues if they are used without a custom trigger that discards incomplete and stale windows at some point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T025248Z" creationid="xccui" creationdate="20190623T041329Z">
        <seg>此外，如果没有为其自定义触发器来丢弃在某些时候出现的不完整或过期的窗口，还会导致一些问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, this approach can suffer from garbage collec‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T020047Z" creationid="xccui" creationdate="20190703T222830Z">
        <seg>此外，该方法可能由于堆中放置了过多常驻内存的对象（long-lived object）而引发垃圾回收停顿（garbage collection pause）问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, users of open source software request or contribute new features that are missing to support their use</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T041404Z" creationid="xccui" creationdate="20190319T054608Z">
        <seg>此外，开源软件用户如果发现某些功能无法满足用例需求，都会向开源社区汇报或亲自操刀上阵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, you can submit applications using the Flink CLI client (./bin/flink) and access the REST interface to request information about the Flink cluster or manage running applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T035931Z" creationid="xccui" creationdate="20190720T035931Z">
        <seg>此外，你还可以使用Flink的CLI客户端（./bin/flink）提交应用，并访问REST接口获取有关Flink集群的信息或管理正在运行的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, you need to adjust Flink’s configuration file ./conf/flink-conf.yaml and con‐ figure the number of application restart attempts:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052757Z" creationid="xccui" creationdate="20190721T052757Z">
        <seg>此外，你需要在./conf/flink-conf.yaml中配置应用尝试重启的最大次数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, you need to set the ImagePullPolicy in the YAML files to Never to ensure Minikube fetches the image from its own registry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T045338Z" creationid="xccui" creationdate="20190730T045338Z">
        <seg>此外，你还需要将YAML文件中的ImagePullPolicy设置为Never，以确保Minikube从自己的注册表中获取镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More‐ over, applications that read from the sink system might observe unexpected results during the time when an application recovers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T200935Z" creationid="xccui" creationdate="20190708T071536Z">
        <seg>此外，从下游数据汇系统中读取数据的应用可能会在应用恢复期间观察到异常结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More‐ over, exactly-once state consistency and the ability to scale an application are funda‐ mental requirements for event-driven applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T074758Z" creationid="xccui" creationdate="20190604T053625Z">
        <seg>此外，作为基本需求，系统要提供精确一次（exactly-once）的状态一致性保障和针对应用的可伸缩性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More‐ over, in combination with the CheckpointListener interface, the snapshotState() method can be used to consistently write data to external datastores by synchronizing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T170224Z" creationid="xccui" creationdate="20190702T071818Z">
        <seg>此外，该方法还可以结合CheckpointListener接口使用，以和Flink检查点同步的方式将数据持续写入外部数据存储中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More‐ over, the data often needs to be transformed into a common format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T062830Z" creationid="esouser" creationdate="20190603T202046Z">
        <seg>此外，开发人员还经常需要将这些数据转换为某种通用格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More‐ over, the deployment configures which ports of the container to open for RPC com‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T143105Z" creationid="xccui" creationdate="20190720T025451Z">
        <seg>此外该Deployment配置了容器需要开放哪些用于RPC通信、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most DataStream API methods accept lambda functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055922Z" creationid="xccui" creationdate="20190618T055552Z">
        <seg>大多数DataStream API的方法都接收Lambda函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most commonly, this is done in a static</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T045549Z" creationid="xccui" creationdate="20190612T043110Z">
        <seg>大多数情况下，这些工作都会在静态的main()方法中完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most function interfaces are designed as SAM (single abstract method) interfaces and they can be implemented as Java 8 lambda functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053424Z" creationid="xccui" creationdate="20190613T022250Z">
        <seg>大多数函数接口都被设计为SAM（single abstract method 单一抽象方法）形式的，因此可以通过Java 8的Labmda函数实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of these features are based on savepoints.1 Flink exposes the following interfaces to monitor and control its master and worker processes, and applications:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T161005Z" creationid="xccui" creationdate="20190726T010049Z">
        <seg>这些功能大都基于保存点机制。1 为了对主进程、工作进程以及应用进行监控，Flink对外公开了以下接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most operators of the DataStream API have a single output—they produce one result stream with a specific data type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063612Z" creationid="xccui" creationdate="20190622T013130Z">
        <seg>大多数DataStream API的算子都只有一个输出，即只能生成一条具有某种数据类型的结果流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most stream transformations are based on user-defined functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T053634Z" creationid="xccui" creationdate="20190613T014153Z">
        <seg>大多数流式转换都是基于用户自定义函数来完成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most streaming applications are ideally executed continuously with as little downtime as possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T042814Z" creationid="xccui" creationdate="20190720T042814Z">
        <seg>大多数流式应用都会尽可能减少停机时间来连续地执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most streaming applications require that failures not affect the correctness of the computed results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T013721Z" creationid="xccui" creationdate="20190702T203714Z">
        <seg>它们中的绝大多数都要求故障不会对计算结果的正确性产生影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-Stream Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022743Z" creationid="xccui" creationdate="20190225T022743Z">
        <seg>基于多流的转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple companies have built streaming analytics services based on Flink’s SQL support both for internal use or to publicly offer them to paying customers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T041142Z" creationid="xccui" creationdate="20190319T040751Z">
        <seg>很多公司基于此构建了流式分析服务，供内部或外界付费用户使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiplexing records most likely introduces additional out-of-orderness with respect to the event-time timestamps such that a downstream timestamp assigner might produce more late records than expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T041831Z" creationid="xccui" creationdate="20190713T040918Z">
        <seg>混合记录有极大可能导致事件时间戳进一步乱序，从而使下游时间戳分配器产生更多的迟到记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multistream Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024730Z" creationid="esouser" creationdate="20190603T145126Z">
        <seg>多流转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multistream transformations merge multiple streams into one stream or split one stream into multiple streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T054711Z" creationid="xccui" creationdate="20190613T024521Z">
        <seg>将多条数据流合并为一条或将一条数据流拆分成多条的多流转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutual authentication can also be enabled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T035342Z" creationid="xccui" creationdate="20190725T035342Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MyAssigner().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044601Z" creationid="xccui" creationdate="20190620T044601Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nat&lt;t4/&gt;‐&lt;t5/&gt; urally, if a system can perform operations faster, it can perform more operations at the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211939Z" creationid="xccui" creationdate="20190402T211902Z">
        <seg>显然，系统执行操作越快，相同时间内执行的操作数量就会越多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naturally, if a system can perform operations faster, it can perform more operations in the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235710Z" creationid="xccui" creationdate="20190605T235634Z">
        <seg>显然，系统执行操作越快，相同时间内执行的操作数目就会越多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Navigate to File -&gt; New -&gt; Project from Existing Sources, select the book examples folder examples-scala, and click OK.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041215Z" creationid="xccui" creationdate="20190611T041215Z">
        <seg>依次找到File -&gt; New -&gt; Project from Existing Sources，选择书中示例文件夹examples-scala，点击OK。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested fields in POJOs and tuples are selected by denoting the nesting level with a "." (period character).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040336Z" creationid="xccui" creationdate="20190618T045900Z">
        <seg>如需选择POJO和元组中嵌套字段，可以利用"."来区分嵌套级别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Network memory is automatically subtracted from the configured JVM heap size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T042042Z" creationid="xccui" creationdate="20190724T042042Z">
        <seg>网络内存会自动从配置的JVM堆内存中抽调出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New distributed stream processing projects are continuously entering the open source stage and are challenging the state-of-the-art with new features and capabilities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T054015Z" creationid="xccui" creationdate="20190319T054015Z">
        <seg>新的分布式流处理项目不断涌入开源领域，依靠其新特性和新功能向旧有的领先技术发起挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New distributed stream processing projects are continu‐ ously entering the open source stage and are challenging the state of the art with new features and capabilities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160505Z" creationid="xccui" creationdate="20190605T050557Z">
        <seg>新的分布式流处理项目不断涌入开源领域，依靠其新的功能特性能向旧有的先进技术发起挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next,  we  use env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T050216Z" creationid="xccui" creationdate="20190612T045706Z">
        <seg>接下来我们使用env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, let’s run one of the book example applications in your IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042102Z" creationid="xccui" creationdate="20190611T042102Z">
        <seg>下一步让我们尝试在IDE里运行书中的一个示例程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we define a timeWindow() transfor‐ mation, which groups the sensor readings of each sensor ID partition into tumbling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051219Z" creationid="xccui" creationdate="20190612T053715Z">
        <seg>接下来我们通过timeWindow()转换，针对每个传感器ID分区都将读数划分为5秒一次的滚动窗口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we describe the semantics of common window types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012953Z" creationid="xccui" creationdate="20190606T012936Z">
        <seg>接下来我们将介绍常见窗口类型的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we introduce application designs based on stateful stream processing that exhibit many interesting characteristics and benefits over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T223624Z" creationid="xccui" creationdate="20190225T222612Z">
        <seg>接下来，我们会介绍基于状态化流处理的应用方法。和传统方法相比，它有很多有趣的特性和优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we introduce application designs based on stateful stream pro‐ cessing that exhibit many interesting characteristics and benefits over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T065714Z" creationid="esouser" creationdate="20190603T163031Z">
        <seg>其次，我们会介绍基于状态化流处理的应用设计。和传统设计相比，它有很多有意义的特性及优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we review the types of guarantees offered by modern stream processors and some mechanisms that systems implement to achieve those guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044532Z" creationid="xccui" creationdate="20190415T044532Z">
        <seg>接下来我们回顾一下现代流处理引擎所提供的不同种类的结果保障以及它们相应的实现机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we review the types of guarantees offered by modern stream processors and some of the mechanisms systems imple‐ ment to achieve those guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034141Z" creationid="xccui" creationdate="20190606T034141Z">
        <seg>接下来我们回顾一下现代流处理引擎所提供的不同种类的结果保障以及它们相应的实现机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we will get to use Flink’s window API, which provides built-in implementations of the most common window types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T053031Z" creationid="xccui" creationdate="20190619T053031Z">
        <seg>接下面我们会讲到Flink的窗口API，它针对几个最为常用的窗口类型都提供了内置实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we will guide you through the process of starting a local cluster and executing a first streaming application in order to give you a first impression of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T054710Z" creationid="xccui" creationdate="20190328T054710Z">
        <seg>接下来为了帮你获得Flink的第一印象，我们将一步步指导你启动本地集群并运行第一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, you have looked into the requirements of processing infinite streams in parallel and you have realized the importance of latency and throughput for stream applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051449Z" creationid="xccui" creationdate="20190416T050633Z">
        <seg>接下来你了解了并行处理无限流的需求并意识到了延迟和吞吐对于流式应用的重要性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, you learned the requirements of pro‐ cessing infinite streams in parallel and saw the importance of latency and throughput for stream applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194946Z" creationid="xccui" creationdate="20190606T040339Z">
        <seg>接下来，你学习了的并行处理无限流的需求，了解了延迟和吞吐对于流式应用的重要性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No action is taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184403Z" creationid="xccui" creationdate="20190626T184403Z">
        <seg>什么都不做。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No matter if water&lt;t2/&gt;‐&lt;t3/&gt; marks are user-defined or automatically generated, tracking global progress in a dis&lt;t4/&gt;‐&lt;t5/&gt; tributed system might be problematic in the presence of straggler tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T031322Z" creationid="xccui" creationdate="20190414T030615Z">
        <seg>无论水位线是由用户定义还是自动生成，只要存在落后的任务，追踪分布式系统中的全局进度就可能出现问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No matter if watermarks are user defined or automatically generated, tracking global progress in a distributed system might be problematic in the presence of straggler tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T162042Z" creationid="xccui" creationdate="20190606T025748Z">
        <seg>无论水位线是由用户定义还是自动生成，只要存在"拖后腿"的任务，追踪分布式系统中的全局进度就可能出现问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nodes represent operators and edges denote data dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T001302Z" creationid="xccui" creationdate="20190401T001240Z">
        <seg>其中节点表示算子，边表示数据依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nodes represent tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021810Z" creationid="xccui" creationdate="20190401T021708Z">
        <seg>每个节点表示一个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-chained task execution with dedicated threads and data transport via buffer channels and serialization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155047Z" creationid="esouser" creationdate="20190514T155047Z">
        <seg>使用特定线程执行非链接任务，利用缓冲通道及序列化进行数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonchained task execution with dedicated threads and data transport via</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T202204Z" creationid="xccui" creationdate="20190606T204033Z">
        <seg>利用专用线程执行非链接任务并通过缓冲通道及序列化进行数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonconsecutive file IDs, the last number in a committed file’s name, do not indicate data loss.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T020346Z" creationid="xccui" creationdate="20190711T020346Z">
        <seg>文件ID（即提交文件名称的最后一个数字）不连续并不代表数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>None of the functions exposes an API to set the time&lt;t8/&gt;‐&lt;t9/&gt; stamps of emitted records, manipulate the event-time clock of a task, or emit watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T140736Z" creationid="esouser" creationdate="20190603T140736Z">
        <seg>但函数没有暴露相应的API来设置发出记录的时间戳，调整任务的事件时间时钟或发出水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, the Data‐ Stream API provides a dedicated SinkFunction interface and a corresponding Rich SinkFunction abstract class.7 The SinkFunction interface provides a single method:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T212922Z" creationid="xccui" creationdate="20190713T212922Z">
        <seg>虽说如此，DataStream API还是为我们提供了一个专门的SinkFunction接口以及它对应的RichSinkFunction抽象类。7 SinkFunction接口内只有一个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonkeyed windows (also called all-windows in the DataStream API) behave exactly the same, except that they collect all data and are not evaluated in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041635Z" creationid="xccui" creationdate="20190622T041635Z">
        <seg>非键值分区窗口（在DataStream API中也称为全量窗口）的行为与之完全相同，只是它们会收集全量数据且不支持并行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonresettable source Resettable source</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170053Z" creationid="xccui" creationdate="20190708T170053Z">
        <seg>不可重置数据源 可重置数据源</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all stream processors are equally well-suited to run event-driven applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T150915Z" creationid="xccui" creationdate="20190604T052517Z">
        <seg>并不是所有的流处理引擎都同等适合来运行事件驱动型应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note shipping records in buffers does imply that Flink’s processing model is based on micro-batches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042016Z" creationid="xccui" creationdate="20190504T042016Z">
        <seg>但注意，从缓冲区中传输记录并不意味着Flink的处理模型是基于微批次的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink does not guarantee that the notifyCheckpointCom plete() method is called for each completed checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T202900Z" creationid="xccui" creationdate="20190702T202900Z">
        <seg>注意，Flink不保证对每个完成的检查点都会调用notifyCheckpointComplete()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink does not implement this naive mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T063617Z" creationid="xccui" creationdate="20190608T224543Z">
        <seg>值得一提的是，Flink没有实现这种朴素策略，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink uses TCP connec&lt;t0/&gt;‐&lt;t1/&gt; tions, thus these requirements are guaranteed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043546Z" creationid="xccui" creationdate="20190415T043439Z">
        <seg>由于Flink使用的是TCP连接，这些需求都能得以保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink uses TCP connec‐ tions, and thus these requirements are guaranteed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T190915Z" creationid="xccui" creationdate="20190606T033713Z">
        <seg>由于Flink使用的是TCP连接，上述需求都能满足。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that GenericWriteAheadSink does not implement the Sink Function interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T063858Z" creationid="xccui" creationdate="20190715T063858Z">
        <seg>注意，GenericWriteAheadSink没有实现SinkFunction接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that all operations are done in a nonblocking fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T060232Z" creationid="xccui" creationdate="20190716T212744Z">
        <seg>注意，以上所有操作都是以非阻塞的方式完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that an explicitly specified trigger overrides the existing trig‐ ger and does not complement it—the window will only be evalu‐ ated based on the trigger that was last defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T025932Z" creationid="xccui" creationdate="20190626T025707Z">
        <seg>需要注意的是，显式指定的触发器会覆盖已有的触发器而非对其进行补充，这意味着窗口仅会基于最新定义的触发器执行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that both bounds may be negative.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T031942Z" creationid="xccui" creationdate="20190628T031942Z">
        <seg>注意，两侧边界值都有可能为负。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that changing the input data type of built-in stateful opera‐ tors, such as window aggregation, time-based joins, or asyncronous functions, often modifies the type of their internal state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T041430Z" creationid="xccui" creationdate="20190705T041430Z">
        <seg>注意，改变内置状态化算子（例如窗口聚合，基于时间的Join或异步函数）的输入数据类型通常都使它们内部状态的类型发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that checkpoint compression is not supported for incremental RocksDB checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T034135Z" creationid="xccui" creationdate="20190731T204852Z">
        <seg>请注意，RocksDB增量检查点不支持压缩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that guaranteeing the consistency of an application’s state is not the same a guarantee‐ ing consistency of its output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T191638Z" creationid="xccui" creationdate="20190606T034216Z">
        <seg>请注意，保证应用状态的一致性和保证输出的一致性并不是一回事儿。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in PROCESS_ONCE mode, no checkpoints are taken after the filesystem path is scanned and all splits are created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T202432Z" creationid="xccui" creationdate="20190710T202432Z">
        <seg>注意，PROCESS_ONCE模式下的数据源在扫描完所有文件并创建好输入划分之后，不会生成任何检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in standalone mode, only the master process will be terminated and the worker processes will continue to run.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045217Z" creationid="xccui" creationdate="20190729T045217Z">
        <seg>注意，在独立集群模式下，只有主进程会被终止，其他工作进程将继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it is currently not possible to pass a custom configuration into the Flink Docker images.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190718T042916Z">
        <seg>注意，目前Flink Docker镜像还不支持接收自定义配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that keyBy() is different from the distribution transforma‐ tions discussed in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070343Z" creationid="xccui" creationdate="20190615T070343Z">
        <seg>注意，keyBy()和本节介绍的分发转换不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that mergable triggers may only use state primitives that can be automatically merged—ListState, ReduceState, or Aggrega tingState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195502Z" creationid="xccui" creationdate="20190626T195502Z">
        <seg>注意，可合并的触发器只能使用那些可以自动合并的状态原语——ListState，ReduceState或AggregatingState。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that only key point queries are supported.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T163801Z" creationid="xccui" creationdate="20190705T163249Z">
        <seg>注意，Flink仅能按照单个键值进行查询，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that shipping records in buffers does imply that Flink’s pro‐ cessing model is based on microbatches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T191414Z" creationid="xccui" creationdate="20190606T195722Z">
        <seg>请注意，将记录放入缓冲区并不意味着Flink的处理模型就是基于微批次的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that some classes are always resolved first in the parent class‐ loader (classloader.parent-first-patterns.default).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T060730Z" creationid="xccui" creationdate="20190723T060730Z">
        <seg>注意，有些类总是会优先在父类加载器（classloader.parent-first-patterns.default）中解析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that stateful transformations and keyed aggregates have to be used with care.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044921Z" creationid="xccui" creationdate="20190614T044921Z">
        <seg>请注意，在使用状态化转换和基于键值的聚合时要格外小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that stream pro&lt;t0/&gt;‐&lt;t1/&gt; cessors can normally only guarantee result correctness for state that lives inside the stream processor itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T045425Z" creationid="xccui" creationdate="20190415T045308Z">
        <seg>注意，流处理引擎通常只能保障其自身内部状态结果的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T032826Z" creationid="xccui" creationdate="20190619T032826Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the ListCheckpointed interface is implemented in Java and expects a java.util.List instead of a Scala native list.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T054346Z" creationid="xccui" creationdate="20190701T054346Z">
        <seg>请注意，ListCheckpointed接口是用Java实现的，所以它内部使用的是java.util.List而非Scala原生列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the Parquet writer is contained in the flink-parquet module, which needs to be added as a dependency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T183007Z" creationid="xccui" creationdate="20190711T182654Z">
        <seg>请注意，Parquet写入器包含在flink-parquet模块中，因此在使用时需要将其添加到依赖中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the application and the savepoint must be compatible—the application must be able to load the state of the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212525Z" creationid="xccui" creationdate="20190609T212448Z">
        <seg>需要注意的是，应用和保存点必须相互兼容，只有这样应用才能加载保存点内的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the choice of a streaming sink affects the end-to-end con‐ sistency of an application, whether the result of the application is provided with at-least once or exactly-once semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051916Z" creationid="xccui" creationdate="20190613T005523Z">
        <seg>注意，无论应用结果是至少一次语义还是精确一次语义，流式数据汇的选择都将影响应用端到端的一致性（end-to-end consistency）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the concept of a container in YARN is different from a container in Docker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T212038Z" creationid="xccui" creationdate="20190718T212038Z">
        <seg>注意，YARN中容器的概念和Docker中的不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the credentials are tied to a Flink cluster and not to a running job;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T023228Z" creationid="xccui" creationdate="20190725T023050Z">
        <seg>注意，授权证书是和Flink集群绑定的，而非某个运行的作业；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the job will continue to run if taking the savepoint fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T204045Z" creationid="xccui" creationdate="20190726T185250Z">
        <seg>请注意，如果保存点生成失败，作业将继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the keys of both streams should</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151936Z" creationid="xccui" creationdate="20190615T050826Z">
        <seg>注意，就像SQL查询中Join的谓词一样，两条流中的键值类型需要是同一类实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the new chained task starts with the operator on which the startNewChain() method is called—Map2 in our example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T204628Z" creationid="xccui" creationdate="20190730T204628Z">
        <seg>请注意，新的链接任务会从调用startNewChain()方法的算子开始，在我们的示例中是Map2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the savepoint does not contain information about opera‐ tor tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215650Z" creationid="xccui" creationdate="20190609T215650Z">
        <seg>注意，保存点没有包含算子任务的相关信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the state of an application will be empty if you start it for the first time or do not provide a savepoint or checkpoint to initial‐ ize the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170539Z" creationid="xccui" creationdate="20190726T032443Z">
        <seg>注意，如果你是第一次启动应用，或没有提供保存点（检查点）来初始化状态，那么应用的状态将被设为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the trigger uses custom state, which is cleaned up using the clear() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201046Z" creationid="xccui" creationdate="20190626T201046Z">
        <seg>注意，该触发器用到了自定义状态并在clear()方法中对其进行了清理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the watermarks of a source instance cannot make pro‐ gress if a partition becomes inactive and does not provide mes‐ sages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T032003Z" creationid="xccui" creationdate="20190709T022630Z">
        <seg>注意，如果某一分区变成非活跃状态且不再提供消息，那么数据源实例的水位线将无法前进。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that these failure scenarios do not affect the exactly-once guarantees of the Cassandra sink connector because it performs UPSERT writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065808Z" creationid="xccui" creationdate="20190715T065808Z">
        <seg>注意，这些失败的场景不会影响Cassandra数据汇连接器的精确一次语义保障，因为它执行的是UPSERT写入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T062507Z" creationid="xccui" creationdate="20190621T062507Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this configuration only affects the first reading positions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040926Z" creationid="xccui" creationdate="20190709T040620Z">
        <seg>注意，上述配置只会对应用首次启动后的读取位置起作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this will void any output guarantees of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T160923Z" creationid="xingcan" creationdate="20190709T160923Z">
        <seg>但请注意，这样应用将无法提供任何输出保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that to be able to efficiently combine the current state with an event and produce a single value, the aggregation function must be associative and commuta&lt;t0/&gt;‐&lt;t1/&gt; tive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035418Z" creationid="xccui" creationdate="20190406T035032Z">
        <seg>注意，为了更有效地合并事件和当前状态、生成单个结果，聚合函数必须是可结合（associative）及可交换（commutative）的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that to be able to efficiently combine the current state with an event and produce a single value, the aggregation function must be associative and commuta‐ tive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061404Z" creationid="xccui" creationdate="20190606T011827Z">
        <seg>注意，为了更有效地合并事件和当前状态并生成单个结果，聚合函数必须是可结合（associative）及可交换（commutative）的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you can customize a window operator by providing a custom trigger or evictor and declaring strategies to deal with late elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T042128Z" creationid="xccui" creationdate="20190622T041859Z">
        <seg>你可以通过提供自定义触发器或移除器以及声明迟到元素处理策略的方式来自定义窗口算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you do not need to provide connection information, as Flink memorized the connection details of the Flink session run‐ ning on YARN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T142443Z" creationid="xccui" creationdate="20190719T015019Z">
        <seg>请注意，由于Flink会记住在YARN上运行的Flink会话连接详情，所以你无须提供连接信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you must configure different cluster IDs for all Flink ses‐ sion clusters that connect to the same ZooKeeper cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T061513Z" creationid="xccui" creationdate="20190721T061217Z">
        <seg>注意，连接同一个ZooKeeper集群的所有处于会话模式的Flink集群都必须配置不同的集群ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you need to start a process that listens on the socket before starting the pro‐ gram.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T023519Z" creationid="xccui" creationdate="20190714T023519Z">
        <seg>注意，在启动程序之前，你需要先启动负责监听套接字的进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you should avoid using Kryo if possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065518Z" creationid="xccui" creationdate="20190616T065518Z">
        <seg>注意，如果可能请尽量避免使用Kryo。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you should design such an operator with efficient state access patterns and effective state cleanup strategies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T203515Z" creationid="xccui" creationdate="20190627T211309Z">
        <seg>注意，你要设计的算子需要具备高效的状态访问模式及有效的状态清理策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you should not access keyed state from the processBroadcastEle ment() method of KeyedBroadcastProcessFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054919Z" creationid="xccui" creationdate="20190702T053934Z">
        <seg>注意，由于广播输入一侧没有指定键值，状态后端无法访问键值分区的状态值，所以你不能从KeyedBroadcastProcessFunction的processBroadcastElement()方法中访问键值分区状态，强行这么做会使状态后端抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: you can also build the JAR file yourself by following the steps on the repo&lt;t0/&gt;‐&lt;t1/&gt; sitory’s README file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035840Z" creationid="xccui" creationdate="20190329T035802Z">
        <seg>注意：你也可以根据代码库中README文件的指示自行构建JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now let’s quickly discuss what is happening under the hood.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T092327Z" creationid="xccui" creationdate="20190611T043738Z">
        <seg>接下来我们快速看一下程序内部发生了什么。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now open your IDE and import the Maven project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040711Z" creationid="xccui" creationdate="20190611T040711Z">
        <seg>现在就可以打开你的IDE，把Maven项目导进去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that we have all that knowledge, it’s time to get our hands dirty and start devel‐ oping Flink applications!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T034012Z" creationid="xccui" creationdate="20190610T033449Z">
        <seg>既然我们已经掌握了这么多理论知识，是时候撸起袖子着手开发Flink应用了！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that you are familiar with the basics of dataflow programming, it’s time to see how these concepts apply to processing data streams in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045530Z" creationid="xccui" creationdate="20190605T233630Z">
        <seg>现在你已经对Dataflow编程的基础有所了解，接下来我们看一下如何将这些概念应用到并行数据流处理中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that you have become familiar with the basics of dataflow programming, it’s time to see how these concepts apply to processing data streams in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142729Z" creationid="xccui" creationdate="20190401T142257Z">
        <seg>现在你已经对dataflow编程的基础有所了解，接下来我们看一下这些概念如何应用于并行数据流处理中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that you have learned how to register, define, and group metrics, you might be wondering how to access them from external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055104Z" creationid="xccui" creationdate="20190804T054935Z">
        <seg>你既然已经学会了如何注册、定义指标并对其分组，那接下来可能就想了解如何从外部系统访问它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you can upload and submit jobs to the Flink cluster running on Kubernetes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T035805Z" creationid="xccui" creationdate="20190720T035746Z">
        <seg>现在你就能够将作业上传并提交至Kubernetes上的Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OUT getResult(ACC accumulator);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004737Z" creationid="xccui" creationdate="20190624T004737Z">
        <seg>OUT getResult(ACC accumulator);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Obviously, the periodic nature of the ETL jobs and reporting queries induce a consid&lt;t0/&gt;‐&lt;t1/&gt; erable latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T031411Z" creationid="xccui" creationdate="20190317T031021Z">
        <seg>就是ETL作业和报告查询的周期性会导致相当高的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course there is much more to learn about stream pro&lt;t0/&gt;‐&lt;t1/&gt; cessing with Apache Flink and that’s what this book is about.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041854Z" creationid="xccui" creationdate="20190328T062511Z">
        <seg>当然，关于用Apache Flink进行流处理要学习的知识还有很多，这也正是本书要介绍的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, none of this matters if your system cannot guard state against failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T203538Z" creationid="xccui" creationdate="20190409T203538Z">
        <seg>当然，如果你的系统无法在故障时保护状态，那一切都是空谈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, there is much more to learn about stream processing with Apache Flink and that’s what this book is about.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124522Z" creationid="xccui" creationdate="20190605T124522Z">
        <seg>当然，关于用Apache Flink进行流处理要学习的知识还有很多，这也正是本书要介绍的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, you can still use processing-time windows and timers if you choose the EventTime time characteristic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T050731Z" creationid="xccui" creationdate="20190619T073009Z">
        <seg>当然，即便选择EventTime时间特性，你仍然可以使用处理时间窗口和计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often are features of these newcomers being adop&lt;t0/&gt;‐&lt;t1/&gt; ted by more stream processors of earlier generations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014815Z" creationid="xccui" creationdate="20190319T055501Z">
        <seg>而这些新特性往往会被更多上一代的流处理引擎所采用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, a database system serves multiple applications that sometimes access the same databases or tables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T195827Z" creationid="esouser" creationdate="20190603T195556Z">
        <seg>很多时候，多个应用会共享同一个数据库系统，有时候还会访问相同的数据库或表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, these include frequently used libraries, such as Apache Commons or Google’s Guava.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T040525Z" creationid="xccui" creationdate="20190619T040525Z">
        <seg>这些依赖通常包括一些诸如Apache Commons或Google Guava等常用库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, this data was either unstruc&lt;t0/&gt;‐&lt;t1/&gt; tured, i.e., not strictly following a relational schema, or too voluminous to be cost-effectively stored in a relational database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T210826Z" creationid="xccui" creationdate="20190228T210612Z">
        <seg>这些数据通常是非结构化（即无法严格匹配关系模式）的，或因数量庞大无法经济高效地存放于关系型数据库系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Oftentimes there is a need to initialize a function before it processes the first record or to retrieve information about the context in which it is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060108Z" creationid="xccui" creationdate="20190618T060108Z">
        <seg>很多时候我们需要在函数处理第一条记录之前进行一些初始化工作或是取得有关执行它的上下文信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the contrary, in continuously running stream&lt;t4/&gt;‐&lt;t5/&gt; ing jobs, state is durable across events and we can expose it as a first-class citizen in the programming model.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053122Z" creationid="xccui" creationdate="20190414T054354Z">
        <seg>反之，在持续运行的流式作业中，每次处理事件状态都是持久化的，我们完全可以将其作为编程模型中的一等公民。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the contrary, stateful operators may maintain information about the events they have received before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T040228Z" creationid="xccui" creationdate="20190405T040212Z">
        <seg>相反，状态化算子可能会维护之前接收的事件信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the home screen, you will see an overview of your cluster configuration including the number of TaskManagers, number of configured and available task slots, and run‐ ning and completed jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T034205Z" creationid="xccui" creationdate="20190802T034135Z">
        <seg>在主界面上，你将看到有关集群配置的概览信息，其中包括TaskManager的数量、配置和可用的任务处理槽以及正在运行和已完成的作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the left hand side you see a JobGraph - the non-parallel representation of an application - consisting of five operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043357Z" creationid="xccui" creationdate="20190423T043236Z">
        <seg>左侧的JobGraph（非并行化的应用表示）包含了5个算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the left-hand side of Figure 3-2 you see a JobGraph—the nonparallel representa‐ tion of an application—consisting of five operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144523Z" creationid="xccui" creationdate="20190606T144451Z">
        <seg>左侧的JobGraph（应用的非并行化表示）包含了5个算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, an append operation is not an idem‐ potent operation, because appending an element multiple times results in multiple appends.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T051847Z" creationid="xccui" creationdate="20190708T065012Z">
        <seg>相反，追加操作（append operation）就不是幂等的，因为多次追加某个元素会导致它出现多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, event time guarantees deterministic results and allows you to deal with events that are late or even out of order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031344Z" creationid="xccui" creationdate="20190606T031309Z">
        <seg>事件时间则与之相反，能保证结果的准确性，并允许你处理延迟甚至无序的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, event time guarantees deterministic results and allows you to deal with events that are late or even out-of-order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050333Z" creationid="xccui" creationdate="20190414T045924Z">
        <seg>与之相对的事件时间能保证确定的结果，并允许你处理延迟甚至无序的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if watermarks are too relaxed, you have high confidence but you might unnecessarily increase processing latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T161536Z" creationid="xccui" creationdate="20190606T025703Z">
        <seg>反之，如果水位线过于宽松，虽然可信度得以保证，但可能会无谓地增加处理延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if watermarks are too slow to arrive, you have high confi&lt;t4/&gt;‐&lt;t5/&gt; dence but you might unnecessarily increase processing latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210859Z" creationid="xccui" creationdate="20190412T210722Z">
        <seg>反之，如果水位线到来的太晚，虽然可信度得到了保证，但可能会无谓地增加处理延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if you generate very tight watermarks—watermarks that might be larger than the timestamps of some later records—time-based computations might be performed before all relevant data has arrived.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T040435Z" creationid="xccui" creationdate="20190621T040435Z">
        <seg>反之，如果生成的水位线过于紧密，即水位线可能大于部分后来数据的时间戳，那么计算可能会在所有相关数据到齐之前就已触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, knowing about all accidents that have ever happened might not be so interesting in this case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043532Z" creationid="xccui" creationdate="20190406T043454Z">
        <seg>此时，我们可能对该位置发生过的所有事故并不感兴趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the sink side, data streams are often produced into message queues to make the events available to subsequent streaming applications, written to filesystems for archiving or making the data available for offline analytics or batch applications, or inserted into key-value stores or relational database systems, like Cassandra, Elastic‐ Search, or MySQL, to make the data searchable and queryable, or to serve dashboard applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T200605Z" creationid="xccui" creationdate="20190708T171112Z">
        <seg>在数据汇一端，数据流中的事件经常会写入消息队列中，以支撑后续流式应用；或是会写入文件系统，实现归档或支撑后续离线分析及批处理应用；也可以插入到键值存储或数据库系统中（如Cassandra、ElasticSearch或MySQL），以供查询、搜索或仪表盘应用使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T030837Z" creationid="xccui" creationdate="20190722T030837Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a Flink YARN session is running, you can submit jobs to the session with the command ./bin/flink run ./path/to/job.jar.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T014726Z" creationid="xccui" creationdate="20190719T014726Z">
        <seg>一旦Flink的YARN会话启动起来，你就可以利用命令"./bin/flink run ./path/to/job.jar"向会话中提交作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a job is scheduled for execution on the next batch, it cannot access the state of the pre&lt;t2/&gt;‐&lt;t3/&gt; vious job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053824Z" creationid="xccui" creationdate="20190414T053811Z">
        <seg>一旦作业调度到下个批次上执行，它将无法访问之前的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a job is scheduled for execution on the next batch, it cannot access the state of the previous job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182213Z" creationid="xccui" creationdate="20190606T032116Z">
        <seg>一旦某个作业被调度到下个批次上执行，它将无法访问之前的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a sender receives a credit notification, it ships as many buffers as it was granted and the size of its backlog, i.e., the number of network buffers that are filled and ready to be shipped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151649Z" creationid="esouser" creationdate="20190513T211245Z">
        <seg>一旦发送端收到信用通知，就会在信用度范围内传输尽可能多的缓冲，并附带积压量（已经填满准备传输的缓冲数目）大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a sender receives a credit notification, it ships as many buffers as it was granted and the size of its backlog—the number of network buffers that are filled and ready to be shipped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T195048Z" creationid="xccui" creationdate="20190606T202839Z">
        <seg>一旦发送端收到信用通知，就会在信用值所限定的范围内尽可能多地传输缓冲数据，并会附带上积压量（已经填满准备传输的网络缓冲数目）大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a transaction is committed, the markers are changed to commit‐ ted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T211753Z" creationid="xccui" creationdate="20190709T211612Z">
        <seg>一旦事务提交，这些标记就会被改为已提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a watermark has been received, operators are signaled that all timestamps for a certain time interval have been observed and either trigger computation or order received events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T161323Z" creationid="xccui" creationdate="20190412T205922Z">
        <seg>算子一旦收到某个水位线，就相当于接到信号：某个特定时间区间的时间戳已经到齐，可以触发窗口计算或对接收的数据进行排序了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once all barriers for a checkpoint have arrived, the operator checkpoints the state, which might now also include modifications caused by records that would usually belong to the next checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T065841Z" creationid="xccui" creationdate="20190609T204938Z">
        <seg>待所有的检查点分隔符都到达以后，算子才将状态存入检查点，这时候状态可能会包含一些由本应出现在下一次检查点的记录所引起的改动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once all checkpoint barriers have been emitted, the task starts to process the buffered records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193035Z" creationid="xccui" creationdate="20190609T193035Z">
        <seg>任务在发出所有的检查点分隔符后就会开始处理缓冲的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once all pods are up, you will have a Flink cluster running on Kubernetes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T034905Z" creationid="xccui" creationdate="20190720T034755Z">
        <seg>待所有Pod都启动完毕，就意味着Flink集群在Kubernetes上成功运行起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once all tasks are up and running, the pro‐ gram starts to produce its results, which should look similar to the following lines:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043424Z" creationid="xccui" creationdate="20190611T043424Z">
        <seg>一旦所有任务启动起来并开始运行，程序就会开始生成类似下面这样的结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once an application is submitted for execution, it starts a JobManager and hands the application over.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061658Z" creationid="xccui" creationdate="20190606T142857Z">
        <seg>一旦某个应用提交执行，Dispatcher会启动一个JobManager并将应用转交给它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once another check‐ point (or savepoint) completes, you can safely remove a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T182125Z" creationid="xccui" creationdate="20190726T181939Z">
        <seg>在当前检查点（或保存点）完成后，你就可以安全地删除旧的保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once data has been emitted to a sink, it is difficult to guarantee result correctness, unless the sink system supports transactions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T191921Z" creationid="xccui" creationdate="20190606T034308Z">
        <seg>一旦数据从数据汇中写出，除非目标系统支持事务，否则结果的正确性将难以保证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once enough slots are available, Flink’s ResourceManager assigns them to the JobManager and the job execution starts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T214748Z" creationid="xccui" creationdate="20190718T214748Z">
        <seg>一旦有足够的处理槽，Flink的ResourceManager就会将它们分配给JobManager，使其可以运行作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once everything has been set up, you can start the Flink cluster by calling ./bin/ start-cluster.sh.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T203739Z" creationid="xccui" creationdate="20190717T203330Z">
        <seg>一切就绪后，你就可以利用./bin/start-cluster.sh脚本来启动Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it is running, look for the JobID in the log file or the web UI; set the JobID in the code of the dashboard and run it as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T045954Z" creationid="xccui" creationdate="20190707T045747Z">
        <seg>随后你需要从日志文件或Web UI中找到JobID，将其设置到代码中，并运行仪表盘应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it received enough TaskManager slots, it distributes the tasks of the ExecutionGraph to the TaskManagers that execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T061952Z" creationid="xccui" creationdate="20190418T035042Z">
        <seg>一旦它收到了足够的TaskManager处理槽，就会将ExecutionGraph中的任务分发给TaskManager来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it receives an application, it starts a JobMan&lt;t4/&gt;‐&lt;t5/&gt; ager and hands the application over.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T053136Z" creationid="xccui" creationdate="20190418T053058Z">
        <seg>一旦接收了某个应用，Dispatcher会启动一个JobManager并将应用交付给它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it receives enough Task‐ Manager slots, it distributes the tasks of the ExecutionGraph to the TaskManag‐ ers that execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060207Z" creationid="xccui" creationdate="20190606T141755Z">
        <seg>一旦它收到了足够数量的TaskManager处理槽（slot），就会将ExecutionGraph中的任务分发给TaskManager来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once sampling is complete, you will see the back-pressure status in the second column.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T152248Z" creationid="xingcan" creationdate="20190802T152248Z">
        <seg>一旦采样结束，你就可以在第二列中看到背压状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once started, the TaskManagers register their slots at Flink’s ResourceMan‐ ager, which provides them to the JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T212915Z" creationid="xccui" creationdate="20190718T212915Z">
        <seg>一旦启动成功，TaskManager就会将自己的处理槽在Flink的ResourceManager中注册，后者会把它们提供给JobManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once that is done, you can call ./bin/ start-zookeeper-quorum.sh to start a ZooKeeper process on each configured node.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T203027Z" creationid="xccui" creationdate="20190720T203027Z">
        <seg>完成后，就可以调用./bin/start-zookeeper-quorum.sh在配置的节点上启动ZooKeeper进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once that timer fires, the onTimer() method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T213456Z" creationid="xccui" creationdate="20190704T213456Z">
        <seg>一旦该计时器触发，就会调用onTimer()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the application is run‐ ning again, you can take a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T034304Z" creationid="xccui" creationdate="20190731T205849Z">
        <seg>应用再次运行后，你就可以为其生成保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the data has been imported into the data warehouse it can be queried and ana&lt;t0/&gt;‐&lt;t1/&gt; lyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192252Z" creationid="xccui" creationdate="20190228T191418Z">
        <seg>一旦数据导入数据仓库，就能对它们做查询分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the data has been imported into the data warehouse it can be queried and ana‐ lyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T064853Z" creationid="esouser" creationdate="20190603T203005Z">
        <seg>一旦数据导入数据仓库，我们就能对它们做查询分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the execution environment has been configured, it is time to do some actual work and start processing streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T052616Z" creationid="xccui" creationdate="20190612T050957Z">
        <seg>在配置完执行环境后，我们就可以着手来做一些实质性的工作并对数据流开始正式处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the job terminates, the Flink cluster is stopped and all resources are returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T211938Z" creationid="xccui" creationdate="20190718T211938Z">
        <seg>一旦作业结束，集群就会停止，全部资源都会归还。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the job-specific containers are running, you can treat the cluster as a regular Flink cluster as described in “Kubernetes” on page 228.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T045515Z" creationid="xccui" creationdate="20190730T045515Z">
        <seg>在针对特定作业的容器运行后，你就可以像228页"Kubernetes"所介绍的那样，将集群视为常规的Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the replay completes and the application is past the point at which it previously failed, the result will be consistent again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T072418Z" creationid="xccui" creationdate="20190708T072418Z">
        <seg>一旦重放完成，应用的进度超过了之前失败的点，其结果就会恢复一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the sender task completes, the data is sent as a batch over a temporary TCP connection to the receiver</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045623Z" creationid="xccui" creationdate="20190504T045549Z">
        <seg>一旦发送端任务完成，所有数据会经由一个到接收端的临时TCP连接，以批量形式发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the sender task completes, the data is sent as a batch over a temporary TCP connection to the receiver.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193024Z" creationid="xccui" creationdate="20190606T200629Z">
        <seg>一旦发送端任务完成，所有数据会经由一个到接收端的临时TCP连接批量发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the state for a certain result has been purged, the result cannot be updated anymore and late events can only be dropped or redirected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T162637Z" creationid="xingcan" creationdate="20190628T162637Z">
        <seg>一旦清除了针对特定结果的状态，这些结果就再也无法更新，而迟到事件也只能被丢弃或重定向。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once they start running, the TaskManagers register themselves at the ResourceMan‐ ager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T153627Z" creationid="xccui" creationdate="20190717T153627Z">
        <seg>一旦它们运行起来，TaskManager就会将自己注册到ResourceManager中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once we have a DataStream, we can apply a transformation on it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051035Z" creationid="xccui" creationdate="20190612T052239Z">
        <seg>一旦得到了DataStream对象，我们就可以对它应用转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you change operator identifiers or the maximum parallelism, you cannot start an application from a savepoint but have to start it from scratch without any state initialization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023237Z" creationid="xccui" creationdate="20190703T015126Z">
        <seg>一旦你修改了算子标识或最大并行度则无法从保存点启动应用，只能选择抛弃状态从头开始运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you find a commit‐ ted file with the same task index and a higher ID, you can safely remove a pending file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T150803Z" creationid="xccui" creationdate="20190711T191859Z">
        <seg>如果你找到了一个具有相同任务索引号、ID更高的已经提交的文件，就可以把处于等待阶段的文件删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you have copied the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T044607Z" creationid="xccui" creationdate="20190730T044607Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you have the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T033437Z" creationid="xccui" creationdate="20190720T033437Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you obtain a state client, you can query the state of an application by calling the getKvState() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T034126Z" creationid="xccui" creationdate="20190707T033408Z">
        <seg>在你得到一个状态客户端对象之后，就可以调用它的getKvState()方法来查询应用的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once your coffee is ready, the barista calls your name and you can pick up your coffee from the bench.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T153941Z" creationid="xccui" creationdate="20190401T152947Z">
        <seg>咖啡制作完成后，店员会叫你的名字，你来从吧台取走咖啡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once your coffee is ready, the barista calls your name and you can pick up your coffee from the counter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050857Z" creationid="xccui" creationdate="20190605T233910Z">
        <seg>咖啡制作完成后，咖啡师会叫你的名字，你来从吧台取走咖啡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One appli&lt;t0/&gt;‐&lt;t1/&gt; cation emits its output to an event log and another application consumes the events that the other application emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152727Z" creationid="xccui" creationdate="20190307T152727Z">
        <seg>即上游应用将结果写入事件日志供下游应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One application emits its output to an event log and another application consumes the events the other appli‐ cation emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214038Z" creationid="esouser" creationdate="20190603T214015Z">
        <seg>上游应用将结果写入事件日志供下游应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One example for such an assigner is the EventTimeSessionWindows assigner we discussed before, which works by creating a new window for each arriving element and merging overlapping win‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045808Z" creationid="xccui" creationdate="20190626T045703Z">
        <seg>一个例子就是我们之前讨论过的EventTimeSessionWindows分配器，它需要为每个到来的元素创建一个新的窗口并在之后合并那些重叠的窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One example would be when checkpoints take a long time but do not consume much resources; for example, due to operations with high-latency calls to external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T203055Z" creationid="xccui" creationdate="20190731T203055Z">
        <seg>一个例子是当生成检查点耗时较长但不会消耗太多资源（例如由于涉及外部系统调用的操作延迟很高）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of Flink’s most valued and unique features are savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T070124Z" creationid="xccui" creationdate="20190609T210433Z">
        <seg>Flink最具价值且独具一格的功能之一是保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the most interesting applications of save‐ points we have seen in the wild is continuously migrating a streaming application to the datacenter that provides the lowest instance prices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T070758Z" creationid="xccui" creationdate="20190609T213849Z">
        <seg>我们在生态中见到保存点最奇葩应用之一是不断将流式应用迁移到实例价格最低的数据中心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One operator (OP-1) has a single operator state (OS-1) and another operator (OP-2) has two keyed states (KS-1 and KS-2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190609T214916Z">
        <seg>其中一个算子（OP-1）有一个算子状态（OS-1），另一个算子（OP-2）有两个键值分区状态（KS-1和KS-2）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One or more columns have to be defined as (composite) primary keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T193429Z" creationid="xccui" creationdate="20190711T193340Z">
        <seg>其中必须有一个或多个列被定义为（符合）主键，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One reason is to break a chain of expensive functions in order to execute them on different processing slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T010441Z" creationid="xccui" creationdate="20190730T191708Z">
        <seg>其中一种情况是我们希望将一连串负载较重的函数拆开，让它们在不同的处理槽内执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One restriction of the split transformation is that all outgoing streams are of the same type as the input type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T064345Z" creationid="xccui" creationdate="20190615T064224Z">
        <seg>split转换限制了所有输出流的类型必须和输入流相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way you can lower latency is by hiring a more skilled barista, i.e. one that prepares coffees faster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210823Z" creationid="xccui" creationdate="20190402T210744Z">
        <seg>一种降低延迟的方法是雇佣更娴熟的咖啡师，他们制作咖啡会更快一些。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Online editions are also available for most titles (http://oreilly.com).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210717Z" creationid="esouser" creationdate="20190603T210717Z">
        <seg>Online editions are also available for most titles (http://oreilly.com).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Online gaming is a simple scenario showing how operator semantics should depend on the time when events actually happen and not the time when the application receives the events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155048Z" creationid="xccui" creationdate="20190411T153601Z">
        <seg>在线游戏这个简单场景展示了算子语义应该依赖事件实际发生时间而非应用收到事件的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only Use Kryo as a Fallback Solution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065453Z" creationid="xccui" creationdate="20190616T065453Z">
        <seg>仅将Kryo作为后备方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only Use Rolling Aggregations on Bounded Key Domains</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062710Z" creationid="xccui" creationdate="20190614T060917Z">
        <seg>只对有限键值域使用滚动聚合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only Use Rolling Reduce on Bounded Key Domains</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062659Z" creationid="xccui" creationdate="20190614T062659Z">
        <seg>只对有限键值域使用滚动reduce操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the split operator allows splitting a stream into multiple streams of the same type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T202733Z" creationid="xccui" creationdate="20190622T013746Z">
        <seg>只有split算子可以将一条流拆分成多条类型相同的流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only when execute() is called does the system trig‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011948Z" creationid="xccui" creationdate="20190613T011858Z">
        <seg>只有在调用execute()方法时，系统才会触发程序执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open Flink’s Web UI by entering the URL http://localhost:8081 in your browser.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123232Z" creationid="xccui" creationdate="20190605T123228Z">
        <seg>在浏览器中输入URL http://localhost:8081，打开Flink Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open Flink’s Web UI on by entering the URL &lt;t0/&gt;http://localhost:8081&lt;t1/&gt; &lt;t2/&gt;in your browser.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035037Z" creationid="xccui" creationdate="20190329T025509Z">
        <seg>在你浏览器中输入URL http://localhost:8081，打开Flink Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open a terminal and run the following Git command to clone the examples-scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T091227Z" creationid="xccui" creationdate="20190611T035954Z">
        <seg>打开终端运行以下Git命令将examples-scala库克隆到你的机器上：1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open a terminal and run the following command to create a Flink Maven Quickstart Scala project as a starting point for your Flink application:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T094150Z" creationid="xccui" creationdate="20190612T004808Z">
        <seg>你可以打开终端运行以下命令来创建Flink Maven Quickstart Scala项目，并以它为基础开发Flink应用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source communities are constantly improving the capabilities of their projects and are pushing the technical boundaries of stream pro‐ cessing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T192800Z" creationid="xccui" creationdate="20190605T050637Z">
        <seg>开源社区通过不断增强它们项目的功能在流处理领域开疆拓土。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source software is a major driver of this trend, mainly due to two reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T052426Z" creationid="xccui" creationdate="20190319T051721Z">
        <seg>开源软件之所以能够主导这一趋势，主要有两方面原因：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source software is a major driver of this trend, mainly due to two reasons:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050320Z" creationid="xccui" creationdate="20190605T050320Z">
        <seg>开源软件之所以能够主导这一趋势，主要有两方面原因：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source stream processing software is a commodity that everybody can eval&lt;t0/&gt;‐&lt;t1/&gt; uate and use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T052828Z" creationid="xccui" creationdate="20190319T052828Z">
        <seg>开源流处理软件作为一件商品，所有人都可以评估和使用它；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source stream processing software is a commodity that everybody can eval‐ uate and use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160213Z" creationid="xccui" creationdate="20190605T050444Z">
        <seg>开源流处理软件作为一类商品，允许任何人评估和使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OpenStack Swift FS</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T043924Z" creationid="xccui" creationdate="20190722T043924Z">
        <seg>OpenStack Swift FS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operating Flink and Streaming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T044237Z" creationid="xccui" creationdate="20190725T043122Z">
        <seg>Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <note>TODO</note>
      <tuv lang="EN-US">
        <seg>Operating Flink and Streaming Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T044232Z" creationid="xccui" creationdate="20190225T025708Z">
        <seg>Flink和流式应用运维</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operation of a window join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040307Z" creationid="xccui" creationdate="20190628T040307Z">
        <seg>基于窗口的Join操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations based on event time are predictable and their results are deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160049Z" creationid="xccui" creationdate="20190606T024302Z">
        <seg>基于事件时间的操作是可预测的，其结果具有确定性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations based on event-time are predictable and their results deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150811Z" creationid="xccui" creationdate="20190412T150811Z">
        <seg>基于事件时间的操作是可预测的，它们的结果非常确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations can be either &lt;t0/&gt;stateless&lt;t1/&gt; or &lt;t2/&gt;stateful&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T213151Z" creationid="xccui" creationdate="20190402T213141Z">
        <seg>这些操作既可以是无状态（stateless）的，也可以是有状态（stateful）的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations can be either stateless or stateful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055520Z" creationid="xccui" creationdate="20190605T235803Z">
        <seg>这些操作既可以是无状态（stateless）的，也可以是状态化（stateful）的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations on Data Streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143937Z" creationid="esouser" creationdate="20190603T143937Z">
        <seg>数据流上的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations on data streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015445Z" creationid="xccui" creationdate="20190225T015445Z">
        <seg>数据流上的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022048Z" creationid="xccui" creationdate="20190225T022048Z">
        <seg>算子状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator Unique Identifiers and Maximum Parallelism Are Baked into Savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015232Z" creationid="xccui" creationdate="20190703T013808Z">
        <seg>算子唯一标识和最大并行度会被固化到保存点中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state cannot be accessed by another task of the same or a different operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061752Z" creationid="xccui" creationdate="20190607T061413Z">
        <seg>算子状态不能通过其他任务访问，无论该任务是否来自相同算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state in streaming jobs is very valuable and should be guarded against fail&lt;t0/&gt;‐&lt;t1/&gt; ures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035634Z" creationid="xccui" creationdate="20190415T035334Z">
        <seg>流式作业中的算子状态十分宝贵，因此需要在故障时予以保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state in streaming jobs is very valuable and should be guarded against fail‐ ures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T184230Z" creationid="xccui" creationdate="20190606T033054Z">
        <seg>在流式作业中，算子的状态十分重要，因此需要在故障时予以保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state is managed per parallel instance of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T035653Z" creationid="xccui" creationdate="20190701T035251Z">
        <seg>算子状态的维护是按照每个算子并行实例来分配的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state is scoped to an operator task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T060735Z" creationid="xccui" creationdate="20190607T060228Z">
        <seg>算子状态的作用域是某个算子任务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state will not be stored locally and needs to be retrieved from the remote storage system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T025325Z" creationid="xccui" creationdate="20190802T025325Z">
        <seg>算子状态不会存储在本地，而是需要从远程存储系统中获取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043737Z" creationid="xccui" creationdate="20190804T043737Z">
        <seg>算子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators A and C are sources and operator E is a sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043400Z" creationid="xccui" creationdate="20190423T043347Z">
        <seg>其中算子A和C是数据源，算子E是数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators C and E have a parallelism of two.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043448Z" creationid="xccui" creationdate="20190423T043412Z">
        <seg>算子C和E的并行度为2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators are executed in parallel by one or more operator tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T071037Z" creationid="xccui" creationdate="20190609T214539Z">
        <seg>算子会在一个或多个任务上并行执行，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators are the basic functional units of a dataflow application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224831Z" creationid="xccui" creationdate="20190331T214759Z">
        <seg>算子是Dataflow程序的基本功能单元，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators can accept multiple inputs and produce multiple output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060919Z" creationid="xccui" creationdate="20190405T155812Z">
        <seg>算子既可以同时接收多个输入流或产生多条输出流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators keep latency statistics in a latency gauge that contains min, max, and mean values, as well as 50, 95, and 99 percentile values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T063100Z" creationid="xccui" creationdate="20190806T063100Z">
        <seg>算子会将延迟统计信息保存在Gauge指标中，其中包含最小值，最大值，平均值以及50、95和99百分位数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that extend GenericWriteAheadSink need to provide three constructor parameters:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T060843Z" creationid="xccui" creationdate="20190715T060843Z">
        <seg>继承自GenericWriteAheadSink的算子需要在构造方法内提供三个参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that implement data ingestion logic are called &lt;t4/&gt;data sources&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152036Z" creationid="xccui" creationdate="20190405T152036Z">
        <seg>实现数据接入操作逻辑的算子称为数据源（data source）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that implement data ingestion logic are called data sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T005820Z" creationid="xccui" creationdate="20190606T005820Z">
        <seg>实现数据接入操作逻辑的算子称为数据源（data source）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that need to be notified about completed check‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T193119Z" creationid="xccui" creationdate="20190702T202152Z">
        <seg>算子为了感知检查点创建成功，可以实现CheckpointListener接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that perform data egress are called &lt;t8/&gt;data sinks&lt;t9/&gt; and exam&lt;t10/&gt;‐&lt;t11/&gt; ples include files, databases, message queues, and monitoring interfaces.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152733Z" creationid="xccui" creationdate="20190405T152512Z">
        <seg>负责数据输出的算子称为数据汇（data sink），其写入的目标包括文件、数据库、消息队列、监控接口等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that perform data egress are called data sinks and examples include files, databases, message queues, and monitoring interfaces.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060316Z" creationid="xccui" creationdate="20190606T010159Z">
        <seg>负责数据输出的算子称为数据汇（data sink），其写入的目标可以是文件、数据库、消息队列以及监控接口等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with keyed state are scaled by repartitioning keys to fewer or more tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190608T055151Z">
        <seg>带有键值分区状态的算子在扩缩容时会根据新的任务数量对键值重新分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with operator broadcast state are scaled up by copying the state to new tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T063024Z" creationid="xccui" creationdate="20190608T061609Z">
        <seg>带有算子广播状态的算子在扩缩容时会把状态拷贝到全部新任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with operator list state are scaled by redistributing the list entries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062333Z" creationid="xccui" creationdate="20190608T060308Z">
        <seg>带有算子列表状态的算子在扩缩容时会对列表中的条目进行重新分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with operator union list state are scaled by broadcasting the full list of state entries to each task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062858Z" creationid="xccui" creationdate="20190608T061211Z">
        <seg>带有算子联合列表状态的算子会在扩缩容时把状态列表的全部条目广播到全部任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators without input ports are called data sources and opera&lt;t4/&gt;‐&lt;t5/&gt; tors without output ports are called data sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190331T223800Z" creationid="xccui" creationdate="20190331T223724Z">
        <seg>没有输入口的算子称为数据源，没有输出口的算子称为数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators without input ports are called data sources and opera‐ tors without output ports are called data sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T043806Z" creationid="xccui" creationdate="20190605T224919Z">
        <seg>没有输入端的算子称为数据源，没有输出端的算子称为数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators, Tasks, and Processing Slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042938Z" creationid="xccui" creationdate="20190423T042938Z">
        <seg>算子、任务以及处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators, tasks, and processing slots</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144442Z" creationid="xccui" creationdate="20190606T144442Z">
        <seg>算子、任务以及处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Option is not defined if the state has not been initialized yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T034548Z" creationid="xccui" creationdate="20190701T034548Z">
        <seg>如果状态尚未初始化则Option为None。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionally output the result to one or more data sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044352Z" creationid="xccui" creationdate="20190612T044352Z">
        <seg>选择性地将结果输出到一个或多个数据汇中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T184156Z" creationid="xccui" creationdate="20190704T184156Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other features include support to upgrade application code or migrate a job to a different cluster or a new version of the stream processor without losing the current state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="xccui" creationdate="20190605T053913Z">
        <seg>此外还有一些新的特性，例如：支持应用代码更新，在不丢失当前状态的前提下将作业迁移至一个新的集群或新版本的流处理引擎等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other features include support to upgrade application code or migrating a job to a different cluster or a new version of the stream processor without losing the current state of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T140840Z" creationid="xccui" creationdate="20190327T140804Z">
        <seg>还有一些特性包括支持应用代码升级，在不丢失当前状态的前提下将作业迁移至一个新的集群或新版本的流处理引擎等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Others more interested in writing Flink code right away might want to read the practical chapters first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041613Z" creationid="esouser" creationdate="20190603T153223Z">
        <seg>或者如果你迫不及待地想开始编写Flink代码，也可以先阅读实践章节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise job recovery might miss metadata that was stored in the temporary directory and fail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043324Z" creationid="xccui" creationdate="20190724T043324Z">
        <seg>否则作业在进行恢复时可能会因为找不到临时目录中的元数据而失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, it returns a local environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045422Z" creationid="xccui" creationdate="20190612T045422Z">
        <seg>否则会返回一个本地环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the default savepoint directory as configured in the flink-conf.yaml file is used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033545Z" creationid="xccui" creationdate="20190726T033545Z">
        <seg>否则，Flink会使用flink-conf.yaml文件中配置的默认保存点路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the operator would have to store the complete stream history.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061442Z" creationid="xccui" creationdate="20190406T035454Z">
        <seg>否则算子就需要存储整个流的历史记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the program fails with a ConnectException because a connection to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T023723Z" creationid="xccui" creationdate="20190714T023631Z">
        <seg>否则程序会因为无法建立套接字连接而抛出ConnectException。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the window operator will accu‐ mulate more and more state over time and your application will probably fail at some</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194322Z" creationid="xccui" creationdate="20190626T194322Z">
        <seg>否则窗口算子的状态会越积越多，最终可能导致你的应用在某个时间出现故障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our TransactionalFileSink in Example 8-15 checks if the transaction file still exists and deletes it if that is the case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053631Z" creationid="xccui" creationdate="20190716T053631Z">
        <seg>示例8-15中的TransactionalFileSink会检查事务文件是否存在，如果存在则将它删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our code exam‐ ples use Scala for conciseness, but the Java API is mostly analogous (exceptions or special cases will be pointed out).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T035509Z" creationid="xccui" creationdate="20190612T034526Z">
        <seg>出于简洁考虑，我们的示例代码还会以Scala版本为主，但绝大多数的Java API都与之类似（如果有例外或特殊情况会指出）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our example application ingests a stream of temperature meas‐ urements from multiple sensors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T041007Z" creationid="xccui" creationdate="20190612T035520Z">
        <seg>示例应用会从多个传感器中获取温度测量数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our implementation in Example 8-15</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053104Z" creationid="xccui" creationdate="20190716T053019Z">
        <seg>示例8-15中，该方法的实现方式是强制写出并关闭事务文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our unique network of experts and innovators share their knowledge and expertise through books, articles, conferences, and our online learning platform.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210831Z" creationid="esouser" creationdate="20190603T210831Z">
        <seg>Our unique network of experts and innovators share their knowledge and expertise through books, articles, conferences, and our online learning platform.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Output the Result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145109Z" creationid="esouser" creationdate="20190603T145109Z">
        <seg>输出结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Output the result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022624Z" creationid="xccui" creationdate="20190225T022624Z">
        <seg>输出结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Over the years the collection and usage of data has grown consistently, and compa‐ nies have designed and built infrastructures to manage that data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T051818Z" creationid="esouser" creationdate="20190603T193927Z">
        <seg>随着数据采集和使用量的不断增长，很多公司都设计并构建了各种基础架构来管理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Source-Generated Timestamps and Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T025549Z" creationid="xccui" creationdate="20190620T025549Z">
        <seg>覆盖数据源生成的时间戳和水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly Media, Inc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210837Z" creationid="esouser" creationdate="20190603T210837Z">
        <seg>O’Reilly Media, Inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly Online Learning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210828Z" creationid="esouser" creationdate="20190603T210828Z">
        <seg>O’Reilly Online Learning</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly books may be purchased for educational, business, or sales promotional use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210716Z" creationid="esouser" creationdate="20190603T210716Z">
        <seg>O’Reilly books may be purchased for educational, business, or sales promotional use.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly’s online learning platform gives you on-demand access to live training courses, in- depth learning paths, interactive coding environments, and a vast collection of text</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210832Z" creationid="esouser" creationdate="20190603T210832Z">
        <seg>O’Reilly’s online learning platform gives you on-demand access to live training courses, in- depth learning paths, interactive coding environments, and a vast collection of text</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PATCH /jobs/&lt;jobID&gt;/rescaling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200947Z" creationid="xccui" creationdate="20190729T200947Z">
        <seg>PATCH /jobs/&lt;jobID&gt;/rescaling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PATCH /jobs/&lt;jobId&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T161809Z" creationid="xccui" creationdate="20190729T161809Z">
        <seg>PATCH /jobs/&lt;jobId&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POJO class with Cassandra Object Mapper annotations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220246Z" creationid="xccui" creationdate="20190711T220246Z">
        <seg>添加了Cassandra Object Mapper注解的POJO类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POJO or case class fields are selected by their field name like in the above example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T042758Z" creationid="xccui" creationdate="20190618T042758Z">
        <seg>POJO或样例类的字段也可以像上面那样根据字段名称进行选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POJOs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T064539Z" creationid="xccui" creationdate="20190617T064539Z">
        <seg>POJO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POJOs, including classes generated by Apache Avro</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065115Z" creationid="xccui" creationdate="20190616T065115Z">
        <seg>POJO（包括Apache Avro生成的类）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POST /jars/&lt;jarId&gt;/run</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T050136Z" creationid="xccui" creationdate="20190729T050136Z">
        <seg>POST /jars/&lt;jarId&gt;/run</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POST /jars/upload</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045512Z" creationid="xccui" creationdate="20190729T045512Z">
        <seg>POST /jars/upload</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POST /jobs/&lt;jobId&gt;/savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162612Z" creationid="xccui" creationdate="20190729T162612Z">
        <seg>POST /jobs/&lt;jobId&gt;/savepoints</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POST /savepoint-disposal</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T193850Z" creationid="xccui" creationdate="20190729T193850Z">
        <seg>POST /savepoint-disposal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PURGE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184625Z" creationid="xccui" creationdate="20190626T184625Z">
        <seg>PURGE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pairs of joined events are passed into a ProcessJoinFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025950Z" creationid="xccui" creationdate="20190628T025950Z">
        <seg>Join成功的事件对会发送给ProcessJoinFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ParallelSourceFunction and RichParallelSourceFunction can be used to define source connectors that run with multiple parallel task instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T145740Z" creationid="xccui" creationdate="20190712T145740Z">
        <seg>ParallelSourceFunction和RichParallelSourceFunction可用于定义能够同时运行多个任务实例的数据源连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parallelization gets complicated, since results depend on both the state and incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T183657Z" creationid="xccui" creationdate="20190606T032919Z">
        <seg>由于结果需要同时依赖状态和到来的事件，所以状态并行化会变得异常复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters The ID of a job as provided by the list application command.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201354Z" creationid="xccui" creationdate="20190729T162708Z">
        <seg>参数 jobId：使用列出应用命令所得到的作业ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters The file must be sent as multipart data Action</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162456Z" creationid="xccui" creationdate="20190729T045622Z">
        <seg>参数 文件必须以Multipart数据形式上传 行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters The path of the savepoint to dispose needs to be provided as a parameter in a JSON object Action</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200727Z" creationid="xccui" creationdate="20190729T200727Z">
        <seg>参数 需要以JSON对象的形式提供要删除的保存点路径 行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters jarId: The ID of the JAR file as provided by the list JAR file command</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162219Z" creationid="xccui" creationdate="20190729T050007Z">
        <seg>参数 jarId：使用列出JAR文件命令所得到的JAR文件ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters jarId: The ID of the JAR file from which the application is started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162234Z" creationid="xccui" creationdate="20190729T050229Z">
        <seg>参数 jarId：启动应用的JAR文件ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters jobID: The ID of a job as provided by the list application command.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201231Z" creationid="xccui" creationdate="20190729T201101Z">
        <seg>参数 jobID：使用列出应用命令所得到的应用ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters jobId: The ID of a job as provided by the list application command</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201155Z" creationid="xccui" creationdate="20190729T153011Z">
        <seg>参数 jorId：使用列出应用命令所得到的作业ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters jobId: The ID of a job as provided by the list application command Action</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162415Z" creationid="xccui" creationdate="20190729T162341Z">
        <seg>参数 jobId：使用列出应用命令所得到的作业ID 行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters tmId: The ID of a connected TaskManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162113Z" creationid="xccui" creationdate="20190729T044720Z">
        <seg>参数 tmId：相连TaskManager的ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Partitioning transformations correspond to the data exchange strategies we intro‐ duced in “Data Exchange Strategies” on page 19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T023702Z" creationid="xccui" creationdate="20190615T064707Z">
        <seg>Flink中的各类分区转换对应我们在第19页"数据交换策略"一节中介绍的多种数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Path: hdfs:///xxx:50070/savepoints/savepoint-bc0b2a-63cf5d5ccef8</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T034945Z" creationid="xccui" creationdate="20190726T034945Z">
        <seg>Path: hdfs:///xxx:50070/savepoints/savepoint-bc0b2a-63cf5d5ccef8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pattern detection or complex event processing (CEP), e.g., for fraud detection in credit card transactions, and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190315T012134Z" creationid="xccui" creationdate="20190307T151505Z">
        <seg>模式识别或复杂事件处理（CEP）（例如：根据信用卡交易记录进行反欺诈），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pattern detection or complex event processing (e.g., for fraud detection in credit card transactions)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055445Z" creationid="esouser" creationdate="20190603T213624Z">
        <seg>模式识别或复杂事件处理（例如：根据信用卡交易记录进行欺诈识别）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pause the ingestion of all input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223558Z" creationid="xccui" creationdate="20190608T223429Z">
        <seg>暂停接收所有输入流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pending Files Might Never Be Committed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T191603Z" creationid="xccui" creationdate="20190711T190933Z">
        <seg>处于等待阶段的文件可能永远无法提交</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pending files</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T190802Z" creationid="xccui" creationdate="20190711T190802Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Per-window state is useful to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T023819Z" creationid="xccui" creationdate="20190624T023819Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performace Implications of Checkpointing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155008Z" creationid="esouser" creationdate="20190603T144627Z">
        <seg>检查点对性能的影响</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performance and Robustness of Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024730Z" creationid="xccui" creationdate="20190225T024730Z">
        <seg>状态化应用的性能及鲁棒性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performance and Robustness of Stateful Applications | 169</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052552Z" creationid="xccui" creationdate="20190707T052552Z">
        <seg>状态化应用的性能及鲁棒性 | 169</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performance and Robustness of Stateful Applications | 171</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052559Z" creationid="xccui" creationdate="20190707T052559Z">
        <seg>状态化应用的性能及鲁棒性 | 171</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performance and Robustness of Stateful Applications | 173</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052604Z" creationid="xccui" creationdate="20190707T052604Z">
        <seg>状态化应用的性能及鲁棒性 | 173</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Periodic assigner: The DataStream API provides a user-defined function called AssignerWithPeriodicWatermarks that extracts a timestamp from each record and is periodically queried for the current watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055335Z" creationid="xccui" creationdate="20190607T034945Z">
        <seg>周期分配器（periodic assigner）：DataStream API提供了一个名为AssignerWithPeriodicWatermarks的用户自定义函数，它可以用来从每条记录提取时间戳，并周期性地响应获取当前水位线的查询请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persistent event logs write all events to durable storage, so that they can be replayed if a task fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193704Z" creationid="xccui" creationdate="20190416T043348Z">
        <seg>持久化事件日志会将所有事件写入永久存储，这样在任务故障时就可以重放它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Person("Adam", 17),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041131Z" creationid="xccui" creationdate="20190617T041131Z">
        <seg>Person("Adam", 17),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Person("Sarah", 23))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041140Z" creationid="xccui" creationdate="20190617T041140Z">
        <seg>Person("Sarah", 23))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Playing online mobile games in the subway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152158Z" creationid="xccui" creationdate="20190411T152153Z">
        <seg>地铁上玩在线手游。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please address comments and questions concerning this book to the publisher:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210836Z" creationid="esouser" creationdate="20190603T210836Z">
        <seg>Please address comments and questions concerning this book to the publisher:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note that &lt;t0/&gt;Figure 3-1&lt;t1/&gt; is a high-level sketch to visualize the responsibilities and interactions of the components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024651Z" creationid="xccui" creationdate="20190423T024651Z">
        <seg>注意，图3-1仅仅从一个较高层次上展示了各组件的职责与交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Policies can be based on time (e.g. events received in the last 5 seconds), on count (e.g. the last 100 events), or on a data property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T050402Z" creationid="xccui" creationdate="20190406T050241Z">
        <seg>决策可以基于时间（例如：最近5秒钟接收的事件）、数量（例如：最新100个事件）或其他数据属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Policies can be based on time (e.g., events received in the last five seconds), on count (e.g., the last one hundred events), or on a data property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063250Z" creationid="xccui" creationdate="20190606T012927Z">
        <seg>策略的指定可以基于时间（例如：最近5秒钟接收的事件）、数量（例如：最新100个事件）或其他数据属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Possible consistency values are:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T210221Z" creationid="xccui" creationdate="20190709T205931Z">
        <seg>可能的一致性选项有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preaggregation and Evictors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203511Z" creationid="xccui" creationdate="20190627T203511Z">
        <seg>预聚合与移除器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T040256Z" creationid="xccui" creationdate="20190225T040256Z">
        <seg>序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface | xi</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130342Z" creationid="xccui" creationdate="20190605T130342Z">
        <seg>序言 | xi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface | xiii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130355Z" creationid="xccui" creationdate="20190605T130355Z">
        <seg>序言 | xiii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T013841Z" creationid="xccui" creationdate="20190225T013841Z">
        <seg>序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preventing Leaking State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024832Z" creationid="xccui" creationdate="20190225T024832Z">
        <seg>防止状态泄露</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously in this chapter, we described the common architecture for data analytics pipelines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T025235Z" creationid="xccui" creationdate="20190317T025021Z">
        <seg>本章前面已经介绍了数据分析管道的通用架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primitives</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T071237Z" creationid="xccui" creationdate="20190615T071237Z">
        <seg>原始类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printed in the United States of America.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210713Z" creationid="esouser" creationdate="20190603T210713Z">
        <seg>Printed in the United States of America.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145830Z" creationid="xccui" creationdate="20190418T035908Z">
        <seg>处理函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process Functions | 117</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041911Z" creationid="xccui" creationdate="20190629T041911Z">
        <seg>处理函数 | 117</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process Functions | 121</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041946Z" creationid="xccui" creationdate="20190629T041946Z">
        <seg>处理函数 | 121</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process functions are com‐ monly used to build event-driven applications and to implement custom logic for which predefined windows and transformations might not be suitable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062009Z" creationid="xccui" creationdate="20190621T044500Z">
        <seg>处理函数常被用于构建事件驱动型应用，或实现一些内置窗口及转换可能不太适合的自定义逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process functions are discussed in more detail in Chapter 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025612Z" creationid="xccui" creationdate="20190607T025612Z">
        <seg>我们会在第6章详细讨论处理函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process functions can also be implemented to support late data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T040440Z" creationid="xccui" creationdate="20190629T034857Z">
        <seg>我们同样可以在处理函数中应对数据迟到的情况，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process functions can emit a record to one or more side outputs via the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T015113Z" creationid="xccui" creationdate="20190622T015113Z">
        <seg>处理函数可以利用Context对象将记录发送至一个或多个副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ProcessWindowFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005621Z" creationid="xccui" creationdate="20190624T005621Z">
        <seg>ProcessWindowFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ProcessWindowFunction is a very powerful window function, but you need to use it with caution since it typically holds more data in state than incrementally aggregating</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034846Z" creationid="xccui" creationdate="20190625T034829Z">
        <seg>ProcessWindowFunction是一个功能十分强大的窗口函数，但你在用它的时候需要小心，因为它和增量聚合函数比起来通常需要在状态中保存更多数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ProcessWindowFunction[(String, Double, Double), MinMaxTemp, String, TimeWindow] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045138Z" creationid="xccui" creationdate="20190625T045138Z">
        <seg>ProcessWindowFunction[(String, Double, Double), MinMaxTemp, String, TimeWindow] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Streams in Parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054741Z" creationid="esouser" creationdate="20190603T143915Z">
        <seg>并行流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Streams in Parallel | 21</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041420Z" creationid="xccui" creationdate="20190606T041420Z">
        <seg>并行数据流处理 | 21</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144150Z" creationid="esouser" creationdate="20190603T144150Z">
        <seg>处理时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Time Versus Event Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144227Z" creationid="esouser" creationdate="20190603T144227Z">
        <seg>处理时间 vs. 事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing streams in parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015430Z" creationid="xccui" creationdate="20190225T015047Z">
        <seg>并行数据流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020340Z" creationid="xccui" creationdate="20190225T020340Z">
        <seg>处理时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time is the time of the local clock on the machine where the operator pro&lt;t0/&gt;‐&lt;t1/&gt; cessing the stream is being executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T144610Z" creationid="xccui" creationdate="20190412T143933Z">
        <seg>处理时间是当前流处理算子所在机器上的本地时钟时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time is the time of the local clock on the machine where the operator pro‐ cessing the stream is being executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023826Z" creationid="xccui" creationdate="20190606T023826Z">
        <seg>处理时间是当前流处理算子所在机器上的本地时钟时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time vs. event time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020419Z" creationid="xccui" creationdate="20190225T020419Z">
        <seg>处理时间 vs. 事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing- time windows trigger based on machine time and include whatever elements happen to have arrived at the operator until that point in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T045243Z" creationid="xccui" creationdate="20190619T065139Z">
        <seg>处理时间窗口基于机器时间触发，它可以涵盖触发时间点之前到达算子的任意元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time can be applicable for applications with very low latency requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042414Z" creationid="xccui" creationdate="20190328T042346Z">
        <seg>处理时间能够用在具有极低延迟需求的应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time semantics can be used for applications with very low latency requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054156Z" creationid="xccui" creationdate="20190605T054156Z">
        <seg>处理时间语义能够用在具有极低延迟需求的应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time timers fire immediately after the registering method returns.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T070456Z">
        <seg>处理时间的计时器会在注册方法返回后立即触发，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time windows introduce the lowest latency possi&lt;t6/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043855Z" creationid="xccui" creationdate="20190414T041008Z">
        <seg>它能够将延迟降至最低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time windows introduce the lowest latency possi‐ ble.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180444Z" creationid="xccui" creationdate="20190606T030730Z">
        <seg>处理时间窗口能够将延迟降至最低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ProcessingTime</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T064851Z" creationid="xccui" creationdate="20190619T064851Z">
        <seg>ProcessingTime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prometheus</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055512Z" creationid="xccui" creationdate="20190804T055512Z">
        <seg>Prometheus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T042451Z" creationid="xccui" creationdate="20190709T042451Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provided Connectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030757Z" creationid="xccui" creationdate="20190225T025117Z">
        <seg>内置连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provided Connectors | 187</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023225Z" creationid="xccui" creationdate="20190717T023225Z">
        <seg>内置连接器 | 187</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provided Connectors | 191</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023229Z" creationid="xccui" creationdate="20190717T023229Z">
        <seg>内置连接器 | 191</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provided Connectors | 193</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T023235Z" creationid="xccui" creationdate="20190717T023235Z">
        <seg>内置连接器 | 193</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing exactly-once guarantees requires at-least-once guarantees, and thus a data replay mechanism is again necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034836Z" creationid="xccui" creationdate="20190606T034836Z">
        <seg>提供精确一次保障是以至少一次保障为前提，因此同样需要数据重放机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing exactly-once guarantees requires at-least-once guarantees, thus a data replay mechanism is again necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044408Z" creationid="xccui" creationdate="20190416T044337Z">
        <seg>提供精确一次保障是以至少一次保障为前提，因此同样需要数据重放机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210715Z" creationid="esouser" creationdate="20190603T210715Z">
        <seg>Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Punctuated assigner: AssignerWithPunctuatedWatermarks is another user- defined function that extracts a timestamp from each record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055401Z" creationid="xccui" creationdate="20190607T035758Z">
        <seg>定点分配器（punctuated assigner）：另一个支持从记录中提取时间戳的用户自定义函数叫做AssignerWithPunctuatedWatermarks。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queries can be executed for batch or streaming analysis without modification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T160754Z" creationid="xingcan" creationdate="20190807T160754Z">
        <seg>你无须修改查询就可以将它们用于批或流的分析之中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queryable State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151202Z" creationid="xccui" creationdate="20190225T024940Z">
        <seg>可查询式状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queryable State | 177</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052633Z" creationid="xccui" creationdate="20190707T052633Z">
        <seg>可查询式状态 | 177</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queryable State | 181</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052640Z" creationid="xccui" creationdate="20190707T052640Z">
        <seg>可查询式状态 | 181</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queryable state does not address all use cases that require an external datastore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T035842Z" creationid="xccui" creationdate="20190705T163738Z">
        <seg>可查询式状态无法应对全部需要外部数据存储的用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queryable state is an easy-to-use feature and can save you the effort of setting up and maintaining a database or key-value store to expose the results of a streaming application to external applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051717Z" creationid="xccui" creationdate="20190707T051717Z">
        <seg>作为一种方便使用的功能，可查询式状态支持将流式应用的结果暴露给外部应用，从而为你节省设置和维护数据库或键值存储的工作量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Querying State from External Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025041Z" creationid="xccui" creationdate="20190225T025041Z">
        <seg>从外部系统查询状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Quite often the logic that needs to be applied on a window can be expressed as an incremental aggregation, but it also needs access to window metadata or state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T045608Z" creationid="xccui" creationdate="20190625T035301Z">
        <seg>其实很多情况下用于窗口的逻辑都可以表示为增量聚合，只不过还需要访问窗口的元数据或状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST command looks like:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T211718Z" creationid="xccui" creationdate="20190729T041108Z">
        <seg>一个典型的curl REST命令就像下面这样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST point:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T041917Z" creationid="xccui" creationdate="20190729T041917Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to cancel an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T161800Z" creationid="xccui" creationdate="20190729T161800Z">
        <seg>取消应用的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to delete a JAR file</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045855Z" creationid="xccui" creationdate="20190729T045855Z">
        <seg>删除JAR文件的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to dispose a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T193847Z" creationid="xccui" creationdate="20190729T193847Z">
        <seg>删除保存点的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to get basic cluster information</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T043758Z" creationid="xccui" creationdate="20190729T043758Z">
        <seg>获取集群基本信息的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to get the JobManager configuration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T043905Z" creationid="xccui" creationdate="20190729T043905Z">
        <seg>获取JobManager配置的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to list all applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T152718Z" creationid="xccui" creationdate="20190729T152718Z">
        <seg>列出所有应用程序的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to list all connected TaskManagers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044013Z" creationid="xccui" creationdate="20190729T044013Z">
        <seg>列出所有相连的TaskManager的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to list all uploaded JAR files</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T212656Z" creationid="xccui" creationdate="20190729T045749Z">
        <seg>列出所有已上传JAR文件的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to list available JobManager metrics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044317Z" creationid="xccui" creationdate="20190729T044317Z">
        <seg>列出JobManager可用指标的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to list available TaskManager metrics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044652Z" creationid="xccui" creationdate="20190729T044652Z">
        <seg>列出TaskManager可用指标的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to rescale an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200944Z" creationid="xccui" creationdate="20190729T200944Z">
        <seg>用于应用扩缩容的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to show details of an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045313Z" creationid="xccui" creationdate="20190729T045313Z">
        <seg>展示应用详细信息的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to shutdown the cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045058Z" creationid="xccui" creationdate="20190729T045058Z">
        <seg>关闭集群的REST调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to start an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T050132Z" creationid="xccui" creationdate="20190729T050132Z">
        <seg>启动应用的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to take a savepoint of an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162609Z" creationid="xccui" creationdate="20190729T162609Z">
        <seg>为应用生成保存点的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>REST request to upload a JAR file</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045508Z" creationid="xccui" creationdate="20190729T045508Z">
        <seg>上传JAR包的REST请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RETAIN_ON_CANCELLATION retains the checkpoint after the application completely fails and when it is explicitly canceled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T205443Z" creationid="xccui" creationdate="20190731T205443Z">
        <seg>RETAIN_ON_CANCELLATION在应用完全失败和显式取消时保留检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Random</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043113Z" creationid="xccui" creationdate="20190614T064954Z">
        <seg>随机</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read an Input Stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145047Z" creationid="esouser" creationdate="20190603T145047Z">
        <seg>读取输入流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read an input stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022556Z" creationid="xccui" creationdate="20190225T022556Z">
        <seg>读取输入流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read offsets of Kafka topic partitions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T205806Z" creationid="xccui" creationdate="20190708T205806Z">
        <seg>从Kafka主题分区的读取偏移</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read one or more streams from data sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043536Z" creationid="xccui" creationdate="20190612T043536Z">
        <seg>从数据源中读取一条或多条流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading from and Writing to External</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T053617Z" creationid="xccui" creationdate="20190707T053617Z">
        <seg>读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading from and Writing to External Systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025053Z" creationid="xccui" creationdate="20190225T025053Z">
        <seg>读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-World Streaming Use-Cases and Deployments</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T212518Z" creationid="esouser" creationdate="20190603T212425Z">
        <seg>真实的流处理用例及部署方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-time metric plots</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T145433Z" creationid="xingcan" creationdate="20190802T145433Z">
        <seg>实时绘制指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-time recommendations (e.g., for recommending products while customers browse a retailer’s website)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055440Z" creationid="esouser" creationdate="20190603T213611Z">
        <seg>实时推荐（例如：在客户浏览商家页面的同时进行产品推荐）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-time recommendations, e.g., for recommending products while customers browse on a retailer’s website,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T151655Z" creationid="xccui" creationdate="20190307T025808Z">
        <seg>实时推荐（例如：在客户浏览商家页面的同时进行产品推荐），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-world sys&lt;t2/&gt;‐&lt;t3/&gt; tems, networks, and communication channels are far from perfect, thus streaming data can often be delayed or arrive out-of-order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T201230Z" creationid="xccui" creationdate="20190409T201230Z">
        <seg>真实世界的系统、网络、通信信道充斥缺陷，因此流数据通常都会有所延迟或以乱序到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-world systems, net‐ works, and communication channels are far from perfect, and streaming data can often be delayed or arrive out of order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064149Z" creationid="xccui" creationdate="20190606T014251Z">
        <seg>现实世界的系统、网络及通信信道往往充斥缺陷，因此流数据通常都会有所延迟或者以乱序到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rebalance and rescale transformations Broadcast</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045642Z" creationid="xccui" creationdate="20190616T045642Z">
        <seg>随机和重调转换 广播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receiving Notifications About Completed Checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155015Z" creationid="esouser" creationdate="20190603T151120Z">
        <seg>接收检查点完成通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receiving Notifications about Completed Checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024630Z" creationid="xccui" creationdate="20190225T024630Z">
        <seg>接收Checkpoint完成通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reconfiguring, scaling, or updating a batch application can be done between executions, which is a lot easier than upgrading an application that is continuously ingesting, processing, and emit‐ ting data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T160831Z" creationid="xccui" creationdate="20190726T005656Z">
        <seg>批处理应用的配置调整、扩缩容或更新可以在它执行间隙完成；而升级一个持续接收、处理数据，并发出结果的应用则要困难很多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records can be emitted together with an associated timestamp, and watermarks can be emitted at any point in time as special records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054705Z" creationid="xccui" creationdate="20190607T034317Z">
        <seg>每个发出的记录都可以附加一个时间戳，水位线可以作为特殊记录在任何时间点发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records that are produced by a function are separately handed over to the next function with  a simple method call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203657Z" creationid="xccui" creationdate="20190606T203657Z">
        <seg>函数生成的记录只需通过简单的方法调用就可以分别发往各自的下游函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records that are produced by a function are separately handed over to the next function with a simple method call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152951Z" creationid="esouser" creationdate="20190514T152951Z">
        <seg>函数生成的记录只需通过简单的方法调用就可以分别发往各自的下游函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records that arrive on partitions that forwarded a barrier already cannot be processed and are buf‐ fered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162650Z" creationid="xccui" creationdate="20190609T162559Z">
        <seg>对于已经提供分隔符的分区，它们新到来的记录会被缓冲起来，不能处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recovering an application from a checkpoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035923Z" creationid="xccui" creationdate="20190609T035923Z">
        <seg>从检查点恢复应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recovery from a Consistent Checkpoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154850Z" creationid="xccui" creationdate="20190225T022157Z">
        <seg>从一致性检查点中恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redirecting Late Events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150750Z" creationid="xccui" creationdate="20190225T023448Z">
        <seg>重定向迟到事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reduce</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061233Z" creationid="xccui" creationdate="20190614T061233Z">
        <seg>Reduce</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReduceFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211922Z" creationid="xccui" creationdate="20190623T211922Z">
        <seg>ReduceFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReduceFunction and AggregateFunction are incremental aggregation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211000Z" creationid="xccui" creationdate="20190623T211000Z">
        <seg>ReduceFunction和AggregateFunction就属于增量聚合函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReduceFunction and AggregateFunction are incrementally applied on events that are assigned to a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T040300Z" creationid="xccui" creationdate="20190624T005741Z">
        <seg>ReduceFunction和AggregateFunction都是增量地应用于分配到窗口的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReduceFunction defines the reduce() method, which takes two input events and returns an event of the same type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T053201Z" creationid="xccui" creationdate="20190614T061856Z">
        <seg>它当中定义的reduce()方法每次接收两个输入事件，生成一个类型相同的输出事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReduceFunction or AggregateFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033307Z" creationid="xccui" creationdate="20190626T033307Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reducing the size of a network buffer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T040843Z" creationid="xccui" creationdate="20190724T040843Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReducingState[T] offers the same methods as ListState[T] (except for addAll() and update()), but instead of appending values to a list, Reducing State.add(value: T) immediately aggregates value using a ReduceFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T022144Z" creationid="xccui" creationdate="20190630T060310Z">
        <seg>ReducingState[T]提供了和ListState[T]相同的方法（除了addAll()和update()），但它的ReducingState.add(value: T)方法会立刻返回一个使用ReduceFunction聚合后的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refer to the Flink documentation to learn about a few other corner cases when enabling exactly-once consistency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T032453Z" creationid="xccui" creationdate="20190710T032453Z">
        <seg>请查看Flink文档了解更多有关启用精确一次一致性时的特殊情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refer to the documenta‐ tion for a reference of available parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T012921Z" creationid="xccui" creationdate="20190719T012826Z">
        <seg>有关它们的详细信息，请参阅文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refer to the official documentation of Apache Flink for a complete list of supported calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T212244Z" creationid="xccui" creationdate="20190729T042817Z">
        <seg>欲获取所支持的完整调用列表，请参阅Apache Flink官方文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refer to “Filesystem Configuration” on page 237 to learn how to configure filesystems in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T184814Z" creationid="xccui" creationdate="20190710T184814Z">
        <seg>有关如何在Flink中配置这些文件系统，请参阅第237页"文件系统配置"一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refer to “Implementing Stateful Functions” on page 154, which discusses stateful functions in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T045701Z" creationid="xccui" creationdate="20190614T045650Z">
        <seg>有关状态化函数的详细信息请参阅第154页"实现状态化函数"一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of whether you keyBy() ConnectedStreams or you connect() two Keyed Streams, the connect() transformation will route all events from both streams with the same key to the same operator instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050651Z" creationid="xccui" creationdate="20190615T050651Z">
        <seg>无论你是对ConnectedStreams执行keyBy()还是对两个已经按键值分好区的数据流执行connect()，connect()转换都会将两个数据流中具有相同键值的事件发往同一个算子实例上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of whether you run Flink in job or session mode on YARN, it needs to have access to Hadoop dependencies in the correct version and the path to the Hadoop configuration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T142048Z" creationid="xccui" creationdate="20190719T011857Z">
        <seg>无论是在YARN上以作业还是会话模式运行，Flink都需要访问正确版本的Hadoop依赖以及Hadoop配置所在路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Registering and using metrics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015102Z" creationid="xccui" creationdate="20190803T015102Z">
        <seg>注册和使用指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Registering and using metrics in a FilterFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015226Z" creationid="xccui" creationdate="20190803T015226Z">
        <seg>在FilterFunction中注册和使用指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removing State from an Application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024915Z" creationid="xccui" creationdate="20190225T024915Z">
        <seg>从应用中删除状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removing a state from the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035722Z" creationid="xccui" creationdate="20190705T035722Z">
        <seg>从应用中移除某个状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reporter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055440Z" creationid="xccui" creationdate="20190804T055440Z">
        <seg>汇报器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reporters need to be configured in flink-conf.yaml.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055733Z" creationid="xccui" creationdate="20190804T055733Z">
        <seg>汇报器需要在flink-conf.yaml中配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Represents state as a list of entries as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060503Z" creationid="xccui" creationdate="20190607T184334Z">
        <seg>同样是将状态表示为一个条目列表，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Represents state as a list of entries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060447Z" creationid="xccui" creationdate="20190607T184245Z">
        <seg>将状态表示为一个条目列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reprocessing all input to reproduce lost state in the case of failures would be both very expensive and time-consuming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T040947Z" creationid="xccui" creationdate="20190415T040923Z">
        <seg>通过重新处理所有输入来重建故障时丢失的状态，不仅代价高，而且非常耗时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reprocessing all input to reproduce lost state in the case of fail‐ ures would be both very expensive and time-consuming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185116Z" creationid="xccui" creationdate="20190606T033139Z">
        <seg>通过重新处理所有输入来重建故障期间丢失的状态，不仅代价高，而且还很耗时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162052Z" creationid="xccui" creationdate="20190729T044322Z">
        <seg>请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request DELETE /cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045100Z" creationid="xccui" creationdate="20190729T045100Z">
        <seg>Request DELETE /cluster</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request GET /jobmanager/config</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162040Z" creationid="xccui" creationdate="20190729T043908Z">
        <seg>请求 GET /jobmanager/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request GET /overview</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162023Z" creationid="xccui" creationdate="20190729T043801Z">
        <seg>请求 GET /overview</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request GET /taskmanagers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162004Z" creationid="xccui" creationdate="20190729T044024Z">
        <seg>请求 GET /taskmanagers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required Software</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022254Z" creationid="xccui" creationdate="20190225T022254Z">
        <seg>所需软件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requirements also differ when it comes to evaluating performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050222Z" creationid="xccui" creationdate="20190401T150306Z">
        <seg>而这些需求差异还体现在性能评测方面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rescale</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043443Z" creationid="xccui" creationdate="20190616T043443Z">
        <seg>重调</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rescaled job bc0b2ad61ecd4a615d92ce25390f61ad.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190728T071916Z" creationid="xccui" creationdate="20190728T071916Z">
        <seg>Rescaled job bc0b2ad61ecd4a615d92ce25390f61ad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reset the states of all stateful tasks to the latest checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040226Z" creationid="xccui" creationdate="20190609T040149Z">
        <seg>利用最新的检查点重置任务状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resettable Source Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055036Z" creationid="xccui" creationdate="20190225T025236Z">
        <seg>可重置的数据源函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162115Z" creationid="xccui" creationdate="20190729T044723Z">
        <seg>响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response A list of all uploaded JAR files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T212918Z" creationid="xccui" creationdate="20190729T045818Z">
        <seg>响应 所有已上传JAR文件的列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response Basic information about the cluster as shown above</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162036Z" creationid="xccui" creationdate="20190729T043835Z">
        <seg>响应 上方展示的基本的集群信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response Lists the job IDs of all running applications and the job IDs of the most recently failed, canceled, and finished</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162243Z" creationid="xccui" creationdate="20190729T152905Z">
        <seg>响应 所有正在运行应用的作业ID列表以及近期失败的、取消的和结束应用的作业ID列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response Returns a list of all TaskManagers including their IDs and basic information, such as memory statistics and connection ports</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162015Z" creationid="xccui" creationdate="20190729T044145Z">
        <seg>响应 返回一个涵盖所有TaskManager的列表，其中包括它们的ID以及基本信息，例如内存统计数据以及连接的端口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response Returns a list of metrics that are available for the JobManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162103Z" creationid="xccui" creationdate="20190729T044403Z">
        <seg>响应 返回JobManager上可获得的指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Response Returns the configuration of the JobManager as defined in ./conf/flink-conf.yaml</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162048Z" creationid="xccui" creationdate="20190729T043934Z">
        <seg>响应 返回./conf/flink-conf/yaml中定义的JobManager配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restart strategies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T151131Z" creationid="xingcan" creationdate="20190801T151131Z">
        <seg>重启策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restart strategies are discussed in more detail in Chapter 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T150158Z" creationid="xccui" creationdate="20190606T150158Z">
        <seg>重启策略会在第10章详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restart strategies will be discussed in more detail in Chapter 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051610Z" creationid="xccui" creationdate="20190502T051440Z">
        <seg>重启策略会在第10章详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restart the whole application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040129Z" creationid="xccui" creationdate="20190609T040129Z">
        <seg>重启整个应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RestartStrategies.fixedDelayRestart(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154422Z" creationid="xingcan" creationdate="20190801T154422Z">
        <seg>RestartStrategies.fixedDelayRestart(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restoring the state of an application is described in a later section of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205243Z" creationid="xccui" creationdate="20190428T205226Z">
        <seg>恢复应用状态将会在本章的稍后一节进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restoring the state of an application is described in “Recovery from a Con‐ sistent Checkpoint” on page 60.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072238Z" creationid="xccui" creationdate="20190606T145348Z">
        <seg>而恢复应用状态则会在第60页"从一致性检查点恢复"一节进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Result Guarantees</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144259Z" creationid="esouser" creationdate="20190603T144259Z">
        <seg>结果保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Result guarantees</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021628Z" creationid="xccui" creationdate="20190225T021628Z">
        <seg>结果保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resume the ingestion of all streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224318Z" creationid="xccui" creationdate="20190608T224238Z">
        <seg>恢复所有数据流的接收。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resume the processing of all tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040646Z" creationid="xccui" creationdate="20190609T040646Z">
        <seg>恢复所有任务的处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retaining checkpoints after an application has stopped</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T204910Z" creationid="xccui" creationdate="20190731T204910Z">
        <seg>应用停止后保留检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a list of metrics available for the chosen TaskManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044753Z" creationid="xccui" creationdate="20190729T044753Z">
        <seg>返回指定TaskManager上可获得的指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revision History for the First Edition</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210732Z" creationid="esouser" creationdate="20190603T210732Z">
        <seg>Revision History for the First Edition</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revisiting the coffee shop example, if the shop is open from 7 a.m. to 7 p.m. and it serves 600 customers in one day, then its average throughput would be 50 customers per hour.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234402Z" creationid="xccui" creationdate="20190605T234402Z">
        <seg>回到刚刚咖啡店的例子，如果它的营业时间是早7点到晚7点，并且一天服务了600名顾客，那么它的平均吞吐是每小时50人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revisiting the coffee shop example, if the shop is open from 7am to 7pm and it serves 600 customers in one day, then its average throughput would be 50 customers per hour.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195720Z" creationid="xccui" creationdate="20190401T195656Z">
        <seg>回到刚刚咖啡店的例子，如果它的营业时间是早7点到晚7点，并且一天服务了600名顾客，那么它的平均吞吐是每小时50人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rich Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022929Z" creationid="xccui" creationdate="20190225T022929Z">
        <seg>富函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rich functions can be parameterized just like regular function classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060523Z" creationid="xccui" creationdate="20190618T060523Z">
        <seg>富函数可以像普通函数类一样接收参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rich functions were discussed in Chapter 5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152340Z" creationid="xccui" creationdate="20190712T152340Z">
        <seg>富函数已经在第5章讨论过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Right after the application was restarted it is in a catch-up phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T145606Z" creationid="xingcan" creationdate="20190801T145606Z">
        <seg>在应用刚刚重启过后，它还处在一个追赶阶段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RocksDB is an embedded key-value store that persists data to the local disk.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T023628Z" creationid="xccui" creationdate="20190704T023628Z">
        <seg>RocksDB是一个嵌入式键值存储（key-value store），它可以将数据保存到本地磁盘上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RocksDB is another memory consumer that needs to be taken into consideration when configuring the memory of a worker process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T041338Z" creationid="xccui" creationdate="20190724T041259Z">
        <seg>我们在为工作进程配置内存时还需要考虑RocksDB的占用量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RocksDB state backend with incremental checkpoints and storing the timers on the heap (default setting), they are checkpointed synchronously.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T065821Z">
        <seg>如果你在使用开启了增量检查点模式RocksDB状态后端，且将计时器存储在堆内（默认设置），计时器写入检查点的过程就会是同步的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RocksDBStateBackend is always writing checkpoints asynchronously:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025002Z" creationid="xccui" creationdate="20190801T025002Z">
        <seg>RocksDBStateBackend生成检查点的过程总是异步进行的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RocksDBStateBackend only requires a path to define the storage location for check‐ points and takes an optional parameter to enable incremental checkpoints (disabled by default).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T024938Z" creationid="xccui" creationdate="20190801T024938Z">
        <seg>RocksDBStateBackend只需一个用于定义检查点存储位置的路径，此外还有一个可选参数可用来启用增量检查点（默认关闭）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RocksDBStateBackend stores all state into local RocksDB instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T023459Z" creationid="xccui" creationdate="20190704T023459Z">
        <seg>RocksDBStateBackend会把全部状态存到本地RocksDB实例中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rolling aggregation transformations are applied on a KeyedStream and produce a DataStream of aggregates, such as sum, minimum, and maximum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T050350Z" creationid="xccui" creationdate="20190614T052018Z">
        <seg>滚动聚合转换作用于KeyedStream上，它将生成一个包含聚合结果（例如求和、最小值、最大值等）的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rolling aggregations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T160158Z" creationid="xccui" creationdate="20190405T160158Z">
        <seg>滚动聚合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Round-Robin</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031352Z" creationid="xccui" creationdate="20190615T071053Z">
        <seg>轮流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run Flink Applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144911Z" creationid="esouser" creationdate="20190603T144911Z">
        <seg>在IDE中运行Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run Flink applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022339Z" creationid="xccui" creationdate="20190225T022339Z">
        <seg>在IDE中运行Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run and Debug Flink Applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144840Z" creationid="esouser" creationdate="20190603T144840Z">
        <seg>在IDE中运行和调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run and Debug Flink Applications in an IDE | 73</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012826Z" creationid="xccui" creationdate="20190612T012826Z">
        <seg>在IDE中执行和调试Flink程序 | 73</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run and debug Flink applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022308Z" creationid="xccui" creationdate="20190225T022308Z">
        <seg>在IDE中执行和调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the command nc -l localhost 9191 on Linux</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T023909Z" creationid="xccui" creationdate="20190714T023909Z">
        <seg>你可以通过运行linux命令"nc -l localhost 9191"来监听localhost:9191端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the example on your local cluster by specifying the applications entry class and the JAR file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035936Z" creationid="xccui" creationdate="20190329T035919Z">
        <seg>通过指定应用的入口类和JAR文件，在你的本地集群上运行示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the example on your local cluster by specifying the application’s entry class and JAR file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201345Z" creationid="xccui" creationdate="20190605T123600Z">
        <seg>通过指定应用的入口类和JAR文件，在你本地集群上运行示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running Flink in Docker is an easy way to set up a Flink cluster on your local machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T140559Z" creationid="xccui" creationdate="20190718T022051Z">
        <seg>你可以利用Docker轻松在本地机器上搭建Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running Job-Specific Images on Minikube</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T044429Z" creationid="xccui" creationdate="20190730T044429Z">
        <seg>在Minikube上运行针对特定作业的镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running Kubernetes on a Local Machine</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T024102Z" creationid="xccui" creationdate="20190719T024102Z">
        <seg>在本地机器上运行Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running Your First Flink Application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T211803Z" creationid="esouser" creationdate="20190603T143056Z">
        <seg>运行首个Flink应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running a job-specific Docker image on Kubernetes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T035411Z" creationid="xccui" creationdate="20190730T035348Z">
        <seg>在Kubernetes上运行针对特定作业的Docker镜像</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running a job-specific Docker image on Kubernetes is very similar to starting a Flink cluster on Kubernetes as described in “Kubernetes” on page 228.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T035515Z" creationid="xccui" creationdate="20190730T035408Z">
        <seg>在Kubernetes上运行针对特定作业的Docker镜像和第228页"Kubernetes"中描述的在Kubernetes上启动Flink集群非常类似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running a job-specific image on a Minikube cluster requires a few more steps than those discussed in “Kubernetes” on page 228.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T214024Z" creationid="xccui" creationdate="20190730T044836Z">
        <seg>在Minikube集群上运行针对特定作业的镜像比我们在228页"Kubernetes"一节中所讨论的步骤要复杂一些。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running and Managing Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025908Z" creationid="xccui" creationdate="20190225T025908Z">
        <seg>运行并管理流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running and Managing Streaming Applications | 247</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040215Z" creationid="xccui" creationdate="20190807T040215Z">
        <seg>运行并管理流式应用 | 247</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running and Managing Streaming Applications | 251</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040220Z" creationid="xccui" creationdate="20190807T040220Z">
        <seg>运行并管理流式应用 | 251</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running and Managing Streaming Applications | 253</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040225Z" creationid="xccui" creationdate="20190807T040225Z">
        <seg>运行并管理流式应用 | 253</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S3 paths are specified with the s3:// scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T043921Z" creationid="xccui" creationdate="20190722T043921Z">
        <seg>S3路径的协议是s3://。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Savepoint 'hdfs:///xxx:50070/savepoints/savepoint-bc0b2a-63cf5d5ccef8' disposed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035212Z" creationid="xccui" creationdate="20190726T035212Z">
        <seg>Savepoint 'hdfs:///xxx:50070/savepoints/savepoint-bc0b2a-63cf5d5ccef8' disposed.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Savepoint completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T034942Z" creationid="xccui" creationdate="20190726T034942Z">
        <seg>Savepoint completed.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Savepoint stored in hdfs:///xxx:50070/savepoints/savepoint-bc0b2a-d08de07fbb10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T184704Z" creationid="xccui" creationdate="20190726T184704Z">
        <seg>Savepoint stored in hdfs:///xxx:50070/savepoints/savepoint-bc0b2a-d08de07fbb10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144644Z" creationid="xccui" creationdate="20190418T035333Z">
        <seg>保存点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Savepoints are taken concurrently with checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T203423Z" creationid="xccui" creationdate="20190731T203245Z">
        <seg>保存点的生成会和检查点并发进行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Savepoints can occupy a significant amount of space and are not automatically deleted by Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035034Z" creationid="xccui" creationdate="20190726T035034Z">
        <seg>保存点可能占用大量空间，且Flink不会自动将其删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Save‐ point state can only be restored to an operator of a started application if their identifi‐ ers are identical.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T024117Z" creationid="xccui" creationdate="20190703T022647Z">
        <seg>只有当目标应用的算子标识和保存点中的算子标识相同时，状态才能顺利恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scala DataStream API shortcut for a FlatMap with a keyed ValueState</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T040821Z" creationid="xccui" creationdate="20190701T023016Z">
        <seg>利用Scala DataStream API中的简写功能实现只有一个键值分区ValueState的FlatMap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scala case classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065042Z" creationid="xccui" creationdate="20190616T065042Z">
        <seg>Scala样例类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalable stream processing technology is rapidly maturing and evolving due to the efforts of many open source communities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160226Z" creationid="xccui" creationdate="20190319T053253Z">
        <seg>得益于众多开源社区的努力，可伸缩的流处理技术能够迅速发展和成熟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling Stateful Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T032530Z" creationid="xccui" creationdate="20190225T022106Z">
        <seg>状态化算子扩缩容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an Application In and Out</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T050414Z" creationid="xccui" creationdate="20190727T050414Z">
        <seg>应用的扩缩容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with keyed state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190608T060217Z">
        <seg>算子扩缩容时键值分区状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with operator broadcast state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062304Z" creationid="xccui" creationdate="20190607T060257Z">
        <seg>算子扩缩容时算子广播状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with operator list state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061028Z" creationid="xccui" creationdate="20190608T061028Z">
        <seg>算子扩缩容时算子列表状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with operator union list state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061516Z" creationid="xccui" creationdate="20190608T061516Z">
        <seg>算子扩缩容时算子联合列表状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling and fault tolerance are handled by the stream processor, and by leveraging an event log as the input source the complete input of an application is reliably stored and can be deterministi‐ cally replayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T034218Z" creationid="xccui" creationdate="20190604T043856Z">
        <seg>伸缩和容错交由流处理引擎完成；以事件日志作为应用的输入，不但完整可靠，而且还支持精准的数据重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling and fault-tolerance do not need special consideration because these aspects are handled by the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014605Z" creationid="xccui" creationdate="20190312T212356Z">
        <seg>无须考虑伸缩性和容错性。这些都交给流处理引擎处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scheduling tasks as slices to slots has the advantage that many tasks are co-located on the TaskManager which means that they can efficiently exchange data within the the same process and without accessing the network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062846Z" creationid="xccui" creationdate="20190424T061942Z">
        <seg>将任务以切片的形式调度至处理槽中有一个好处：TaskManager中的多个任务可以在同一进程内高效地执行数据交换而无须访问网络。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scheduling tasks as slices to slots has the advantage that many tasks are colocated on the TaskManager, which means they can efficiently exchange data within the the same process and without accessing the network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144717Z" creationid="xccui" creationdate="20190606T144717Z">
        <seg>将任务以切片的形式调度至处理槽中有一个好处：TaskManager中的多个任务可以在同一进程内高效地执行数据交换而无须访问网络。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scope</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T042944Z" creationid="xccui" creationdate="20190804T042944Z">
        <seg>域</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scope Identifiers per Job Must Be Unique</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043806Z" creationid="xccui" creationdate="20190804T043806Z">
        <seg>每个作业的域标识必须唯一</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scoping and formatting metrics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T034217Z" creationid="xingcan" creationdate="20190802T152539Z">
        <seg>域和格式指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing a running job</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201519Z" creationid="xccui" creationdate="20190605T123752Z">
        <seg>展示运行作业的Apache Flink Web UI截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing a running job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041702Z" creationid="xccui" creationdate="20190329T041546Z">
        <seg>展示运行作业的Apache Flink Web仪表盘截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing the overview</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201430Z" creationid="xccui" creationdate="20190605T123350Z">
        <seg>Apache Flink Web UI概览页面截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing the overview.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041649Z" creationid="xccui" creationdate="20190329T035553Z">
        <seg>展示概览的Apache Flink Web仪表盘截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Search for the AverageSensorReadings class and open it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042128Z" creationid="xccui" creationdate="20190611T042128Z">
        <seg>找到AverageSensorReadings类，打开它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sebastopol</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210641Z" creationid="esouser" creationdate="20190603T210641Z">
        <seg>Sebastopol</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, a checkpoint may be delayed because we need to wait for another checkpoint to complete results in a lower check‐ pointing interval, leading to longer catch-up processing during recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T201744Z" creationid="xccui" creationdate="20190731T201726Z">
        <seg>其次，检查点生成会被推迟，因为等待当前正在进行的检查点完成会导致更高的生成间隔，继而导致在恢复时需要更长时间去处理数据和追赶进度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, it matches for each operator the state identifiers (see “Savepoints” for details) of the savepoint and the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T045659Z" creationid="xccui" creationdate="20190727T045605Z">
        <seg>其次，它会针对每个算子比较保存点和应用内的状态标识符（详细信息请参阅"保存点"一节）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, the latest results computed by the stream processor are not accurate but only approximated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T030945Z" creationid="xccui" creationdate="20190327T030820Z">
        <seg>其次，流处理引擎计算的最新结果仅仅是不精确的近似结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, the results compu‐ ted by the stream processor are only approximate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053042Z" creationid="xccui" creationdate="20190605T052957Z">
        <seg>其次，流处理引擎计算的结果只是近似的；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, you can have tasks from different operators performing computations on the same or different data in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034118Z" creationid="xccui" creationdate="20190401T031957Z">
        <seg>再者，你可以让不同算子的任务（基于相同或不同的数据）并行计算，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025635Z" creationid="xccui" creationdate="20190225T025635Z">
        <seg>安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Chapter 3 for details on how operator list union state is distributed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T170312Z" creationid="xccui" creationdate="20190702T071938Z">
        <seg>有关算子列表状态在实例上进行分配的详情请参阅第3章。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Chapter 3 to learn about savepoints and what you can do with them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T020639Z" creationid="xccui" creationdate="20190726T020639Z">
        <seg>有关保存点及其用途请参阅第3章。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Chapter 5 for details on the RichFunction interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024619Z" creationid="xccui" creationdate="20190714T024619Z">
        <seg>有关该抽象类的详细信息，请参阅第5章。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Chapter 6 for details about the timestamp assigner interfaces.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T035332Z" creationid="xccui" creationdate="20190709T035332Z">
        <seg>有关时间戳分配接口的详细信息请参照第6章。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Chapter 8 for details on keyed state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190615T052230Z">
        <seg>有关键值分区状态的详细信息请参阅第8章。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See details in “Apache Kafka Sink Connector”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201125Z" creationid="xccui" creationdate="20190716T201125Z">
        <seg>详情参见"Apache Kafka Sink Connector"一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See http://oreilly.com/catalog/errata.csp?isbn=9781491974292 for release details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210735Z" creationid="esouser" creationdate="20190603T210735Z">
        <seg>See http://oreilly.com/catalog/errata.csp?isbn=9781491974292 for release details.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the documentation to learn more about the available set‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030748Z" creationid="xccui" creationdate="20190801T030748Z">
        <seg>有关这些设置的具体信息，请参阅文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See “Checkpointing and State Backends” on page 243 for a description</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025815Z" creationid="xccui" creationdate="20190801T025728Z">
        <seg>（有关可用的配置项，请参见第243页"检查点和状态后端"一节）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See “Configuring Recovery” for details on this feature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T023128Z" creationid="xccui" creationdate="20190725T023128Z">
        <seg>有关该功能的详细信息，请参阅"配置故障恢复"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See “Scaling Stateful Operators” on page 56 for details on how the different types of operator state and keyed state are scaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T055239Z" creationid="xccui" creationdate="20190727T055239Z">
        <seg>有关不同类型的算子状态和键值分区状态是如何伸缩的，请参见第56页"状态化算子扩缩容"一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See “Scaling Stateful Operators” on page 56 for details on the distribution behavior of operator list state and union list state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T163240Z" creationid="xccui" creationdate="20190712T163240Z">
        <seg>有关算子列表状态或联合列表状态的分配行为细节，请参照第56页"状态化算子的扩缩容"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Select the Maven project to import</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041645Z" creationid="xccui" creationdate="20190611T041645Z">
        <seg>选择要导入的Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Selecting metrics to plot</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T144552Z" creationid="xingcan" creationdate="20190802T144552Z">
        <seg>选择需要绘制的指标</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Selling or distributing a CD-ROM of examples from O’Reilly books does require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210819Z" creationid="esouser" creationdate="20190603T210819Z">
        <seg>Selling or distributing a CD-ROM of examples from O’Reilly books does require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Semantic.AT_LEAST_ONCE, which guarantees that no write is lost but might be duplicated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T210413Z" creationid="xccui" creationdate="20190709T210413Z">
        <seg>Semantic.AT_LEAST_ONCE，保证数据不会丢失，但可能会重复写入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Semantic.EXACTLY_ONCE, which builds on Kafka’s transactions to write each record exactly once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T210557Z" creationid="xccui" creationdate="20190709T210557Z">
        <seg>Semantic.EXACTLY_ONCE，基于Kafka的事务机制，保证记录可以精确一次写入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Semantic.NONE, which provides no guarantees—records might be lost or written multiple times.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T210305Z" creationid="xccui" creationdate="20190709T210305Z">
        <seg>Semantic.NONE，不做任何一致性保障，记录可能会丢失或写入多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sending a request that blocks the asyncInvoke() method</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T213621Z" creationid="xccui" creationdate="20190716T213518Z">
        <seg>发送导致asyncInvoke()方法阻塞的请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sending an asynchronous request but waiting inside the asyncInvoke() method for the request to complete</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T213546Z" creationid="xccui" creationdate="20190716T213546Z">
        <seg>发送异步请求，但在asyncInvoke()方法内等待请求完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sending individual records over a network connection is inefficient and causes signif&lt;t0/&gt;‐&lt;t1/&gt; icant overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T210046Z" creationid="esouser" creationdate="20190513T210046Z">
        <seg>通过网络连接逐条发送记录不但低效，还会导致很多额外开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sending individual records over a network connection is inefficient and causes signif‐ icant overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202509Z" creationid="xccui" creationdate="20190606T202509Z">
        <seg>通过网络连接逐条发送记录不但低效，还会导致很多额外开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading contains the sensor ID, a timestamp denoting when the measurement was taken, and the measured temperature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052008Z" creationid="xccui" creationdate="20190612T052008Z">
        <seg>每一条SensorReading数据都包括传感器ID，表示测试时间的时间戳以及测量的温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(r.id, r.timestamp, celsius)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042303Z" creationid="xccui" creationdate="20190612T042303Z">
        <seg>SensorReading(r.id, r.timestamp, celsius)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041720Z" creationid="xccui" creationdate="20190329T041720Z">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259) SensorReading(sensor_6,1547718199000,15.402984393403084) SensorReading(sensor_7,1547718199000,6.720945201171228) SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123937Z" creationid="xccui" creationdate="20190605T123937Z">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259) SensorReading(sensor_6,1547718199000,15.402984393403084) SensorReading(sensor_7,1547718199000,6.720945201171228) SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041735Z" creationid="xccui" creationdate="20190329T041735Z">
        <seg>SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_6,1547718199000,15.402984393403084)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041723Z" creationid="xccui" creationdate="20190329T041723Z">
        <seg>SensorReading(sensor_6,1547718199000,15.402984393403084)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_7,1547718199000,6.720945201171228)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041731Z" creationid="xccui" creationdate="20190329T041731Z">
        <seg>SensorReading(sensor_7,1547718199000,6.720945201171228)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading, (String, Long, Int, String), String, TimeWindow] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T033945Z" creationid="xccui" creationdate="20190629T033945Z">
        <seg>SensorReading, (String, Long, Int, String), String, TimeWindow] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212826Z" creationid="xccui" creationdate="20190711T212826Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SerializationSchema is the counterpart of the DeserializationSchema that we dis‐ cussed in the Kafka source section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T150319Z" creationid="xingcan" creationdate="20190709T150319Z">
        <seg>SerializationSchema和我们在Kafka数据源一节讨论的DeserializationSchema作用相反。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session &lt;t0/&gt;windows are useful in a common real-world scenario where neither&lt;t1/&gt; &lt;t2/&gt;tumbling nor sliding windows can be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024942Z" creationid="xccui" creationdate="20190407T024730Z">
        <seg>会话窗口在一类常见的真实场景下非常有用，该场景中既不适合用滚动窗口也不适合用滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013824Z" creationid="xccui" creationdate="20190606T013824Z">
        <seg>会话窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193607Z" creationid="xccui" creationdate="20190409T193607Z">
        <seg>会话窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060219Z" creationid="xccui" creationdate="20190623T060219Z">
        <seg>会话窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows are useful in common real-world scenarios where neither tum‐ bling nor sliding windows can be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063724Z" creationid="xccui" creationdate="20190606T013410Z">
        <seg>会话窗口（session window）在一些常见的真实场景中非常有用，这些场景既不适合用滚动窗口也不适合用滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows group events in session based on a &lt;t11/&gt;session gap&lt;t12/&gt; value that defines the time of inactivity to consider a session closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193417Z" creationid="xccui" creationdate="20190409T192834Z">
        <seg>会话窗口根据会话间隔（session gap）将事件分为不同的会话，该间隔值定义了会话在关闭前的非活动时间长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows group events in sessions based on a session gap value that defines the time of inactivity to consider a session closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013807Z" creationid="xccui" creationdate="20190606T013807Z">
        <seg>会话窗口根据会话间隔（session gap）将事件分为不同的会话，该间隔值定义了会话在关闭前的非活动时间长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sessions are com‐ prised of a series of events happening in adjacent times followed by a period of inactivity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013650Z" creationid="xccui" creationdate="20190606T013650Z">
        <seg>会话由发生在相邻时间内的一系列事件外加一段非活动时间组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sessions com&lt;t7/&gt;‐&lt;t8/&gt; prise of a series of events happening in adjacent times followed by a period of inactivity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025627Z" creationid="xccui" creationdate="20190407T025430Z">
        <seg>会话由发生在相邻时间内的一系列事件外加一段非活动时间组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set Up the Execution Environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044650Z" creationid="esouser" creationdate="20190603T145031Z">
        <seg>设置执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set up the Execution Environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022537Z" creationid="xccui" creationdate="20190225T022537Z">
        <seg>设置运行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set up the execution environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044657Z" creationid="xccui" creationdate="20190612T043506Z">
        <seg>设置执行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Flink Up for Streaming Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025346Z" creationid="xccui" creationdate="20190225T025346Z">
        <seg>配置Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up Flink for Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T032047Z" creationid="xccui" creationdate="20190717T031148Z">
        <seg>搭建Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up Flink for Streaming Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042400Z" creationid="esouser" creationdate="20190603T152129Z">
        <seg>搭建Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up a Development Environment for</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T142736Z" creationid="xccui" creationdate="20190606T042846Z">
        <seg>设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up a Development Environment for Apache Flink | 71</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012812Z" creationid="xccui" creationdate="20190612T012812Z">
        <seg>设置Apache Flink开发环境 | 71</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up a Development Environment for Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T142736Z" creationid="esouser" creationdate="20190603T144822Z">
        <seg>设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting a unique identifier for an operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024124Z" creationid="xccui" creationdate="20190703T024124Z">
        <seg>为算子设置唯一标识</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the Parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050657Z" creationid="esouser" creationdate="20190603T145135Z">
        <seg>设置并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the maximum parallelism of operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025050Z" creationid="xccui" creationdate="20190703T025015Z">
        <seg>设置算子的最大并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022755Z" creationid="xccui" creationdate="20190225T022755Z">
        <seg>设置并发度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the time characteristic to EventTime enables timestamp and watermark handling, and as a result, event-time operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T050712Z" creationid="xccui" creationdate="20190619T072909Z">
        <seg>将时间特性设置为EventTime后就可以对时间戳和水印进行处理，从而实现事件时间相关操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the time characteristic to event time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T072602Z" creationid="xccui" creationdate="20190619T072515Z">
        <seg>将时间特性设为事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting up a development environment for Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022243Z" creationid="xccui" creationdate="20190225T022243Z">
        <seg>设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shows text that should be replaced with user-supplied values or by values deter‐ mined by context.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210808Z" creationid="esouser" creationdate="20190603T210808Z">
        <seg>Shows text that should be replaced with user-supplied values or by values deter‐ mined by context.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shuts down the Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045125Z" creationid="xccui" creationdate="20190729T045125Z">
        <seg>关闭Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Side outputs are a feature of process functions to emit multiple streams from a function with possibly different types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T014947Z" creationid="xccui" creationdate="20190622T014308Z">
        <seg>而处理函数提供的副输出功能允许从同一函数发出多条数据流，且它们的类型可以不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to ReduceFunction, AggregateFunction is also incrementally applied to the elements that are applied to a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T035836Z" creationid="xccui" creationdate="20190624T002618Z">
        <seg>和ReduceFunction类似，AggregateFunction也会以增量方式应用于窗口内的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to a CoFlatMapFunction, a CoProcessFunction offers a transformation method for each input, processElement1() and processElement2().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T012245Z" creationid="xccui" creationdate="20190622T030504Z">
        <seg>和ComFlatMapFunction类似，CoProcessFunction也提供了一对作用在每个输入上的转换方法——processFunction1()和processFunction2()。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to job mode, Flink’s Web UI is linked from the Application Overview of YARN’s Web UI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T015129Z" creationid="xccui" creationdate="20190719T015129Z">
        <seg>和作业模式类似，Flink的Web UI链接可以从YARN Web UI的Application Overview页面上找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to other data processing systems, Flink looks at the URI scheme of a path to identify the filesystem the path refers to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T042616Z" creationid="xccui" creationdate="20190722T032221Z">
        <seg>和其他数据处理系统类似，Flink通过检查路径URI的协议（scheme）来识别目标文件系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the Kafka source connector, you can pass a Properties object to pro‐ vide custom options to the internal Kafka client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T151114Z" creationid="xingcan" creationdate="20190709T151114Z">
        <seg>和Kafka数据源连接器类似，你可以利用Properties对象为内部Kafka客户端提供一些自定义选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the ProcessFunction, both methods are called with a Context object that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T012359Z" creationid="xccui" creationdate="20190622T030518Z">
        <seg>它们和ProcessFunction中的方法类似，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to watermarks, checkpoint barriers are broadcasted to all connected parallel tasks to ensure that each task receives a barrier from each of its input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T160224Z" creationid="xccui" creationdate="20190609T160142Z">
        <seg>和水位线类似，检查点分隔符总是以广播形式发送，从而可以确保每个任务能从它们的每个输入都收到一个分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to watermarks, checkpoint barriers are injected by source operators into the regular stream of records and cannot overtake or be passed by other records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T064727Z" creationid="xccui" creationdate="20190609T060328Z">
        <seg>和水位线类似，这些检查点分隔符会通过数据源算子注入到常规的记录流中。相对其他记录，它们在流中的位置无法提前或延后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, consider an operator that raises an alert when it detects a “high temperature” event followed by a “smoke” event within 10 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181858Z" creationid="xccui" creationdate="20190414T052537Z">
        <seg>类似地，假设还有一个算子，会在每次检测到"高温"事件且在随后10分钟内出现"烟雾"事件时报警。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if a system’s capacity is small, events will be buffered and have to wait before they get processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T203907Z" creationid="xccui" creationdate="20190402T203453Z">
        <seg>同样，如果系统性能不足，事件很容易堆积缓冲，必须等待一段时间才能处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the Back Pressure tab displays back-pressure statistics per operator and sub‐ task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T152126Z" creationid="xingcan" creationdate="20190802T152126Z">
        <seg>同样，Back Pressure选项卡内展示了每个算子和子任务的背压统计信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple value conversions, splitting of records, or filtering of records are examples of common basic functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053528Z" creationid="xccui" creationdate="20190613T025145Z">
        <seg>常见的基本转换函数有：简单的值转换，记录拆分或过滤等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since  the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054220Z" creationid="xccui" creationdate="20190702T054220Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Apache Derby does not provide a built-in UPSERT statement, the example sink performs UPSERT writes by first trying to update a row and inserting a new row if no</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T052416Z" creationid="xccui" creationdate="20190714T052004Z">
        <seg>Apache Derby没有内置UPSERT语句。为此，示例中的数据汇是通过尝试更新、并在对应键值的数据不存在时执行插入的方式模拟UPSERT操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is a distributed system and runs processes on cluster or cloud environments, filesystems typically need to be globally accessible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T150459Z" creationid="xccui" creationdate="20190722T031715Z">
        <seg>作为一个分布式系统，Flink需要在集群或云端环境中运行进程。对应地，文件系统通常需要支持全局访问，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is a distributed system, the JobManager and TaskManagers typically run as separate JVM processes on different machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T092512Z" creationid="xccui" creationdate="20190611T051402Z">
        <seg>Flink作为一个分布式系统，其JobManager和TaskManager一般会在不同机器上作为独立的JVM进程运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is a distributed system, the local state needs to be protected against failures to avoid data loss in case of application or machine failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T073210Z" creationid="esouser" creationdate="20190603T210018Z">
        <seg>由于采用的是分布式架构，Flink需要对本地状态予以保护，以避免因应用或机器故障导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is a distributed system, the local state needs to be protected against failures to avoid data loss in case of application or machine failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T032404Z" creationid="xccui" creationdate="20190305T032238Z">
        <seg>而由于是分布式的，Flink需要保护本地状态，以防因应用或机器故障导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is implemented in Java and Scala, all components run on Java Virtual Machines (JVMs).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141455Z" creationid="xccui" creationdate="20190606T141316Z">
        <seg>由于Flink本身是用Java和Scala实现的，因此所有组件都基于Java虚拟机（JVM）运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is implemented in Java and Scala, all components run on a Java Virtual Machine (JVM).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033634Z" creationid="xccui" creationdate="20190418T033634Z">
        <seg>由于Flink本身是用Java和Scala实现的，因此所有组件都运行在Java虚拟机（JVM）之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink’s type system generates serializers depending on the data type of a state, the serializers are likely to change when the data type of a state changes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T052151Z" creationid="xccui" creationdate="20190705T052151Z">
        <seg>由于Flink的类型系统需要根据状态的数据类型生成序列化器，所以当状态的数据类型发生改变时，序列化器也可能随之改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Kryo is a general-purpose serializer it is usually not very efficient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065540Z" creationid="xccui" creationdate="20190616T065540Z">
        <seg>由于Kryo是一个通用序列化器，因此通常效率不高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since POJO fields do not have a natural order, they need to be treated differently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212747Z" creationid="xccui" creationdate="20190711T212747Z">
        <seg>由于POJO的字段不存在顺序，它需要被区别对待。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since RocksDB is an external component, it brings its own set of tuning parameters that can also be tweaked for your application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030303Z" creationid="xccui" creationdate="20190801T030303Z">
        <seg>由于RocksDB是一个外部组件，你也可以根据自己的应用对它自身的一些参数进行调整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since StateBackend is a public interface, it is also possible to implement a custom state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025522Z" creationid="xccui" creationdate="20190704T025522Z">
        <seg>由于StateBackend接口是公开的，所以你也可以实现自定义的状态后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since a socket does not have built-in transactional support, transactional writes can only be done using Flink’s generic WAL sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T042653Z" creationid="xccui" creationdate="20190714T042632Z">
        <seg>而同时它也没有提供内置的事务支持，所以事务性写只能通过Flink的通用WAL数据汇来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since check‐ points are synchronized with function invocations, multiple state updates do not pro‐ vide any benefits but can cause additional serialization overhead when updating state several times in a single function call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T035120Z" creationid="xccui" creationdate="20190704T035120Z">
        <seg>由于检查点需要和函数调用同步，所以在单个函数内调用多次更新状态没有任何好处，反而会带来额外的序列化开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since each parallel instance of the function must hold all rules in its operator state, the rules stream needs to be broadcasted to ensure each instance of the function receives all rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T203601Z" creationid="xccui" creationdate="20190701T203601Z">
        <seg>由于函数的所有并行实例都需要在算子状态中保存全部规则，所以规则流需要以广播形式发送，以便每个实例都能收到全部规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since elements are typically ingested in parallel, any operation that causes Flink to redistribute elements across parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T054701Z" creationid="xccui" creationdate="20190620T031159Z">
        <seg>由于元素的读取过程通常都是并行的，所以一切引起Flink跨并行数据流分区进行重新分发的操作（例如改变并行度，keyBy()或显式重新分发）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since files might not appear in order of their modification timestamps, they may be ignored by the filesys‐ tem source connector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T201731Z" creationid="xccui" creationdate="20190710T201731Z">
        <seg>由于文件可能不会按照它们修改时间的顺序出现，所以文件系统数据源连接器可能会忽略部分文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it has to iterate over all elements, it can only be used if no</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014717Z" creationid="xccui" creationdate="20190626T014717Z">
        <seg>由于需要遍历所有元素，移除器只有在未指定增量聚合函数的时候才能使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it holds all state in memory and checkpoints are completely stored in the volatile and JVM-size</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T021734Z" creationid="xccui" creationdate="20190731T213711Z">
        <seg>由于它将所有状态保存在内存中，而且检查点全部位于易失且受JVM大小约束的JobManager堆存储内，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it is not possible to change the identifiers in a savepoint, you will have fewer options to update and evolve your application if</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T205006Z" creationid="xccui" creationdate="20190727T050344Z">
        <seg>保存点中的标识是无法修改的，因此你如果没有使用uid()手动分配算子标识，那么在更新或改进应用时就会受到一些限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since its beginning, Flink has a very active and continuously growing community of users and contributors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T220449Z" creationid="xccui" creationdate="20190225T220008Z">
        <seg>Flink自创建伊始就拥有一个活跃、不断发展的用户及贡献者群体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since its beginning, Flink has had a very active and continuously grow‐ ing community of users and contributors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T063717Z" creationid="esouser" creationdate="20190603T162841Z">
        <seg>它自创建伊始就拥有一个活跃、不断发展的用户及贡献者群体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since its memory is volatile, the state is lost in case of a JobManager failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T021715Z" creationid="xccui" creationdate="20190704T020651Z">
        <seg>因为内存具有易失性，所以一旦JobManager出现故障，状态就会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since keyed state is distributed across all parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T022531Z" creationid="xccui" creationdate="20190706T022531Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since most applications can only read files once they are finalized and streaming applications run for long periods of time, streaming sink connectors typically chunk their output into multiple files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T204114Z" creationid="xccui" creationdate="20190710T204114Z">
        <seg>由于大多数应用只有在文件最终确定后才会读取其内容，且流式应用通常会运行很长时间，所以流式数据汇连接器通常会将其输出写入多个文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since multiple applications might work on the same data representation or share the same infrastructure, changing the schema of a table or scaling a database system requires careful planning and a lot of effort.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T145106Z" creationid="esouser" creationdate="20190603T200017Z">
        <seg>一旦多个应用基于相同的数据表示或共享架构，那么更改Schema或对数据库系统进行扩缩容必将劳心费力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since our KeyedProcessFunction always updates the registered timer by deleting the current timer and registering a new one, only a single timer is registered per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T034243Z" creationid="xccui" creationdate="20190704T213431Z">
        <seg>由于KeyedProcessFunction总会在注册新计时器之前将已有的计时器删除，所以每个键值在同一时间最多只会有一个注册的计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since release 1.0, the API has remained stable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T204214Z" creationid="xccui" creationdate="20190708T204002Z">
        <seg>自1.0发布版以来，它的API一直比较稳定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since savepoints are handled by the system similarly to regular checkpoints, operators also receive checkpoint completion notifications for completed savepoints and act on them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T180037Z" creationid="xccui" creationdate="20190726T035625Z">
        <seg>由于系统对于保存点的处理和常规的检查点类似，所以在保存点完成后算子同样会收到检查点完成完成通知并据其做出反应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since savepoints are such a powerful feature, many users periodically create save‐ points to be able to go back in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T070839Z" creationid="xccui" creationdate="20190609T213645Z">
        <seg>保存点的功能如此强大，以至于很多用户都会周期性地创建保存点，从而可以及时"回到过去"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since state can become quite large and checkpointing requires writing the data over the network to a remote storage system, taking a checkpoint can easily take several seconds to minutes—much too long for latency-sensitive applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202510Z" creationid="xccui" creationdate="20190609T200126Z">
        <seg>由于状态可能会很大，而且生成检查点需要把这些数据通过网络写入远程存储系统，该过程可能持续数秒，甚至数分钟，这对于一些延迟敏感的应用而言时间过久。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since state manage‐ ment is always custom and manually done in process functions, Flink does not pro‐ vide a built-in API to support late data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041037Z" creationid="xccui" creationdate="20190629T035942Z">
        <seg>但由于处理函数内部的状态管理都是通过手工自定义来完成的，所以Flink没有在其中内置和迟到数据处理相关的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming appli&lt;t2/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150756Z" creationid="xccui" creationdate="20190401T150551Z">
        <seg>但由于流式应用会一直执行且输入可能是无限的，因此在数据流处理中没有总执行时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming applications are often required to run 24/7 with minimum downtime, many stream processors added features such as highly-available setups, tight integration with resource managers, such as YARN or Mesos, and the ability to dynamically scale streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T140537Z" creationid="xccui" creationdate="20190327T140011Z">
        <seg>由于流式应用经常需要近7*24小时不间断运行，很多流处理引擎会添加像高可用设置、与资源管理器（YARN、Mesos等）紧密集成、动态扩展流式应用等特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming appli‐ cations run continuously and the input is potentially unbounded, there is no notion of total execution time in data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050547Z" creationid="xccui" creationdate="20190605T233740Z">
        <seg>但由于流式应用会持续执行且输入可能是无限的，所以在数据流处理中没有总执行时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming operators process potentially unbounded data, caution should be taken to not allow internal state to grow indefinitely.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182956Z" creationid="xccui" creationdate="20190414T054737Z">
        <seg>由于流式算子处理的都是潜在无穷无尽的数据，因此必须小心避免内部状态无限增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since task chaining improves the perfor‐ mance of most applications, it is enabled by default in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T010334Z" creationid="xccui" creationdate="20190730T191338Z">
        <seg>由于任务链接可以提高大多数应用的性能，所以Flink默认会启动它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since tasks maintain their state locally, Flink has to ensure that this state is not lost and remains consistent in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T152710Z" creationid="xccui" creationdate="20190608T152636Z">
        <seg>由于每个任务会把状态维护在本地，Flink要保证发生故障时状态不丢不错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T040616Z" creationid="xccui" creationdate="20190724T040616Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the aggregation is performed by the ReduceFunction, the ProcessWindowFunction only needs to append the window end timestamp to the incrementally computed result as shown in Example 6-14.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T050106Z" creationid="xccui" creationdate="20190625T045016Z">
        <seg>由于聚合逻辑是由ReduceFunction执行的，ProcessWindowFunction只需要像示例6-14中那样，将窗口的结束时间戳加到递增计算结果后面即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the application’s source tasks were reset to an earlier input position, it processes data that it processed before the failure and data that accumulated while the applica‐ tion was down.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T145810Z" creationid="xingcan" creationdate="20190801T145810Z">
        <seg>由于应用的数据源任务被重置到一个较早的输入位置，所以它会处理故障发生前以及应用在停止工作期间积累的一些数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the checkpoint data is written twice, local recovery adds overhead to checkpointing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T163950Z" creationid="xingcan" creationdate="20190801T163950Z">
        <seg>由于检查点数据需要被写入两次，所以本地恢复会为检查点生成带来一定额外开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the checkpoint was not committed yet, the sink will write all records again during recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065401Z" creationid="xccui" creationdate="20190715T065401Z">
        <seg>由于此时检查点还未提交，下次恢复时会重写全部记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the events of both streams are mapped into the same windows, triggers and evictors behave exactly as in regular window operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T204456Z" creationid="xccui" creationdate="20190628T053412Z">
        <seg>由于两条流中的事件会被映射到同一个窗口中，因此该过程中的触发器和移除器与常规窗口算子中的完全相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the handling of state directly affects the semantics of an operator, Flink cannot automati‐ cally clean up state and free storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T033125Z" creationid="xccui" creationdate="20190704T135936Z">
        <seg>由于对状态的处理会直接影响算子语义，所以Flink无法通过自动清理状态来释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the length of a session is not defined beforehand but depends on the actual data, tumbling and sliding win&lt;t9/&gt;‐&lt;t10/&gt; dows cannot be applied in this scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T192212Z" creationid="xccui" creationdate="20190407T030004Z">
        <seg>由于会话长度并非预先定义好，而是和实际数据有关，因此无论是滚动还是滑动窗口都无法用于该场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the length of a session is not defined beforehand but depends on the actual data, tumbling and sliding win‐ dows cannot be applied in this scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013707Z" creationid="xccui" creationdate="20190606T013707Z">
        <seg>由于会话长度并非预先定义好，而是和实际数据有关，因此无论是滚动还是滑动窗口都无法用于该场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the log will be recovered, no records will be lost in the case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T051045Z" creationid="xccui" creationdate="20190715T051045Z">
        <seg>由于它在发生故障时可以恢复，所以不会导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the logic for splitting and merging</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T060037Z" creationid="xccui" creationdate="20190701T060037Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the maximum operator parallelism is four, the application requires at least four available processing slots to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043551Z" creationid="xccui" creationdate="20190423T043528Z">
        <seg>由于算子最大并行度是4，因此应用若要执行则至少需要4个处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the pur‐ pose of checkpoints is to ensure an application can be restarted in case of a failure, they are deleted when an application is explicitly canceled.4 However, consistent snap‐ shots of the state of an application can be used for many more things than just failure recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T070034Z" creationid="xccui" creationdate="20190609T205625Z">
        <seg>检查点的目的是保证应用可以在出现故障的时候顺利重启，因此当应用被手动停止后，检查点也会随之删除。4 但应用状态的一致性快照除了故障恢复外，还有很多其他用途。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the setup requires several steps, such as generating certificates, setting up TrustStores and KeyStores, and configuring cipher suites, we refer you to the official Flink documentation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T040938Z" creationid="xccui" creationdate="20190725T040938Z">
        <seg>由于启用步骤较为繁琐（需要生成证书，设置TrustStores和KeyStores，并配置密码套件等），我们建议你查阅Flink官方文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the sink buf‐ fers records in the state backend, the WAL sink can be used with any kind of sink system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T200956Z" creationid="xccui" creationdate="20190708T074429Z">
        <seg>由于该数据汇利用状态后端缓冲记录，所以它适用于任何一种数据汇系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the start and the end of a session window depend on the received elements, a window assigner cannot immediately assign all the elements to the correct window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T031758Z" creationid="xccui" creationdate="20190623T061801Z">
        <seg>由于会话窗口的开始和结束都取决于接收的元素，因此窗口分配器无法实时将所有元素分配到正确的窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since they depend on the ingestion order, count-based windows are not deter‐ ministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T040009Z" creationid="xccui" creationdate="20190623T035800Z">
        <seg>由于要依赖元素的到达顺序，基于数量的窗口具有不确定性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since this state is never cleaned up, you should only apply a rolling aggregations operator on a stream with a bounded key domain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T060153Z" creationid="xccui" creationdate="20190614T061231Z">
        <seg>由于这些状态不会被自动清理，所以该算子只能用于键值域有限的流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since this state is never cleaned up, you should only apply a rolling reduce operator on a stream with a bounded key domain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T060117Z" creationid="xccui" creationdate="20190614T062950Z">
        <seg>由于这些状态不会被自动清理，所以该算子只能用于键值域有限的流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since watermarks should be data driven, a watermark generator (either integrated in a source function or in a timestamp assigner) will not emit new water‐ marks if it does not receive input records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T043042Z" creationid="xccui" creationdate="20190713T042810Z">
        <seg>由于水位线其实是数据驱动的，水位线生成器（无论是集成在数据源函数中的还是在时间戳分配器中的）若是收不到输入记录，就不会发出新的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we are using a simple nonmergable ValueState, the trigger is not mer‐ gable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201301Z" creationid="xccui" creationdate="20190626T201301Z">
        <seg>由于我们使用了简单的不可合并状态ValueState，所以无法对触发器进行合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you are running a streaming application, it will continue to run until you cancel it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045509Z" creationid="xccui" creationdate="20190329T045426Z">
        <seg>由于运行的是流式应用，因此它会一直运行下去，直到你手动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you are running a streaming application, the application will continue to run until you cancel it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124357Z" creationid="xccui" creationdate="20190605T124127Z">
        <seg>由于应用是流式的，它会一直运行下去，直到你手动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you do not take into consideration late events and out-of-order events, a window simply needs to buffer up events and immediately trigger computation once the specified time length is reached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180546Z" creationid="xccui" creationdate="20190414T041209Z">
        <seg>由于无需考虑迟到或乱序的事件，窗口只需简单地缓冲事件，然后在达到特定时间后立即触发窗口计算即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since, multiple applications might work on the same data representation or share the same infrastructure, changing the schema of a table or scaling a database system requires careful planning and a lot of effort.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T185223Z" creationid="xccui" creationdate="20190226T164028Z">
        <seg>一旦多个应用基于相同的数据表示或共享架构，那么更改表模式或对数据库系统扩容必将费心费力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sink operators keep statistics on latency markers received per parallel source instance, thus checking the latency marker at sinks can be used to approximate how long it takes for records to traverse the dataflow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T063345Z" creationid="xccui" creationdate="20190806T063345Z">
        <seg>数据汇算子会为每个数据源的并行实例分别保存延迟标记的统计信息，因此通过检查数据汇的延迟标记可以估计出记录流遍整个Dataflow所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SinkFunction in Example 8-12 neither performs idempotent writes nor features</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T032219Z" creationid="xccui" creationdate="20190714T032219Z">
        <seg>而8-12中的SinkFunction二者都不具备。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sinks acknowledge the reception of a checkpoint barrier to the JobManager and a checkpoint is complete when all tasks have acknowledged the successful check‐ pointing of their state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195511Z" creationid="xccui" creationdate="20190609T194625Z">
        <seg>数据汇任务向JobManager确认收到检查点分隔符，在所有任务成功将自身状态存入检查点后整个应用的检查点才算完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slf4j</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055536Z" creationid="xccui" creationdate="20190804T055536Z">
        <seg>Slf4j</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding &lt;t0/&gt;windows assign events into overlapping buckets of fixed size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024655Z" creationid="xccui" creationdate="20190407T023648Z">
        <seg>滑动窗口（sliding window）将事件分配到大小固定且相互重叠的桶中，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding count-based window with a length of 4 events and a slide of 3 events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024429Z" creationid="xccui" creationdate="20190407T024415Z">
        <seg>长度为4个事件滑动间隔为3个事件的基于数量的滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding count-based window with a length of four events and a slide of three events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013350Z" creationid="xccui" creationdate="20190606T013314Z">
        <seg>长度为4个事件滑动间隔为3个事件的基于数量的滑动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054549Z" creationid="xccui" creationdate="20190623T054549Z">
        <seg>滑动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding windows assign events into overlapping buckets of fixed size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063526Z" creationid="xccui" creationdate="20190606T013132Z">
        <seg>滑动窗口（sliding window）将事件分配到大小固定且（允许）相互重叠的桶中，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far we have discussed how to generate watermarks using a TimestampAssigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T055235Z" creationid="xccui" creationdate="20190620T055210Z">
        <seg>目前为止，我们已经讨论过如何使用TimestampAssigner生成水位线，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far we have explained how to start an application on a running Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T213419Z" creationid="xccui" creationdate="20190729T202209Z">
        <seg>到目前为止，我们已经介绍过如何在一个运行的Flink集群上启动一个应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far we have explained what timestamps and watermarks are and how they are internally handled by Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054525Z" creationid="xccui" creationdate="20190607T033537Z">
        <seg>到目前为止，我们已经解释了时间戳和水位线的含义以及它们在Flink内部的处理逻辑，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, you have seen how stream processing addresses limitations of traditional batch processing and how it enables new applications and architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T052148Z" creationid="xccui" creationdate="20190329T050348Z">
        <seg>至此，你已经了解过流式应用如何突破传统批处理的局限以及它如何支持新的应用和架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, you have seen how stream processing addresses some of the limitations of tra‐ ditional batch processing and how it enables new applications and architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T195929Z" creationid="xccui" creationdate="20190605T224637Z">
        <seg>至此，你不但已经见过流式应用是如何突破传统批处理的一些局限以及它如何支持新的应用和架构，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, can you get both low latency and high throughput or is this a hopeless endeavor?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054529Z" creationid="xccui" creationdate="20190605T235232Z">
        <seg>既然这样，可以通过某种方式同时获得低延迟和高吞吐吗？还是说这根本不切实际？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, it is crucial to configure the transaction timeout property appropriately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T013049Z" creationid="xccui" creationdate="20190709T223036Z">
        <seg>所以说，有必要为它配置一个合适的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, sinks that extend GenericWriteAheadSink cannot be added using DataStream.addSink() but are attached using the DataStream.transform() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064152Z" creationid="xccui" creationdate="20190715T064136Z">
        <seg>因此我们无法使用DataStream.addSink()方法添加一个继承自GenericWriteAheadSink的数据汇，而是要用到DataStream.transform()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Socket Window WordCount (RUNNING)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033029Z" creationid="xccui" creationdate="20190726T033029Z">
        <seg>Socket Window WordCount (RUNNING)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Linux distribution periodically clean the temporary direc‐ tory /tmp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043123Z" creationid="xccui" creationdate="20190724T043123Z">
        <seg>部分Linux发行版会定期清理/tmp临时目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some applications also leverage Flink’s domain-specific libraries, such as the Table API, SQL, or the CEP library.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035212Z" creationid="xccui" creationdate="20190619T035212Z">
        <seg>还有一些应用需要用到Flink一些特定领域的库（例如：Table API、SQL或CEP库）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some backends do not support all options and might ignore them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T044514Z" creationid="xccui" creationdate="20190724T044514Z">
        <seg>如果状态后端不支持某些选项，则可能会自动忽略它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some checkpointing options are backend specific.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T044656Z" creationid="xccui" creationdate="20190724T044639Z">
        <seg>部分检查点的选项是某些状态后端所特有的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the first research proto‐ types and commercial products date back to the late 1990s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160105Z" creationid="xccui" creationdate="20190605T045832Z">
        <seg>一些最初的研究原型和商业产品甚至可以追溯到上世纪90年代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the transformations you saw in the previous section require a key specifica‐ tion or field reference on the input stream type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T035957Z" creationid="xccui" creationdate="20190617T062440Z">
        <seg>上一节中涉及的部分转换需要基于输入流的类型指定键值或引用字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some sink systems provide a transaction ID that can be used to commit or abort an open transaction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T031214Z" creationid="xccui" creationdate="20190716T031214Z">
        <seg>部分数据汇系统可以提供用于提交或终止已开启事务的事务ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some special types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065127Z" creationid="xccui" creationdate="20190616T065127Z">
        <seg>一些特殊类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some transformations can produce a new DataStream, pos‐ sibly of a different type, while other transformations do not modify the records of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052746Z" creationid="xccui" creationdate="20190612T052453Z">
        <seg>有些会生成一个新的DataStream（类型可能不同）；而另外的一些不会修改DataStream中的记录，仅会通过分区或分组的方式将其重新组织。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes it is necessary or desirable to control the partitioning strategies at the application level or define custom partitioners.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T064628Z" creationid="xccui" creationdate="20190615T065406Z">
        <seg>某些时候，我们有必要或希望能够在应用级别控制这些分区策略，或者自定义分区器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes the input stream contains special tuples or markers that indicate the stream’s progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T053858Z" creationid="xccui" creationdate="20190620T053858Z">
        <seg>有时候输入流中会包含一些用于指示系统进度的特殊元组或标记。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, though, the necessary information cannot be extracted (e.g., because of Java erasing generic type information).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T035731Z" creationid="xccui" creationdate="20190617T061027Z">
        <seg>但有时候一些必要的信息可能无法提取（例如：由于Java会擦除泛型信息）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Source Functions, Timestamps, and Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055042Z" creationid="xccui" creationdate="20190225T025249Z">
        <seg>数据源函数、时间戳及水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Source functions are discussed in more detail in “Implementing a Custom Source Function” on page 202.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054925Z" creationid="xccui" creationdate="20190607T034915Z">
        <seg>我们会在第202页"实现自定义数据源函数"一节详细讨论数据源函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SourceContext provides the following methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T035739Z" creationid="xccui" creationdate="20190713T035640Z">
        <seg>它的类提供了以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SourceFunction and ParallelSourceFunction define two methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T150854Z" creationid="xccui" creationdate="20190712T150854Z">
        <seg>SourceFunction和ParallelSourceFunction中定义了两个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SourceFunction and RichSourceFunction can be used to define nonparallel source connectors—sources that run with a single task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T054543Z" creationid="xccui" creationdate="20190712T145628Z">
        <seg>SourceFunction和RichSourceFunction可用于定义非并行的数据源连接器，只能在单任务下运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SourceFunction that counts to Long.MaxValue</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152418Z" creationid="xccui" creationdate="20190712T152418Z">
        <seg>从0数到Long.MaxValue的SourceFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sources checkpoint their state and emit a checkpoint barrier</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155352Z" creationid="xccui" creationdate="20190609T155352Z">
        <seg>数据源为状态生成检查点并发出检查点分隔符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special thanks go to our fellow Flink committers: Alan Gates, Aljoscha Krettek, Andra Lungu, ChengXiang Li, Chesnay Schepler, Chiwan Park, Daniel Warneke, Dawid Wysakowicz, Gary Yao, Greg Hogan, Gyula Fóra, Henry Saputra, Jamie Grier, Jark Wu, Jincheng Sun, Konstantinos Kloudas, Kostas Tzoumas, Kurt Young, Márton Balassi, Matthias J. Sax, Maximilian Michels, Nico Kruber, Paris Carbone, Robert</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T143900Z" creationid="xccui" creationdate="20190605T132711Z">
        <seg>特别感谢Flink社区的Committer们：Alan Gates、Aljoscha Krettek、Andra Lungu、ChengXiang Li（李呈祥）、Chesnay Schepler、Chiwan Park、 Daniel Warneke、Dawid Wysakowicz、Gary Yao、Greg Hogan、Gyula Fóra、Henry Saputra、Jamie Grier、Jark Wu（伍翀）、Jincheng Sun（孙金城）、 Konstantinos Kloudas、Kostas Tzoumas、Kurt Young（杨克特）、Márton Balassi、Matthias J. Sax、Maximilian Michels、Nico Kruber、Paris Carbone、Robert</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specific reading positions for all partitions as provided by a Map object:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040542Z" creationid="xccui" creationdate="20190709T040528Z">
        <seg>利用一个Map对象为所有分区指定读取位置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, we explain how to define and interact with different types of state in user-defined func‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T033930Z" creationid="xccui" creationdate="20190630T033819Z">
        <seg>具体而言，我们将解释如何在用户自定义函数中定义不同类型的状态并与之交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying Unique Operator Identifiers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024703Z" creationid="xccui" creationdate="20190225T024703Z">
        <seg>指定算子唯一标识</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Split a tuple stream into a stream with large numbers and a stream with small numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T062047Z" creationid="xccui" creationdate="20190615T062047Z">
        <seg>将元组流拆分成一条大数字流和一条小数字流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Split and select</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210029Z" creationid="xccui" creationdate="20190615T052247Z">
        <seg>Split和Select</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Split is the inverse transformation to the union transformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T054002Z" creationid="xccui" creationdate="20190615T053736Z">
        <seg>split转换是union转换的逆操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Split operator list state for better distribution during rescaling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062645Z" creationid="xccui" creationdate="20190701T062645Z">
        <seg>将算子列表状态拆分，从而在扩缩容时实现更佳的分布</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stand-Alone Cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025413Z" creationid="xccui" creationdate="20190225T025413Z">
        <seg>独立集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standalone Cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152136Z" creationid="esouser" creationdate="20190603T152136Z">
        <seg>独立集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Start a local Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025029Z" creationid="xccui" creationdate="20190329T025015Z">
        <seg>启动本地Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Start a local Flink cluster:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123053Z" creationid="xccui" creationdate="20190605T123051Z">
        <seg>启动本地Flink集群：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Start a new task chain with an operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T204340Z" creationid="xccui" creationdate="20190730T204340Z">
        <seg>为算子开启一个新的链接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Started the Queryable State Proxy Server @ …</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T055830Z" creationid="xccui" creationdate="20190706T055830Z">
        <seg>Started the Queryable State Proxy Server @ …</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting a Flink cluster on YARN in job mode</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T212412Z" creationid="xccui" creationdate="20190718T212412Z">
        <seg>以作业模式启动Flink YARN集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting a Flink cluster on YARN in session mode</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T214410Z" creationid="xccui" creationdate="20190718T214410Z">
        <seg>以会话模式启动Flink YARN集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting a master and a worker container in Docker</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T032410Z" creationid="xccui" creationdate="20190718T032410Z">
        <seg>在Docker中启动一个主容器和一个工作容器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting a standalone Flink cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T135610Z" creationid="xccui" creationdate="20190717T153341Z">
        <seg>启动一个Flink独立集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T025115Z" creationid="xccui" creationdate="20190726T025115Z">
        <seg>启动应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting an application from a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213449Z" creationid="xccui" creationdate="20190609T213449Z">
        <seg>从保存点启动应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting an application from a savepoint allows you to do much more.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211859Z" creationid="xccui" creationdate="20190609T211810Z">
        <seg>而将应用从某个保存点启动还能让你做更多事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting an application from a savepoint is fairly simple.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T040029Z" creationid="xccui" creationdate="20190727T040029Z">
        <seg>从保存点启动应用非常简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025408Z" creationid="xccui" creationdate="20190329T025102Z">
        <seg>Starting cluster.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting execution of program</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040009Z" creationid="xccui" creationdate="20190329T040009Z">
        <seg>Starting execution of program</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting from the base directory, the templates are located in:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T213925Z" creationid="xccui" creationdate="20190730T043818Z">
        <seg>从根目录算起，模板位于：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting from the base folder of the distribution, the script is located at ./ flink-container/docker/build.sh.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T213718Z" creationid="xccui" creationdate="20190730T033921Z">
        <seg>脚本位于发行版根目录中./flink-container/docker/build.sh。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting standalonesession daemon on host xxx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025401Z" creationid="xccui" creationdate="20190329T025401Z">
        <seg>Starting standalonesession daemon on host xxx.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting taskexecutor daemon on host xxx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025415Z" creationid="xccui" creationdate="20190329T025415Z">
        <seg>Starting taskexecutor daemon on host xxx.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starts the application defined by the JAR file (and entry-class) with the provided parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T050513Z" creationid="xccui" creationdate="20190729T050513Z">
        <seg>使用指定参数启动JAR文件（以及入口类）所指定的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State Backends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022056Z" creationid="xccui" creationdate="20190225T022056Z">
        <seg>状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State Management</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022008Z" creationid="xccui" creationdate="20190225T022008Z">
        <seg>状态管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State Management | 53</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032642Z" creationid="xccui" creationdate="20190610T032642Z">
        <seg>状态管理 | 53</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State and Consistency Models</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144240Z" creationid="esouser" creationdate="20190603T144240Z">
        <seg>状态和一致性模型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State and Consistency Models | 33</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041500Z" creationid="xccui" creationdate="20190606T041500Z">
        <seg>状态和一致性模型 | 33</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State and consistency models</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020429Z" creationid="xccui" creationdate="20190225T020429Z">
        <seg>状态和一致性模型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State backends differ in how state is checkpointed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061922Z" creationid="xccui" creationdate="20190608T053842Z">
        <seg>不同的状态后端生成状态检查点的方式也存在一定差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State checkpointing is important because Flink is a distributed system and state is only locally maintained.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061838Z" creationid="xccui" creationdate="20190608T053330Z">
        <seg>由于Flink是一个分布式系统但只在本地维护状态，所以状态检查点就显得极其重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State evolution and migration is an important topic in the Flink community and receives a lot of attention.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T035456Z" creationid="xccui" creationdate="20190705T053545Z">
        <seg>状态的演变和迁移在Flink社区是一个非常重要的主题，也得到了很多关注。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State is ubiquitous in data processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050647Z" creationid="xccui" creationdate="20190414T050539Z">
        <seg>状态在数据处理中无处不在，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State management</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032900Z" creationid="xccui" creationdate="20190606T032900Z">
        <seg>状态管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State management&lt;t0/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055905Z" creationid="xccui" creationdate="20190414T055905Z">
        <seg>状态管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State partitioning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032915Z" creationid="xccui" creationdate="20190606T032915Z">
        <seg>状态划分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State partitioning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T033332Z" creationid="xccui" creationdate="20190415T033332Z">
        <seg>状态划分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State primitives expose the structure of the state to Flink and enable more efficient state accesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T223623Z" creationid="xccui" creationdate="20190607T222211Z">
        <seg>通过这些状态原语可以为Flink状态指定不同的结构，从而实现更加高效的状态访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032954Z" creationid="xccui" creationdate="20190606T032954Z">
        <seg>状态恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T034727Z" creationid="xccui" creationdate="20190415T034727Z">
        <seg>状态恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State() method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T174104Z" creationid="xccui" creationdate="20190712T174104Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State, state consistency, and Flink’s checkpointing mechanism will be discussed in more detail in the following chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T033014Z" creationid="xccui" creationdate="20190305T033014Z">
        <seg>我们会在接下来的章节详细讨论状态、状态一致性以及Flink的checkpointing机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State, state consistency, and Flink’s checkpointing mech‐ anism will be discussed in more detail in the following chapters, but, for now, Figure 1-4 shows a stateful streaming Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T160225Z" creationid="esouser" creationdate="20190603T210107Z">
        <seg>图1-4简单展示了Flink的状态化流式应用。有关状态、状态一致性以及Flink的检查点机制会在后面的章节详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042412Z" creationid="xccui" creationdate="20190629T042412Z">
        <seg>状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Operators and Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023527Z" creationid="xccui" creationdate="20190225T023519Z">
        <seg>状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014544Z" creationid="xccui" creationdate="20190225T014544Z">
        <seg>状态化流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Stream Processing | 5</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130813Z" creationid="xccui" creationdate="20190605T130813Z">
        <seg>状态化流处理 | 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful operators and user functions are common building blocks of stream process‐ ing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052039Z" creationid="xccui" creationdate="20190629T042647Z">
        <seg>状态化算子及用户函数都是流处理应用中的常见组成部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful operators use both incom&lt;t2/&gt;‐&lt;t3/&gt; ing events and internal state to compute their output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T051928Z" creationid="xccui" creationdate="20190414T051928Z">
        <seg>状态化算子同时利用到来的事件和内部状态来计算输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful operators use both incoming events and internal state to compute their output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181422Z" creationid="xccui" creationdate="20190606T031507Z">
        <seg>状态化算子同时使用传入的事件和内部状态来计算输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing applications are more challenging to parallelize and oper&lt;t4/&gt;‐&lt;t5/&gt; ate in a fault tolerant manner because state needs to be efficiently partitioned and reli&lt;t6/&gt;‐&lt;t7/&gt; ably recovered in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151433Z" creationid="xccui" creationdate="20190405T040600Z">
        <seg>状态化流处理应用在并行化和容错方面会麻烦很多，因为需要对状态进行高效划分并且在出错时需进行可靠的故障恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing applications are more challenging to parallelize and oper‐ ate in a fault-tolerant manner because state needs to be efficiently partitioned and reliably recovered in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T055329Z" creationid="xccui" creationdate="20190606T005043Z">
        <seg>状态化流处理应用在并行化和容错方面会更具挑战性，因为它们需要对状态进行高效划分并且在出错时需进行可靠的故障恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing applications often ingest their incoming events from an event log.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T034141Z" creationid="xccui" creationdate="20190305T034141Z">
        <seg>状态化流处理应用通常会从事件日志中读取事件记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing has implications on many aspects of a stream processor such as failure recovery and memory management as well as the maintenance of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T213444Z" creationid="xccui" creationdate="20190630T032323Z">
        <seg>状态化流处理会在故障恢复、内存管理以及流式应用维护等很多方面对流处理引擎产生影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing in Flink is discussed in detail in “Implementing Stateful Functions” on</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033814Z" creationid="xccui" creationdate="20190619T033814Z">
        <seg>有关Flink中状态化流处理的内容会在154页"实现状态化函数"一节详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing is an application design pattern for processing unbounded streams of events and is applicable to many different use cases in the IT infrastructure of a com&lt;t0/&gt;‐&lt;t1/&gt; pany.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T034013Z" creationid="xccui" creationdate="20190301T202026Z">
        <seg>作为一类面向无限事件流的应用设计模式，状态化流处理可用于公司IT基础设施中的很多用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing is an application design pattern for processing unbounded streams of events and is applicable to many different use cases in the IT infrastructure of a company.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T030537Z" creationid="esouser" creationdate="20190603T204846Z">
        <seg>作为一类面向无限事件流的应用设计模式，状态化流处理适用于公司IT基础设施中的很多用例场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful transformations that are applied on a KeyedStream read from and write to state in the context of the currently processed event’s key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044300Z" creationid="xccui" creationdate="20190614T044151Z">
        <seg>作用于KeyedStream的状态化转换可以对当前处理事件键值所对应上下文中的状态进行读写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateless operations are easy to parallelize, since events can be processed independently of each other and of their arriving order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T055130Z" creationid="xccui" creationdate="20190405T035840Z">
        <seg>由于事件处理互不影响且与事件到来的时间无关，无状态的操作很容易并行化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateless operations do not maintain any internal state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T035709Z" creationid="xccui" creationdate="20190405T035709Z">
        <seg>无状态的操作不会维持内部状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Statistics for a running job</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T144301Z" creationid="xingcan" creationdate="20190802T144301Z">
        <seg>作业运行的统计信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stores a key-value map per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T221802Z" creationid="xccui" creationdate="20190607T220156Z">
        <seg>每个键对应存储一个键值映射，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stores a list of values per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T220018Z" creationid="xccui" creationdate="20190607T215922Z">
        <seg>每个键对应存储一个值的列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stores a single value of arbitrary type per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T215753Z" creationid="xccui" creationdate="20190607T215707Z">
        <seg>每个键对应存储一个任意类型的值，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream API program essentially boils down to combining such transformations to create a dataflow graph that implements the application logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T053620Z" creationid="xccui" creationdate="20190613T013744Z">
        <seg>完成一个DataStream API程序在本质上可以归结为：通过组合不同的转换来创建一个满足应用逻辑的Dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream API transformations we have seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T043218Z" creationid="xccui" creationdate="20190621T043218Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T050207Z" creationid="xccui" creationdate="20190329T050207Z">
        <seg>流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing Fundamentals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014755Z" creationid="xccui" creationdate="20190225T014755Z">
        <seg>流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing with Apache</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T050752Z" creationid="esouser" creationdate="20190603T142341Z">
        <seg>基于Apache Flink的流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing with Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210705Z" creationid="esouser" creationdate="20190603T210656Z">
        <seg>Stream Processing with Apache Flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing with Apache Flink, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210737Z" creationid="esouser" creationdate="20190603T210737Z">
        <seg>Stream Processing with Apache Flink, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing engines usually provide a set of built-in operations to ingest, trans&lt;t0/&gt;‐&lt;t1/&gt; form, and output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T212650Z" creationid="xccui" creationdate="20190402T212535Z">
        <seg>流处理引擎通常会提供一系列内置操作来实现数据流的获取、转换以及输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing engines usually provide a set of built-in operations to ingest, trans‐ form, and output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235741Z" creationid="xccui" creationdate="20190605T235741Z">
        <seg>流处理引擎通常会提供一系列内置操作来实现数据流的获取、转换以及输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing technology is becoming more and more popular with companies big and small because it provides superior solutions for many established use cases such as data analytics, ETL, and transactional applications, but also facilitates novel applications, software architectures, and business opportunities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T064456Z" creationid="esouser" creationdate="20190603T162936Z">
        <seg>流处理技术正受到越来越多不同规模公司的青睐，这是因为它不仅可以为很多现有场景提供更优的解决方案（例如数据分析、ETL以及事务性应用），还能催生很多新颖的应用、软件架构以及商业机会。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing technology is being rapidly adopted by companies and enterprises of any size because it provides superior solutions for many established use cases but also facilitates novel applications, software architectures, and business opportunities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T222030Z" creationid="xccui" creationdate="20190225T221738Z">
        <seg>而流处理技术本身也迅速在各种规模的公司和企业中普及，这是因为它不仅可以为现有用例提供更优的解决方案，更可催生很多新颖的应用、软件架构以及商业机会。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processors like Flink also support event-time pro‐ cessing to produce correct and deterministic results and the ability to process large amounts of data in little time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155904Z" creationid="xccui" creationdate="20190605T045138Z">
        <seg>诸如Flink之类的流处理引擎还需要支持事件时间处理，从而可以生成精准、确定的结果，并具备在短时间内处理大量数据的能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processors of this generation made the lambda archi&lt;t2/&gt;‐&lt;t3/&gt; tecture obsolete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T135152Z" creationid="xccui" creationdate="20190327T135031Z">
        <seg>这使得Lambda架构彻底沦为历史。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processors of this generation made the lambda architecture obsolete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053621Z" creationid="xccui" creationdate="20190605T053616Z">
        <seg>这使得Lambda架构彻底沦为历史。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream&lt;t2/&gt;‐&lt;t3/&gt; ing jobs run for long periods of time, thus state might be collected over several days or even months.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T040818Z" creationid="xccui" creationdate="20190415T040248Z">
        <seg>流式作业会运行较长时间，因此状态可能是数天甚至数月才收集而来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamExecutionEnvironment and it takes the following values:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T033320Z" creationid="xccui" creationdate="20190619T055332Z">
        <seg>时间特性是StreamExecutionEnvironment的一个属性，它可以接收以下值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamExecutionEnvironment as shown in Example 7-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204734Z" creationid="xccui" creationdate="20190702T204734Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamExecutionEnvironment.disableOperatorChaining()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203003Z" creationid="xccui" creationdate="20190730T203003Z">
        <seg>StreamExecutionEnvironment.disableOperatorChaining()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamExecutionEnvironment:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T191753Z" creationid="xccui" creationdate="20190730T191753Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming Analytics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014658Z" creationid="xccui" creationdate="20190225T014658Z">
        <seg>流式分析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming analytics applications are commonly used for:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045410Z" creationid="xccui" creationdate="20190605T045410Z">
        <seg>流式分析应用常用于：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming application with two stateful sources, two stateful tasks, and two stateless sinks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062410Z" creationid="xccui" creationdate="20190609T062410Z">
        <seg>拥有两个状态化数据源、两个状态化任务以及两个无状态数据汇的流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications are long-running and their workloads are often unpredicta‐ ble.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T043644Z" creationid="xccui" creationdate="20190725T043644Z">
        <seg>流式应用通常都需要长时间运行，这就导致了它的工作负载往往难以预测。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications are often designed to run continuously for months or years.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T130113Z" creationid="xccui" creationdate="20190704T035535Z">
        <seg>流式应用经常会被设计成需要长年累月地连续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications are supposed to run continuously and must recover from fail‐ ures, such as failing machines or processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T013527Z" creationid="xccui" creationdate="20190702T203549Z">
        <seg>连续运行的流式应用需要具备从（机器或进程）故障中恢复的能力，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications are typically designed to run 24/7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071805Z" creationid="xccui" creationdate="20190424T064357Z">
        <seg>流式应用通常都会设计成7×24小时运行，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications need to exchange data in a pipelined fashion, i.e., each pair of TaskManagers maintains a permanent TCP connection to exchange data&lt;t2/&gt;3&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042859Z" creationid="xccui" creationdate="20190504T042843Z">
        <seg>流式应用需要以流水线方式交换数据，即每对TaskManager之间都维护一个永久的TCP连接来交换数据3。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications need to exchange data in a pipelined fashion—each pair of TaskManag‐ ers maintains a permanent TCP connection to exchange data.2 With a shuffle connec‐ tion pattern, each sender task needs to be able to send data to each receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T192058Z" creationid="xccui" creationdate="20190606T195847Z">
        <seg>流式应用需要以流水线方式交换数据，因此每对TaskManager之间都要维护一个永久的TCP连接来执行数据交换2。在Shuffle连接模式下，每个发送端任务都需要向任意一个接收任务传输数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications usually emit their results to some external system, such as Apache Kafka, a filesystem, or a database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054057Z" creationid="xccui" creationdate="20190612T054057Z">
        <seg>流式应用通常都会把结果发送到某些外部系统，例如Apache Kafka，文件系统或数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming systems define their behavior in the pres&lt;t0/&gt;‐&lt;t1/&gt; ence of failures by offering result guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044432Z" creationid="xccui" creationdate="20190415T044326Z">
        <seg>流处理系统通过不同的结果保障来定义故障时的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming systems define their behavior in the presence of failures by offering result guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034128Z" creationid="xccui" creationdate="20190606T034128Z">
        <seg>流处理系统通过不同的结果保障来定义故障时的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamingFileSink Requires Checkpointing Be Enabled</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T192804Z" creationid="xccui" creationdate="20190711T192804Z">
        <seg>StreamingFileSink需要检查点处于开启状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamingFileSink provides end-to-end exactly-once guarantees for an application given that the application is configured with exactly-once checkpoints and all its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205037Z" creationid="xccui" creationdate="20190710T205037Z">
        <seg>假如应用配置了精确一次检查点，且它所有数据源都能在故障时重置，那么StreamingFileSink就可以提供端到端的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamingFileSink provides exactly-once output guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T183344Z" creationid="xccui" creationdate="20190711T183344Z">
        <seg>StreamingFileSink可以提供精确一次的输出保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamingFileSink simply incre‐ ments the file IDs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T020827Z" creationid="xccui" creationdate="20190711T020809Z">
        <seg>StreamingFileSink只是单纯地对ID执行递增操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamingFileSink supports two modes of writing records to part files: row encod‐ ing and bulk encoding.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T023309Z" creationid="xccui" creationdate="20190711T022658Z">
        <seg>StreamingFileSink支持两种分块文件的写入模式：行编码（row encoding）和批量编码（bulk encoding）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamingFileSink will never move files from pending into fin‐ ished state, if an application does not enable checkpointing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T192930Z" creationid="xccui" creationdate="20190711T192930Z">
        <seg>如果应用没有开启检查点，StreamingFileSink将永远不会把等待状态的文件变为完成状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream‐ ing jobs run for long periods of time, and thus state might be collected over several days or even months.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185018Z" creationid="xccui" creationdate="20190606T033124Z">
        <seg>流式作业通常会运行较长时间，因此状态可能是经过数天甚至数月才收集得到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String and a Double field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T043951Z" creationid="xccui" creationdate="20190716T043951Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sub&lt;t0/&gt;‐&lt;t1/&gt; sets of an organization’s data are stored in multiple of these systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T040827Z" creationid="xccui" creationdate="20190314T065729Z">
        <seg>一些机构的数据可能会同时存储在多个系统里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Submitting a job to a Flink YARN session cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T232119Z" creationid="xccui" creationdate="20190718T232119Z">
        <seg>向会话模式的Flink YARN集群提交作业</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Submitting an application to a Flink standalone cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T153719Z" creationid="xccui" creationdate="20190717T153719Z">
        <seg>向Flink独立集群提交应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequent transformations pro‐ cess the elements of all input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T060929Z" creationid="xccui" creationdate="20190614T064047Z">
        <seg>这样后续的转换操作就可以对所有输入流中的元素统一处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently, Flink’s ResourceManager requests containers from YARN’s ResourceManager and starts TaskManager pro‐ cesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T212751Z" creationid="xccui" creationdate="20190718T212751Z">
        <seg>随后，Flink的ResourceManager会向YARN的ResourceManager申请容器并启动TaskManager进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently, it merges all windows with overlapping ranges.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T032036Z" creationid="xccui" creationdate="20190623T062316Z">
        <seg>随后分配器会将所有范围存在重叠的窗口合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently, the task updates its event-time clock to be the minimum of all partition watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T024721Z" creationid="xccui" creationdate="20190607T024706Z">
        <seg>随后，任务会把事件时间时钟调整为所有分区水位线中最小的那个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently, we showed you how to implement custom source and sink connectors, including WAL and 2PC sink connectors, providing detailed examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T214509Z" creationid="xccui" creationdate="20190716T214235Z">
        <seg>随后，我们通过详细示例向你展示了如何实现自定义的数据源连接器以及数据汇连接器，其中主要包括基于WAL和2PC的数据汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055728Z" creationid="xccui" creationdate="20190414T055139Z">
        <seg>摘要可能是一个计数值，一个累加和，至今所见事件的抽样，一个窗口缓冲，或是只保留了那些运行应用感兴趣属性的某种自定义数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a summary can be a count, a sum, a sample of the events seen so far, a window buffer, or a custom data structure that preserves some property of interest to the running application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T183345Z" creationid="xccui" creationdate="20190606T032633Z">
        <seg>这种摘要可能是一个数量值，一个累加值，一个对至今为止全部事件的抽样，一个窗口缓冲或是一个保留了应用运行过程中某些有价值信息的自定义数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such an architecture implies that a separate system needs to be set up and maintained, which can be a major effort, especially if this needs to be a distributed system as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T162351Z" creationid="xccui" creationdate="20190705T162351Z">
        <seg>为了实现该架构，我们需要搭建和维护一套独立的系统。它工作量可能非常大，尤其在系统同样是分布式的情况下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such records are called late records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T065826Z" creationid="xccui" creationdate="20190529T035345Z">
        <seg>我们称此类记录为迟到记录（late record）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021634Z" creationid="xccui" creationdate="20190225T021634Z">
        <seg>总结</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary | 15</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130843Z" creationid="xccui" creationdate="20190605T130843Z">
        <seg>总结 | 15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary | 219</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T214545Z" creationid="xccui" creationdate="20190716T214545Z">
        <seg>总结 | 219</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary | 69</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032814Z" creationid="xccui" creationdate="20190610T032814Z">
        <seg>总结 | 69</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary | 77</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012750Z" creationid="xccui" creationdate="20190612T012750Z">
        <seg>总结 | 77</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supplemental material (code examples in Java and Scala) is available for download at</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210813Z" creationid="esouser" creationdate="20190603T210813Z">
        <seg>Supplemental material (code examples in Java and Scala) is available for download at</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supported Data Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022807Z" creationid="xccui" creationdate="20190225T022807Z">
        <seg>支持的数据类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift FS paths are identified by the swift:// scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T044245Z" creationid="xccui" creationdate="20190722T044245Z">
        <seg>Swift FS路径协议是swift://。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021655Z" creationid="xccui" creationdate="20190225T021655Z">
        <seg>系统架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Architecture | 39</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032542Z" creationid="xccui" creationdate="20190610T032542Z">
        <seg>系统架构 | 39</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Configuration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025523Z" creationid="xccui" creationdate="20190225T025523Z">
        <seg>系统配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Configuration | 239</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042848Z" creationid="xccui" creationdate="20190725T042848Z">
        <seg>系统配置 | 239</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Configuration | 241</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042858Z" creationid="xccui" creationdate="20190725T042858Z">
        <seg>系统配置 | 241</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Configuration | 243</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042914Z" creationid="xccui" creationdate="20190725T042914Z">
        <seg>系统配置 | 243</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System scope configuration options and their default values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043022Z" creationid="xccui" creationdate="20190804T043022Z">
        <seg>系统域的配置项和它们的默认值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T053620Z" creationid="xccui" creationdate="20190707T053620Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T element, long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190004Z" creationid="xccui" creationdate="20190626T190004Z">
        <seg>T element, long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TXN defines a transaction identifier that can be used to identify and recover a transaction after a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T051945Z" creationid="xccui" creationdate="20190716T044057Z">
        <seg>TXN定义了可用于故障后事务识别与恢复的事务标识符的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T043745Z" creationid="xccui" creationdate="20190729T043745Z">
        <seg>表10-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T050122Z" creationid="xccui" creationdate="20190729T050122Z">
        <seg>表10-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T152653Z" creationid="xccui" creationdate="20190729T152653Z">
        <seg>表10-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045252Z" creationid="xccui" creationdate="20190729T045252Z">
        <seg>表10-12，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T161752Z" creationid="xccui" creationdate="20190729T161752Z">
        <seg>表10-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-14.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162554Z" creationid="xccui" creationdate="20190729T162554Z">
        <seg>表10-14，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-15.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T193831Z" creationid="xccui" creationdate="20190729T193831Z">
        <seg>表10-15，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-16 shows the REST call to rescale an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200926Z" creationid="xccui" creationdate="20190729T200926Z">
        <seg>表10-16展示了对应用进行扩缩容的REST调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200931Z" creationid="xccui" creationdate="20190729T200931Z">
        <seg>表10-16，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-17.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043003Z" creationid="xccui" creationdate="20190804T043003Z">
        <seg>表10-17，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-18</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043548Z" creationid="xccui" creationdate="20190804T043548Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-18.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043637Z" creationid="xccui" creationdate="20190804T043637Z">
        <seg>表10-18，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055446Z" creationid="xccui" creationdate="20190804T055446Z">
        <seg>表10-19</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T043846Z" creationid="xccui" creationdate="20190729T043846Z">
        <seg>表10-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T043937Z" creationid="xccui" creationdate="20190729T043937Z">
        <seg>表10-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-4 shows the REST request to list all metrics that are collected for the Job‐ Manager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044251Z" creationid="xccui" creationdate="20190729T044251Z">
        <seg>表10-4展示的REST请求可以列出JobManager中收集的全部指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044255Z" creationid="xccui" creationdate="20190729T044255Z">
        <seg>表10-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-5 shows the REST request to list all metrics that are collected for the Task‐ Managers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044604Z" creationid="xccui" creationdate="20190729T044604Z">
        <seg>表10-5展示的REST请求可以列出TaskManager中收集的全部指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044609Z" creationid="xccui" creationdate="20190729T044609Z">
        <seg>表10-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045041Z" creationid="xccui" creationdate="20190729T045041Z">
        <seg>表10-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045456Z" creationid="xccui" creationdate="20190729T045456Z">
        <seg>表10-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045737Z" creationid="xccui" creationdate="20190729T045737Z">
        <seg>表10-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 10-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045848Z" creationid="xccui" creationdate="20190729T045848Z">
        <seg>表10-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 8-1 shows the end-to-end consistency guarantees for different types of source and sink connectors that can be achieved in the best case; depending on the imple‐ mentation of the sink, the actual consistency might be worse.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T165942Z" creationid="xccui" creationdate="20190708T165942Z">
        <seg>表8-1展示了不同类型的数据源和数据汇接收器在最好的情况下能够实现的端到端的一致性。根据数据汇的具体实现，实际的一致性可能无法达到最佳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table 8-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T165946Z" creationid="xccui" creationdate="20190708T165946Z">
        <seg>表8-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table API and SQL for Relational Analysis</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152519Z" creationid="esouser" creationdate="20190603T152515Z">
        <seg>用于关系型分析的Table API及SQL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table of Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T013833Z" creationid="xccui" creationdate="20190225T013833Z">
        <seg>目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tables 10-1, 10-2, and 10-3 show the REST requests to obtain infor‐ mation about a Flink cluster, such as the number of task slots, running and finished jobs, the configuration of the JobManager, or a list of all connected TaskManagers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044022Z" creationid="xccui" creationdate="20190729T043740Z">
        <seg>表10-1，10-2和10-3所展示的REST请求可用来获取Flink集群信息，例如：任务槽的数量，正在运行和已结束的作业，JobManager的配置以及所有相连的TaskManager列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tables 10-11, 10-12, and 10-13 show how to manage running applications using the REST API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T152650Z" creationid="xccui" creationdate="20190729T152650Z">
        <seg>表10-11、10-12和10-13展示了如何使用REST API管理正在运行的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tables 10-7, 10-8, and 10-9 show the REST endpoints to manage these JAR files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045705Z" creationid="xccui" creationdate="20190729T045436Z">
        <seg>表10-7、10-8和10-9展示了用于管理这些JAR文件的REST端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take a checkpoint by copying the state of each task to a remote, persistent stor‐ age.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224051Z" creationid="xccui" creationdate="20190608T224031Z">
        <seg>将所有任务的状态拷贝到远程持久化存储，生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take a look at the Flink docu‐ mentation to learn how to implement and register a custom filesystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T050756Z" creationid="xccui" creationdate="20190722T050756Z">
        <seg>有关实现和注册自定义文件系统的内容请查阅Flink文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take a look at the official documentation for details about how to access this informa‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T161749Z" creationid="xccui" creationdate="20190729T161749Z">
        <seg>获取这些信息的详细途径请查阅官方文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take for example a rolling aggregation operator that outputs the current sum of all the events it has seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T052032Z" creationid="xccui" creationdate="20190414T052003Z">
        <seg>以某个滚动聚合算子为例，它会输出至今所有看到的事件之和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take, for example, a rolling aggregation operator that outputs the current sum of all the events it has seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181616Z" creationid="xccui" creationdate="20190606T031517Z">
        <seg>以某个滚动聚合算子为例，假设它会输出至今为止所见到的全部事件之和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takes a savepoint of the application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T181124Z" creationid="xccui" creationdate="20190729T181124Z">
        <seg>为指定应用生成一个保存点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Takes a savepoint, cancels the application, and restarts it with the new default parallelism from the savepoint Response</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201651Z" creationid="xccui" creationdate="20190729T201651Z">
        <seg>生成一个保存点，取消应用，并将它以新的默认并行度从保存点中重启 响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taking a savepoint from an application and restoring an application from a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215136Z" creationid="xccui" creationdate="20190609T215136Z">
        <seg>为应用生成保存点和从保存点恢复应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taking and disposing of a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033154Z" creationid="xccui" creationdate="20190726T033154Z">
        <seg>生成和清除保存点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043118Z" creationid="xccui" creationdate="20190804T043118Z">
        <seg>任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task Chaining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021822Z" creationid="xccui" creationdate="20190225T021822Z">
        <seg>任务链接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task Execution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021752Z" creationid="xccui" creationdate="20190225T021752Z">
        <seg>任务执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task Failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144251Z" creationid="esouser" creationdate="20190603T144251Z">
        <seg>任务故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task chaining can significantly reduce the communication costs between local tasks, but there are also cases when it makes sense to execute a pipeline without chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T201858Z" creationid="xccui" creationdate="20190606T203900Z">
        <seg>虽然任务链接可以有效地降低本地任务之间的通信开销，但有的流水线应用反而不需要启用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task chaining can significantly reduce the communication costs between local tasks, however there are also cases when it makes sense to execute a pipeline without chain&lt;t0/&gt;‐&lt;t1/&gt; ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T154339Z" creationid="esouser" creationdate="20190514T154032Z">
        <seg>虽然任务链接可以有效地降低本地任务之间的通信开销，但并不意味着所有的流水线执行都要启用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task chaining fuses the parallel tasks of two or more operators into a single task that is executed by a single thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T010307Z" creationid="xccui" creationdate="20190730T161613Z">
        <seg>任务链接将两个或多个算子的并行任务融合在一起，从而可以让它们在同一线程中执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task chaining is enabled by default in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155143Z" creationid="esouser" creationdate="20190514T155137Z">
        <seg>Flink在默认情况下会开启任务链接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T204829Z" creationid="xccui" creationdate="20190225T020501Z">
        <seg>任务故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043728Z" creationid="xccui" creationdate="20190804T043728Z">
        <seg>任务：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManager and job</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043109Z" creationid="xccui" creationdate="20190804T043109Z">
        <seg>TaskManager及作业</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManager failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205310Z" creationid="xccui" creationdate="20190428T205310Z">
        <seg>TaskManager故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManager metrics.scope.tm</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043100Z" creationid="xccui" creationdate="20190804T043100Z">
        <seg>TaskManager metrics.scope.tm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManager: &lt;host&gt;, &lt;tm_id&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043715Z" creationid="xccui" creationdate="20190804T043715Z">
        <seg>TaskManager： &lt;host&gt;, &lt;tm_id&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManagers &lt;t0/&gt;are the worker processes of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T051341Z" creationid="xccui" creationdate="20190418T051341Z">
        <seg>TaskManager是Flink的工作进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManagers are the worker processes of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061010Z" creationid="xccui" creationdate="20190606T142307Z">
        <seg>TaskManager是Flink的工作进程（worker process）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks can register timers at the timer service to perform a computa&lt;t2/&gt;‐&lt;t3/&gt; tion at a specific point in time in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041504Z" creationid="xccui" creationdate="20190529T041236Z">
        <seg>这些定时器可由任务在时间服务内注册，并在将来的某个时间点执行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks can register timers at the timer service to perform a computa‐ tion at a specific point in time in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T070559Z" creationid="xccui" creationdate="20190606T210249Z">
        <seg>这些计时器是由任务在时间服务内注册，并在将来的某个时间点执行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks checkpoint their state once all barriers have been received, then they forward the checkpoint barrier</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T192452Z" creationid="xccui" creationdate="20190609T191948Z">
        <seg>任务在收到全部分隔符后将状态存入检查点，然后向下游转发检查点分隔符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks continue regular processing after the checkpoint barrier is forwarded</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193707Z" creationid="xccui" creationdate="20190609T193606Z">
        <seg>任务在转发检查点分隔符后继续进行常规处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks have an internal time service that maintains timers and is activated when a water&lt;t0/&gt;‐&lt;t1/&gt; mark is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041324Z" creationid="xccui" creationdate="20190529T040840Z">
        <seg>任务的内部时间服务（time service）会维护定时器（timer），并在接收到水位线时激活。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks have an internal time service that maintains timers and is activated when a water‐ mark is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T052518Z" creationid="xccui" creationdate="20190606T210238Z">
        <seg>任务内部的时间服务（time service）会维护一些计时器（timer），它们依靠接收到水位线来激活。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks of operators that are in different slot-sharing groups are not exe‐ cuted by the same slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T021640Z" creationid="xccui" creationdate="20190731T014732Z">
        <seg>属于不同处理槽共享组的算子，其任务会交由不同的处理槽执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks of time-based opera&lt;t2/&gt;‐&lt;t3/&gt; tors collect and process records with possibly unordered timestamps and finalize a computation when their event-time clock, which is advanced by received watermarks, indicates that no more records with relevant timestamps have to be expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035025Z" creationid="xccui" creationdate="20190529T034137Z">
        <seg>对基于时间算子的任务而言，其收集和处理的记录可能会包含乱序的时间戳。只有当它们的事件时间时钟（由接收的水位线驱动）指示不必再等那些包含相关时间戳的记录时，才会最终触发计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks of time-based opera‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205539Z" creationid="xccui" creationdate="20190606T205539Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks wait to receive a barrier on each input partition; records from input streams for which a barrier already arrived are buffered; all other records are regularly processed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193637Z" creationid="xccui" creationdate="20190609T175039Z">
        <seg>任务等待接收所有输入分区的分隔符，来自已接收分隔符输入分区的记录会被缓存，其他记录则按常规处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks with keyed state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T191928Z">
        <seg>带有键值分区状态的任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks with operator state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061908Z" creationid="xccui" creationdate="20190607T061908Z">
        <seg>带有算子状态的任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TextInputFormat reads text files line-wise (split by newline characters), subclasses of CsvInputFormat read files with comma- separated values, and AvroInputFormat reads files with Avro-encoded records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T195957Z" creationid="xccui" creationdate="20190710T195957Z">
        <seg>TextInputFormat会按行（由换行符指定）读取文本文件，CsvInputFormat的子类可用来读取CSV（comma-separated values）文件，AvroInputFormat可以读取存有Avro编码格式记录的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thank you, Adam Kawa, Aljoscha Krettek, Kenneth Knowles, Lea Giordano, Matthias J. Sax, Stephan Ewen, Ted Malaska, and Tyler Akidau.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T161943Z" creationid="xccui" creationdate="20190608T161943Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thank you, Alicia Young, Colleen Lobner, Christine Edwards, Katherine Tozer, Marie Beaugureau, and Tim McGovern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T162030Z" creationid="xccui" creationdate="20190605T134127Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to the built-in logic of GenericWriteAheadSink, it is not difficult to imple‐ ment a sink that leverages a WAL.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T060707Z" creationid="xccui" creationdate="20190715T060707Z">
        <seg>多亏了GenericWriteAheadSink的内部逻辑才让我们可以相对容易地实现基于WAL的数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is because the number of tasks might change when an application is started with different parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062816Z" creationid="xccui" creationdate="20190609T215724Z">
        <seg>这是因为任务数目可能会随着应用启动时所指定的并行度而改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, after recovery, it should know whether an event update has already been reflected on the state or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045657Z" creationid="xccui" creationdate="20190416T044436Z">
        <seg>即在故障恢复后，引擎需要知道某个事件对应的更新是否已经反映到状态上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, how long do we have to wait before we can be certain that we have received all events that happened before a certain point of time?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160704Z" creationid="xccui" creationdate="20190412T161649Z">
        <seg>换言之，我们需要等多久才能确定已经收到了所有发生在某个特定时间点之前的事件？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the API calls that create stream sources and transformations do not immediately trigger any data processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053155Z" creationid="xccui" creationdate="20190613T011133Z">
        <seg>也就是说，那些创建数据源和转换操作的API调用不会当即触发任何数据处理，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the processing of an event does not depend on any events seen in the past and no history is kept.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T055045Z" creationid="xccui" creationdate="20190405T035802Z">
        <seg>即处理事件时无需依赖过去看到的事件，也不保存历史数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, throughput tells us how many events the system can process per time unit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195507Z" creationid="xccui" creationdate="20190401T195445Z">
        <seg>它告诉我们系统每单位时间可以处理多少事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, we are concerned with what the application code sees as state value after recovering from a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T191604Z" creationid="xccui" creationdate="20190415T045129Z">
        <seg>也就是说，我们关注故障恢复后应用代码能够看到的状态值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you are primarily concerned with determining the &lt;t0/&gt;peak&lt;t1/&gt; throughput, i.e. the perfor&lt;t2/&gt;‐&lt;t3/&gt; mance limit when your system is at its maximum load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T205829Z" creationid="xccui" creationdate="20190401T203852Z">
        <seg>换言之，首要关注点是确定峰值吞吐，即系统满负载时的性能上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you are primarily concerned with determining the peak throughput—the perfor‐ mance limit when your system is at its maximum load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052457Z" creationid="xccui" creationdate="20190605T234550Z">
        <seg>换言之，首要的关注点是确定峰值吞吐，即系统满负载时的性能上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you can re-play a stream and analyze historic data as if events are happening in real-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T154822Z" creationid="xccui" creationdate="20190412T154656Z">
        <seg>这意味着你可以通过重放数据流来分析历史数据，就如同它们是实时产生的一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you can replay a stream and analyze historic data as if events are happening in real time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025105Z" creationid="xccui" creationdate="20190606T025105Z">
        <seg>这意味着你可以通过重放数据流来分析历史数据，就如同它们是实时产生的一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you will get the fastest service if you are the only customer in the coffee shop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054048Z" creationid="xccui" creationdate="20190402T204424Z">
        <seg>也就是说，如果咖啡店只有你一名顾客，你将获得最快的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means each parallel instance of the function is responsible for a subrange of the key domain and maintains the corresponding state instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T020043Z" creationid="xccui" creationdate="20190630T035827Z">
        <seg>这意味着每个函数的并行实例都会负责一部分键值域并维护相应的状态实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That’s it!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041710Z" creationid="xccui" creationdate="20190611T041710Z">
        <seg>就这么简单！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That’s it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T022452Z" creationid="xccui" creationdate="20190328T061659Z">
        <seg>就这么简单，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203027Z" creationid="esouser" creationdate="20190603T203027Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The -p 8081:8081 parameter of the first command maps port 8081 of the master container to port 8081 of the host machine to make the Web UI accessible from the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T041219Z" creationid="xccui" creationdate="20190718T035511Z">
        <seg>第一个命令中的"-p 8081:8081"参数将主容器的8081端口映射到宿主机的8081端口，使得Flink Web UI能够从外部宿主机访问到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ./bin/ flink.bat script for the Windows command line provides only very limited functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T165919Z" creationid="xccui" creationdate="20190726T021808Z">
        <seg>针对Windows系统所提供的./bin/flink.bat脚本功能有限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ./bin/start-cluster.sh script starts a master process on the local machine and one or more TaskManagers on the local or remote machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T195037Z" creationid="xccui" creationdate="20190717T163010Z">
        <seg>./bin/start-cluster.sh脚本会在本地机器上启动一个主进程，并在本地或远程机器上启动一个或多个TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ./flink-container/docker directory also contains a docker-compose.yml file to deploy a Flink application with docker-compose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T213816Z" creationid="xccui" creationdate="20190730T035047Z">
        <seg>./flink-container/docker目录还包含了一个docker-compose.yml文件，用于通过docker-compose部署Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 2PC protocol piggybacks on Flink’s existing checkpointing mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T163409Z" creationid="xccui" creationdate="20190708T163409Z">
        <seg>2PC协议需要基于Flink已有的检查点机制来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;Dispatcher&lt;t1/&gt; runs across job executions and provides a REST interface to sub&lt;t2/&gt;‐&lt;t3/&gt; mit applications for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T053228Z" creationid="xccui" creationdate="20190418T052650Z">
        <seg>Dispatcher会跨多个作业运行，它提供了一个REST接口来提交要执行的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;JobManager&lt;t1/&gt; is the master process that controls the execution of a single application, i.e., each application is controlled by a different JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033838Z" creationid="xccui" creationdate="20190418T033838Z">
        <seg>JobManager作为主进程，控制着单个应用的执行。换句话说，每个应用都由一个不同的JobManager掌控。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;broadcast&lt;t1/&gt; strategy sends every data item to all parallel tasks of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135817Z" creationid="xccui" creationdate="20190401T134909Z">
        <seg> 广播策略（broadcast strategy）会把数据项发往下游算子的全部并发任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;forward&lt;t1/&gt; strategy sends data from a task to a receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135823Z" creationid="xccui" creationdate="20190401T134033Z">
        <seg>转发策略（forward strategy）在发送端任务和接收端任务之间进行一对一的数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;key-based&lt;t1/&gt; strategy partitions data by a key attribute and guarantees that data items having the same key will be processed by the same task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135841Z" creationid="xccui" creationdate="20190401T135059Z">
        <seg>基于键值的策略（key-based strategy）根据某一键值属性将数据分成多份并保证键值相同的数据项一定会交由同一个任务处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;random&lt;t1/&gt; strategy uniformly distributes data items to operator tasks in order to evenly distribute the load across computing tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T140101Z" creationid="xccui" creationdate="20190401T135738Z">
        <seg>随机策略（random strategy）为了实现计算任务的负载均衡，会将数据均匀分配至算子的所有任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Apache Software Foundation alone is the home of more than a dozen projects related to stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050546Z" creationid="xccui" creationdate="20190605T050546Z">
        <seg>仅Apache软件基金会一家就有十多个和流处理相关的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Apache Software Foundation alone is the home of more than a dozen projects that are related to stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T053503Z" creationid="xccui" creationdate="20190319T053503Z">
        <seg>仅Apache软件基金会一家就有十多个和流处理相关的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Application Might Not Rescale</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201821Z" creationid="xccui" creationdate="20190729T201821Z">
        <seg>应用扩缩容可能失败</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053550Z" creationid="xccui" creationdate="20190416T053550Z">
        <seg>Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Architecture of Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021648Z" creationid="xccui" creationdate="20190225T021648Z">
        <seg>Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The BroadcastProcessFunction and KeyedBroadcastProcess Function differ from each other as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T053632Z" creationid="xccui" creationdate="20190702T053632Z">
        <seg>BroadcastProcessFunction和KeyedBroadcastProcessFunction本身也有所不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The BucketAssigner can be configured on the builder using the withBucketAssigner() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T212110Z" creationid="xccui" creationdate="20190710T212110Z">
        <seg>我们可以使用构建器的withBucketAssigner()方法配置BucketAssigner。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CLI client lets you retrieve and visualize query results in the command line, which makes it a great tool to try out and debug Flink SQL queries or run exploratory queries on streaming or batch data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T161536Z" creationid="xingcan" creationdate="20190807T161536Z">
        <seg>CLI客户端允许你在命令行中获取和可视化查询结果，这使它成为一个在流式或批式数据上调试Flink SQL查询或运行探索式查询的绝佳工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CQL statements in Example 8-6 create a keyspace</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210014Z" creationid="xccui" creationdate="20190711T210014Z">
        <seg>示例8-6中的CQL语句创建了一个"example"键空间以及该键空间下的"sensors"表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Cassandra sink builders for tuples, case classes, and rows require the specifica‐ tion of a CQL INSERT query.5 The query is configured using the CassandraSink Builder.setQuery() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212343Z" creationid="xccui" creationdate="20190711T212226Z">
        <seg>若是要创建针对元组、样例类或Row类型的Cassandra数据汇构建器，你需要提供一个CQL INSERT查询。5 该查询可以用CassandraSinkBuilder.setQuery()方法配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Cassandra sink connector benefits from the WAL because it guards from nondeterministic keys and prevents inconsistent writes to Cassandra.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065931Z" creationid="xccui" creationdate="20190715T065931Z">
        <seg>WAL对于Cassandra数据汇连接器的意义在于，它可以在键值不确定的情况下避免不一致的写入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Cassandra sink connector follows the same approach when the WAL is not enabled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T032630Z" creationid="xccui" creationdate="20190715T032630Z">
        <seg>在未启用WAL时，Cassandra数据汇连接器也会使用该方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Cassandra sink connector with WAL is implemented based on Flink’s GenericWriteAheadSink operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T224111Z" creationid="xccui" creationdate="20190711T224111Z">
        <seg>带有WAL的Cassandra数据汇连接器是基于Flink的GenericWriteAheadSink算子实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Cassandra sink connector with WAL-enabled implements this interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T035652Z" creationid="xccui" creationdate="20190715T035652Z">
        <seg>启用WAL的Cassandra数据汇连接器就实现了该接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CheckpointedFunction interface defines two methods, initializeState() and snapshotState(), which work similar to the methods of the ListCheckpointed interface for operator list state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T063959Z" creationid="xccui" creationdate="20190702T063959Z">
        <seg>CheckpointedFunction接口定义了两个方法——initializeState()和snapshotState()，它们的工作模式和算子列表状态中ListCheckpointed接口的方法类似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CheckpointedFunction interface is the lowest-level interface to specify stateful functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T052126Z" creationid="xccui" creationdate="20190702T055816Z">
        <seg>CheckpointedFunction是用于指定状态化函数的最低级别接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Checkpoints tab (Figure 10-3) displays statistics about previous and current checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T151923Z" creationid="xingcan" creationdate="20190802T145453Z">
        <seg>Checkpoints选项卡（图10-3）展示了有关以往和现在检查点的统计信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CoProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023132Z" creationid="xccui" creationdate="20190225T023132Z">
        <seg>CoProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CoProcessFunction also provides an onTimer() callback method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T012345Z" creationid="xccui" creationdate="20190622T031242Z">
        <seg>CoProcessFunction同样提供了onTimer()回调方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ConnectedStreams object provides map() and flatMap() methods that expect a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T041020Z" creationid="xccui" creationdate="20190615T041010Z">
        <seg>ConnectedStreams对象提供了map()和flatMap()方法，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Context object is what makes a process function special.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062408Z" creationid="xccui" creationdate="20190621T054010Z">
        <seg>Context对象是让处理函数与众不同的精华所在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Context object of SinkFunction provides access to the current processing time, the current watermark (i.e., the current event time at the sink), and the timestamp of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T213101Z" creationid="xccui" creationdate="20190713T213101Z">
        <seg>我们可以利用其中的Context对象访问当前处理时间，当前水位线（数据汇当前的事件时间）以及记录的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Context object of the ProcessWindowFunction gives access to the metadata of the window, the current pro‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011411Z" creationid="xccui" creationdate="20190624T011304Z">
        <seg>ProcessWindowFunction的Context对象可以用于访问窗口的元数据，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataSet API for Batch Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152457Z" creationid="esouser" creationdate="20190603T152457Z">
        <seg>用于批处理的DataSet API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataSet API provides operators to perform filtering, mapping, selection, joins, and groupings, as well as connectors to read and write datasets from and to external systems, such as filesystems and data‐ bases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T153929Z" creationid="xingcan" creationdate="20190807T153929Z">
        <seg>DataSet API提供了用于过滤、映射、选择、连接以及分组的算子，同时还有从外部系统（如文件系统和数据库）读写数据集的连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014854Z" creationid="xccui" creationdate="20190612T014854Z">
        <seg>DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API (v1.7) | 79</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045132Z" creationid="xccui" creationdate="20190619T045132Z">
        <seg>DataStream API （1.7版本） | 79</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API (v1.7).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022444Z" creationid="xccui" creationdate="20190225T022435Z">
        <seg>DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API exposes interfaces and methods to define custom window oper‐ ators by allowing you to implement your own assigners, triggers, and evictors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051018Z" creationid="xccui" creationdate="20190625T051229Z">
        <seg>DataStream API对外暴露了自定义窗口算子的接口和方法，你可以实现自己的分配器（assigner）、触发器（trigger）以及移除器（evictor）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API features the abstraction of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060633Z" creationid="xccui" creationdate="20190614T043951Z">
        <seg>作为DataStream API中一类特殊的DataStream，KeyedStream抽象可以从逻辑上将事件按照键值分配到多条独立的子流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API of Flink 1.7 features the WindowFunction interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010353Z" creationid="xccui" creationdate="20190624T010232Z">
        <seg>Flink 1.7版本的DataStream API还提供了WindowFunction接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides a family of low-level transformations, the process functions, which can also access record timestamps and watermarks and register timers that trigger at a specific time in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T012118Z" creationid="xccui" creationdate="20190621T043822Z">
        <seg>DataStream API提供了一组相对底层的转换——处理函数。除了基本功能，它们还可以访问记录的时间戳和水位线，并支持注册在将来某个特定时间触发的计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides built-in methods for the most common window oper‐ ations as well as a very flexible windowing mechanism to define custom windowing logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T023619Z" creationid="xccui" creationdate="20190622T033836Z">
        <seg>DataStream API针对一些最常见窗口操作都提供了内置方法，还提供了一些非常灵活的窗口机制来自定义窗口逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides different options for how to handle late events:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T152913Z" creationid="xingcan" creationdate="20190628T152913Z">
        <seg>DataStream API提供了不同的选项来应对迟到事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides event-time and processing-time assigners, as well as shortcut methods, and a time interval offset can be set as the third parameter to the window assigner:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060021Z" creationid="xccui" creationdate="20190623T055947Z">
        <seg>DataStream API提供了针对事件时间和处理时间的分配器以及相关的简写方法。你可以将时间间隔偏移设为窗口分配器的第三个参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides implementations for two common cases of timestamp assigners with periodic watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051417Z" creationid="xccui" creationdate="20190620T051417Z">
        <seg>DataStream API内置了两个针对常见情况的周期性水位线时间戳分配器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides powerful yet easy-to-use tools to access and maintain operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T050309Z" creationid="xccui" creationdate="20190707T050309Z">
        <seg>DataStream API提供了强大、易用的工具来访问和维护算子状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides rich functions that expose more functionality than the regular functions discussed until now.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041053Z" creationid="xccui" creationdate="20190618T060242Z">
        <seg>DataStream API提供了一类富函数，它和我们之前见到的普通函数相比可对外提供更多功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides the TimestampAssigner interface to extract time‐ stamps from elements after they have been ingested into the streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T053716Z" creationid="xccui" creationdate="20190620T025925Z">
        <seg>DataStream API中提供了TimestampAssigner接口，用于从已读入流式应用的元素中提取时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides the connect transformation to support such use cases.1 The DataStream.connect() method receives a DataStream and returns a Connected Streams object, which represents the two connected streams:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T055224Z" creationid="xccui" creationdate="20190615T040600Z">
        <seg>DataStream API提供的connect转换可以用来实现该用例。1 DataStream.connect()方法接收一个DataStream并返回一个ConnectedStream对象，该对象表示两个联结起来（connected）的流：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides the following rolling aggregation methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T050806Z" creationid="xccui" creationdate="20190614T052557Z">
        <seg>DataStream API中提供了以下滚动聚合方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides transformations for the most common data transfor‐ mation operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T023051Z" creationid="xccui" creationdate="20190613T023051Z">
        <seg>DataStream API为一些最常见的数据转换操作都提供了对应的转换抽象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides two interfaces to implement source connectors along with corresponding RichFunction abstract classes:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T145834Z" creationid="xccui" creationdate="20190712T145346Z">
        <seg>DataStream API提供了两个接口以及二者对应的RichFunction抽象类来实现数据源连接器：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream.split()  method  returns  a  SplitStream,  which  provides  a select() method to select one or more streams from the SplitStream by specify‐ ing the output names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061408Z" creationid="xccui" creationdate="20190615T061408Z">
        <seg>DataStream.split()方法会返回一个SplitStream对象，它提供的select()方法可以让我们通过指定输出名称的方式从SplitStream中选择一条或多条流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream.split() method receives an OutputSelector that defines how stream elements are assigned to named outputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T064050Z" creationid="xccui" creationdate="20190615T054406Z">
        <seg>DataStream.split()方法接收一个OutputSelector，它用来定义如何将数据流的元素分配到不同的命名输出（named output）中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream.union() method merges two or more DataStreams of the same type and produces a new DataStream of the same type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T054951Z" creationid="xccui" creationdate="20190614T063938Z">
        <seg>DataStream.union()方法可以合并两条或多条类型相同的DataStream，生成一个新的类型相同的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Datastream API provides two assigners—TumblingEventTimeWindows and Tum blingProcessingTimeWindows—for tumbling event-time and processing-time win‐ dows, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042428Z" creationid="xccui" creationdate="20190623T042428Z">
        <seg>DataStream API针对事件时间和处理时间的滚动窗口分别提供了对应的分配器——TumblingEventTimeWindows和TumblingProcessingTimeWindows。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Dispatcher runs across job executions and provides a REST interface to sub‐ mit applications for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061537Z" creationid="xccui" creationdate="20190606T142757Z">
        <seg>Dispatcher会跨多个作业运行，它提供了一个REST接口来让我们提交需要执行的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Docker internal hostname of the Job‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T033938Z" creationid="xccui" creationdate="20190718T033938Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Evictor interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201543Z" creationid="xccui" creationdate="20190627T201543Z">
        <seg>移除器接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Evictor is an optional component in Flink’s windowing mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201644Z" creationid="xccui" creationdate="20190626T201345Z">
        <seg>Evictor是Flink窗口机制中的一个可选组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Evolution of Open Source Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T064839Z" creationid="xccui" creationdate="20190225T014710Z">
        <seg>开源流处理的演变</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Evolution of Open Source Stream Processing | 11</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T064839Z" creationid="xccui" creationdate="20190605T130824Z">
        <seg>开源流处理的演变 | 11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The FilterFunction interface is typed to the type of the input stream and defines the filter() method that is called with an input event and returns a boolean:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052914Z" creationid="xccui" creationdate="20190613T052914Z">
        <seg>FilterFunction接口的类型为输入流的类型，它的filter()方法会接收一个输入事件，返回一个布尔值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Flink HA mode is configured in the ./conf/flink-conf.yaml file by setting the parameters as shown in Example 9-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T203631Z" creationid="xccui" creationdate="20190720T203631Z">
        <seg>你可以像示例9-5那样在./conf/flink-conf.yaml文件中设置参数来配置Flink HA模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Flink Kafka connector does not rely on Kafka’s own offset- tracking mechanism, which is based on so-called consumer groups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T205635Z" creationid="xccui" creationdate="20190708T205408Z">
        <seg>Flink Kafka连接器并不依赖于Kafka自身基于消费者组（consumer group）的偏移追踪机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Flink Kafka connector ingests event streams in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T204638Z" creationid="xccui" creationdate="20190708T204638Z">
        <seg>Flink Kafka连接器会以并行方式获取事件流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Flink Maven archetypes we introduced in “Bootstrap a Flink Maven Project” on page 76 generate Maven projects that are configured to produce application-fat JARs that include all required dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T043037Z" creationid="xccui" creationdate="20190619T043037Z">
        <seg>我们在第76页"创建Flink Maven项目"中介绍了利用Flink Maven模板生成Maven项目，其中就加入了生成包含全部所需依赖的胖JAR的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Flink commu‐ nity is currently working on improving the support for state evolution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T054631Z" creationid="xccui" creationdate="20190727T054614Z">
        <seg>Flink社区正在努力改善对状态变化的支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Flink distribution folder must be located on all machines at the same path.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T200522Z" creationid="xccui" creationdate="20190717T200030Z">
        <seg>Flink发行版目录在所有机器上的路径必须一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Flink docu‐ mentation provides more details on the configuration of S3 filesystems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T043852Z" creationid="xccui" creationdate="20190722T043852Z">
        <seg>你可以Flink文档中找到更多有关S3文件系统配置的详细信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The GenericWriteAheadSink template collects all outgoing records per check‐ point and stores them in the operator state of the sink task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T035547Z" creationid="xccui" creationdate="20190715T035307Z">
        <seg>GenericWriteAheadSink模板会收集每个检查点周期内所有需要写出的记录，并将它们存储到数据汇任务的算子状态中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The GlobalWindows Assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044253Z" creationid="xccui" creationdate="20190626T044253Z">
        <seg>GlobalWindows分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The GlobalWindows assigner maps all elements to the same global window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052454Z" creationid="xccui" creationdate="20190626T044319Z">
        <seg>GlobalWindows分配器会将所有元素映射到一个全局窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ID of a job can be obtained from the Web UI, the REST API, or using the command-line client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170658Z" creationid="xccui" creationdate="20190726T032913Z">
        <seg>该作业ID可以通过Web UI、REST API或命令行客户端获取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Interval Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023305Z" creationid="xccui" creationdate="20190225T023305Z">
        <seg>The Interval Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Iterable parameter of the ProcessWindowFunc tion.process() method will only provide a single value, the incrementally aggrega‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040022Z" creationid="xccui" creationdate="20190625T040022Z">
        <seg>这样传递给ProcessWindowFunction.process()方法的Iterable参数内将只有一个值，即增量聚合的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JAR file of a dependency can be added to the ./lib folder of a Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041644Z" creationid="xccui" creationdate="20190619T041644Z">
        <seg>可以将依赖的JAR包放到设置Flink的./lib目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Java API provides an AsyncDataStream class with the respective static methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T210045Z" creationid="xccui" creationdate="20190716T210045Z">
        <seg>Java API中提供了包含这些静态方法的AsyncDataStream类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobID can be obtained via the REST API, the Web UI, or the log files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T034916Z" creationid="xccui" creationdate="20190707T034916Z">
        <seg>其中的JobID可以通过REST API、Web UI或者日志文件得到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobID is used to specify the job when taking a save‐ point, canceling, or rescaling an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170251Z" creationid="xccui" creationdate="20190726T031120Z">
        <seg>该JobID可以在生成保存点、取消应用或对应用进行扩缩容时用来指定作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager can then assign tasks to the slots to execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061320Z" creationid="xccui" creationdate="20190606T142633Z">
        <seg>之后，JobManager就可以向处理槽中分配任务来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager can then assigns tasks to the slots to execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062133Z" creationid="xccui" creationdate="20190418T051927Z">
        <seg>随后，JobManager就可以向处理槽中分配任务来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager con&lt;t4/&gt;‐&lt;t5/&gt; verts the JobGraph into a physical dataflow graph called the ExecutionGraph, which consists of tasks that can be executed in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T034733Z" creationid="xccui" creationdate="20190418T034656Z">
        <seg>JobManager将JobGraph转化成名为ExecutionGraph的物理dataflow图，该图包含了那些可以并行执行的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager controls the execution of a streaming application and keeps metadata  about its execution, such as pointers to completed checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T065522Z" creationid="xccui" creationdate="20190606T145722Z">
        <seg>它用于控制流式应用执行以及保存该过程中的元数据（如已完成检查点的存储路径）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager controls the execution of a streaming application and keeps metadata about its execution, such as pointers to completed checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T043258Z" creationid="xccui" creationdate="20190502T042809Z">
        <seg>它用于控制流式应用执行以及保存该过程中的元数据（例如用于完成checkpoint的指针）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager converts the JobGraph into a physical dataflow graph called the ExecutionGraph, which consists of tasks that can be executed in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141728Z" creationid="xccui" creationdate="20190606T141717Z">
        <seg>JobManager将JobGraph转化成名为ExecutionGraph的物理Dataflow图，该图包含了那些可以并行执行的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager is the master process that controls the execution of a single application—each application is controlled by a different JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T163019Z" creationid="xccui" creationdate="20190606T141505Z">
        <seg>作为主进程（master process），JobManager控制着单个应用的执行。换句话说，每个应用都由一个不同的JobManager掌控。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager receives an application for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T034042Z" creationid="xccui" creationdate="20190418T033907Z">
        <seg>JobManager可以接收用于执行的应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager records the check‐ point of an application as completed once it has received a checkpoint acknowledge‐ ment from all tasks of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194311Z" creationid="xccui" creationdate="20190609T194259Z">
        <seg>JobManager在接收到所有应用任务返回的检查点确认消息后，就会将此次检查点标记为完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager requests the necessary processing slots from the ResourceManager and deploys the job for execution once the requested slots have been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T155524Z" creationid="xccui" creationdate="20190717T155524Z">
        <seg>JobManager向ResourceManager申请必要数量的处理槽，并在处理槽准备完毕后将作业部署执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager requests the necessary resources (TaskManager slots) to execute the tasks from the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060159Z" creationid="xccui" creationdate="20190418T034828Z">
        <seg>JobManager从ResourceManager申请执行任务的必要资源（TaskManager处理槽）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager requests the required slots from the ResourceManager to run the Flink job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T212709Z" creationid="xccui" creationdate="20190718T212709Z">
        <seg>JobManager会向ResourceManager申请运行Flink作业所需的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager spans the JobGraph into an ExecutionGraph and assigns the tasks to the four avail&lt;t2/&gt;‐&lt;t3/&gt; able slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T163951Z" creationid="xccui" creationdate="20190423T163315Z">
        <seg>JobManager将JobGraph转成ExecutionGraph并将任务分配到4个空闲槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager stores all</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T044922Z" creationid="xccui" creationdate="20190720T044922Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Job‐ Manager receives an application for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T055934Z" creationid="xccui" creationdate="20190606T141542Z">
        <seg>JobManager可以接收要执行的应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Job‐ Manager spans the JobGraph into an ExecutionGraph and assigns the tasks to the four available slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071244Z" creationid="xccui" creationdate="20190606T144553Z">
        <seg>JobManager将JobGraph"展开成"ExecutionGraph并把任务分配到4个空闲处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Kafka sink provides at-least-once guarantees under the following condi‐ tions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T153953Z" creationid="xingcan" creationdate="20190709T153953Z">
        <seg>在满足以下条件时，它才可以提供精确一次保障：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The KeyedProcessFunction is a very versatile function and can be applied to a Keyed Stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053015Z" creationid="xccui" creationdate="20190621T052943Z">
        <seg>KeyedProcessFunction作用于KeyedStream之上，它的用法非常灵活。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lambda architecture aimed to improve the high result latency of the original batch analytics architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T015919Z" creationid="xccui" creationdate="20190322T054026Z">
        <seg>Lambda架构旨在改善原始批量分析架构中结果的高延迟问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lambda architecture augments the traditional periodic batch processing archi&lt;t0/&gt;‐&lt;t1/&gt; tecture with a Speed Layer that is powered by a low-latency stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032853Z" creationid="xccui" creationdate="20190322T043932Z">
        <seg>Lambda架构在传统周期性批处理架构的基础上添加了一个由低延迟流处理引擎所驱动的"提速层"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lambda architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T043711Z" creationid="xccui" creationdate="20190322T043711Z">
        <seg>Lambda架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ListCheckpointed interface does not work with state handles like Val ueState or ListState, which are registered at the state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T040235Z" creationid="xccui" creationdate="20190701T040223Z">
        <seg>该接口不像ValueState或ListState状态句柄那样直接在状态后端注册，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ListCheckpointed interface uses Java serialization to serialize and deserialize the list of state objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063049Z" creationid="xccui" creationdate="20190701T063049Z">
        <seg>ListCheckpointed接口使用Java序列化机制来对状态对象进行序列化和反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ListState implementation of RocksDBStateBackend deseri‐ alizes all list entries before constructing Iterable to read the values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T032212Z" creationid="xccui" creationdate="20190704T032212Z">
        <seg>在构造用于数据访问的Iterable对象之前，RocksDBStateBackend的ListState需要将它所有的列表条目反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The MapFunction is typed to the types of the input and output events and can be specified using the MapFunction interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055306Z" creationid="xccui" creationdate="20190613T050021Z">
        <seg>MapFunction的两个类型参数分别是输入事件和输出事件的类型，它们可以通过MapFunction接口来指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The MergingWindowAssigner is used for win‐ dow operators that need to merge existing windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045834Z" creationid="xccui" creationdate="20190626T045356Z">
        <seg>MergingWindowAssigner可用于需要对已有窗口进行合并的窗口算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Met ricGroup provides ways to create nested, named metrics hierarchies and provides methods to register the following metric types:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T024913Z" creationid="xccui" creationdate="20190803T024913Z">
        <seg>MetricGroup提供了各种创建嵌套、命名指标层次（metrics hierarchy）的方法，并提供了注册以下指标类型的方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The OnTimerContext provides the same serv‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T055416Z" creationid="xccui" creationdate="20190621T055144Z">
        <seg>OnTimerContext能够提供和processElement()方法中的Context对象相同的服务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The OutputSelector defines the select() method that is called for each input event and returns a java.lang.Itera ble[String].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T064207Z" creationid="xccui" creationdate="20190615T054416Z">
        <seg>OutputSelector中定义的select()方法会在每个输入事件到来时被调用，并随即返回一个java.lang.Iterable[String]对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The O’Reilly logo is a registered trademark of O’Reilly Media, Inc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210736Z" creationid="esouser" creationdate="20190603T210736Z">
        <seg>The O’Reilly logo is a registered trademark of O’Reilly Media, Inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ProcessWindowFunction is a full window function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211521Z" creationid="xccui" creationdate="20190623T211454Z">
        <seg>ProcessWindowFunction就是一个全量窗口函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The QueryableStateClient is initialized with the hostname of any TaskManager and the port on which the queryable state client proxy is listening.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T125108Z" creationid="xccui" creationdate="20190706T125108Z">
        <seg>为了初始化QueryableStateClient，你需要提供任意一个TaskManager的主机名以及其上可查询式状态客户端代理的监听端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The QueryableStateClient is used by an external application to submit queries and retrieve results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T200711Z" creationid="xccui" creationdate="20190705T200711Z">
        <seg>QueryableStateClient用于外部系统提交查询及获取结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The QueryableStateClientProxy accepts and serves client requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T201502Z" creationid="xccui" creationdate="20190705T201502Z">
        <seg>QueryableStateClientProxy用于接收并响应客户端请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The QueryableStateServer serves the requests of a client proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T201531Z" creationid="xccui" creationdate="20190705T201531Z">
        <seg>QueryableStateServer用于处理客户端代理的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST API also provides more detailed information about the following aspects of an application:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T153448Z" creationid="xccui" creationdate="20190729T153448Z">
        <seg>REST API还提供了和应用以下方面相关的更多详细信息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST API can also be used to manage and monitor Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045336Z" creationid="xccui" creationdate="20190729T045336Z">
        <seg>REST API还可用于管理和监控Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST API can be directly accessed by users or scripts and exposes information about the Flink cluster and its applications, including metrics as well as endpoints to submit and control applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T211455Z" creationid="xccui" creationdate="20190729T035942Z">
        <seg>REST API可供用户或脚本直接访问，它可以对外公开有关Flink集群和应用的信息，包括指标数据及用于提交和控制应用程序的端点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST API exposes endpoints to query information about a running cluster and to shut it down.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T043359Z" creationid="xccui" creationdate="20190729T043219Z">
        <seg>REST API公开的一些端点可用来查询有关正在运行集群的信息或将其关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST API is the underlying interface that is used by the command-line cli‐ ent and Web UI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T012401Z" creationid="xccui" creationdate="20190726T012401Z">
        <seg>一套用于命令行客户端和Web UI的底层REST API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST interface enables the dispatcher to serve as an HTTP entry point to clusters that are behind a firewall.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T053416Z" creationid="xccui" creationdate="20190418T053359Z">
        <seg>REST接口允许Dispatcher作为防火墙后集群的一个HTTP入口点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST interface enables the dispatcher to serve as an HTTP entry point to clusters that are behind a fire‐ wall.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061813Z" creationid="xccui" creationdate="20190606T142920Z">
        <seg>REST接口使得Dispatcher可以作为防火墙后集群的一个HTTP入口点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ReduceFunction was introduced in “KeyedStream Transformations” on page 87 when discussing running aggregations on keyed streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T033739Z" creationid="xccui" creationdate="20190623T214033Z">
        <seg>我们已经在第87页"基于KeyedStream的转换"一节讨论在键值分区流上运行聚合时介绍过ReduceFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Resour&lt;t4/&gt;‐&lt;t5/&gt; ceManager also takes care of terminating idle TaskManagers to free compute resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T051307Z" creationid="xccui" creationdate="20190418T051307Z">
        <seg>同时，ResourceManager还负责终止空闲的TaskManager以释放计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ResourceManager also takes care of terminating idle TaskManagers to free com‐ pute resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142256Z" creationid="xccui" creationdate="20190606T142256Z">
        <seg>同时，ResourceManager还负责终止空闲的TaskManager以释放计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ResourceManager assigns TaskManagers to the JobManager, which deploys the job once all required resources are available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T030330Z" creationid="xccui" creationdate="20190718T030330Z">
        <seg>ResourceManager负责将TaskManager分配给JobManager，而JobManager在所有资源备齐后会对作业进行部署。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ResourceManager hands out the previously idling processing slots and the application restarts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T034524Z" creationid="xccui" creationdate="20190721T034524Z">
        <seg>ResourceManager将之前空闲的处理槽分发出去，应用就会重新启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ResourceManager is responsible for managing TaskManager slots, Flink’s unit of processing resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062008Z" creationid="xccui" creationdate="20190418T050109Z">
        <seg>ResourceManager负责管理Flink的处理资源单元——TaskManager处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Rest of the Flink Ecosystem</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152428Z" creationid="esouser" creationdate="20190603T152428Z">
        <seg>Flink生态的其他组成部分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RocksDBStateBackend also checkpoints the state to a remote and persistent file system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T024037Z" creationid="xccui" creationdate="20190704T024037Z">
        <seg>RocksDBStateBackend同样会将状态以检查点形式写入远程持久化文件系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RuntimeContext can be used to retrieve information such as the function’s parallelism, its subtask index, and the name of the task that executes the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041336Z" creationid="xccui" creationdate="20190619T033451Z">
        <seg>从RuntimeContext中能够获取到一些信息，例如函数的并行度，它所在子任务的索引号以及执行函数的任务名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Scala DataStream API also has built-in support for lambda functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060002Z" creationid="xccui" creationdate="20190613T022402Z">
        <seg>Scala DataStream API同样内置了对Lambda函数的支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Scala DataStream API offers syntactic shortcuts to define map and flatMap func‐ tions with a single ValueState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T022541Z" creationid="xccui" creationdate="20190701T022541Z">
        <seg>Scala DataStream API为只有单个ValueState的map和flatMap函数提供了简便写法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Scala DataStream API uses regular Scala tuples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070731Z" creationid="xccui" creationdate="20190616T070721Z">
        <seg>Scala DataStream API使用常规Scala元组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SimpleStringSchema, which is used in Example 8-1, is a built-in DeserializationSchema that simply deserializes a byte array into a String.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T213513Z" creationid="xccui" creationdate="20190708T213513Z">
        <seg>示例8-1中用到的SimpleStringSchema是一个内置的DeserializationSchema，它会简单地将字节数组反序列化成String。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The StateDe scriptor is specific to the state primitive and includes the name of the state and the data types of the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T065447Z" creationid="xccui" creationdate="20190630T065447Z">
        <seg>每个状态原语都有自己特定的StateDescriptor，它其中包含了状态名称和类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Stream ingFileSink ensures this does not result in data loss.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T191634Z" creationid="xccui" creationdate="20190711T191053Z">
        <seg>虽然StreamingFileSink保证不会因此导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The StreamExecutionEnvironment provides methods to create stream sources that ingest data streams into the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T052700Z" creationid="xccui" creationdate="20190612T051229Z">
        <seg>StreamExecutionEnvironment为我们提供了一系列创建流式数据源的方法，用以将数据流读取到应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The String values that are returned for a record specify the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T060916Z" creationid="xccui" creationdate="20190615T060916Z">
        <seg>针对某记录所返回的一系列String值指定了该记录需要被发往哪些输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Summary view aggregates checkpoint statistics and provides minimum, maximum, and average values over all completed checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T151903Z" creationid="xingcan" creationdate="20190802T151903Z">
        <seg>Summary页面会对检查点的统计信息进行聚合，提供所有已完成检查点的最小、最大和平均值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Table API is a language-integrated query (LINQ) API for Scala and Java.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T160709Z" creationid="xingcan" creationdate="20190807T160709Z">
        <seg>Table API是一个在Scala和Java之上的LINQ（language-integrated query语言集成查询） API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TaskMan&lt;t0/&gt;‐&lt;t1/&gt; agers take care of shipping data from sending tasks to receiving tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041011Z" creationid="xccui" creationdate="20190504T040910Z">
        <seg>TaskManager负载将数据从发送任务传输至接收任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TaskMan‐ agers take care of shipping data from sending tasks to receiving tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195332Z" creationid="xccui" creationdate="20190606T195324Z">
        <seg>TaskManager负责将数据从发送任务传输至接收任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TimerService and Timers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023114Z" creationid="xccui" creationdate="20190225T023114Z">
        <seg>TimerService和定时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TimerService of the Context and OnTimerContext objects offers the following methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T055620Z" creationid="xccui" creationdate="20190621T055620Z">
        <seg>Context和OnTimerContext对象中的TimerService提供了以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Trigger interface features a call‐ back method that is invoked when windows are merged to merge state that is associ‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T050617Z" creationid="xccui" creationdate="20190626T050313Z">
        <seg>Trigger接口有一个回调方法，会在对目标窗口的相关状态进行合并时被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TwoPhase CommitSinkFunction works quite similar to the WAL sink, but it does not collect records in Flink’s application state; rather, it writes them in an open transaction to an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T200621Z" creationid="xccui" creationdate="20190715T200031Z">
        <seg>TwoPhaseCommitSinkFunction的工作原理和基于WAL的数据汇类似，但它不会在Flink的应用状态中收集记录，而是会把它们写入外部数据汇系统某个开启的事务中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TwoPhaseCommitSinkFunction implements the following protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T200651Z" creationid="xccui" creationdate="20190715T200651Z">
        <seg>TwoPhaseCommitSinkFunction实现的协议如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TwoPhaseCommitSinkFunction template leverages transactional features of the external sink system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T035723Z" creationid="xccui" creationdate="20190715T035723Z">
        <seg>TwoPhaseCommitSinkFunction模板充分利用了外部数据汇系统的事务功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The WAL is stored and checkpointed as operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T045610Z" creationid="xccui" creationdate="20190715T045610Z">
        <seg>WAL会以算子状态的形式存储和写入检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The WAL sink writes all result records into application state and emits them to the sink system once it receives the notification that a checkpoint was completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T200950Z" creationid="xccui" creationdate="20190708T074310Z">
        <seg>WAL数据汇会将所有结果记录写入应用状态中，并在收到检查点完成通知后将它们发送到数据汇系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Web UI can be used to upload application JAR files and run the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T042240Z" creationid="xccui" creationdate="20190718T042240Z">
        <seg>Web UI可用来上传应用JAR包并运行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Web UI is a web interface that provides details and metrics about a Flink cluster and running applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T014020Z" creationid="xccui" creationdate="20190726T014020Z">
        <seg>一个用于提供有关Flink集群和当前运行应用详细信息及指标的Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Web UI is described in “Flink Web UI”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T014113Z" creationid="xccui" creationdate="20190726T014113Z">
        <seg>有关Web UI的信息请参照"Flink Web UI"一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Web UI of the started Flink cluster is served by the master process running on some node in the YARN cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T013236Z" creationid="xccui" creationdate="20190719T013236Z">
        <seg>Flink集群的Web UI由YARN集群某个节点上的主进程负责提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Window Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023309Z" creationid="xccui" creationdate="20190225T023309Z">
        <seg>The Window Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The WindowAssigner determines for each arriving element to which windows it is assigned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041002Z" creationid="xccui" creationdate="20190626T041002Z">
        <seg>WindowAssigner用于决定将到来的元素分配给哪些窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The WindowAssigner returns zero, one, or multiple window objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033551Z" creationid="xccui" creationdate="20190626T033551Z">
        <seg>WindowAssigner会返回零个、一个或多个窗口对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above command sets the default parallelism of the execution environment to 16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170320Z" creationid="xccui" creationdate="20190726T031213Z">
        <seg>上述命令会把执行环境的默认并行度设置为16。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above command starts the application from the main() method of the class that is referenced in the program-class property of the JAR file’s META-INF/MANI‐ FEST.MF file without passing any arguments to the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T030338Z" creationid="xccui" creationdate="20190726T025302Z">
        <seg>上述命令会从JAR包中META-INF/MANIFEST.MF文件内program-class属性所引用的main()方法启动应用，且不会向其传递任何参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The accumulator maintains a running sum and count and the getResult() method computes the average value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T040049Z" creationid="xccui" creationdate="20190624T005407Z">
        <seg>其累加器负责维护不断变化的温度总和及数量，getResult()方法用来计算平均值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The acknowledgment messages to the JobManager are analogous to the commit vote of the textbook 2PC protocol.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T210057Z" creationid="xccui" creationdate="20190715T210057Z">
        <seg>该确认消息对于JobManager而言相当于2PC协议中的提交投票。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The advantages of applying ReduceFunction on a window are the constant and small state size per window and the simple function interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T035612Z" creationid="xccui" creationdate="20190624T001857Z">
        <seg>在窗口上应用ReduceFunction的优点是只须为每个窗口维护一个常数级别的小状态，此外函数的接口也很简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The algorithm does not pause the complete application but decouples checkpointing from processing, so that some tasks continue processing while others persist their state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T064446Z" creationid="xccui" creationdate="20190609T055752Z">
        <seg>该算法不会暂停整个应用，而是会把生成检查点的过程和处理过程分离，这样在部分任务持久化状态的过程中，其他任务还可以继续执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The amount of memory assigned for network buffers is configured with the taskman ager.network.memory.fraction key, which determines the fraction of the JVM size allocated for network buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T040642Z" creationid="xccui" creationdate="20190724T040358Z">
        <seg>设置内存分配量的配置项是taskmanager.network.memory.fraction，它的值决定了JVM为网络缓冲区分配的内存比例，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The animal on the cover of Stream Processing with Apache Flink is a Eurasian red squirrel (Sciurus vulgaris).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T035602Z" creationid="xccui" creationdate="20190808T035602Z">
        <seg>本书封面上的动物是欧亚红松鼠（Sciurus vulgaris）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The appli&lt;t0/&gt;‐&lt;t1/&gt; cation we are going to run converts and aggregates randomly generated temperature sensor readings by time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T055143Z" creationid="xccui" creationdate="20190328T054951Z">
        <seg>该应用会读取随机生成的温度传感器数值，并按时间对它们执行转换和聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application consists of a so- called JobGraph, a logical dataflow graph (see “Introduction to Dataflow Programming”), and a JAR file that bundles all the required classes, libraries, and other resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T055735Z" creationid="xccui" creationdate="20190606T141549Z">
        <seg>该应用会包含一个所谓的JobGraph，一个逻辑Dataflow图（见"Dataflow编程介绍"），以及一个打包了全部所需类、库以及其他资源的JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application consists of a so-called JobGraph, a logical dataflow graph (see &lt;t2/&gt;Chapter 2&lt;t3/&gt;), and a JAR file that bundles all required classes, libraries, and other resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T034834Z" creationid="xccui" creationdate="20190418T034254Z">
        <seg>该应用会包含一个所谓的JobGraph，一个逻辑dataflow图（见第2章），还有一个打包了全部所需类、库以及其他资源的JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application consists of two source tasks that each consume a stream of increasing numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061931Z" creationid="xccui" creationdate="20190609T061931Z">
        <seg>应用包含了两个数据源任务，每个任务都会各自消费一条自增数字流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application has a single source task that consumes a stream of increasing num‐ bers—1, 2, 3, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T030703Z" creationid="xccui" creationdate="20190609T030545Z">
        <seg>该应用有一个数据源任务，负责从一个递增数字（1、2、3……）流中读取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application in Example 10-3 consists of five operators, two sources, two inter‐ mediate operators, and a sink operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T020216Z" creationid="xccui" creationdate="20190731T020016Z">
        <seg>示例10-3中的应用包含了五个算子——两个数据源，两个中间算子和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application is depicted in Figure 3-19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T063223Z" creationid="xccui" creationdate="20190609T062323Z">
        <seg>应用细节如图3-19所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application logic to read from and write to state is often straightforward.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055248Z" creationid="xccui" creationdate="20190607T055148Z">
        <seg>应用读写状态的逻辑通常都很简单，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application receives the stream of temperature sensor readings you have seen previously and an additional stream of smoke level measurements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T061555Z" creationid="xccui" creationdate="20190615T035958Z">
        <seg>该应用会接收一条包含之前所见到的全部温度传感器读数的数据流，以及另外一条烟雾指数测量值数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application requires 10 processing slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T020157Z" creationid="xccui" creationdate="20190731T020157Z">
        <seg>应用总共需要10个处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application we are going to run converts and aggregates randomly generated temperature sensor readings by time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122633Z" creationid="xccui" creationdate="20190605T122633Z">
        <seg>该应用会读取随机生成的温度传感器数值，并按时间对它们执行转换和聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application will continue running if the savepoint command failed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T193338Z" creationid="xccui" creationdate="20190729T193338Z">
        <seg>反之如果保存点命令失败，则应用将继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application will continue to run with the original parallelism if the triggered savepoint failed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201858Z" creationid="xccui" creationdate="20190729T201858Z">
        <seg>如果触发生成保存点失败，应用会以原并行度继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application will replay (and fast for‐ ward) the input events from the event log until it reaches the tail of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T160750Z" creationid="esouser" creationdate="20190603T211749Z">
        <seg>随后应用会从事件日志中读取并（快速）重放输入事件，直到追赶上数据流当前的进度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The applications are usually connected to external services or face human users and continuously process incoming events such as orders, or mails, or clicks on a website.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T162118Z" creationid="xccui" creationdate="20190226T162118Z">
        <seg>此类应用通常会连接外部服务或真人用户，并持续处理诸如订单、邮件、网站点击等传入的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The applications in Figure 1-5 are connected by event logs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055745Z" creationid="esouser" creationdate="20190603T213929Z">
        <seg>图1-5中不同应用之间通过事件日志进行连接，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The applications in our example architecture are connected by event logs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T073244Z" creationid="xccui" creationdate="20190307T152633Z">
        <seg>示例架构中的应用通过事件日志进行连接，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application’s restart strategy determines how often the JobManager restarts the application and how long it waits between restart attempts.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145716Z" creationid="xccui" creationdate="20190606T145556Z">
        <seg>应用的重启策略决定了JobManager以何种频率重启应用以及重启尝试之间的等待间隔。1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application’s restart strategy&lt;t0/&gt;2&lt;t1/&gt; determines how often the JobManager tries to restart the application and how long it waits between restart attempts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210615Z" creationid="xccui" creationdate="20190428T210355Z">
        <seg>应用的重启策略决定了JobManager以何种频率尝试重启应用以及重启尝试之间的等待间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The architecture is depicted in &lt;t0/&gt;Figure 1-3&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194650Z" creationid="xccui" creationdate="20190228T194528Z">
        <seg>图1-3详细描绘了其架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arguments of the StreamExecutionEnvironment.readFile() method are:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185126Z" creationid="xccui" creationdate="20190710T185126Z">
        <seg>StreamExecutionEnvironment.readFile()方法的参数包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asQueryableState() method appends a queryable state sink to the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062429Z" creationid="xccui" creationdate="20190706T062429Z">
        <seg>asQueryableState()方法会在数据流后面添加一个可查询式状态的数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignTimestampsAndWater marks(new SensorTimeAssigner) method assigns the timestamps and watermarks that are required for event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052108Z" creationid="xccui" creationdate="20190612T052108Z">
        <seg>assignTimestampsAndWatermarks(new SensorTimeAssigner)方法负责分配事件时间所需的时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assigner determines to which windows the element needs to be routed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052038Z" creationid="xccui" creationdate="20190625T051958Z">
        <seg>该分配器决定了元素应该被路由至哪（几）个窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asyncInvoke() method is called for each input record with two parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T200933Z" creationid="xccui" creationdate="20190716T200933Z">
        <seg>对于每个输入记录我们都会使用两个参数去调用asyncInvoke()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asyncInvoke() method of DerbyAsyncFunction in Example 8-17 wraps the blocking JDBC query in a Future, which is executed via CachedThreadPool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T212123Z" creationid="xccui" creationdate="20190716T212123Z">
        <seg>示例8-17中DerbyAsyncFunction的asyncInvoke()方法将阻塞式的JDBC查询包在Future对象中，后者会通过CachedThreadPool来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asynchronous operator that applies an AsyncFunction is configured with the AsyncDataStream object,10 which provides two static methods: orderedWait() and unorderedWait().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201937Z" creationid="xccui" creationdate="20190716T201937Z">
        <seg>接收AsyncFunction的异步算子可以通过AsynDataStream对象来配置，10 它提供了两个静态方法：orderedWait()和unorderedWait()。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The batch processor periodically processes the data in batch storage, writes the exact results into a batch table, and drops the corre‐ sponding inaccurate results from the speed table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052357Z" creationid="xccui" creationdate="20190605T052246Z">
        <seg>批处理引擎周期性地处理批量存储的数据，将精确结果写入批处理表，随后将"提速表"中对应的非精确结果删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012714Z" creationid="xccui" creationdate="20190606T012714Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The blob.storage.directory key configures the local storage directory of the blob server, which is used to exchange larger files such as the application JAR files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043446Z" creationid="xccui" creationdate="20190724T043446Z">
        <seg>blob.storage.directory参数项用于配置Blob服务器的本地存储目录，该目录常用于大文件（例如应用JAR包）交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The blue and green slot-sharing groups require four slots each due to the maximum parallelism of their assigned operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T020320Z" creationid="xccui" creationdate="20190731T020320Z">
        <seg>blue和green处理槽共享组由于其所含算子的最大并行度为4，因此分别需要4个处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The book examples are provided as a Maven project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T091552Z" creationid="xccui" creationdate="20190611T040502Z">
        <seg>书中的示例都是以Maven项目的形式出现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The boolean condition is implemented as a function either using the FilterFunction interface or a lambda function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055913Z" creationid="xccui" creationdate="20190613T052627Z">
        <seg>可以利用FilterFunction接口或Lambda函数来实现定义布尔条件的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The boundaries of session windows are defined by gaps of inactivity, time intervals in which no record is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060946Z" creationid="xccui" creationdate="20190623T060946Z">
        <seg>会话窗口的边界由非活动间隔，即没有收到记录的时间间隔来定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The broadcast state is discussed in detail in “Using Connected Broadcast State” on page 160.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210044Z" creationid="xccui" creationdate="20190615T053447Z">
        <seg>我们会在第160页"使用联结的广播状态"一节详细讨论该功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The broadcast strategy sends every data item to all parallel tasks of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045141Z" creationid="xccui" creationdate="20190605T233431Z">
        <seg>广播策略（broadcast strategy）会把数据项发往下游算子的全部并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The broadcast() method replicates the input data stream so that all events are sent to all parallel tasks of the downstream operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045756Z" creationid="xccui" creationdate="20190616T045756Z">
        <seg>broadcast()方法会将输入流中的事件复制并发往所有下游算子的并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bucket is chosen by a BucketAssigner, which is a public interface and returns for every record a BucketId that determines the directory to which the record will be written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T212830Z" creationid="xccui" creationdate="20190710T212007Z">
        <seg>桶的选择由BucketAssigner完成，它是一个公开接口，可以为每条记录返回一个用来决定记录写入目录的BucketId。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The build script creates and registers a new Docker image that is based on a Java Alpine image, a minimal base image that provides Java.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190730T034222Z">
        <seg>该构建脚本会基于一个提供Java的最小基本镜像Java Alpine，来创建并注册一个新的Docker镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The build script for the provided image is a good starting point for a custom image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T144102Z" creationid="xccui" creationdate="20190720T042618Z">
        <seg>我们提供的镜像构建脚本对你构建自定义镜像是一个很好的参考。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The build scripts of the available Docker Flink images are a good starting point for customized images.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190718T043154Z">
        <seg>已有Flink Docker镜像中的构建脚本可以在一定程度上帮助你快速上手。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The business logic is constrained by how much it can control state and time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T061822Z" creationid="xccui" creationdate="20190313T051256Z">
        <seg>其业务逻辑受制于系统对状态和时间的把控能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The cancel() method is invoked by Flink when the application is canceled and shut down.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T151958Z" creationid="xccui" creationdate="20190712T151958Z">
        <seg>Flink会在应用被取消或关闭时调用cancel()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The cashier receives your payment and passes your order to the barista who prepares your beverage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T152916Z" creationid="xccui" creationdate="20190401T152703Z">
        <seg>收银员收到你的付款后会把订单交给帮你准备饮品的咖啡师。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The central class in Flink’s type system is TypeInformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T034353Z" creationid="xccui" creationdate="20190617T050145Z">
        <seg>Flink类型系统的核心类是TypeInformation，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The certificate acts as a shared secret and can be embedded into containers or attached to a YARN setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T024629Z" creationid="xccui" creationdate="20190725T024629Z">
        <seg>证书的作用相当于密钥，可以嵌入到容器里或附加到YARN的设置上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The challenges of end-to-end exactly-once applications and approaches to address them are dis‐ cussed in detail in “Application Consistency Guarantees” on page 184.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054457Z" creationid="xccui" creationdate="20190609T054457Z">
        <seg>有关端到端精确一次应用所面临的挑战和解决方案会在184页"应用一致性保障"一节详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkpoint barriers are notifications to start a new transaction, the notifications of all operators about the success of their individual checkpoint are their commit votes, and the messages of the JobManager that notify about the success of a checkpoint are the instructions to commit the transactions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T165247Z" creationid="xccui" creationdate="20190708T165247Z">
        <seg>检查点分隔符可认为是开启新事务的通知，所有算子完成各自检查点的通知可看做是提交投票（commit vote），而来自JobManager的检查点创建成功的消息其实是提交事务的指令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkpoint barriers emitted by the source tasks are shipped to the connected tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155503Z" creationid="xccui" creationdate="20190609T155503Z">
        <seg>数据源任务发出的检查点分隔符会传输到与之相连的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkpoint is complete when all tasks have finished their copies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224148Z" creationid="xccui" creationdate="20190608T224148Z">
        <seg>在所有任务完成自己的拷贝工作后，检查点生成完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkpointing interval is an important parameter that affects the overhead of the checkpointing mechanism during regular processing and the time it takes to recover from a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T205252Z" creationid="xccui" creationdate="20190702T205252Z">
        <seg>检查点间隔是影响常规处理期间检查点机制的开销以及故障恢复所需时间的一个重要参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The choice also affects the performance of a function because each state backend provides its own implementations for these primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T041207Z" creationid="xccui" creationdate="20190630T041207Z">
        <seg>同时，由于每个状态后端都为这些原语提供了自己的实现，该选择还会影响函数的性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The choice of the right state primitive depends on how the function interacts with the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T021018Z" creationid="xccui" creationdate="20190630T040955Z">
        <seg>它的选择取决于函数同状态的交互方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The choice of the state backend has implications on the robust‐ ness and performance of a stateful application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221454Z" creationid="xccui" creationdate="20190703T221454Z">
        <seg>状态后端的选择会影响状态化应用的鲁棒性及性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The classpath of the Hadoop dependencies must be declared</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025757Z" creationid="xccui" creationdate="20190722T025757Z">
        <seg>Hadoop依赖的Classpath需要在HADOOP_CLASSPATH环境变量中声明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The classpath option of the hadoop command prints its configured classpath.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T030321Z" creationid="xccui" creationdate="20190722T030321Z">
        <seg>hadoop命令的classpath选项会打印出它所配置的Classpath。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The clean-up time is computed by adding one hour to the timestamp of the current record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T212741Z" creationid="xccui" creationdate="20190704T212741Z">
        <seg>清理时间被设置为比当前记录时间晚一小时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client prints a list of all running jobs, including their JobIDs, when you run the following command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170706Z" creationid="xccui" creationdate="20190726T033016Z">
        <seg>你可以使用以下命令控制客户端打印出所有正在运行作业（包括其JobID）的列表：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client submits</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T030304Z" creationid="xccui" creationdate="20190726T030304Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client will try to start the static main() method of the my.app.MainClass class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T031802Z" creationid="xccui" creationdate="20190726T031802Z">
        <seg>客户端将尝试启动my.app.MainClass类的静态main()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The close() method is a finalization method for the function and it is called once per task after the last call of the transformation method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041234Z" creationid="xccui" creationdate="20190619T033120Z">
        <seg>close()作为函数的终止方法，会在每个任务的转换方法调用结束后调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code examples of the book use Maven build manage‐ ment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T072354Z" creationid="xccui" creationdate="20190611T020420Z">
        <seg>书中示例代码都是使用Maven来进行构建管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code examples of this book are hosted on GitHub.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T091102Z" creationid="xccui" creationdate="20190611T035214Z">
        <seg>书中的示例代码托管在GitHub上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in Example 10-1 results in three tasks—a chained task for Filter1 and Map1, an individual task for Map2, and a task for Filter2, which is not allowed to be chained to Map2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203822Z" creationid="xccui" creationdate="20190730T203822Z">
        <seg>示例10-1中的代码会生成三个任务——一个Filter1和Map1的链接任务，一个针对Map2单独任务以及一个Filter2的任务（不允许和Map2进行链接）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in Example 10-6 shows the implementation of the WatermarkGauge metric,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031728Z" creationid="xccui" creationdate="20190803T031728Z">
        <seg>示例10-6中的代码展示了如何实现WatermarkGauge指标，它会对外提供当前的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in Example 6-15 creates a cus‐ tom assigner for 30-second tumbling event-time windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042251Z" creationid="xccui" creationdate="20190626T042251Z">
        <seg>示例6-15中的代码为每30秒的滚动事件时间窗口创建了一个自定义分配器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in Example 6-2 shows how to use a timestamp assigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T033319Z" creationid="xccui" creationdate="20190620T033319Z">
        <seg>示例6-2中的代码展示了时间戳分配器的使用方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in Examples 6-13 and 6-14 shows how to solve the same use case as the code in Example 6-12 with a combination of a ReduceFunction and a Pro cessWindowFunction, emitting every 5 seconds the minimun and maximum temper‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T045942Z" creationid="xccui" creationdate="20190625T043225Z">
        <seg>示例6-13和6-14中的代码展示了如何使用ReduceFunction和ProcessWindowFunction的组合来应对与示例6-12中相同的用例——</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The combination of Flink’s checkpointing and recovery mechanism and resettable source connectors guarantees that an application will not lose any data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T061643Z" creationid="xccui" creationdate="20190708T061643Z">
        <seg>Flink的检查点和恢复机制结合可重置的数据源连接器能够确保应用不会丢失数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The combination of time-based computations as discussed in Chapter 6 and scalable state management empowers developers to realize sophisticated streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051518Z" creationid="xccui" creationdate="20190707T051354Z">
        <seg>开发人员利用我们在第6章介绍的基于时间的计算以及可伸缩的状态管理，能够实现复杂的流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The command</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T183744Z" creationid="xccui" creationdate="20190726T183744Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The command returns some basic information about the cluster, such as the Flink version, the number of TaskManagers, slots, and jobs that are running, finished, can‐ celled, or failed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T211806Z" creationid="xccui" creationdate="20190729T042102Z">
        <seg>该命令会返回集群的一些基本信息（例如：Flink版本，TaskManager和处理槽的数量，以及当前正在运行、已完成、已取消或已失败的作业）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The command triggers a savepoint for the job with the provided JobID.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033419Z" creationid="xccui" creationdate="20190726T033419Z">
        <seg>该命令会触发JobID所指定的作业生成一个保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The command-line client is a tool used to submit and control applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T012314Z" creationid="xccui" creationdate="20190726T012314Z">
        <seg>一个用于提交和控制应用的命令行客户端工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The command-line client is based on a bash script.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T165956Z" creationid="xccui" creationdate="20190726T021717Z">
        <seg>以上命令行客户端是基于Bash脚本完成的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The completed build is located in the ./build-target folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025335Z" creationid="xccui" creationdate="20190722T025335Z">
        <seg>完整的构建结果将位于./build-target文件夹中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The completed checkpoint can be used to recover the appli‐ cation from a failure as described before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194512Z" creationid="xccui" creationdate="20190609T194447Z">
        <seg>如前所述，应用在发生故障时就可以利用这个生成好的检查点进行恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The configuration can be defined per URI scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T150721Z" creationid="xccui" creationdate="20190722T045601Z">
        <seg>该配置支持为每个URI协议单独定义，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The configuration file is read by dif‐ ferent components, such as the start scripts, the master and worker JVM processes, and the CLI client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T042020Z" creationid="xccui" creationdate="20190723T041916Z">
        <seg>会供不同组件（如启动脚本、主进程和工作进程以及CLI客户端）读取使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The configuration key taskmanager.memory.segment-size determines the size of a network buffer, which is 32 KB by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T040733Z" creationid="xccui" creationdate="20190724T040733Z">
        <seg>配置项taskmanager.memory.segment-size决定了网络缓冲区的大小，其默认值是32KB。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The configuration keys contain constant strings, such as “taskmanager,” and variables shown in angle brackets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043302Z" creationid="xccui" creationdate="20190804T043302Z">
        <seg>配置键由常量字符串（例如"taskmanager"）和尖括号中的变量组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The configuration of the application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T153517Z" creationid="xccui" creationdate="20190729T153517Z">
        <seg>应用的配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connect transformation and the cofunctions discussed in this section are more generic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T062436Z" creationid="xccui" creationdate="20190615T045206Z">
        <seg>本节讨论的connect转换以及协处理函数（cofunction）通用性更强。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connector is fully self-contained and does not expose any dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T044108Z" creationid="xccui" creationdate="20190722T044108Z">
        <seg>该连接器同样可以独立工作，没有暴露任何对外的依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connec‐ tion limits can be configured either separately for input and output connections or as the total number of connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T050237Z" creationid="xccui" creationdate="20190722T050237Z">
        <seg>你既可以为输入和输出单独限制连接数，也可以对总的连接数加以限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The consistency guarantees that Flink’s Kafka sink provides depend on its configura‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T153919Z" creationid="xingcan" creationdate="20190709T153919Z">
        <seg>Flink kafka数据汇所提供的一致性保障取决于它的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constructed plan is translated into a JobGraph and submitted to a JobManager for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T012200Z" creationid="xccui" creationdate="20190613T012055Z">
        <seg>构建完的计划会被转成JobGraph并提交至JobManager执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constructor of TwoPhaseCommitSinkFunction requires two TypeSerializer— one for the TXN type and the other for the CONTEXT type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052518Z" creationid="xccui" creationdate="20190716T052518Z">
        <seg>TwoPhaseCommitSinkFunction的构造函数需要传入两个TypeSerializer，一个用于TXN类型，另一个用于CONTEXT类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constructor takes three arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T212438Z" creationid="xccui" creationdate="20190708T212438Z">
        <seg>构造方法需要三个参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constructor used in Example 8-2 receives three parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T145434Z" creationid="xingcan" creationdate="20190709T145434Z">
        <seg>示例8-2中的构造方法接收三个参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The containers work together like a stand‐ alone deployment (see “Standalone Cluster”).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T022325Z" creationid="xccui" creationdate="20190718T022325Z">
        <seg>这些容器的工作原理和独立集群部署（请参阅"独立集群"）类似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The content of the window is completely discarded and the window including all metadata is removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184909Z" creationid="xccui" creationdate="20190626T184757Z">
        <seg>完全清除窗口内容，并删除窗口自身及其元数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corre‐ sponding FlatMapFunction defines the flatMap() method, which may return zero, one, or more events as results by passing them to the Collector object:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060359Z" creationid="xccui" creationdate="20190613T055004Z">
        <seg>对应的FlatMapFunction定义了flatMap()方法，你可以在其中通过向Collector对象传递数据的方式返回零个、一个或多个事件作为结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The curl command to start an application with a default parallelism of 4 is:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T212923Z" creationid="xccui" creationdate="20190729T152600Z">
        <seg>以下curl命令可以启动应用并将默认并行度设置为4：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The curl command to trigger a savepoint without canceling is:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T213249Z" creationid="xccui" creationdate="20190729T181400Z">
        <seg>仅生成保存点而不取消应用的curl命令是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The curl command to upload a JAR file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045720Z" creationid="xccui" creationdate="20190729T045720Z">
        <seg>用于上传JAR文件的curl命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dashboard will</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T045936Z" creationid="xccui" creationdate="20190707T045936Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data that is stored in the various transactional database systems of a company can provide valuable insights about a company’s business operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T024400Z" creationid="esouser" creationdate="20190603T201131Z">
        <seg>存储于不同事务型数据库系统中的数据，可以为公司提供业务运营相关的分析见解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data that is stored in the various transactional database systems of a company can provide valuable insights about various aspects of the company’s business.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T191929Z" creationid="xccui" creationdate="20190228T173220Z">
        <seg>存储于公司多个事务型数据库系统中的数据，可以为公司业务提供各个方面的宝贵见解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data type must be specified because</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T071400Z" creationid="xccui" creationdate="20190630T071033Z">
        <seg>由于Flink需要为状态创建合适的序列化器，因此数据类型指定是强制的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data types handled by the state are specified as Class or TypeInformation objects (see “Types” on page 97 for a discussion of Flink’s type handling).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T070936Z" creationid="xccui" creationdate="20190630T070936Z">
        <seg>状态处理的数据类型可以通过Class或TypeInformation对象指定（有关Flink类型处理的讨论请参见第97页的"类型"一节）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data written to the batch storage is periodically processed by a batch processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T045024Z" creationid="xccui" creationdate="20190322T045655Z">
        <seg>而批处理引擎会定期处理数据并将结果写入批量存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045718Z" creationid="xccui" creationdate="20190620T045718Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default configuration of a Kafka cluster can still lead to data loss, even after a write is acknowledged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T033350Z" creationid="xccui" creationdate="20190710T032530Z">
        <seg>即使已经确认数据写入成功，Kafka集群如果采用默认配置，则仍可能丢失数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default constructor is required by Flink as mentioned in “Supported Data Types” on page 98 when discussing supported data types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220137Z" creationid="xccui" creationdate="20190711T220137Z">
        <seg>此外，正如第98页"支持的数据类型"一节中所介绍的，Flink还需要POJO有一个默认构造方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default is one slot per TaskMan‐ ager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T062245Z" creationid="xccui" creationdate="20190723T062245Z">
        <seg>它的默认值是每个TaskManager一个处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default maximum parallelism of an operator depends on the operator’s parallel‐ ism in the application’s first version:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025347Z" creationid="xccui" creationdate="20190703T025347Z">
        <seg>算子的默认最大并行度会取决于应用首个版本中算子的并行度：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default parallelism can be specified when starting an application (e.g., using the -p parameter in the CLI client).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T205914Z" creationid="xccui" creationdate="20190728T041947Z">
        <seg>该默认并行度可以在启动应用时指定（例如在CLI客户端中使用-p参数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default parallelism of an execution environment is overwritten by all settings explicitly specified by the source code of the application—the parallelism that is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T031441Z" creationid="xccui" creationdate="20190726T031347Z">
        <seg>执行环境的默认并行度可以被代码中显式设置的并行度所覆盖，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default parallelism of an operator can be overridden by specifying it explicitly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060553Z" creationid="xccui" creationdate="20190616T060553Z">
        <seg>可以通过显式指定来覆盖算子的默认并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default restart strategy used if no restart strategy is explicitly defined is a fixed- delay restart strategy with Integer.MAX_VALUE restart attempts and a 10-second delay.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154706Z" creationid="xingcan" creationdate="20190801T154706Z">
        <seg>如果没有显式指定重启策略，默认的策略是以10秒延迟尝试Integer.MAX_VALUE次的固定延迟重启策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default scheduling behavior was explained in Chapter 3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015401Z" creationid="xccui" creationdate="20190731T015401Z">
        <seg>第3章介绍了默认的调度行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default state backend of an application is MemoryStateBackend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T212636Z" creationid="xccui" creationdate="20190731T212636Z">
        <seg>应用默认的状态后端是MemoryStateBackend。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dependency for Flink’s universal Kafka connector is added to a Maven project as shown in the following:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T043637Z" creationid="xccui" creationdate="20190709T043637Z">
        <seg>我们可以像下面这样把Flink通用的Kafka连接器依赖添加到Maven项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dependency for the universal Flink Kafka connector is added to a Maven project as shown in the following:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T043749Z" creationid="xccui" creationdate="20190708T204612Z">
        <seg>我们可以像下面这样把Flink通用的Kafka连接器依赖添加到Maven项目中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The descriptors for ReducingState and AggregatingState also need a ReduceFunction or AggregateFunction object to aggregate the added</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T034717Z" creationid="xccui" creationdate="20190630T065617Z">
        <seg>ReducingState和AggregatingState的描述符还需要接收一个ReduceFunction或AggregateFunction对象，以此来对加入的值进行聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The different state backends can be created with minimum settings as shown in the following.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T035220Z" creationid="xccui" creationdate="20190801T022306Z">
        <seg>你可以像下面这样以最少的设置创建不同的状态后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The directory also contains a YAML file job- cluster-service.yaml that defines a Kubernetes service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T044406Z" creationid="xccui" creationdate="20190730T044406Z">
        <seg>该目录中还包含了一个YAML文件job-cluster-service.yaml，可用于定义Kubernetes的Service。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The directory contains two template files:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T043831Z" creationid="xccui" creationdate="20190730T043831Z">
        <seg>该目录包含了两个模板文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The directory is config‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043722Z" creationid="xccui" creationdate="20190724T043722Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dis&lt;t6/&gt;‐&lt;t7/&gt; patcher also runs a web dashboard to provide information about job executions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024218Z" creationid="xccui" creationdate="20190423T024218Z">
        <seg>Dispatcher同时还会启动一个web仪表盘，用来提供有关作业执行的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dispatcher also runs a web dashboard to provide information about job executions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201540Z" creationid="xccui" creationdate="20190606T142935Z">
        <seg>Dispatcher同时还会启动一个Web UI，用来提供有关作业执行的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The documentation also includes how-tos and tips for different environments, such as standalone clusters, Kubernetes, and YARN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T041443Z" creationid="xccui" creationdate="20190725T041443Z">
        <seg>文档中还包含了针对不同环境（例如独立集群、Kubernetes和YARN）的方法和小窍门。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The earliest offset of each individual partition:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040246Z" creationid="xccui" creationdate="20190709T035343Z">
        <seg>每个分区最早的偏移：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The easiest way to handle late events is to simply discard them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T153552Z" creationid="xingcan" creationdate="20190628T153520Z">
        <seg>处理迟到事件最简单的方式就是直接将其丢弃，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The embedded execution mode starts an application and the whole Flink system in a single JVM process, which can be used to run and debug Flink jobs within an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T200520Z" creationid="xccui" creationdate="20190605T121832Z">
        <seg>Flink的嵌入式执行模式可将应用自身连同整个Flink系统在单个JVM进程内启动，方便从IDE里运行和调试Flink作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end timestamp of GlobalWindows is Long.MAX_VALUE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044811Z" creationid="xccui" creationdate="20190626T044725Z">
        <seg>GlobalWindows的结束时间戳是Long.MAX_VALUE，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end-to- end consistency of the application depends on the integration of the chosen stream sinks with Flink’s checkpointing algorithm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053123Z" creationid="xccui" creationdate="20190613T005721Z">
        <seg>该一致性取决于所选数据汇和Flink检查点算法的组合情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The env.log.dir key configures the directory into which a TaskManager writes its log files (by default, the ./log directory in the Flink setup).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043623Z" creationid="xccui" creationdate="20190724T043623Z">
        <seg>env.log.dir参数用于配置TaskManager的日志文件目录（默认值是Flink安装位置的./log目录）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event log decouples senders and receivers and provides asynchronous, non-blocking event transfer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T072837Z" creationid="xccui" creationdate="20190308T072837Z">
        <seg>事件日志将发送端和接收端解耦，并提供异步非阻塞的事件传输机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event log decouples senders and receivers and provides asynchro‐ nous, nonblocking event transfer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214042Z" creationid="esouser" creationdate="20190603T214042Z">
        <seg>事件日志将发送端和接收端解耦，并提供异步非阻塞的事件传输机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event log pub&lt;t0/&gt;‐&lt;t1/&gt; lishes the changes to consumers that incorporate the updates into the affected data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062519Z" creationid="xccui" creationdate="20190314T072026Z">
        <seg>事件日志系统将改动发布给消费者，再由消费者将更新整合到相关数据存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event-time clocks of a task with two input streams will corre‐ spond to the watermarks of the slower stream and usually the records or intermediate results of the faster stream are buffered in state until the event-time clock allows pro‐ cessing them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054503Z" creationid="xccui" creationdate="20190607T033418Z">
        <seg>对于一个有两个输入流的任务而言，其事件时间时钟会受制于那个相对较慢的流，而较快流的记录或中间结果会在状态中缓冲，直到事件时间时钟到达允许处理它们的那个点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The events are merged in a FIFO fashion—the operator does not produce a specific order of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T061211Z" creationid="xccui" creationdate="20190614T064449Z">
        <seg>union执行过程中，事件会以FIFO的方式合并，其顺序无法得到任何保证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The events of the nonbroadcasted stream are simply forwarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T023229Z" creationid="xccui" creationdate="20190615T052015Z">
        <seg>而所有非广播流的事件只是会被简单地转发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The evictBefore() and evictAfter() methods are called before and after a window function is applied on the content of a window, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203253Z" creationid="xccui" creationdate="20190627T202249Z">
        <seg>evictBefore()和evictAfter()方法分别会在窗口函数作用于窗口内容之前和之后调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The evictor is an optional component that can be injected before or after a Process WindowFunction is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051523Z" creationid="xccui" creationdate="20190625T214328Z">
        <seg>移除器作为一个可选组件，允许在ProcessWindowFunction调用之前或之后注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact results are written into a batch table and the corresponding inaccurate results from the speed table are dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032903Z" creationid="xccui" creationdate="20190322T051608Z">
        <seg>在精确结果写入批处理表后，"提速表"中对应的非精确结果就可以删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example application emits an alert event if the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061945Z" creationid="xccui" creationdate="20190630T061945Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples repository contains an application that fails and recovers in regular intervals to demonstrate the behavior of StdOutWriteAheadSink and a regular Data Stream.print() sink in case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064946Z" creationid="xccui" creationdate="20190715T064946Z">
        <seg>示例仓库中还包含了一个应用，它会周期性地发生故障并执行恢复，我们以此来展示StdOutWriteAheadSink和常规的DataStream.print()数据汇在故障时的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception that caused an application to fail</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T161718Z" creationid="xccui" creationdate="20190729T161718Z">
        <seg>导致应用失败的异常信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execu&lt;t5/&gt;‐&lt;t6/&gt; tion of tasks and the concept of slots is discussed in more detail in a later section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062139Z" creationid="xccui" creationdate="20190418T052505Z">
        <seg>我们将在随后一节更详细讨论任务执行和处理槽的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T050338Z" creationid="xccui" creationdate="20190612T051339Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execution environment determines whether the program is running on a local machine or on a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044916Z" creationid="xccui" creationdate="20190612T044916Z">
        <seg>执行环境决定了应用是在本地机器上还是集群上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execu‐ tion of tasks and the concept of slots is discussed in “Task Execution”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142745Z" creationid="xccui" creationdate="20190606T142726Z">
        <seg>我们将在"任务执行"一节进一步讨论任务执行和处理槽的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expressiveness of the API and the quality of state handling and event-time support determine the business logic that can be implemented and exe‐ cuted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T074408Z" creationid="xccui" creationdate="20190604T052839Z">
        <seg>API的表达能力以及对状态处理和事件时间的支持水平等诸多因素决定了可以实现和执行的业务逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The external identifier that is passed with the setQueryable() method can be freely chosen and is only used to configure the queryable state client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T061603Z" creationid="xccui" creationdate="20190706T061603Z">
        <seg>传递给setQueryable()方法的外部标识符可以随意选择，它们只会在可查询式状态客户端的配置中用到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The external sink system must provide transactional support or the sink must be able to emulate transactions on the external system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T213759Z" creationid="xccui" creationdate="20190715T213520Z">
        <seg>外部数据汇系统必须支持事务，否则就要在数据汇上模拟外部系统的事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The external system supports updates per key, such as a relational database sys‐ tem or a key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T043528Z" creationid="xccui" creationdate="20190714T043528Z">
        <seg>外部系统支持按照键值更新，例如关系型数据库或键值存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The extracted directory includes a ./bin folder with bash scripts1 to start and stop Flink processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T135813Z" creationid="xccui" creationdate="20190717T162753Z">
        <seg>解压后的目录包含了一个./bin文件夹，里面包含了用于启动和停止Flink进程的bash脚本 1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The extracted timestamps are assigned to the respective record and the queried watermarks are ingested into the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T035457Z" creationid="xccui" creationdate="20190607T035446Z">
        <seg>提取出来的时间戳会附加到各自的记录上，查询得到的水位线会注入到数据流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The failure rate is specified as the maximum number of failures within a time interval.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154021Z" creationid="xingcan" creationdate="20190801T154021Z">
        <seg>故障率被定义为某个时间间隔内的最大故障数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The failure-rate restart strategy restarts an application as long as a configurable failure rate is not exceeded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154156Z" creationid="xingcan" creationdate="20190801T153906Z">
        <seg>failure-rate重启策略允许在未超过故障率的前提下不断重启应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fields are mapped to the parameters based on their position; the first value is converted to the first parameter and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212714Z" creationid="xccui" creationdate="20190711T212714Z">
        <seg>字段到参数的映射是按照位置进行的，即第一个值转换为第一个参数，以此类推。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure shows four sender and four receiver tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044155Z" creationid="xccui" creationdate="20190504T044155Z">
        <seg>其中包含了4个发送端和4个接收端任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The files are also provided in our repository.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T143802Z" creationid="xccui" creationdate="20190720T033342Z">
        <seg>所有这些文件同样可以从我们的代码库中找到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filesystem source is part of the flink-streaming-java module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T184024Z" creationid="xccui" creationdate="20190710T184024Z">
        <seg>该文件系统数据源是flink-streaming-java模块的一部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The file‐ system source connector provides only at-least-once guarantees when checkpointing is enabled if the FileInputFormat does not implement the CheckpointableInputFor mat interface because the input format will start reading from the beginning of the split that was processed when the last complete checkpoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T193855Z" creationid="xccui" creationdate="20190710T193855Z">
        <seg>如果FileInputFormat没有实现CheckpointableInputFormat接口，则文件系统数据源连接器在启用检查点的情况下只能提供至少一次保障，因为InputFormat会从划分的起点，也就是上一次成功生成检查点时的处理位置，开始读取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filter transformation drops or forwards events of a stream by evaluating a boolean condition on each input event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053755Z" creationid="xccui" creationdate="20190613T051252Z">
        <seg>Filter转换利用一个作用在每条输入事件上的布尔条件来决定流中事件的去存：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first argument defines the topics to read from.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T212503Z" creationid="xccui" creationdate="20190708T212452Z">
        <seg>第一个参数是要读取的主题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first field is a list of the flatMap results, and the second field is the new value of the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T035014Z" creationid="xccui" creationdate="20190701T035014Z">
        <seg>其中第一个字段是flatMap的结果列表，第二个字段是新的状态值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first field of the SensorReading is a sensorId, the second field is the time‐ stamp in milliseconds since 1970-01-01-00:00:00.000, and the third field is an average temperature computed over 5 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124114Z" creationid="xccui" creationdate="20190605T123948Z">
        <seg>SensorReading的第一个字段是sensorId，第二个字段是用自1970-01-01-00:00:00.000以来的毫秒数所表示的时间戳，第三个字段是每隔5秒计算出的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first field of the tuple holds the input record to flatMap, and the second field holds an Option of the retrieved state for the key of the processed record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T034047Z" creationid="xccui" creationdate="20190701T034040Z">
        <seg>参数元组的第一个字段是flatMap的输入记录；第二个字段是一个Option对象，其中保存了针对当前记录键值的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first generation of distributed open source stream processors (2011) focused on event processing with millisecond latencies and provided guarantees against loss of events in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T192923Z" creationid="xccui" creationdate="20190605T050830Z">
        <seg>第一代开源分布式流处理引擎（2011年）专注于以毫秒级延迟处理数据并保证系统故障时事件不会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first generation of distributed open source stream processors (2011) that got sub&lt;t0/&gt;‐&lt;t1/&gt; stantial adoption focused on event processing with millisecond latencies and pro&lt;t2/&gt;‐&lt;t3/&gt; vided guarantees that events would never be lost in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T050636Z" creationid="xccui" creationdate="20190322T040934Z">
        <seg>第一代开源分布式流处理引擎（2011年）专注于以毫秒级延迟处理数据并保证系统出错时事件不会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first interface defines assigners that emit watermarks periodically while the second injects watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055253Z" creationid="xccui" creationdate="20190620T045145Z">
        <seg>前者定义的分配器会周期性地发出水位线，而后者会根据输入事件的属性来生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first parameter is a comma-separated string of Kafka broker addresses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T145524Z" creationid="xingcan" creationdate="20190709T145524Z">
        <seg>第一个参数是英文逗号分隔的Kafka Broker地址字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first parameter is the input record and the second parameter is a callback object to return</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T200951Z" creationid="xccui" creationdate="20190716T200951Z">
        <seg>第一个参数是输入记录，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first thing a Flink application needs to do is set up its execution environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044646Z" creationid="xccui" creationdate="20190612T044646Z">
        <seg>Flink应用要做的第一件事就是设置执行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first type are periodic report queries that compute business relevant statistics such as revenue, user growth, or production output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T193927Z" creationid="xccui" creationdate="20190228T193139Z">
        <seg>第一类是定期报告查询，用于计算业务相关的统计信息，如收入、用户增长、产出等，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fixed-delay restart strategy restarts an application a fixed number of times and waits a configured time before a restart attempt.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T153809Z" creationid="xingcan" creationdate="20190801T153809Z">
        <seg>fixed-delay重启策略会以配置的固定间隔尝试将应用重启某个固定次数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flatMap transformation applies a function on each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T055027Z" creationid="xccui" creationdate="20190613T054855Z">
        <seg>flatMap转换会针对每个到来事件应用一个函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flatMap transformation is similar to map, but it can produce zero, one, or more output events for each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053414Z" creationid="xccui" creationdate="20190613T053414Z">
        <seg>flatMap转换类似于map，但它可以对每个到来事件产生零个、一个或多个输出事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flatMapWithState() method expects a function that accepts a Tuple2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T032420Z" creationid="xccui" creationdate="20190701T032420Z">
        <seg>调用flatMapWithState()方法时需要提供一个参数为Tuple2的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The folder contains a file flink-scala-project-0.1.jar, which is the JAR file of your Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T094933Z" creationid="xccui" creationdate="20190612T010603Z">
        <seg>该文件夹里会有一个flink-scala-project-0.1.jar文件，也就是你Flink应用打成的JAR包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code declares the id field as the key of a stream of SensorReading records:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051701Z" creationid="xccui" creationdate="20190614T051701Z">
        <seg>以下代码针对SensorReading记录流将其中的id字段声明为键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how to apply a KeyedProcessFunction to a KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063414Z" creationid="xccui" creationdate="20190621T070648Z">
        <seg>以下代码展示了如何在一个KeyedStream上面使用KeyedProcessFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how to define a window operator with a custom trigger and evictor:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014836Z" creationid="xccui" creationdate="20190626T014836Z">
        <seg>以下代码展示了如何使用自定义触发器和移除器来定义窗口算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how to define event-time and processing-time tumbling windows on a stream of sensor data measurements:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042900Z" creationid="xccui" creationdate="20190623T042900Z">
        <seg>以下代码展示了如何在一个传感数据测量流上定义事件时间和处理时间滚动窗口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how to group the sensor readings in sliding windows of 1 hour size with a 15-minute slide interval.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055645Z" creationid="xccui" creationdate="20190623T055634Z">
        <seg>以下代码展示了如何将传感器读数按照大小为1小时、滑动间隔为15分钟的滑动窗口进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how to specify a window assigner and a window function on a keyed or nonkeyed stream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041304Z" creationid="xccui" creationdate="20190622T041304Z">
        <seg>以下代码展示了如何在一个键值分区或非键值分区流上指定窗口分配器和窗口函数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows the depend‐ ency you need to add to the build file of your application in order to use the Cassan‐ dra sink connector:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T203319Z" creationid="xccui" creationdate="20190711T203319Z">
        <seg>为了在应用中使用Cassandra数据汇连接器，你需要在你的应用构建文件中添加以下依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows the interface of the ProcessWindowFunction:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010446Z" creationid="xccui" creationdate="20190624T010446Z">
        <seg>以下代码展示了ProcessWindowFunction接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows win‐ dows with an offset of 15 minutes that start at 00:15:00, 01:15:00, 02:15:00, and so on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054422Z" creationid="xccui" creationdate="20190623T054422Z">
        <seg>以下代码展示了偏移量为15分钟的窗口，它们将从00:15:00、01:15:00、02:15:00……时间点开始：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example code shows how to use the methods of a RichFlat MapFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034214Z" creationid="xccui" creationdate="20190619T033912Z">
        <seg>示例5-3展示了如何使用RichFlatMapFunction中的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example fil‐ ters a DataStream of tuples with two fields:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T025227Z" creationid="xccui" creationdate="20190616T070849Z">
        <seg>以下示例展示了如何对一个双字段元组的DataStream进行过滤处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example keys the input stream by the second field of the input tuple:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040148Z" creationid="xccui" creationdate="20190618T033243Z">
        <seg>下方示例以输入元组的第二个字段作为输入流的键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example partitions a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050622Z" creationid="xccui" creationdate="20190616T050622Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example show a lambda function that filters tweets contain‐ ing the word “flink”:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055928Z" creationid="xccui" creationdate="20190618T055838Z">
        <seg>下面示例中的Lambda函数会过滤出所有包含"flink"一词的推文：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows a MapFunction that provides its return type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061907Z" creationid="xccui" creationdate="20190617T061907Z">
        <seg>下面的例子展示了一个提供返回类型的MapFunction：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows a filter that drops all sensor measurements with tem‐ perature below 25°F:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060139Z" creationid="xccui" creationdate="20190613T053205Z">
        <seg>下方例子所展示的filter会丢弃所有温度低于25°F的传感器测量值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows how to update a field of a Java tuple:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040456Z" creationid="xccui" creationdate="20190617T040456Z">
        <seg>下面的例子展示了如何对Java元组的字段进行更新：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following examples show how to group the sensor readings into session windows where each session is defined by a 15-minute period of inactivity:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061426Z" creationid="xccui" creationdate="20190623T061426Z">
        <seg>以下示例展示了如何将传感器读数按照会话窗口进行分组，其中每个会话的非活动时间都设置为15分钟：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following expression accesses the field of a tuple nested in a POJO:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050556Z" creationid="xccui" creationdate="20190618T050556Z">
        <seg>下方表达式用于访问嵌套在POJO中某一元组的字段：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following is a simple mapper that extracts the first field (id) of each SensorRead ing in the input stream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055355Z" creationid="xccui" creationdate="20190613T050710Z">
        <seg>下方展示的是一个简单的映射器，它会提取输入流中的每个SensorReading记录的第一个字段（id）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following shows how to generate watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055825Z" creationid="xccui" creationdate="20190620T051912Z">
        <seg>下方展示了如何针对递增时间戳生成水位线：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following shows how to union three streams of type SensorReading into a single stream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064843Z" creationid="xccui" creationdate="20190614T064837Z">
        <seg>以下示例展示了如何将三条类型为SensorReading的数据流合并为一条：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following shows the WindowAssigner interface:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052235Z" creationid="xccui" creationdate="20190626T041550Z">
        <seg>以下展示的就是WindowAssigner接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following state primitives are supported by Flink:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T041221Z" creationid="xccui" creationdate="20190630T041221Z">
        <seg>Flink目前支持以下状态原语：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following typographical conventions are used in this book:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210759Z" creationid="esouser" creationdate="20190603T210759Z">
        <seg>The following typographical conventions are used in this book:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The follow‐ ing code shows the interface of the AggregateFunction:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T003526Z" creationid="xccui" creationdate="20190624T003526Z">
        <seg>以下代码展示了AggregateFunction的接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fol‐ lowing code shows how to use this shortcut:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T053713Z" creationid="xccui" creationdate="20190623T053713Z">
        <seg>以下代码展示了如何使用这种简写：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fol‐ lowing steps show you how to start a local Flink cluster and submit an application for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201033Z" creationid="xccui" creationdate="20190605T123013Z">
        <seg>启动本地Flink集群并提交应用到上面执行的步骤如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forward and random strategies as key-based</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T140502Z" creationid="xccui" creationdate="20190401T140430Z">
        <seg>转发和随机策略同样基于键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forward strategy and the random strategy can also be viewed as variations of the key-based strategy, where the first preserves the key of the upstream tuple while the latter performs a random re-assignment of keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142138Z" creationid="xccui" creationdate="20190401T140443Z">
        <seg>转发策略和随机策略也可以看做基于键值策略的变种，前者保留了上游元组的键值，后者会随机分配键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forward strategy sends data from a task to a receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233408Z" creationid="xccui" creationdate="20190605T233408Z">
        <seg>转发策略（forward strategy）在发送端任务和接收端任务之间进行一对一的数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The framework style follows the traditional approach of submitting an application (or query) via a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T063832Z" creationid="xccui" creationdate="20190606T144133Z">
        <seg>基于框架的模式采用的是传统方式，即通过客户端提交应用（或查询）到正在运行的服务上；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The framework style is follows the traditional approach of submitting an application (or query) via a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T040741Z" creationid="xccui" creationdate="20190423T040646Z">
        <seg>基于框架的模式遵循传统方式，即通过客户端提交应用（或查询）到正在运行的服务上；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function also returns a Tuple2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T034935Z" creationid="xccui" creationdate="20190701T034935Z">
        <seg>该函数同样会返回一个Tuple2对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function can be specified with a class that implements the ReduceFunction inter‐ face.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T054323Z" creationid="xccui" creationdate="20190614T061729Z">
        <seg>我们可以通过实现ReduceFunction接口来指定一个reduce函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function in the above example counts per parallel instance how many tempera‐ ture measurements exceeded a configured threshold.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T053354Z" creationid="xccui" creationdate="20190701T053354Z">
        <seg>上述例子中的函数会统计每个并行实例中超过阈值的温度值数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function interface defines the transformation method that needs to be imple‐ mented by the user, such as the map() method in the example above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T054343Z" creationid="xccui" creationdate="20190613T020932Z">
        <seg>函数接口规定了用户需要实现的转换方法，例如上例中的map()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function is also properly integrated with Flink’s checkpointing mechanism—input records that are currently waiting for a response are checkpointed and queries are repeated in the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T194626Z" creationid="xccui" creationdate="20190716T194626Z">
        <seg>AsyncFunction还与Flink的检查点机制进行了良好的集成，所有正在等待响应的输入记录都会被写入检查点并支持在恢复时重新发送请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function is applied on a stream of sentences, splits each sentence by the space character, and emits each resulting word as an individual record:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060521Z" creationid="xccui" creationdate="20190613T061921Z">
        <seg>这个函数会作用于一个语句流上，将每个语句按照空格字符分割，然后把分割得到的每个单词作为一条独立的记录发出去：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function is called for each record of the stream and returns zero, one, or more records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053136Z" creationid="xccui" creationdate="20190621T053136Z">
        <seg>该函数会针对流中的每条记录调用一次，并返回零个、一个或多个记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function monitors the temperatures of sensors and emits a warning if the tem‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T070743Z" creationid="xccui" creationdate="20190621T070743Z">
        <seg>该函数对传感器温度进行监测，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function that applies the rules ingests two input streams, the event stream and the rules stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T203028Z" creationid="xccui" creationdate="20190701T203028Z">
        <seg>规则应用函数需要同时接收这两条输入流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function uses operator state and has a single state variable for each parallel operator instance that is checkpointed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T053909Z" creationid="xccui" creationdate="20190701T053909Z">
        <seg>它其中用到了算子状态，该状态会为每个并行算子实例保存一个状态变量并通过ListCheckpointed接口定义的方法创建检查点和进行恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions encapsulate the user application logic and define how the elements of the input stream are transformed into the elements of the output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T014237Z" creationid="xccui" creationdate="20190613T014237Z">
        <seg>这些函数封装了用户应用逻辑，定义了输入流的元素如何转换为输出流的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions of the operators are fused into a single task that is executed by a single thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T201014Z" creationid="xccui" creationdate="20190606T203546Z">
        <seg>多个算子的函数被"融合"到同一个任务中，在同一个线程内执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions of the&lt;t1/&gt; &lt;t2/&gt;operators are fused into a single task which is executed by a single thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153708Z" creationid="esouser" creationdate="20190514T152833Z">
        <seg>算子里的函数被揉到同一个任务中，在一个线程里执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions that offer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T204318Z" creationid="xccui" creationdate="20190704T204318Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fundamental difference between rebalance() and rescale() lies in the way task connections are formed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T044140Z" creationid="xccui" creationdate="20190616T044140Z">
        <seg>rebalance()和rescale()的本质不同体现在生成任务连接的方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fundamental mode of operation - batch processing - is the same regardless whether the architecture is based on a data ware&lt;t2/&gt;‐&lt;t3/&gt; house or components of the Hadoop ecosystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T030601Z" creationid="xccui" creationdate="20190317T030601Z">
        <seg>基本操作模式（批处理）对基于数据仓库或Hadoop生态组件的架构，都是都是完全相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fused tasks exchange records by method calls and thus with basically no communication costs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T191248Z" creationid="xccui" creationdate="20190730T191248Z">
        <seg>融合的任务只需通过方法调用就可以进行记录交换，因此几乎没有通信成本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generated pom.xml file also contains instructions on how to add new dependencies to your project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010743Z" creationid="xccui" creationdate="20190612T010743Z">
        <seg>生成的pom.xml文件里还包含一些如何往项目中添加其他依赖的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The gen‐ erated folder contains a src/ folder and a pom.xml file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005659Z" creationid="xccui" creationdate="20190612T005652Z">
        <seg>生成的文件夹内包含了一个src/目录和一个pom.xml文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The getKvState() method returns a CompletableFuture[S] where S is the type of the state (e.g., ValueState[_] or MapState[_, _]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035005Z" creationid="xccui" creationdate="20190707T035005Z">
        <seg>getKvState()方法返回一个CompletableFuture[S]，其中S是状态类型（例如ValueState[_]或MapState[_, _]）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The getter and setter functions must follow the default naming scheme, which is Y getX() and setX(Y x) for a field x of type Y.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T042605Z" creationid="xccui" creationdate="20190617T044510Z">
        <seg>这些方法需要遵循默认的命名规范，即对于Y类型的x字段方法头分别为Y getX()和setX(Y x)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The global() method sends all events of the input data stream to the first paral‐ lel task of the downstream operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045845Z" creationid="xccui" creationdate="20190616T045845Z">
        <seg>global()方法会将输入流中的所有事件发往下游算子的第一个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The goal of this chapter is to introduce the fundamental concepts of stream process‐ ing and the requirements of its frameworks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T042658Z" creationid="xccui" creationdate="20190605T224706Z">
        <seg>通过本章，我们旨在介绍流处理的基础概念及其处理框架的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The handle does not hold the state itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T021003Z" creationid="xccui" creationdate="20190701T021003Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The heap memory is used for all objects, including the TaskMan‐ ager runtime, operators and functions of the application, and in-flight data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T034239Z" creationid="xccui" creationdate="20190724T034239Z">
        <seg>堆内存需要供所有对象使用，包括TaskManager运行时，应用的算子和函数，以及处理中的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hostname (or IP address) of the machine that runs the master process needs to be configured in the ./conf/flink-conf.yaml file with the config key jobman ager.rpc.address.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T200756Z" creationid="xccui" creationdate="20190717T200756Z">
        <seg>在./conf/flink-conf.yaml文件中将jobmanager.rpc.address一项配置为主进程所在机器的主机名（或IP地址）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hostnames (or IP addresses) of all machines that should run TaskManagers need to be listed in the ./conf/slaves file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T202358Z" creationid="xccui" creationdate="20190717T195851Z">
        <seg>将所有需要运行TaskManager的主机名（或IP地址）列在./conf/slaves文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The idea here is to only write those results to an external sink system that have been computed before the last successful checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T200941Z" creationid="xccui" creationdate="20190708T072819Z">
        <seg>它的基本思路是只有在上次成功的检查点之前计算的结果才会被写入外部数据汇系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iden‐ tifiers are written into a savepoint as metadata with the actual state data of an opera‐ tor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015428Z" creationid="xccui" creationdate="20190703T015428Z">
        <seg>该标识会作为元数据和算子的实际状态一起写入保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The idle mechanism of sources can be used to address the problem of not advancing watermarks as discussed earlier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034838Z" creationid="xccui" creationdate="20190607T034838Z">
        <seg>数据源空闲声明机制可以用来解决上面提到的水位线不向前推进的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The image also includes the code to run a JobManager and ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190423T030328Z">
        <seg>镜像中还包含着运行JobManager以及ResourceManager的代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The image can be started in two ways—as a JobMaster con‐ tainer or a TaskManager container.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190729T214549Z">
        <seg>该镜像可以以两种方式启动——作为JobMaster容器或TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation details of SensorTimeAssigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051005Z" creationid="xccui" creationdate="20190612T052147Z">
        <seg>你现在还无须关心SensorTimeAssigner的实现细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of a ReadingFilter function that dynamically filters a stream of sensor readings based on a stream of filter switches is shown in Example 6-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T014345Z" creationid="xccui" creationdate="20190622T031929Z">
        <seg>示例6-9给出了ReadingFilter函数的实现，它基于过滤开关流对传感器读数流进行动态过滤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of the TempIncreaseAlterFunction is shown in Example 6-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071207Z" creationid="xccui" creationdate="20190621T071207Z">
        <seg>示例6-5给出了TempIncreaseAlterFunction的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The import steps are similar for most IDEs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040757Z" creationid="xccui" creationdate="20190611T040757Z">
        <seg>大多数IDE的导入步骤都很类似，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The importance of state becomes even more evident if we consider the case of using a batch processing system to analyze an unbounded data set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053157Z" creationid="xccui" creationdate="20190414T053157Z">
        <seg>如果考虑使用批处理系统分析有限数据集的情况，那么状态的重要性就越发明显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The importance of state becomes even more evident if we consider the case of using a batch processing system to analyze an unbounded dataset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031746Z" creationid="xccui" creationdate="20190606T031623Z">
        <seg>在使用批处理系统分析有限数据集的情况下，状态的重要性会越发凸显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The individual state backends are described in more detail in “Choosing a State Backend” on page 169.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T212621Z" creationid="xccui" creationdate="20190731T212621Z">
        <seg>我们已经在第169页"选择状态后端"一节对每个状态后端都进行了详细的描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ingestion time of an event is the time it entered the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T050010Z" creationid="xccui" creationdate="20190619T071759Z">
        <seg>它表示事件进入流处理引擎的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializeState() method is called when a par‐ allel instance of CheckpointedFunction is created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T154753Z" creationid="xccui" creationdate="20190702T064300Z">
        <seg>initializeState()方法会在创建CheckpointedFunction的并行实例时被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interface defines an input type, IN, an accumulator of type ACC, and a result type OUT.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005027Z" creationid="xccui" creationdate="20190624T005027Z">
        <seg>该接口定义了输入类型IN，累加器类型ACC以及结果类型OUT。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interface of AsyncFunction is shown in the following:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T200747Z" creationid="xccui" creationdate="20190716T200738Z">
        <seg>AsyncFunction接口内容如下所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interface pro‐ vides two methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T040549Z" creationid="xccui" creationdate="20190701T040549Z">
        <seg>ListCheckpointed接口提供了两个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The internal Kafka client can be configured to retry writes before declaring them failed by setting the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T053417Z" creationid="xingcan" creationdate="20190709T154506Z">
        <seg>你可以通过将重试属性（retries property）设置为一个大于0（0是默认值）的值来配置内部的kafka客户端在宣告写入失败之前重试几次，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interval in milliseconds in which the path is periodically scanned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T191253Z" creationid="xccui" creationdate="20190710T191253Z">
        <seg>针对目标路径周期性扫描的时间间隔（以毫秒为单位）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interval is specified in milliseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T055102Z" creationid="xccui" creationdate="20190806T055102Z">
        <seg>间隔以毫秒为单位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interval join currently only supports event time and operates with INNER JOIN</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025409Z" creationid="xccui" creationdate="20190628T025409Z">
        <seg>基于间隔的Join目前只支持事件时间以及INNER JOIN语义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interval join joins events from two streams that have a common key and that have timestamps not more than specified intervals apart from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T211758Z" creationid="xccui" creationdate="20190627T211758Z">
        <seg>基于间隔的Join会对两条流中拥有相同键值以及彼此之间时间戳不超过某一指定间隔的事件进行Join。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The introductory example actually uses a simple KeySelector function in the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051741Z" creationid="xccui" creationdate="20190618T051634Z">
        <seg>开篇示例其实就是在keyBy()方法中使用了一个简单的KeySelector函数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The io.tmp.dirs parameter is used as the default value for the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043024Z" creationid="xccui" creationdate="20190724T042920Z">
        <seg>io.tmp.dirs参数值路径会默认用于Flink大多数有本地存储需求的组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iterator returned by get() returns an Iterable with a single entry, which is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061108Z" creationid="xccui" creationdate="20190630T060432Z">
        <seg>ReducingState.get()方法返回的Iterable对象只有一个条目，即聚合后的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The job ID of the started application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T050607Z" creationid="xccui" creationdate="20190729T050607Z">
        <seg>应用启动后的作业ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The join in Figure 6-7 stores all records with timestamps larger than the current watermark—15 minutes from stream A—and all records with timestamps larger than the current watermark—one hour from stream B. You should be aware that the storage requirements of the interval join may significantly increase if the event time of both input streams is not synchronized because the watermark is deter‐ mined by the “slower” stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T204137Z" creationid="xccui" creationdate="20190628T034102Z">
        <seg>图6-7中的Join需要存储数据流A中所有时间戳大于当前水位线减去15分钟的记录，以及数据流B中所有时间戳大于当前水位线减去1小时的记录。不难想象，如果两条流的事件时间不同步，那么Join所需的存储就会显著增加，因为水位线总是由"较慢"的那条流来决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The join interval is symmetric, i.e., an event from B joins with all events from A that are no more than 15 minutes earlier and at most one hour later than the B event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025002Z" creationid="xccui" creationdate="20190627T214134Z">
        <seg>Join间隔具有对称性，因此上面的条件也可以表示为A中事件的时间戳相较B中事件的时间戳不早于15分钟且不晚于1小时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key and value of the map can be of arbitrary type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T221809Z" creationid="xccui" creationdate="20190607T221757Z">
        <seg>该映射的键和值可以是任意类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key does not necessarily have to be a field of the input event but can be derived using arbitrary computations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052030Z" creationid="xccui" creationdate="20190618T052030Z">
        <seg>这个键值不一定非要是输入事件中的一个字段，而是可以经由任意计算得来的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key-based strategy partitions data by a key attribute and guarantees that data items having the same key will be processed by the same task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045240Z" creationid="xccui" creationdate="20190605T233508Z">
        <seg>基于键值的策略（key-based strategy）根据某一键值属性对数据分区，并保证键值相同的数据项会交由同一任务处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyBy transformation converts a DataStream into a KeyedStream by specifying a key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050208Z" creationid="xccui" creationdate="20190614T050208Z">
        <seg>keyBy转换通过指定键值的方式将一个DataStream转化为KeyedStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyBy() method receives an argument that specifies the key (or keys) to group by and returns a KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051446Z" creationid="xccui" creationdate="20190614T051446Z">
        <seg>keyBy()方法接收一个用来指定分区键值（可以是多个）的参数，返回一个KeyedStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyed state instances of a function are distributed across all parallel tasks of the function’s operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T015108Z" creationid="xccui" creationdate="20190630T035709Z">
        <seg>函数的键值分区状态实例会分布在函数所在算子的所有并行任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051834Z" creationid="xccui" creationdate="20190605T051834Z">
        <seg>Lambda架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda architecture augments the traditional periodic batch processing architec‐ ture with a speed layer that is powered by a low-latency stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193331Z" creationid="xccui" creationdate="20190605T051842Z">
        <seg>Lambda架构在传统周期性批处理架构的基础上添加了一个由低延迟流处理引擎所驱动的"提速层"（speed layer）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda architecture is no longer state of the art, but is still used in many places.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T163047Z" creationid="xccui" creationdate="20190605T052742Z">
        <seg>虽然Lambda架构已经算不上最先进，但应用仍然非常广泛。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda function r =&gt; r.id extracts the id field of a sensor reading r.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055915Z" creationid="xccui" creationdate="20190614T051803Z">
        <seg>Lambda函数r =&gt; r.id表示从传感器读数r中提取id字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda reduce function forwards the first tuple field (the key field) and concate‐ nates the List[String] values of the second tuple field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T054715Z" creationid="xccui" creationdate="20190614T062552Z">
        <seg>用于reduce的Lambda函数会直接转发第一个字段（键值字段），并将所有第二个字段中的List[String]值连接合并起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last reading position known by Kafka for the consumer group that was con‐ figured via the group.id parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T035349Z" creationid="xccui" creationdate="20190709T035159Z">
        <seg>通过group.id参数配置的Kafka消费者组所记录的最后读取位置，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latest offset of each individual partition:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T040315Z" creationid="xccui" creationdate="20190709T040315Z">
        <seg>每个分区最晚的偏移：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latter decision is based on a trigger condition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022846Z" creationid="xccui" creationdate="20190406T045549Z">
        <seg>其中参与计算的决策会根据触发条件判定，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latter will be replaced at runtime with actual values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043319Z" creationid="xccui" creationdate="20190804T043319Z">
        <seg>后者会在运行时被替换成实际的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The leading Dis‐ patcher recovers the failed application by starting a new JobManager thread that looks up the metadata pointer in ZooKeeper and loads the metadata from the persis‐ tent storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T050503Z" creationid="xccui" creationdate="20190721T050503Z">
        <seg>该Dispatcher会启动一个新的JobManager线程来恢复故障应用。新的JobManager会从ZooKeeper中查找元数据的存储路径，并依此从持久化存储中读取元数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The library style of running Flink applications resembles the deployment of micro‐ services in a containerized environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T030404Z" creationid="xccui" creationdate="20190730T030404Z">
        <seg>以库模式运行Flink应用有些类似于容器化环境中的微服务部署。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list entries can be of arbitrary type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T220045Z" creationid="xccui" creationdate="20190607T220045Z">
        <seg>列表中的条目可以是任意类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list includes the internal ID of a JAR file, its original name, and the time when it was uploaded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045843Z" creationid="xccui" creationdate="20190729T045843Z">
        <seg>该列表包含了JAR文件的内部ID、其原始名称以及上传时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The live updated results of a streaming analytics application can be used to power dashboard applications as shown in Figure 1-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155543Z" creationid="xccui" creationdate="20190605T044552Z">
        <seg>如图1-6所示，流式分析应用实时更新的结果可用于支撑仪表盘应用的展示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The live updated results of a streaming analytics applications can be used to power dashboard applications as shown in &lt;t8/&gt;Figure 1-6&lt;t9/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062117Z" creationid="xccui" creationdate="20190317T061352Z">
        <seg>如图1-6所示，流式分析应用的实时更新结果可以支撑表盘应用的展示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The logic of an application is defined by chaining transformations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051134Z" creationid="xccui" creationdate="20190612T052904Z">
        <seg>应用程序的逻辑是通过一系列转换来定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lower and upper bounds are defined as negative and positive time intervals, for example, as between(Time.hour(-1), Time.minute(15)).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T030211Z" creationid="xccui" creationdate="20190628T030211Z">
        <seg>下界和上界分别由负时间间隔和正时间间隔来定义，例如between(Time.hour(-1), Time.minute(15))。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lower and upper bounds can be arbitrarily chosen as long as the lower bound is smaller than the upper bound; you</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T030743Z" creationid="xccui" creationdate="20190628T030705Z">
        <seg>在满足下界值小于上界值的前提下，你可以任意对它们赋值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main take-away here is that lowering latency actually increases throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211801Z" creationid="xccui" creationdate="20190402T211645Z">
        <seg>这里的要点就是降低延迟实际上可以提高吞吐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main takeaway here is that lowering latency increases throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054722Z" creationid="xccui" creationdate="20190605T235620Z">
        <seg>此处的要点就是：降低延迟实际上可以提高吞吐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The map transformation is specified by calling the DataStream.map() method and produces a new DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T044734Z" creationid="xccui" creationdate="20190613T042736Z">
        <seg>通过调用DataStream.map()方法可以指定map转换产生一个新的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The master container is started from the Flink 1.7 Docker image (image: flink: 1.7) with an argument that starts the master process (args: - jobmanager).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190720T025352Z">
        <seg>主进程容器从Flink 1.7 Docker镜像（image: flink: 1.7）启动主进程（需要配置参数args: - jobmanager）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The master deployment configuration is shown in Example 9-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024937Z" creationid="xccui" creationdate="20190720T024826Z">
        <seg>示例9-2展示了主进程的Deployment配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The master process runs a Dispatcher and a ResourceManager in separate threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T153534Z" creationid="xccui" creationdate="20190717T153534Z">
        <seg>主进程会启动单独的线程来运行Dispatcher和ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum number of application master execution attempts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052636Z" creationid="xccui" creationdate="20190721T052636Z">
        <seg>ApplicationMaster尝试执行的最大次数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum parallelism can be set for all operators of an applica‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024952Z" creationid="xccui" creationdate="20190703T024952Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum parallelism parameter of an operator defines the number of key groups into which the keyed state of the operator is split.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024348Z" creationid="xccui" creationdate="20190703T024348Z">
        <seg>算子的最大并行度参数定义了算子在对键值状态进行分割时所用到的键值组（key group）的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mechanism is similar to buffering techniques used in networking or disk IO pro&lt;t2/&gt;‐&lt;t3/&gt; tocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041925Z" creationid="xccui" creationdate="20190504T041925Z">
        <seg>其机制和网络以及磁盘IO协议中的缓冲技术很像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mechanism is similar to the buffering techniques used in networking or disk I/O protocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T191311Z" creationid="xccui" creationdate="20190606T195538Z">
        <seg>它的机制类似于网络以及磁盘I/O协议中的缓冲技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mechanism relies on the ability of a sink to commit a transaction after recovering from a failure that was opened before a completed checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T163142Z" creationid="xccui" creationdate="20190708T163142Z">
        <seg>该机制需要数据汇在故障恢复后能够提交在检查点完成前开启的事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The menu on the left links to more detailed information on jobs and configu‐ ration parameters and also allows job submission by uploading a JAR.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T034406Z" creationid="xccui" creationdate="20190802T034406Z">
        <seg>你可以通过左侧菜单访问作业的详细信息和配置参数页面，还可以上传JAR来提交作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The metadata of the window typically contains information that can be used</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023219Z" creationid="xccui" creationdate="20190624T011756Z">
        <seg>窗口的元数据通常包含了一些可用作窗口标识的信息，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method clears all state associated with the key, the last temperature and the last timer state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T213923Z" creationid="xccui" creationdate="20190704T213923Z">
        <seg>该回调方法会清除所有当前键值的状态，包括用于保存最近一次温度以及前一个计时器时间的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method distributes records randomly according to a uniform distribution to the parallel tasks of the following operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T071043Z" creationid="xccui" creationdate="20190615T071043Z">
        <seg>该方法会依照均匀分布随机地将记录发往后继算子的并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method has to return</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T050302Z" creationid="xccui" creationdate="20190701T050302Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method has two parameters, checkpointId, which is a unique, monotonically increasing identifier for checkpoints, and timestamp, which is the wall-clock time when the master initiated the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023229Z" creationid="xccui" creationdate="20190701T050128Z">
        <seg>它接收两个参数：checkpointId是一个针对检查点的唯一且单调递增的标识，timestamp是JobManager开始创建检查点的机器时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method is called with a FunctionInitializationContext object that provides access to an Operator StateStore and a KeyedStateStore object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T154848Z" creationid="xccui" creationdate="20190702T064526Z">
        <seg>Flink在调用该方法时会传入一个FunctionInitializationContext对象，我们可以利用它访问OperatorStateStore及KeyedStateStore对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method is called with a list of state objects and has to restore the state of the operator based on these objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T051344Z" creationid="xccui" creationdate="20190701T051344Z">
        <seg>该方法接收一个状态对象列表，并需要基于这些对象恢复算子状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method must return true if all writes succeeded and false if a write failed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T063425Z" creationid="xccui" creationdate="20190715T063425Z">
        <seg>它会在全部记录写出成功时返回true，如果失败则会返回false。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method receives an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T063045Z" creationid="xccui" creationdate="20190715T063045Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method returns the right builder for the data type of the DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T211604Z" creationid="xccui" creationdate="20190711T211310Z">
        <seg>构建器的类型会和传入的DataStream类型相吻合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method takes several parameters, such as the JobID of the running application, the state identifier, the key for which the state should be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T034827Z" creationid="xccui" creationdate="20190707T034116Z">
        <seg>该方法需要接收几个参数，例如：当前运行应用的JobID，状态标识符，所需状态的键值，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The methods, processElement() and processBroadcastElement(), are called with different context objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T045919Z" creationid="xccui" creationdate="20190702T045919Z">
        <seg>processElement()和processBroadcastElement()两个方法在调用时会传入不同的上下文对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mode can either be PRO CESS_ONCE or PROCESS_CONTINUOUSLY.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185644Z" creationid="xccui" creationdate="20190710T185632Z">
        <seg>可选项为PROCESS_ONCE或PROCESS_CONTINUOUSLY。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mode in which the path should be read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185608Z" creationid="xccui" creationdate="20190710T185608Z">
        <seg>目标路径的读取模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The more resources available for recovery, the faster the catch-up phase completes and the faster processing latencies go back to normal.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T150822Z" creationid="xingcan" creationdate="20190801T150822Z">
        <seg>用于恢复的资源越多，追赶阶段的时长就会越短，处理延迟也就恢复得越快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most important</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T034145Z" creationid="xccui" creationdate="20190724T034145Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most trivial way would be to simply restart the job, but then we would have to replay all data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044142Z" creationid="xccui" creationdate="20190415T044114Z">
        <seg>最傻的办法就是简单地重启作业，但这样的话我们必须重放全部数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most widely used types can be grouped into the following categories:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T064954Z" creationid="xccui" creationdate="20190616T064954Z">
        <seg>使用最多的可以分为以下几类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The naive approach to taking a checkpoint from a streaming application—to pause, checkpoint, and resume the application—is not practical for applications that have even moderate latency requirements due to its “stop-the-world” behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T055438Z" creationid="xccui" creationdate="20190609T054707Z">
        <seg>针对流式应用，生成检查点的朴素方法就是暂停执行，生成检查点，然后恢复应用。但这种"停止一切"的行为，即便对于那些具有中等延迟要求的应用也很不切实际。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name for the new image</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190730T034326Z">
        <seg>新镜像的名称</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060732Z" creationid="xccui" creationdate="20190618T060732Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name that the user specifies when registering the metric</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T033606Z" creationid="xccui" creationdate="20190804T033529Z">
        <seg>用户在注册指标时指定的名称</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The network</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041626Z" creationid="xccui" creationdate="20190504T041203Z">
        <seg>TaskManager的网络模块在传输记录前会将它们在缓冲区中收集起来，因此，记录并非逐个发送的，而是在缓冲区中以批次形式发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The network component of a TaskManager collects records in buffers before they are shipped, i.e., records are not shipped one by one but batched into buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T191248Z" creationid="xccui" creationdate="20190606T195414Z">
        <seg>它的网络模块在记录传输前会先将它们收集到缓冲区中。换言之，记录并非逐个发送的，而是在缓冲区中以批次形式发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next block of code shows the Trigger API:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185923Z" creationid="xccui" creationdate="20190626T185923Z">
        <seg>以下代码块展示了Trigger的API：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next example shows how to connect a (nonkeyed) DataStream with a broadcas‐ ted stream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T063259Z" creationid="xccui" creationdate="20190615T051632Z">
        <seg>下面的例子展示了如何联结一个（未按照键值分区的）DataStream和一个广播流：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The no-restart strategy does not restart an application, but fails it immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154226Z" creationid="xingcan" creationdate="20190801T154135Z">
        <seg>no-restart策略不会重启应用，而是让它立即失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The null parameter of TextInputFormat in Example 8-3 defines the path that is separately set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185340Z" creationid="xccui" creationdate="20190710T185340Z">
        <seg>示例8-3中TextInputFormat的null参数表示要单独设置读取路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of buffers depends on the total number of network connections between operator tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T035333Z" creationid="xccui" creationdate="20190724T035333Z">
        <seg>其数目取决于算子任务之间的网络连接总数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of connections are tracked per TaskManager process and path authority</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T050055Z" creationid="xccui" creationdate="20190722T050055Z">
        <seg>连接数会以每个TaskManager进程、每个路径为单位分别追踪，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of key groups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T031615Z" creationid="xccui" creationdate="20190729T031615Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of key groups limits the maximum number of parallel tasks to which keyed state can be scaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024550Z" creationid="xccui" creationdate="20190703T024550Z">
        <seg>该数量限制了键值分区状态可以被扩展到的最大并行任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of parallel tasks of an operator is called the parallelism of the operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051400Z" creationid="xccui" creationdate="20190616T051400Z">
        <seg>算子并行化任务的数目称为该算子的并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of slots a TaskManager offers is controlled with the taskmanager.num berOfTaskSlots key in the configuration file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T062226Z" creationid="xccui" creationdate="20190723T062226Z">
        <seg>TaskManager所提供的处理槽数量是由配置文件中的taskmanager.numberOfTaskSlots项来指定的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of slots limits the number of tasks a TaskManager can execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142537Z" creationid="xccui" creationdate="20190606T142537Z">
        <seg>处理槽的数目限制了一个TaskManager可执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of slots limits the number of tasks that a TaskMan&lt;t3/&gt;‐&lt;t4/&gt; ager can execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062053Z" creationid="xccui" creationdate="20190418T051544Z">
        <seg>处理槽的数目限制了一个TaskManager可执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of slots usually only needs to be configured for standalone setups as</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T062316Z" creationid="xccui" creationdate="20190723T062316Z">
        <seg>通常你只需要在独立集群模式下设置处理槽的数量，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The observation that data processing systems (at this point in time) could either provide fast or accurate results led to the design of the so-called Lambda architecture which is depicted in &lt;t6/&gt;Figure 1-7&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T043705Z" creationid="xccui" creationdate="20190322T043255Z">
        <seg>以当时的眼光看待流处理系统，快速计算和准确结果二者不可兼得，因此才有了所谓的Lambda架构，详见图1-7。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The observation that data processing systems (at this point in time) could either provide fast or accurate results led to the design of the so-called lambda architecture, which is depicted in Figure 1-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193153Z" creationid="xccui" creationdate="20190605T051725Z">
        <seg>以当时的眼光看待流处理系统，计算快速和结果准确二者不可兼得，因此才有了所谓的Lambda架构，见图1-7。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The obvious next step is to learn how to actually implement a DataStream program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T095013Z" creationid="xccui" creationdate="20190612T011435Z">
        <seg>接下来需要学的自然就是如何实现DataStream程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The open() and close() methods of a RichFlatMapFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034240Z" creationid="xccui" creationdate="20190619T034231Z">
        <seg>RichFlatMapFunction中的open()和close()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The open() method is an initialization method for the rich function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060850Z" creationid="xccui" creationdate="20190618T060850Z">
        <seg>open()是富函数中的初始化方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator identifier and state name are required to be able to map the state data of a savepoint to the states of the operators of a starting application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023147Z" creationid="xccui" creationdate="20190609T215456Z">
        <seg>该算子标识和状态名需要能将保存点的状态数据映射到应用启动后的算子状态上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator is integrated with Flink’s checkpointing mecha‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T042626Z" creationid="xccui" creationdate="20190715T041530Z">
        <seg>这些算子会和Flink的检查点机制相结合，致力于将记录以精确一次语义写入外部系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator keeps the current minimum value and accordingly updates it for each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061545Z" creationid="xccui" creationdate="20190606T011920Z">
        <seg>其算子会维护当前的最小值，并根据每个到来的事件去更新这个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator keeps the current value of the sum as its internal state and updates it every time it receives a new event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181721Z" creationid="xccui" creationdate="20190414T052338Z">
        <seg>该算子以内部状态形式存储当前的累加值，并会在每次收到新事件时对其进行更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator keeps the current&lt;t4/&gt; &lt;t5/&gt;minimum value and accordingly updates it for each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035839Z" creationid="xccui" creationdate="20190406T035703Z">
        <seg>其算子会维护当前的最小值，并根据每个到来的事件同步更新这个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator needs to store the “high temperature” event in its internal state until it sees the “smoke” event or the until 10-minute time period expires.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031605Z" creationid="xccui" creationdate="20190606T031527Z">
        <seg>这个算子需要将"高温"事件存为内部状态，直到接下来发现"烟雾"事件或超过10分钟的有效时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator needs to store the “high temperature” event in its internal state, until it sees the “smoke” event or the until 10-minute time period expires.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T052942Z" creationid="xccui" creationdate="20190414T052942Z">
        <seg>这个算子需要将"高温"事件存为内部状态，直到发现"烟雾"事件或超过10分钟的过期时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator pipeline</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152223Z" creationid="esouser" creationdate="20190514T152223Z">
        <seg>图3-5中的算子所组成的流水线就满足上述需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator pipeline shown in Figure 3-5 fulfills these requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T200313Z" creationid="xccui" creationdate="20190606T203341Z">
        <seg>图3-5中算子所组成的流水线就满足上述条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator plan of the application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T153513Z" creationid="xccui" creationdate="20190729T153513Z">
        <seg>应用的算子计划（operator plan）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operators are assigned to three slot-</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T020050Z" creationid="xccui" creationdate="20190731T020050Z">
        <seg>它们分别被分配到处理槽共享组green，yellow和blue中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The options are ignored if the sink emits tuples, case classes, or rows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T223047Z" creationid="xccui" creationdate="20190711T223047Z">
        <seg>如果是写元组、样例类或Row的情况，这些选项将被忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order in which the broadcasted events arrive at the different parallel tasks of the broadcast state operator might differ if the operator that emits the broadcasted messages runs with a parallel‐ ism larger than 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T055428Z" creationid="xccui" creationdate="20190702T055428Z">
        <seg>如果发出广播消息的算子并行度大于1，那么广播事件到达广播状态算子不同并行任务的顺序可能会不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ordering guarantee is limited to a partition—Kafka does not provide ordering guarantees when reading from different partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T202818Z" creationid="xccui" creationdate="20190708T202655Z">
        <seg>但这样的话就只能针对某个分区实现保序，即它不能够保证不同分区间的事件顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The org.apache.flink.metrics.Meter interface pro‐ vides methods to mark the occurrence of one or more events, get the current rate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033947Z" creationid="xccui" creationdate="20190803T033856Z">
        <seg>org.apache.flink.metrics.Meter接口提供的方法可用于标记一个或多个事件发生、获取每秒事件发生的速率以及获取当前meter标记的事件数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original goals of this architecture were to improve the high result latency of the original batch analytics architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193729Z" creationid="xccui" creationdate="20190605T052749Z">
        <seg>它的最初目标是改善原始批量分析架构中结果的高延迟问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other common case of periodic watermark generation is when you know the maximum lateness that you will encounter in the input stream—the maximum differ‐ ence between an element’s timestamp and the largest timestamp of all perviously</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055905Z" creationid="xccui" creationdate="20190620T052720Z">
        <seg>另一个周期性生成水位线的常见情况是，你知道输入流中的延迟（任意新到元素和已到时间戳最大元素之间的时间差）上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other operators have a parallelism of four.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043456Z" creationid="xccui" creationdate="20190423T043437Z">
        <seg>其余算子的并行度为4。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other oper‐ ators have a parallelism of four.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144533Z" creationid="xccui" creationdate="20190606T144533Z">
        <seg>其余算子的并行度为4。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output can be read as follows: the first field of the SensorReading is a sen&lt;t0/&gt;‐&lt;t1/&gt; sorId, the second field is the timestamp as milliseconds since &lt;t2/&gt;1970-01-01-00:00:00.000&lt;t3/&gt;, and the third field is an average temperature compu&lt;t4/&gt;‐&lt;t5/&gt; &lt;t6/&gt;ted over five seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045333Z" creationid="xccui" creationdate="20190329T043115Z">
        <seg>输出说明如下：SensorReading的第一个字段是sensorId，第二个字段是以距1970-01-01-00:00:00.000的毫秒数表示的时间戳，第三个字段是每隔5秒计算出的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output is only eventually consistent, because results are reset to a previous version during recovery, meaning consumers might read older results than read previously.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T202412Z" creationid="xccui" creationdate="20190711T202304Z">
        <seg>之所以如此，是因为在恢复期间写出的结果会被重置到以前的版本。这意味着后续的消费者可能会读到比之前读取的值更旧的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the example is (1,2,2) followed by (1,7,2) for the key “1” and (2,3,1) followed by (2,5,1) for the key “2.” The first</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T062202Z" creationid="xccui" creationdate="20190614T055254Z">
        <seg>示例对于键值"1"首先输出(1,2,2)，然后是(1,7,2)；对于键值"2"首先输出(2,3,1)，然后是(2,5,1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the job is written to the standard out of Flink’s worker process which is by default redirected into a file in the &lt;t0/&gt;./log&lt;t1/&gt; folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042518Z" creationid="xccui" creationdate="20190329T042238Z">
        <seg>作业的输出会写入Flink工作进程的标准输出，默认情况下它会重定向到./log目录下的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the job is written to the standard out of Flink’s worker process, which is redirected into a file in the ./log folder by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123802Z" creationid="xccui" creationdate="20190605T123802Z">
        <seg>作业的输出会写入Flink工作进程的标准输出，默认情况下它会重定向到./log目录下的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the program is written to the standard out (or console) window of your IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042955Z" creationid="xccui" creationdate="20190611T042955Z">
        <seg>程序的输出会写到你IDE的标准输出（或控制台）窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the source tasks is partitioned into streams of  even and odd numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062132Z" creationid="xccui" creationdate="20190609T062059Z">
        <seg>数据源任务的输出会被分成奇数流和偶数流两个部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output starts with a few log statements about the states that parallel operator tasks go through, such as SCHED‐ ULING, DEPLOYING, and RUNNING.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T092101Z" creationid="xccui" creationdate="20190611T043225Z">
        <seg>输出以几行日志语句开始，它们记录了并行算子所经过的一系列状态，例如：SCHEDULING、DEPLOYING以及RUNNING。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The overall logic is the same, but instead of calling a JoinFunction for every pair of events from both inputs, a CoGroupFunction is called once per window with iterators over the elements from both inputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T204605Z" creationid="xccui" creationdate="20190628T053655Z">
        <seg>Join和Cogroup的总体逻辑相同，二者的唯一区别是：Join会为两侧输入中的每个事件对调用JoinFunction；而Gogroup中用到的GoGroupFunction会以两个输入的元素遍历器为参数，只在每个窗口中被调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parallelism of an operator can be controlled at the level of the execution environ‐ ment or per individual operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051555Z" creationid="xccui" creationdate="20190616T051555Z">
        <seg>算子的并行度可以在执行环境级别或单个算子级别进行控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parallelism of the environment (and thus also the default parallelism of all operators) is automatically initialized based on the context in which the application is started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T024422Z" creationid="xccui" creationdate="20190616T052730Z">
        <seg>而环境的并行度（即所有算子的默认并行度）则会根据应用启动时所处的上下文自动初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameter -m defines the host to which the job is submitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T012521Z" creationid="xccui" creationdate="20190719T012334Z">
        <seg>参数-m用来定义提交作业的目标主机。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameter is ignored in PROCESS_ONCE mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T191331Z" creationid="xccui" creationdate="20190710T191331Z">
        <seg>如果选择PROCESS_ONCE，该参数会被忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The path of a part file has the fol‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T213913Z" creationid="xccui" creationdate="20190710T213913Z">
        <seg>这些文件的路径遵循以下规则：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The path that should be read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185401Z" creationid="xccui" creationdate="20190710T185401Z">
        <seg>要读取的目标路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The performance of a stateful operator (built-in or user-defined) depends on several aspects, including the data types of the state, the state backend of the application, and the chosen state primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T031325Z" creationid="xccui" creationdate="20190704T030838Z">
        <seg>状态化算子（无论是内置的还是用户自定义的）的性能取决于多个方面，包括状态的数据类型，应用的状态后端以及所选的状态原语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pom.xml file of a generated Maven project contains comments that explain how to add additional dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041642Z" creationid="xccui" creationdate="20190619T043504Z">
        <seg>所生成Maven项目中的pom.xml文件包含了教你如何添加额外依赖的注释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The port also exposes Flink’s REST API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T042322Z" creationid="xccui" creationdate="20190718T042322Z">
        <seg>它的端口同样是Flink REST API的端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ports used by the client proxy and server and additional parameters can be con‐ figured in the ./conf/flink-conf.yaml file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T055955Z" creationid="xccui" creationdate="20190706T055955Z">
        <seg>客户端代理和服务器所使用的端口以及一些额外的参数可以在./conf/flink-conf.yaml文件中配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The possible TriggerResult values enable you to implement sophisticated window‐ ing logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185344Z" creationid="xccui" creationdate="20190626T185344Z">
        <seg>多样化的TriggerResult返回值可以让你实现复杂的窗口逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous chapter discussed important concepts of distributed stream processing, such as parallelization, time, and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053758Z" creationid="xccui" creationdate="20190416T053731Z">
        <seg>上一章主要讨论了分布式流处理中的一些重要概念，例如：并行、时间、状态等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous chapter introduced two concepts Flink leverages to provide event-time semantics: record timestamps and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T064038Z" creationid="xccui" creationdate="20190606T204552Z">
        <seg>上一章我们介绍了Flink在提供处理时间语义时所采用的两个概念：记录时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous chapter introduced two concepts that Flink leverages to pro&lt;t2/&gt;‐&lt;t3/&gt; vide event-time semantics: record timestamps and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T034944Z" creationid="xccui" creationdate="20190523T034944Z">
        <seg>上一章介绍了Flink在提供处理时间语义时所采用的两个概念：记录时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that Alice lives in Berlin and she takes the subway to work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152542Z" creationid="xccui" creationdate="20190411T150344Z">
        <seg>但问题在于，爱丽丝住在柏林，每天乘地铁上班，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that Alice lives in Berlin and takes the subway to work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154529Z" creationid="xccui" creationdate="20190606T014945Z">
        <seg>然而有个问题：爱丽丝住在柏林，每天乘地铁上班，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that Minikube tries to fetch the custom image from a public Docker image registry instead of the local Docker registry of your machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T045005Z" creationid="xccui" creationdate="20190730T045005Z">
        <seg>主要问题是Minikube会尝试从公共Docker镜像注册表而不是本地机器的Docker注册表获取自定义镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of copying data to the data warehouse is called extract-transform-load (ETL).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192128Z" creationid="xccui" creationdate="20190228T190335Z">
        <seg>这个向数据仓库拷贝数据的过程被称为提取-转换-加载（Extract-Transform-Load，ETL）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of copying data to the data warehouse is called extract–transform–load (ETL).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T202730Z" creationid="esouser" creationdate="20190603T202730Z">
        <seg>这个向数据仓库拷贝数据的过程被称为提取-转换-加载（Extract-Transform-Load，ETL）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of waiting for all barriers to arrive is called barrier alignment, and it is depicted in Figure 3-22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T065323Z" creationid="xccui" creationdate="20190609T162722Z">
        <seg>这个等待所有分隔符到达的过程称为分隔符对齐，我们在图3-22中对它进行了展示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process() method is called with the key of the window, an Iterable to access the elements of the window, and a Collector to emit results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T040725Z" creationid="xccui" creationdate="20190624T011149Z">
        <seg>process()方法在被调用时会传入窗口的键值、一个用于访问窗口内元素的Iterator以及一个用于发出结果的Collector。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The processElement() and onTimer() methods are synchronized to prevent concurrent access and manipu‐ lation of state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062912Z" creationid="xccui" creationdate="20190621T061008Z">
        <seg>processElement()和onTimer()两个方法是做了同步的，这样可以防止并发访问或操作状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program fails while a task is running the sendValues() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065124Z" creationid="xccui" creationdate="20190715T065124Z">
        <seg>程序在任务运行sendValues()方法时发生故障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program in Example 5-1 converts the temperatures from Fahrenheit to Celsius and computes the average temperature every 5 seconds for each sensor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T052149Z" creationid="xccui" creationdate="20190612T035758Z">
        <seg>示例5-1中的程序将温度从华氏度转为摄氏度并计算每个传感器每5秒的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program will continue to generate new events, process them, and emit new results every second until you terminate it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T092230Z" creationid="xccui" creationdate="20190611T043547Z">
        <seg>如果不手动终止，这个程序会不停生成新的事件、对它们进行处理并每秒产生新的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The project contains two skeleton files, BatchJob.scala and StreamingJob.scala, as a starting point for your own programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T094749Z" creationid="xccui" creationdate="20190612T010104Z">
        <seg>你可以使用项目生成的两个框架文件，BatchJob.scala和StreamingJob.scala，作为你程序的起点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol and the requirements of the sink system might be easier to understand by looking at a concrete example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T031720Z" creationid="xccui" creationdate="20190716T031720Z">
        <seg>为了理解数据汇系统的协议和需求，我们来看一个具体的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose of checkpoints is to recover an application after a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T204953Z" creationid="xccui" creationdate="20190731T204953Z">
        <seg>检查点的目的是用于应用故障恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose of the snapshotState()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071540Z" creationid="xccui" creationdate="20190702T071540Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The random data exchange strategy is implemented by the DataStream.shuf fle() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043250Z" creationid="xccui" creationdate="20190615T070800Z">
        <seg>我们可以利用DataStream.shuffle()方法实现随机数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The random strategy uniformly distributes data items to operator tasks in order to evenly distribute the load across computing tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233607Z" creationid="xccui" creationdate="20190605T233549Z">
        <seg>随机策略（random strategy）会将数据均匀分配至算子的所有任务，以实现计算任务的负载均衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rapid digitalization and emergence of connected systems made it possible to collect much more data in real-time and immediately act on this data for example by adjusting to changing conditions or by personalizing user experiences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T052548Z" creationid="xccui" creationdate="20190317T051706Z">
        <seg>数字化的迅猛发展和互联系统的出现使得我们可以实时获取更多数据并立即根据它们采取行动，例如：适应状况的变化或个性化用户体验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reading position in a Kafka partition is called an offset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T202954Z" creationid="xccui" creationdate="20190708T202954Z">
        <seg>Kafka中分区的读取位置称为偏移（offset）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason for this is to keep the number of default dependencies low.4 Most connec‐ tors and libraries rely on one or more libraries, which typically have several addi‐ tional transitive dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T040303Z" creationid="xccui" creationdate="20190619T035840Z">
        <seg>之所以这么做是为了保持默认依赖的简洁性，4 因为大多数连接器或库还需要依赖其他库，而这些库通常又会级联引用更多的依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason is that proxy services offer more authentication and configuration options than Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T035641Z" creationid="xccui" creationdate="20190725T035622Z">
        <seg>其原因在于代理服务和Flink相比，提供了更多的身份验证及配置选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rebalance() method partitions the input stream so that events are evenly distributed to successor tasks in a round-robin fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031409Z" creationid="xccui" creationdate="20190616T043105Z">
        <seg>rebalance()方法会将输入流中的事件以轮流方式均匀分配给后继任务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receiver processes the shipped data with the reserved buffers and uses the sender’s backlog size to prioritize the next credit grants for all its connected senders.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T195811Z" creationid="esouser" creationdate="20190514T143015Z">
        <seg>接收端使用保留的缓冲来处理收到的数据，同时依据各发送端的积压量信息来计算所有相连的发送端在下一轮的信用优先级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receiving task takes the buffer from the queue and deserializes the incoming records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194041Z" creationid="esouser" creationdate="20190513T192253Z">
        <seg>接收任务会从这个队列里获取缓冲区并将其中的记录反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reduce transformation is a generalization of the rolling aggregation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061250Z" creationid="xccui" creationdate="20190614T061250Z">
        <seg>reduce转换是滚动聚合转换的泛化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relevant configu‐ ration keys are:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T045625Z" creationid="xccui" creationdate="20190722T045625Z">
        <seg>相关配置的键是：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remote storage for checkpointing could be a distributed filesystem or a database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053803Z" creationid="xccui" creationdate="20190608T053742Z">
        <seg>该远程存储可能是一个分布式文件系统，也可能是某个数据库系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rescale transformation is more efficient if the number of receiver tasks is a multitude of the number of sender tasks or vice versa.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T044029Z" creationid="xccui" creationdate="20190616T044029Z">
        <seg>当接收端任务远大于发送端任务的时候，该方法会更有效，反之亦然。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rescale() method also distributes events in a round-robin fashion, but only to a subset of successor tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031526Z" creationid="xccui" creationdate="20190616T043552Z">
        <seg>rescale()也会以轮流方式对事件进行分发，但分发目标仅限于部分后继任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the Flink ecosystem</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030241Z" creationid="xccui" creationdate="20190225T030241Z">
        <seg>Flink生态的其他组成部分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The restart strategy of an application is configured via StreamExecutionEnvironment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154355Z" creationid="xingcan" creationdate="20190801T154355Z">
        <seg>你可以像示例10-4那样使用StreamExecutionEnvironment配置应用重启策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The restoreState() method is always invoked when the state of a function needs to be initialized—when the job is started (from a savepoint or not) or in the case of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T051246Z" creationid="xccui" creationdate="20190701T051246Z">
        <seg>restoreState()方法会在初始化函数状态时调用，该过程可能发生在作业启动（无论是否从保存点）或故障恢复的情况下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result data has a deterministic (composite) key, on which idempotent updates can be performed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T043141Z" creationid="xccui" creationdate="20190714T043141Z">
        <seg>结果数据中用于幂等更新的（复合）键值是确定的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result stream is written to the standard output by calling print():</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051844Z" creationid="xccui" creationdate="20190612T054705Z">
        <seg>我们通过调用print()方法将结果写到标准输出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results of the program are emitted to standard output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042541Z" creationid="xccui" creationdate="20190611T042541Z">
        <seg>程序的结果会写入标准输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rolling aggregate operator keeps a state for every key that is processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061006Z" creationid="xccui" creationdate="20190614T061006Z">
        <seg>滚动聚合算子会为每个处理过的键值维持一个状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rolling reduce operator keeps a state for every key that is pro‐ cessed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T055940Z" creationid="xccui" creationdate="20190614T062936Z">
        <seg>滚动reduce算子会为每个处理过的键值维持一个状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The run() method is called once by Flink and runs in a dedicated source thread, typically reading or receiving data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T151645Z" creationid="xccui" creationdate="20190712T151454Z">
        <seg>run()方法只会在Flink中调用一次，后者会专门为它开一个的线程，该线程通常会循环读取或接收数据并将它们发出（无限流）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The run() method is doing the actual work of reading or receiving records and ingesting them into a Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T151024Z" creationid="xccui" creationdate="20190712T151024Z">
        <seg>run()方法负责执行具体记录读入或接收工作，它会将这些记录传入Flink应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The script is included in the source distribution and Flink’s Git repository.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T030847Z" creationid="xccui" creationdate="20190730T030819Z">
        <seg>你可以从源码发行版或Flink的Git仓库中找到它，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The script requires the fol‐ lowing parameters:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034231Z" creationid="xccui" creationdate="20190730T034231Z">
        <seg>脚本所需参数如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The script will start a local JobManager and start one TaskMan‐ ager for each entry in the slaves file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T203839Z" creationid="xccui" creationdate="20190717T203728Z">
        <seg>该脚本会在本地启用一个JobManager，并针对slaves文件中的每一个条目启动一个TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second approach to achieve end-to-end exactly-once consistency is based on transactional writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T072527Z" creationid="xccui" creationdate="20190708T072527Z">
        <seg>实现端到端精确一次一致性的第二个途径是事务性写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second argument is a DeserializationSchema or KeyedDeserialization Schema.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T213336Z" creationid="xccui" creationdate="20190708T213336Z">
        <seg>第二个参数是一个DeserializationSchema或KeyedDeserializationSchema。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second is the name of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T150222Z" creationid="xingcan" creationdate="20190709T150222Z">
        <seg>第二个参数是数据写入的目标主题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second property is used to handle streams with out-of-order record timestamps, such as the records with timestamps 3 and 5 in &lt;t0/&gt;Figure 3-8&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T034143Z" creationid="xccui" creationdate="20190523T042812Z">
        <seg>第二个属性是用来应对那些记录时间戳乱序的数据流，例如图3-8中所示的时间戳3和5。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second property is used to handle streams with out-of-order record timestamps, such as the records with timestamps 3 and 5 in Figure 3-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T065559Z" creationid="xccui" creationdate="20190606T205450Z">
        <seg>第二个属性可用来处理数据流中时间戳乱序的记录，例如图3-8中的时间戳为3和5的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second step of a FileInputFormat is to receive an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T192117Z" creationid="xccui" creationdate="20190710T192117Z">
        <seg>FileInputFormat读取过程的第二步是接收一个输入划分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second type are ad-hoc queries that aim to provide answers to specific questions and support business-critical deci&lt;t2/&gt;‐&lt;t3/&gt; sions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T030047Z" creationid="xccui" creationdate="20190228T193848Z">
        <seg>第二类是即席查询，其主要目的是通过解答特定问题来辅助商业决策。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second type are ad-hoc queries that aim to provide answers to specific questions and support business-critical decisions, for example a query to collect revenue numbers and spending on radio commercials to evaluate the effectiveness of a marketing cam‐ paign.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154650Z" creationid="esouser" creationdate="20190603T203150Z">
        <seg>第二类是即席查询（ad-hoc query）。其主要目的是通过解答特定问题来辅助关键性的商业决策，例如：通过查询来整合营收数字和电台广告中的投入，以评估市场营销的有效性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The serialization format of state is an important aspect when updating an application and is discussed later in this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023627Z" creationid="xccui" creationdate="20190701T023627Z">
        <seg>状态的序列化格式是在更新应用时需要重点考虑的一个方面，我们将在本章稍后对此进行讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The serializer is also used to convert the raw bytes back into JVM objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T051605Z" creationid="xccui" creationdate="20190705T051605Z">
        <seg>该序列化器还用于将原始字节转换回JVM对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The serializers that convert the state JVM objects into bytes are generated and configured by Flink’s type system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T050137Z" creationid="xccui" creationdate="20190705T050113Z">
        <seg>用于转换JVM中状态对象的序列化器是由Flink的类型系统生成和配置的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service can be a Flink Dispatcher, a Flink JobManager, or YARN’s ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025600Z" creationid="xccui" creationdate="20190423T025547Z">
        <seg>此处的服务可以是Flink Dispatcher，Flink JobManager或是YARN的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service can be a Flink Dispatcher, a Flink Job‐ Manager, or YARN’s ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143452Z" creationid="xccui" creationdate="20190606T143434Z">
        <seg>这里的服务可以是Flink Dispatcher，Flink JobManager或是YARN的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service defi‐ nition that exposes the master process and makes it accessible to the worker contain‐ ers is shown in Example 9-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T031729Z" creationid="xccui" creationdate="20190720T031729Z">
        <seg>示例9-4中展示的Service定义会将主进程暴露出来以供工作进程容器访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service latency is the time you spend in the coffee shop, from the moment you enter until you have your first sip of coffee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050924Z" creationid="xccui" creationdate="20190605T233933Z">
        <seg>所谓服务延迟就是你在店内买咖啡的时间，即从你进门的一刻到抿到第一口咖啡的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The session is stopped and all resources are freed when the script is terminated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T142325Z" creationid="xccui" creationdate="20190719T014049Z">
        <seg>在脚本终止时，会话就会停止，一切资源得以释放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The session mode starts a long-running Flink cluster that can run multiple jobs and needs to be manually stopped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T213546Z" creationid="xccui" creationdate="20190718T213546Z">
        <seg>而在会话模式下，系统会启动一个长时间运行的Flink集群，该集群可以运行多个作业，需要我们手动停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest thing to do when a task fails is to do nothing to recover lost state and replay lost events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034336Z" creationid="xccui" creationdate="20190415T051105Z">
        <seg>任务发生故障时最简单的措施就是既不恢复丢失的状态，也不重放丢失的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest way to get an overview of your Flink cluster as well as a glimpse of what your jobs are doing internally is to use Flink’s Web UI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T034006Z" creationid="xccui" creationdate="20190802T033812Z">
        <seg>了解Flink集群和内部作业工作情况概要最简单的方法就是使用Flink Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sink achieves this by a commit protocol that moves files through different stages, in progress, pending,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T192247Z" creationid="xccui" creationdate="20190711T183631Z">
        <seg>它的实现方式是采用一种提交协议，该协议会基于Flink的检查点机制将文件在不同阶段（进行，等待及完成）间转移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sink commits a transaction when it receives the completion notifica‐ tion of the corresponding checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T040014Z" creationid="xccui" creationdate="20190715T040014Z">
        <seg>数据汇在接收到对应检查点的完成通知后才会提交事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sink connector throws an exception if a write does not succeed, causing the application to fail and recover.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T154318Z" creationid="xingcan" creationdate="20190709T154318Z">
        <seg>如果数据汇连接器写入不成功，则会抛出异常，继而导致应用失败并进行故障恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sink connector waits for Kafka to acknowledge in-flight records before com‐ pleting its checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T161250Z" creationid="xingcan" creationdate="20190709T161021Z">
        <seg>数据汇连接器要在检查点完成前等待kafka确认记录写入完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sink in Example 8-15 appends the value as a String to the transaction file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052819Z" creationid="xccui" creationdate="20190716T052819Z">
        <seg>示例8-15中的数据汇将传入值以String形式写到事务文件中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sink must be able to recover a transaction after a process failed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T030823Z" creationid="xccui" creationdate="20190716T030823Z">
        <seg>数据汇需要在进程发生故障时进行事务恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sink task also starts a new transaction for all records that arrive before the next checkpoint barrier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T212123Z" creationid="xccui" creationdate="20190715T210500Z">
        <seg>而同时，它还会为在下一个检查点分隔符之前到来的所有记录开启一个新的事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sink task must not yet commit the transac‐ tion, because it is not guaranteed that all tasks of the job will complete their check‐ points.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T212112Z" creationid="xccui" creationdate="20190715T210205Z">
        <seg>由于数据汇任务此时还不能保证所有作业任务都可以顺利完成检查点工作，所以它暂时无法提交事务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The slide value defines the interval at which a new bucket is created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024245Z" creationid="xccui" creationdate="20190407T024134Z">
        <seg>滑动间隔决定每隔多久生成一个新的桶。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sliding count-based window of &lt;t5/&gt;Figure 2-8&lt;t6/&gt; has a length of 4 events and slide of 3 events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024330Z" creationid="xccui" creationdate="20190407T024330Z">
        <seg>在图2-8中，基于数量的滑动窗口的长度为4个事件，滑动间隔为3个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sliding count-based window of Figure 2-8 has a length of four events and slide of three events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013302Z" creationid="xccui" creationdate="20190606T013302Z">
        <seg>在图2-8中，基于数量的滑动窗口的长度为4个事件，滑动间隔为3个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sliding window assigner assigns elements to fixed-sized windows that are shifted by a specified slide interval, as shown in Figure 6-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054743Z" creationid="xccui" creationdate="20190623T054743Z">
        <seg>如图6-2所示，滑动窗口分配器将元素分配给大小固定且按指定滑动间隔移动的窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The snapshot State() method splits the operator state into multiple parts and the restoreState()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T060605Z" creationid="xccui" creationdate="20190701T060430Z">
        <seg>snapshotState()方法能够将算子状态分为多个部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The snapshotState() method is called immediately before a checkpoint is taken and receives a FunctionSnapshotContext object as the parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071327Z" creationid="xccui" creationdate="20190702T071327Z">
        <seg>snapshotState()方法会在生成检查点之前调用，它需要接收一个FunctionSnapshotContext对象作为参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The snapshotState() method is invoked when Flink triggers a checkpoint of the stateful function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T041236Z" creationid="xccui" creationdate="20190701T045645Z">
        <seg>snapshotState()方法会在Flink触发为状态化函数生成检查点时调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The source is automatically set as active as soon as it starts to emit records again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T051609Z" creationid="xccui" creationdate="20190713T051609Z">
        <seg>数据源一旦开始接收记录，就会恢复活动状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The source task stores the current offset of its input stream as  state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T031659Z" creationid="xccui" creationdate="20190609T030952Z">
        <seg>数据源算子的任务会把输入流的当前偏移量存为状态；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The src/ folder has the follow‐ ing structure:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005710Z" creationid="xccui" creationdate="20190612T005710Z">
        <seg>src/目录的结构如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The standard Flink Docker images are a good starting point to customize your own Flink images.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190722T005506Z">
        <seg>标准的Flink Docker镜像可以帮助你快速上手定制自己的Flink镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The start scripts must be able to start a Java process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T175231Z" creationid="xccui" creationdate="20190717T175212Z">
        <seg>但前提是启动脚本可以启动Java进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The start-cluster.sh script requires a passwordless SSH configuration on all machines to be able to start the TaskManager processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T195955Z" creationid="xccui" creationdate="20190717T195955Z">
        <seg>start-cluster.sh脚本需要针对所有运行TaskManager进程的机器配置无密码SSH登录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T034421Z" creationid="xccui" creationdate="20190724T034421Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state backend is responsible for storing the local state of each task instance and persisting it to remote storage when a checkpoint is taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T213832Z" creationid="xccui" creationdate="20190703T213832Z">
        <seg>状态后端负责存储每个状态实例的本地状态，并在生成检查点时将它们写入远程持久化存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state backend notifies the task once its state checkpoint is complete and the task acknowledges the check‐ point at the JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T154433Z" creationid="xccui" creationdate="20190609T154111Z">
        <seg>状态后端会在状态存为检查点完成后通知任务，然后任务会给JobManager发送确认消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state backend of an application is responsible for maintaining the local state, per‐ forming checkpoints and savepoints, and recovering the application state after a fail‐ ure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T212359Z" creationid="xccui" creationdate="20190731T212359Z">
        <seg>应用状态后端负责维护本地状态、生成检查点和保存点以及在故障时恢复应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state copies in the savepoint are organized by an operator identifier and a state name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023143Z" creationid="xccui" creationdate="20190609T215249Z">
        <seg>保存点中的状态副本会按照算子标识和状态名称进行组织。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state elements can be accessed by calling List State.get(), which returns an Iterable[T] over all state elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T021316Z" creationid="xccui" creationdate="20190630T053907Z">
        <seg>还可以使用ListState.get()访问状态元素（它会返回一个可遍历所有元素的Iterable[T]对象）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state handle object (lastTempState in Example 7-2) is a regular member variable of the function class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063849Z" creationid="xccui" creationdate="20190701T020612Z">
        <seg>我们一般会将状态句柄对象（示例7-2中的lastTempState）声明为函数类的常规成员变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state handle object only provides access to the state, which is stored an maintained in the state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T034920Z" creationid="xccui" creationdate="20190701T020932Z">
        <seg>状态句柄对象只提供用于访问状态的接口而不会存储状态本身，具体保存工作需要由状态后端来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state is check‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T035406Z" creationid="xccui" creationdate="20190715T035406Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state name is scoped to the operator so that a function can have more</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T070147Z" creationid="xccui" creationdate="20190630T070107Z">
        <seg>状态名称的作用域是整个算子，因此你可以通过在函数中注册多个状态描述符的方式得到多个状态对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state of an application that was running for several weeks can be expensive or even impossible to recompute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T212148Z" creationid="xccui" creationdate="20190702T211747Z">
        <seg>在应用运行较长一段时间后，其状态就会变得成本十分昂贵，甚至无法重新计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state of the application is automatically redistributed to the larger or smaller number of parallel operator tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T055120Z" creationid="xccui" creationdate="20190727T055120Z">
        <seg>应用的状态会自动重新分配到更多或更少的并行算子任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state of the window is not changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184622Z" creationid="xccui" creationdate="20190626T184622Z">
        <seg>窗口状态不会发生任何变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state primitive offers many of the methods of a regular Java Map such as get(key: K), put(key: K, value:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T060032Z" creationid="xccui" creationdate="20190630T055837Z">
        <seg>该状态原语提供了很多常规Java Map中的方法，例如get(key: K)，put(key: K, value: V)，contains(key: K)，remove(key: K)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state stores are responsible for regis‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T064841Z" creationid="xccui" creationdate="20190702T064841Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state-cleaning mechanism implemented by the above KeyedProcessFunction works as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T211645Z" creationid="xccui" creationdate="20190704T211645Z">
        <seg>上述KeyedProcessFunction实现的状态清除策略的工作机制如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stateful streaming application processes events as usual and stores and updates its intermedi‐ ate or final results in a queryable state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T163104Z" creationid="xccui" creationdate="20190705T163104Z">
        <seg>状态化流式应用可以按照正常流程处理事件，并在可查询状态中对其中间或最终结果进行存储和更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The steps of this naive algorithm would be:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223351Z" creationid="xccui" creationdate="20190608T223351Z">
        <seg>朴素算法的步骤包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The storage location of the local state copy can be specified as well (taskmanager.state.local.root-dirs).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T045130Z" creationid="xccui" creationdate="20190724T045130Z">
        <seg>本地状态副本的存储位置同样可配（taskmanager.state.local.root-dirs）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The storage location of the uploaded JAR file</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045656Z" creationid="xccui" creationdate="20190729T045656Z">
        <seg>上传JAR文件的存储位置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The straightforward approach for such use cases is to implement a MapFunction that queries the datastore for every processed record, waits for the query to return a result,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T191848Z" creationid="xccui" creationdate="20190716T191458Z">
        <seg>该用例的一个直观解决方案是实现一个MapFunction，它会针对每一条处理记录去查询数据库并等待结果返回，随后才可以丰富记录并发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream of numbers is partitioned into a stream of even and odd numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T030857Z" creationid="xccui" creationdate="20190609T030659Z">
        <seg>数字流会被分成奇数流和偶数流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream processor computes approximated results in near real time and writes them into a speed table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193242Z" creationid="xccui" creationdate="20190605T052213Z">
        <seg>流处理引擎会近实时地计算出近似结果，并将其写入"提速表"中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream processor computes possibly inaccurate results in near real-time and writes the results into a speed table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032857Z" creationid="xccui" creationdate="20190322T045515Z">
        <seg>流处理引擎会近实时地计算出一个可能并不精确的结果，随后将其写入"提速表"中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sum tasks persist the current sum value as state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T031626Z" creationid="xccui" creationdate="20190609T031626Z">
        <seg>求和算子的任务会把当前和值存为状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The system needs to efficiently manage the state and make sure it is protected from concurrent updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T183450Z" creationid="xccui" creationdate="20190606T032909Z">
        <seg>系统需要高效地管理状态并保证它们不受并发更新的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The system needs to efficiently manage the state and make&lt;t1/&gt; &lt;t2/&gt;sure it is protected from concurrent updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T033323Z" creationid="xccui" creationdate="20190415T033225Z">
        <seg>系统需要高效地管理状态并保证它们在面对并发更新时不会出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The system scope declares what component of the system the metric refers to and what context information it should include.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T034301Z" creationid="xccui" creationdate="20190804T034301Z">
        <seg>系统域用于声明指标所对应的系统组件及包含的上下文信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task can be explicitly canceled at some point in time or terminated in the case of a finite stream when the input is fully consumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T151919Z" creationid="xccui" creationdate="20190712T151919Z">
        <seg>其任务可以在某个时间点被显式取消，或是在有限流的情况下待数据完全消费完毕后自动终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task can then choose which entries to use and which to dis‐ card.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061346Z" creationid="xccui" creationdate="20190608T061317Z">
        <seg>随后由任务自己决定哪些条目该保留，哪些该丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task emits a watermark with the updated event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T070807Z" creationid="xccui" creationdate="20190606T213002Z">
        <seg>任务根据更新后的事件时间将水位线发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task emits a watermark with the updated event-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042340Z" creationid="xccui" creationdate="20190529T042213Z">
        <seg>根据更新后的事件时间发出水位线记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task updates its internal event-time clock based on the watermark’s time&lt;t0/&gt;‐&lt;t1/&gt; stamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041933Z" creationid="xccui" creationdate="20190529T041933Z">
        <seg>基于水位线记录的时间戳更新内部事件时间时钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task updates its internal event-time clock based on the watermark’s time‐ stamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T212920Z" creationid="xccui" creationdate="20190606T212920Z">
        <seg>基于水位线记录的时间戳更新内部事件时间时钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tasks of a running application are continuously exchanging data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T190921Z" creationid="xccui" creationdate="20190504T040830Z">
        <seg>在运行状态下，应用的任务会持续进行数据交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tasks of operators with two or more input streams such as Union or CoFlatMap (see “Multistream Transformations”) also compute their event-time clock as the mini‐ mum of all partition watermarks—they do not distinguish between partition water‐ marks of different input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054214Z" creationid="xccui" creationdate="20190607T025821Z">
        <seg>对于那些有着两条或多条输入数据流的算子，如Union或CoFlatMap（详见"多流转换"一节），它们的任务同样是利用全部分区水位线中的最小值来计算事件时间时钟，并没有考虑分区是否来自不同的输入流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tasks of the operator will not be chained to preceding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T011015Z" creationid="xccui" creationdate="20190730T204023Z">
        <seg>该方法会让对应算子的任务断开与之前的任务链接，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tasks of the operators with a parallelism of four are assigned to each slot.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062201Z" creationid="xccui" creationdate="20190423T164129Z">
        <seg>对于并行度为4的算子，其任务会每个处理槽分配一个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task’s time service identifies all timers with a time smaller than the updated event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T052629Z" creationid="xccui" creationdate="20190606T212936Z">
        <seg>任务的时间服务会找出所有触发时间小于更新后事件时间的计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task’s time service identifies all timers with a time smaller than the updated event-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042031Z" creationid="xccui" creationdate="20190529T042031Z">
        <seg>任务的时间服务会找出所有触发时间小于更新后事件时间的定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third and biggest challenge that comes with stateful operators is ensuring that state can be recovered and results will be correct even in the presence of fail‐ ures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T184111Z" creationid="xccui" creationdate="20190606T032958Z">
        <seg>最后一个也是最大的挑战在于，状态化算子需要保证状态可以恢复，并且即使出现故障也要确保结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third generation of distributed open source stream processors (2015) addressed the dependency of results on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053334Z" creationid="xccui" creationdate="20190605T053320Z">
        <seg>第三代分布式流处理引擎（2015年）解决了结果对事件到来时间及顺序的依赖问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third generation of distributed open source stream processors (2015) fixed the dependency of results on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T050910Z" creationid="xccui" creationdate="20190327T050627Z">
        <seg>第三代分布式流处理引擎（2015年）修复了结果对事件到来时间及顺序的依赖问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third parameter is a Properties object that configures the Kafka client that is internally used to connect to and read from Kafka.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T015924Z" creationid="xccui" creationdate="20190709T015924Z">
        <seg>第三个参数是一个Properties对象，它用于配置连接器内部负责连接和从Kafka读取数据的Kafka客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The time characteristic is a property of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T064821Z" creationid="xccui" creationdate="20190619T064821Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The time interval can be set in milliseconds, seconds, minutes, hours, or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042758Z" creationid="xccui" creationdate="20190623T042741Z">
        <seg>时间间隔允许以毫秒、秒、分钟、小时或天数来表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timeout parameters define how long to wait until a connection request fails</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T050649Z" creationid="xccui" creationdate="20190722T050649Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timer will fire when the processing time of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060222Z">
        <seg>当执行机器的处理时间到达给定的时间戳时，该计时器就会触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timer will fire when the watermark is updated to a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062743Z" creationid="xccui" creationdate="20190621T060423Z">
        <seg>当更新后的水位线时间戳大于或等于计时器的时间戳时，它就会触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timestamp argument gives the timestamp of the firing timer and the Collec</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T054908Z" creationid="xccui" creationdate="20190621T054908Z">
        <seg>timestamp参数给出了所触发计时器的时间戳，Collector可用来发出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timestamp associates a record with a specific point</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204839Z" creationid="xccui" creationdate="20190606T204839Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timestamp associates an record with a specific point in time, usually the point in time at which the event that is represented by the record happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035521Z" creationid="xccui" creationdate="20190523T035521Z">
        <seg>时间戳将记录和特定时间点进行关联，这些时间点通常是记录所表示事件的发生时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The traditional approach of a periodic ETL job to move data between storage systems is typically not able to propagate updates fast enough.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T070853Z" creationid="xccui" creationdate="20190314T070853Z">
        <seg>传统方式是通过定期执行ETL作业来转移数据，但这种更新传播方式往往不够迅速。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The traditional architecture that most businesses implement distinguishes two types of data process‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063923Z" creationid="esouser" creationdate="20190603T194352Z">
        <seg>绝大多数企业所实现的传统架构都会将数据处理分为两类：事务型处理和分析型处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transformation logic can be either integrated in the operator or provided by a user-defined function (UDF), as shown in &lt;t4/&gt;Figure 2-4&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T155218Z" creationid="xccui" creationdate="20190405T153643Z">
        <seg>如图2-4所示，具体转换逻辑可以是算子内置的，也可以由用户自定义函数（UDF）提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transformation logic can be either integrated in the operator or provided by a user-defined function, as shown in Figure 2-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060613Z" creationid="xccui" creationdate="20190606T011328Z">
        <seg>如图2-4所示，转换逻辑可以是算子内置的，也可以由用户自定义函数提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The trigger defines (fires) when a window is considered ready for evaluation and when a window is purged and its contents are cleared.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051257Z" creationid="xccui" creationdate="20190625T053029Z">
        <seg>触发器定义了窗口何时准备好执行计算（触发），何时需要清除自身及保存的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The trigger fires at most every second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200209Z" creationid="xccui" creationdate="20190626T200209Z">
        <seg>触发周期不小于一秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The trigger registers a timer when the first event is assigned to a window, 1 second ahead of the current watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195833Z" creationid="xccui" creationdate="20190626T195833Z">
        <seg>它在第一个事件分配给窗口时注册了一个比当前水位线快1秒的计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The truth is, processing time can indeed be useful in some cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180456Z" creationid="xccui" creationdate="20190606T030701Z">
        <seg>事实上，处理时间的确有其特定的适用场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tuple classes are strongly typed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T015557Z" creationid="xccui" creationdate="20190617T015557Z">
        <seg>这些元组类都是强类型的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two tasks of operators C and E are assigned to slots 1.1 and 2.1 and slots 1.2 and 2.2, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144657Z" creationid="xccui" creationdate="20190606T144651Z">
        <seg>其余两个算子C和E的任务会分别放到处理槽1.1、2.1和处理槽1.2、2.2中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two tasks of operators C and E are assigned to slots 1.1 and 2.1 and slots 1.2 and 2.2, respectively&lt;t4/&gt;1&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062232Z" creationid="xccui" creationdate="20190423T164232Z">
        <seg>其余两个算子C和E的任务会分别放到处理槽1.1、2.1和处理槽1.2、2.2中1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two types of pods—master and worker—behave just like the processes of a standalone or Docker deployment we described before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024811Z" creationid="xccui" creationdate="20190720T024811Z">
        <seg>这两类Pod（主进程和工作进程）的工作原理和我们之前介绍的独立集群模式以及Docker部署模式中的进程相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the output stream is the same as the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T052856Z" creationid="xccui" creationdate="20190614T061549Z">
        <seg>因此输出流的类型会永远和输入流保持一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the queryable state is ValueState, which holds values of the type of the input stream—our example (String, Double).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062731Z" creationid="xccui" creationdate="20190706T062731Z">
        <seg>可查询式状态的类型是ValueState，它内部的数据类型和输入流的类型相同（在我们示例中即(String, Double)）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type parameters of the function define its input and output types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T200825Z" creationid="xccui" creationdate="20190716T200825Z">
        <seg>函数的类型参数定义了输入和输出的数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The types of guarantees you have seen so far refer to the state of an application that is managed by the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035037Z" creationid="xccui" creationdate="20190606T035014Z">
        <seg>至今为止你看到的保障类型都仅限于流处理引擎自身的应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The types of guarantees you have seen so far refer to the stream processor component only.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045141Z" creationid="xccui" creationdate="20190416T045141Z">
        <seg>至今为止你看到的保障类型都仅限于流处理引擎组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ubiquitous problem of out-of-order data can also be solved with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160220Z" creationid="xccui" creationdate="20190606T024422Z">
        <seg>时常产生的无序问题也可以借此解决。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unique identifier and maximum parallelism of operators are baked into a savepoint and cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015228Z" creationid="xccui" creationdate="20190703T013858Z">
        <seg>算子的唯一标识和最大并行度会被固化到保存点中，不可更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The updates are written to and distributed by the event log.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T040443Z" creationid="xccui" creationdate="20190605T040204Z">
        <seg>具体而言就是将更新写入事件日志系统，并由它进行分发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The views expressed in this work are those of the authors, and do not represent the publisher’s views.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210738Z" creationid="esouser" creationdate="20190603T210738Z">
        <seg>The views expressed in this work are those of the authors, and do not represent the publisher’s views.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The voting phase of the 2PC protocol starts when the JobManager initiates a checkpoint and injects barriers in the sources of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T205321Z" creationid="xccui" creationdate="20190715T205321Z">
        <seg>2PC协议的投票阶段始于JobManager对某个检查点进行初始化并向应用数据源中注入分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The way operators interact with state has implications on the robustness and perfor‐ mance of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T210942Z" creationid="xccui" creationdate="20190703T210535Z">
        <seg>算子和状态的交互会对应用的鲁棒性及性能产生一定影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window content holds the elements that have been assigned to the window or the result of the incremental aggregation in case the window operator has a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051944Z" creationid="xccui" creationdate="20190626T033304Z">
        <seg>窗口内容包含了分配给窗口的元素，或当窗口算子配置了ReduceFunction或AggregateFunction时增量聚合所得到的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window definition looked a bit different in our first DataStream API example, “Operations on Data Streams” on page 22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T051241Z" creationid="xccui" creationdate="20190623T051241Z">
        <seg>在第22页"数据流上的操作"一节，我们第一个DataStream API示例中定义窗口的方式看上去有些不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window operator API provides a method to explicitly declare that you expect late elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164103Z" creationid="xingcan" creationdate="20190628T164103Z">
        <seg>窗口算子API提供了一个方法，可用来显式声明支持迟到的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window operator deletes a window when the end time of the window, defined by the end timestamp of the window object, is reached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T035514Z" creationid="xccui" creationdate="20190626T035514Z">
        <seg>窗口算子会在窗口结束时间（由窗口对象中的结束时间戳定义）到达时删除窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window operator groups elements based on the returned objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033717Z" creationid="xccui" creationdate="20190626T033717Z">
        <seg>窗口算子会根据返回的对象对元素进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window result will not depend on how fast the stream is read or processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071159Z" creationid="xccui" creationdate="20190619T071135Z">
        <seg>窗口结果不会取决于数据流的读取或处理速度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window’s state is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T001324Z" creationid="xccui" creationdate="20190624T001324Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The worker containers are based on the same</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T143422Z" creationid="xccui" creationdate="20190720T030029Z">
        <seg>其容器所需的Flink Docker镜像和主进程Deployment的完全相同，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The worker deployment looks almost identical to the master deployment with a few differences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025926Z" creationid="xccui" creationdate="20190720T025926Z">
        <seg>工作进程的Deployment和主进程的Deployment几乎一模一样，二者只有几点不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The worker process to which a task is assigned, the tasks that are colocated with a task, and the number of tasks that are assigned to a worker process can have a significant impact on an application’s performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T005800Z" creationid="xccui" creationdate="20190730T160953Z">
        <seg>任务分配的目标工作进程，任务的共存情况以及工作进程中的任务数都会对应用性能带来显著影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The yellow slot-sharing group requires two slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T020336Z" creationid="xccui" creationdate="20190731T020336Z">
        <seg>yellow处理槽共享组只需2个处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The “Extract hashtags" and “Count" operators have two parallel operator tasks, each performing a computation on a subset of the input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021422Z" creationid="xccui" creationdate="20190401T003521Z">
        <seg>"Extract hashtags"和"Count"算子都包含两个并行算子任务，每个任务负责计算一部分输入数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The&lt;t8/&gt; &lt;t9/&gt;behavior of windows is defined by a set of policies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T045355Z" creationid="xccui" creationdate="20190406T045224Z">
        <seg>窗口的行为是由一组策略定义的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then suddenly the train enters a tunnel and her phone gets dis‐ connected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154622Z" creationid="xccui" creationdate="20190606T015033Z">
        <seg>突然，地铁开进隧道，手机断网了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then suddenly, the train enters a tunnel and her phone gets dis&lt;t2/&gt;‐&lt;t3/&gt; connected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151228Z" creationid="xccui" creationdate="20190411T150738Z">
        <seg>突然，地铁开进隧道，手机断网了，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then we introduced the idea of stateful stream processing and explained how it addresses a wide spectrum of use cases, rang‐ ing from business applications and microservices to ETL and data analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T125220Z" creationid="xccui" creationdate="20190605T125200Z">
        <seg>随后我们介绍了状态化流处理的基本思想，解释了它如何处理从业务应用和微服务到ETL和数据分析的多种用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, can you somehow get both low latency and high throughput or is this a hope&lt;t0/&gt;‐&lt;t1/&gt; less endeavour?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210637Z" creationid="xccui" creationdate="20190402T210637Z">
        <seg>既然这样，可以通过某种方式同时获得低延迟和高吞吐吗？还是说根本不切实际？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, we use the keyBy() transformation to parti‐ tion the sensor readings by their sensor ID.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053453Z" creationid="xccui" creationdate="20190612T053453Z">
        <seg>然后我们使用keyBy()转换，将传感器读数按照传感器ID进行分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, we will cover the process functions, low-level transformations that provide access to timestamps and watermarks and can register timers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T012139Z" creationid="xccui" creationdate="20190619T052920Z">
        <seg>随后我们会介绍处理函数，它对应的底层转换可以访问时间戳和水位线，还能注册计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a few more notable configuration options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T032350Z" creationid="xccui" creationdate="20190709T032350Z">
        <seg>还有一些我们认为值得关注的配置选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a few parameters in the ./conf/flink- conf.yaml configuration file you can use to control Flink’s recovery behavior on YARN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T232411Z" creationid="xccui" creationdate="20190718T232411Z">
        <seg>你可以通过./conf/flink-conf.yaml配置文件来控制Flink在YARN上的故障恢复行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a few things to consider when running a Flink application with a Kafka sink that operates in exactly-once mode, and it helps to roughly understand how Kafka processes transactions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T211236Z" creationid="xccui" creationdate="20190709T211236Z">
        <seg>如果你为Flink应用配置了在精确一次模式下工作的Kafka数据汇，则要考虑一些问题，它们将帮助你对Kafka的事务处理有一个大概的认识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also applications that do not emit results but keep them internally to serve them via Flink’s queryable state feature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051625Z" creationid="xccui" creationdate="20190612T054456Z">
        <seg>还有一些应用不会发出结果，而是将它们保存在内部，利用Flink的可查询式状态（queryable state）功能对外提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also constructor variants to enable or disable asynchronous checkpointing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022823Z" creationid="xccui" creationdate="20190801T022823Z">
        <seg>其他一些构造函数可用来选择是否开启异步检查点（默认开启）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are different types of transformations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051051Z" creationid="xccui" creationdate="20190612T052303Z">
        <seg>转换的类型多种多样：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are different ways to specify keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051541Z" creationid="xccui" creationdate="20190614T051506Z">
        <seg>指定键值的方式多种多样，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many popular libraries out there, such as Apache Commons or Google Guava, for various use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041422Z" creationid="xccui" creationdate="20190619T034840Z">
        <seg>很多流行库（例如：Apache Commons或Google Guava）会用于各种不同的用例场景中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are rich versions of all the DataStream API transformation functions, and you can use them in the same places you can use a regular function or lambda function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041112Z" creationid="xccui" creationdate="20190618T060440Z">
        <seg>DataStream API中的所有转换函数都有对应的富函数，它们允许的使用位置和普通函数以及Lambda函数相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several aspects that affect the behavior of an appli‐ cation such as the choice of the state backend that locally maintains the state and performs checkpoints, the configuration of the checkpointing algorithm, and the size of the application’s state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T025041Z" creationid="xccui" creationdate="20190703T210934Z">
        <seg>这些影响的原因是多方面的，例如：对于用来维护本地状态和生成检查点的状态后端的选择，配置的检查点生成算法以及应用状态大小等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several event log sys&lt;t0/&gt;‐&lt;t1/&gt; tems available as open source software, Apache Kafka being the most popular, or as integrated services offered by cloud computing providers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T060116Z" creationid="xccui" creationdate="20190305T055922Z">
        <seg>有不少事件日志系统会以开源软件或云计算集成服务的形式出现，其中最流行的当属Apache Kafka。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several event log sys‐ tems available as open source software, Apache Kafka being the most popular, or as integrated services offered by cloud computing providers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T160458Z" creationid="esouser" creationdate="20190603T211119Z">
        <seg>有不少事件日志系统都是开源软件，其中最流行的当属Apache Kafka；也有部分系统会以云计算提供商集成服务的形式提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are some ideas to support this case by offering an offline tool to convert savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T045447Z" creationid="xccui" creationdate="20190705T045352Z">
        <seg>有一些思路是通过提供一个用来转换保存点的离线工具来支持这种情况，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three ways to provide Flink with Hadoop dependencies:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T010251Z" creationid="xccui" creationdate="20190722T010251Z">
        <seg>为Flink添加Hadoop依赖的方式有三种：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two aspects of triggers that require special care: cleaning up state and merging triggers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193859Z" creationid="xccui" creationdate="20190626T193859Z">
        <seg>但有两类触发器需要格外小心：状态清理触发器及合并触发器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two failure cases that can result in records being emitted</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065037Z" creationid="xccui" creationdate="20190715T065037Z">
        <seg>有两种故障会导致记录发出多次：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two options for externalized checkpoints:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T205338Z" creationid="xccui" creationdate="20190731T205338Z">
        <seg>外化检查点有两个选项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two techniques that sink connectors can apply in dif‐ ferent situations to achieve exactly-once guarantees: idempotent writes and transactional writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T072535Z" creationid="xccui" creationdate="20190708T063145Z">
        <seg>根据情况不同，这些连接器可以使用两种技术来实现精确一次保障：幂等性写（idempotent write）以及事务性写（transactional write）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two types of functions that can be applied on a window:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T210034Z" creationid="xccui" creationdate="20190623T210034Z">
        <seg>可用于窗口的函数类型有两种：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two types of state, operator state and keyed state, that are accessible from different scopes and discussed in the following sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060341Z" creationid="xccui" creationdate="20190607T023422Z">
        <seg>根据作用域的不同，状态可以分为两类：算子状态（operator state）和键值分区状态（keyed state），我们将在接下来的几节介绍它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two ways state can be modified:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043947Z" creationid="xccui" creationdate="20190705T043919Z">
        <seg>我们有两种办法可以对状态进行修改：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two ways to ensure all dependencies are available to an application when it is executed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041104Z" creationid="xccui" creationdate="20190619T041054Z">
        <seg>有两种方法可以保证在执行应用时可以同时使用所有依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two ways to provide TypeInformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061719Z" creationid="xccui" creationdate="20190617T061659Z">
        <seg>其方法有二。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There exists a vibrant community around Flink and we encourage you to connect with other users, start contributing, or find out what companies are building with Flink to help inspire your own work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T052109Z" creationid="xccui" creationdate="20190807T052109Z">
        <seg>围绕Flink有一个充满活力的社区，我们鼓励你接触一下其他用户，开始为社区做一些贡献或从别的Flink公司用户那里寻求一些启发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a service that exposes the ports of the master pod to the worker pods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024632Z" creationid="xccui" creationdate="20190720T024529Z">
        <seg>此外还有一个Service，用于将主进程Pod的端口暴露给工作进程所在Pod。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also the option to delegate the partitioning to Kafka based on the message key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T040314Z" creationid="xccui" creationdate="20190710T035955Z">
        <seg>此外还可以选择让Kafka根据消息的键值来完成分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There, we defined an event-time tumbling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T025825Z" creationid="xccui" creationdate="20190623T051346Z">
        <seg>那里，我们使用timeWindow(size)方法定义了一个事件时间滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, a common technique to continuously ingest files is to write them in a temporary directory and atomically move them to the monitored directory once they are finalized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T200640Z" creationid="xccui" creationdate="20190710T200640Z">
        <seg>因此持续读取文件的常用技术是把它们写入一个临时目录，并在最后以原子操作的方式将它们移动到监视目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, a function can only access the state that belongs to the record it currently processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T063851Z" creationid="xccui" creationdate="20190630T063851Z">
        <seg>这样，函数每次只能访问属于当前处理记录的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, a stand‐ alone Flink cluster requires standby Dispatcher and TaskManager processes that can take over the work of failed processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T025430Z" creationid="xccui" creationdate="20190721T025348Z">
        <seg>因此，在独立集群模式下，Flink需要后备Dispatcher和TaskManager进程，用来接管故障进程的工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, all configuration values are preserved after the object is deserialized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054924Z" creationid="xccui" creationdate="20190618T054924Z">
        <seg>这样在对象反序列化后，全部配置值都可以保留。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, filesystems are commonly used to “connect” streaming and batch applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T183725Z" creationid="xccui" creationdate="20190710T183725Z">
        <seg>因此，我们通常会用它来"连接"流式应用和批处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, it does not work with the Windows command line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T165737Z" creationid="xccui" creationdate="20190726T021735Z">
        <seg>因此无法在Windows命令行下运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, it is important that application state can be migrated to a new version of the application or be redistributed to more or fewer operator tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T212646Z" creationid="xccui" creationdate="20190702T212646Z">
        <seg>所以说，能够将应用状态迁移到一个新版本的应用或重新分配到不同数量的算子任务上就变得十分重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, it is not necessary to define data types to hold keys and values, which avoids a lot of boilerplate code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040116Z" creationid="xccui" creationdate="20190617T063903Z">
        <seg>因此，没有必要为键和值再单独定义数据类型，这样可以省去大量样板代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, many applications must be able to automatically recover from failure of any process involved in the execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T042936Z" creationid="xccui" creationdate="20190720T042936Z">
        <seg>因此，很多应用必须能够从执行过程所涉及的任意应用故障中自动恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, resettable sources and Flink’s recovery mechanism are not sufficient to provide end-to-end exactly-once guarantees even though the application state is exactly-once consistent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T062430Z" creationid="xccui" creationdate="20190708T062430Z">
        <seg>因此，可重置的数据源以及Flink的恢复机制虽然可以为应用状态提供精确一次的一致性保障，但无法提供端到端的精确一次保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, such changes are not safepoint compatible even though they look unobtrusive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T034629Z" creationid="xccui" creationdate="20190705T041619Z">
        <seg>因此，这些看上去不惹眼的改动其实并非是保存点兼容的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the asyncInvoke() method should quickly return by starting an asynchro‐ nous request and handling the result with a callback that forwards the result to ResultFuture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T213320Z" creationid="xccui" creationdate="20190716T213320Z">
        <seg>因此asyncInvoke()方法需要在发出异步请求后立即返回，并处理回调函数将结果发给ResultFuture。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the operator emits a result that is incomplete or inaccurate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T160353Z" creationid="xingcan" creationdate="20190628T160353Z">
        <seg>这表示算子之前发出的结果可能是不完整或不准确的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the trigger fires, at most, every second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200010Z" creationid="xccui" creationdate="20190626T200010Z">
        <seg>因此该触发器最多每秒触发一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, we strongly recommend manually assign‐ ing unique identifiers to operators and not relying on Flink’s default assignment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T030745Z" creationid="xccui" creationdate="20190610T030737Z">
        <seg>所以我们强烈建议手工指定算子标识，而不要依赖Flink的默认分配机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are the most widely used connectors and they also represent important types of source and sink systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T201320Z" creationid="xccui" creationdate="20190708T200928Z">
        <seg>这些连接器的应用最为广泛，同时上面所列出的也代表了几类重要的数据源和数据汇系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These chapters guide you through setting up a development environment, cover the basics of the DataStream API, and go into the details of Flink’s time seman&lt;t2/&gt;‐&lt;t3/&gt; tics and window operators, its connectors to external systems, and the details of Flink’s fault-tolerant operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191557Z" creationid="xccui" creationdate="20190225T165712Z">
        <seg>这些章节将指导你完成开发环境设置，学习DataStream API的基础知识，深入了解Flink的时间语义、窗口算子、外部系统连接器以及Flink容错性operator state的细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These components are a JobManager, a ResourceManager, a TaskManager, and a Dispatcher.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T055541Z" creationid="xccui" creationdate="20190418T033541Z">
        <seg>这些组件是：JobManager、ResourceManager、TaskManager和Dispatcher。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These components need to be carefully orchestrated and especially error handling and failure recovery can become challenging.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T063117Z" creationid="xccui" creationdate="20190317T063117Z">
        <seg>这些组件需要仔细地协调，尤其是错误处理和故障恢复可能颇具挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These fea‐ tures are disabled by default and can be enabled by adding the parameter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T042612Z" creationid="xccui" creationdate="20190709T042437Z">
        <seg>该功能默认情况下是关闭的，你可以通过在Properties对象中为配置属性flink.partition-discovery.interval-millis设置一个非负的值来启用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions are typically very space-efficient and eventually emit the aggregated value as a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T032157Z" creationid="xccui" creationdate="20190623T210933Z">
        <seg>此类函数函数通常会十分节省空间且最终会将聚合值作为单个结果发送出去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include more fine-grained statistics about your tasks, such as buffer usage, watermarks, and input/output rates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T144528Z" creationid="xingcan" creationdate="20190802T144528Z">
        <seg>这些指标包含了有关任务细粒度的统计信息，例如缓冲区的使用情况、水位线以及输入输出速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These metrics are assembled into reports that help the management to assess the business’s overall health.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T025100Z" creationid="esouser" creationdate="20190603T203141Z">
        <seg>将这些指标整合成报告，能够帮助管理层评估企业整体健康状况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These metrics are assembled into reports that help to assess the situation of the business.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T193934Z" creationid="xccui" creationdate="20190228T193457Z">
        <seg>在报告中汇总这些指标，有助于评估业务状况；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operations consume one event after the other and apply some trans&lt;t2/&gt;‐&lt;t3/&gt; formation to the event data, producing a new output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T034637Z" creationid="xccui" creationdate="20190405T153227Z">
        <seg>这些操作挨个读取事件，对其应用某些转换并产生一条新的输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operations consume one event after the other and apply some trans‐ formation to the event data, producing a new output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011319Z" creationid="xccui" creationdate="20190606T011303Z">
        <seg>这些操作逐个读取事件，对其应用某些转换并产生一条新的输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operations define how events are assigned to tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064903Z" creationid="xccui" creationdate="20190615T064903Z">
        <seg>这些操作定义了如何将事件分配给不同任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators can be combined into dataflow processing graphs to implement the logic of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054922Z" creationid="xccui" creationdate="20190402T212738Z">
        <seg>这些算子可以组合生成Dataflow处理图，从而实现流式应用所需的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These parameters are a unique operator identifier and the maximum parallelism (for opera‐ tors with keyed state).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015253Z" creationid="xccui" creationdate="20190703T012359Z">
        <seg>这两个参数是算子唯一标识和最大并行度（只针对具有键值分区状态的算子）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These systems are typically designed with separate tiers for data processing (the application itself) and data storage (a transactional database system) as shown in Figure 1-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T071853Z" creationid="esouser" creationdate="20190603T195128Z">
        <seg>如图1-1所示，这些应用系统通常都会设置独立的数据处理层（应用程序本身）和数据存储层（事务型数据库系统）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These systems had rather low-level APIs and did not provide built-in support for accurate and con&lt;t4/&gt;‐&lt;t5/&gt; sistent results of streaming applications because the results depended on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T042817Z" creationid="xccui" creationdate="20190322T042044Z">
        <seg>它们的API非常底层，而且并未针对流式应用结果的准确性和一致性提供内置保障。其结果完全取决于事件到达的时间和顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These systems had rather low-level APIs and did not provide built-in support for accurate and consistent results of streaming applications because the results depended on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051546Z" creationid="xccui" creationdate="20190605T051546Z">
        <seg>它们的API非常底层，而且并未针对流式应用结果的准确性和一致性提供内置保障。其结果完全取决于事件到达的时间和顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These tasks can be of the same operator (data parallelism), a different operator (task parallelism), or even from a different application (job parallelism).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041312Z" creationid="xccui" creationdate="20190423T041251Z">
        <seg>这些任务可以属于同一个算子（数据并行），也可以是不同算子（任务并行），甚至还可以来自不同的应用（作业并行）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These tasks can be sub‐ tasks of the same operator (data parallelism), a different operator (task parallelism), or even from a different application (job parallelism).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144322Z" creationid="xccui" creationdate="20190606T144322Z">
        <seg>这些任务可以属于同一个算子（数据并行），也可以是不同算子（任务并行），甚至还可以来自不同的应用（作业并行）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These timers are maintained by the window operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T034804Z" creationid="xccui" creationdate="20190626T034804Z">
        <seg>这些计时器由窗口算子负责维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two interfaces extend the Time stampAssigner interface provided by the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055217Z" creationid="xccui" creationdate="20190620T044932Z">
        <seg>这两个接口都继承自DataStream API所提供的TimestampAssigner接口，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They also support</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T041632Z" creationid="xccui" creationdate="20190618T041617Z">
        <seg>同时还支持选择嵌套字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are called on a stream of elements and produce a new stream of timestamped elements and water‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055053Z" creationid="xccui" creationdate="20190620T033231Z">
        <seg>它们会作用在数据流的元素上面，生成一条带有时间戳和水位线的新数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are discussed further in “Declaring Keyed State at RuntimeCon‐ text” on page 154.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T223752Z">
        <seg>更多相关内容请见154页"在RuntimeContext中声明键值分区状态"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are related to record timestamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T051937Z" creationid="xccui" creationdate="20190606T205410Z">
        <seg>和记录的时间戳存在联系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can also modify the structure of the dataflow graph by either splitting a stream into multi&lt;t0/&gt;‐&lt;t1/&gt; ple streams or merging streams into a single flow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T160048Z" creationid="xccui" creationdate="20190405T160023Z">
        <seg>也可以通过单流分割或合并多条流来改变dataflow图的结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can also modify the structure of the dataflow graph by either splitting a stream into multi‐ ple streams or merging streams into a single flow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060929Z" creationid="xccui" creationdate="20190606T011745Z">
        <seg>也可以通过单流分割或合并多条流来改变Dataflow图的结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can only be applied if the window collects all added events and does not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203833Z" creationid="xccui" creationdate="20190627T203825Z">
        <seg>该操作的应用前提是窗口能够取得全部已加入的事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They communicate via event logs instead of REST calls and hold application data as local state instead of writing it to and reading it from an external data store, such as a transactional database or key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152406Z" creationid="xccui" creationdate="20190307T152335Z">
        <seg>微服务通过REST调用进行通信，利用关系型数据库或键值存储等外部系统存储数据；而事件驱动型应用利用事件日志进行通信，而其数据会以本地状态形式存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They communicate via event logs instead of REST calls and hold application data as local state instead of writing it to and reading it from an external datastore, such as a relational database or key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T073910Z" creationid="esouser" creationdate="20190603T213740Z">
        <seg>微服务通过REST调用进行通信，利用事务型数据库或键值存储等外部系统存储数据；而事件驱动型应用利用事件日志进行通信，其数据则会以本地状态形式存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They consume data from inputs, perform a computation on them, and produce data to outputs for further processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T200240Z" creationid="xccui" creationdate="20190331T215135Z">
        <seg>它们从输入获取数据，对其进行计算，然后产生数据并发往输出以供后续处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They control how long to wait for data to arrive before performing a computation, such as finalizing a window computation and emitting the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T060607Z" creationid="xccui" creationdate="20190621T030937Z">
        <seg>它们控制着在执行某些计算（例如完成窗口计算并发出结果）前需要等待数据到达的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They enable transfor‐ mations such as aggregations on bounded intervals of an unbounded stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T033021Z" creationid="xccui" creationdate="20190622T033021Z">
        <seg>它们可以在无限数据流上基于有界区间实现聚合等转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They follow the UNIX philoso&lt;t0/&gt;‐&lt;t1/&gt; phy of doing a single thing and doing it well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T171125Z" creationid="xccui" creationdate="20190227T233311Z">
        <seg>每个应用都遵循UNIX设计哲学：专注做好一件事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They follow the UNIX philosophy of doing a single thing and doing it well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200630Z" creationid="esouser" creationdate="20190603T200630Z">
        <seg>每个应用都遵循UNIX设计哲学：专注做好一件事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They must be monotonically increasing to ensure the event-time clocks of tasks are progressing and not going backward.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T065400Z" creationid="xccui" creationdate="20190606T205354Z">
        <seg>必须单调递增。这是为了确保任务中的事件时间时钟正确前进，不会倒退。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They need to be serialized and deserialized to ship them over the network or write them into or read them from state backends, checkpoints, and savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T063508Z" creationid="xccui" creationdate="20190616T063508Z">
        <seg>出于网络传输，读写状态、检查点和保存点等目的，需要对它们进行序列化和反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They use a state backend–specific storage format and do not support rescaling.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T034140Z" creationid="xccui" creationdate="20190731T205713Z">
        <seg>它们会使用特定于某个状态后端的存储格式，且不支持扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of user interac&lt;t0/&gt;‐&lt;t1/&gt; tions on websites or in mobile apps, placements of orders, server logs, or sensor measurements; all of these data are streams of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T035558Z" creationid="xccui" creationdate="20190301T035451Z">
        <seg>考虑一下，无论是网站或移动应用中的用户交互还是订单下达，无论是服务器日志还是传感器测量结果，这些数据本质上都是事件流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of user interac‐ tions on websites or in mobile apps, placements of orders, server logs, or sensor measurements; all of these are streams of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T160038Z" creationid="esouser" creationdate="20190603T204811Z">
        <seg>请考虑一下，无论是网站或移动应用中的用户交互或订单下达，还是服务器日志或传感器测量结果，这些数据本质上都是事件流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Third, the Lambda architecture is hard to setup and maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T031328Z" creationid="xccui" creationdate="20190327T030936Z">
        <seg>最后，Lambda架构很难配置和维护，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Third, the lambda architecture is hard to set up and maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053103Z" creationid="xccui" creationdate="20190605T053047Z">
        <seg>最后，Lambda架构很难配置和维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T040320Z" creationid="xccui" creationdate="20190401T032416Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to easily scale the application by adjusting its parallelism via the submission client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T054115Z" creationid="xccui" creationdate="20190616T054115Z">
        <seg>这样就可以通过提交客户端来轻易调整并行度，从而实现应用的扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to implement operators that are dynam‐ ically configured via a data stream (e.g., to add or remove filtering rules or update machine-learning models).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T063856Z" creationid="xccui" creationdate="20190615T053341Z">
        <seg>你可以利用广播状态实现一个通过数据流进行动态配置的算子（例如：添加、删除规则或者更新机器学习模型）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to migrate an application to a newer Flink version or to a different cluster or data- center.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212841Z" creationid="xccui" creationdate="20190609T212841Z">
        <seg>这允许你把应用迁移到一个新的Flink版本，或是一个不同的集群或数据中心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also means the effective checkpointing interval is at least 30 seconds and there is at most one checkpoint happening at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T202637Z" creationid="xccui" creationdate="20190731T202637Z">
        <seg>而这也意味着有效检查点生成间隔至少要为30秒，且同时最多只可以生成一个检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This application design can cause problems when applications need to evolve or scale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T053337Z" creationid="esouser" creationdate="20190603T195919Z">
        <seg>该设计在应用需要更新或扩缩容时，容易导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach is useful if none of the provided builds work for your setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025725Z" creationid="xccui" creationdate="20190722T025725Z">
        <seg>本方法适用于上面所提供的构建方式都无法满足你所需设置的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect depends on the APIs of the stream processor, what kinds of state primitives it provides, and on the quality of its support for event-time processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014629Z" creationid="xccui" creationdate="20190314T062102Z">
        <seg>具体一些，这种能力依赖于流处理引擎的API、提供的状态原语以及对事件时间处理的支持程度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect depends on the APIs of the stream processor, what kinds of state primitives it provides, and the quality of its support for event-time processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T074509Z" creationid="xccui" creationdate="20190604T053132Z">
        <seg>这方面要取决于流处理引擎的API、提供的状态原语以及对事件时间处理的支持程度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior can cause problems if the event times of the individual input streams of an application are not aligned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054258Z" creationid="xccui" creationdate="20190607T031013Z">
        <seg>如果不同输入流的事件时间没有对齐，那么该行为就会导致一些问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior guarantees end-to-end exactly-once because in case of a failure, the application is reset to the last checkpoint and no results have been emitted to the sink system after that checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T073220Z" creationid="xccui" creationdate="20190708T073220Z">
        <seg>该行为可以提供端到端的精确一次保障，因为在发生故障后，应用会被重置到上一个检查点，而接收系统不会收到任何在该检查点之后生成的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior yields nondeterministic results and is usually</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T062739Z" creationid="xccui" creationdate="20190615T045745Z">
        <seg>该行为会产生不确定的结果，而这往往并不是我们希望看到的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book couldn’t have been possible without the help and support of several amaz‐ ing people.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T160100Z" creationid="xccui" creationdate="20190605T131119Z">
        <seg>本书的付梓离不开众多能人志士的帮助和支持，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book covers the DataStream API and ProcessFunctions which provide primitives for common stream processing operations, such as windowing and asynchronous operations, and interfaces to precisely control state and time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T044508Z" creationid="xccui" creationdate="20190328T043432Z">
        <seg>本书涵盖了DataStream API和ProcessFunction的相关内容，它们提供了通用的流处理操作原语（如：窗口划分、异步操作）以及精确控制时间和状态的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book covers the DataStream API and process functions, which provide primitives for common stream processing operations, such as windowing and asynchronous operations, and interfaces to precisely control state and time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195629Z" creationid="xccui" creationdate="20190605T060812Z">
        <seg>本书涵盖了DataStream API和处理函数（process function）的相关内容，它们提供了通用的流处理操作原语（如窗口划分和异步操作）以及精确控制时间和状态的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book is here to help you get your job done.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210815Z" creationid="esouser" creationdate="20190603T210815Z">
        <seg>This book is here to help you get your job done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book summarizes knowledge obtained through years of design, development, and testing performed by the Apache Flink community at large.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T050109Z" creationid="xccui" creationdate="20190605T131400Z">
        <seg>书中总结了Apache Flink社区多年来在设计、开发、测试等方面积累的知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book will teach you everything to know about stream processing with Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T042801Z" creationid="xccui" creationdate="20190225T042801Z">
        <seg>本书将教给你用Apache Flink进行流处理的一切知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book will teach you everything you need to know about stream processing with Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031208Z" creationid="esouser" creationdate="20190603T152621Z">
        <seg>本书将教给你基于Apache Flink进行流处理的一切知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be a problem if you</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063507Z" creationid="xccui" creationdate="20190701T063507Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be a single topic, a list of topics, or a regular expression that matches all topics to read from.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T212847Z" creationid="xccui" creationdate="20190708T212614Z">
        <seg>它可以是单个主题，一个主题列表或是某个匹配所有目标主题的正则表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be done by registering timers for a point of time in the future.4 Similar to state, timers are registered in the context of the currently active key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T033740Z" creationid="xccui" creationdate="20190704T202730Z">
        <seg>该工作可以通过注册针对未来某个时间点的计时器来完成。4 和状态类似，计时器也会注册在当前活动键值的上下文中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be easily handled by including the &lt;job_id&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T044514Z" creationid="xccui" creationdate="20190804T044514Z">
        <seg>为此你可以将&lt;job_id&gt;加入到标识中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be ensured by running one or more standby workers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T162301Z" creationid="xccui" creationdate="20190717T162301Z">
        <seg>我们可以通过运行一个或多个后备工作进程来对此进行保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be explained by looking at the steps of a naive algorithm that takes a consistent checkpoint of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T063502Z" creationid="xccui" creationdate="20190608T223205Z">
        <seg>我们可以通过一个朴素算法对应用建立一致性检查点的步骤进行解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be very problematic, because it may prevent the whole application from advancing its watermarks and hence lead to a stalling application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T042614Z" creationid="xccui" creationdate="20190713T042614Z">
        <seg>该行为可能会导致严重问题，因为它有可能会阻碍全局水位线的前进，继而导致应用停止工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This case is shown in Figure 6-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053502Z" creationid="xccui" creationdate="20190625T053502Z">
        <seg>该情况如图6-4所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter focuses on the implementation of stateful user-defined functions and discusses the performance and robustness of stateful applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T213627Z" creationid="xccui" creationdate="20190630T033720Z">
        <seg>本章重点介绍如何实现状态化用户自定义函数，并讨论状态化应用的性能及健壮性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter introduces the basics of Flink’s DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014914Z" creationid="xccui" creationdate="20190612T014914Z">
        <seg>本章主要介绍Flink DataStream API的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter is still rather independent of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T053557Z" creationid="xccui" creationdate="20190329T053557Z">
        <seg>本章节内容仍然独立于Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter provides relevant background information to successfully implement and operate advanced streaming applications with Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T043453Z" creationid="xccui" creationdate="20190416T054356Z">
        <seg>本章会涉及使用Apache Flink实现并操纵高级流式应用的相关背景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This check is necessary to ensure event time continuously increases; otherwise no watermark is produced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055513Z" creationid="xccui" creationdate="20190620T050454Z">
        <seg>这项检查对于保证事件时间持续递增十分必要，一旦检查失败将不会生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This checkpointing and recovery mechanism can provide exactly-once consistency for application state, given that all operators checkpoint and restore all of their states</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T043911Z" creationid="xccui" creationdate="20190609T040709Z">
        <seg>如果所有算子都将它们全部的状态写入检查点并从中恢复，并且所有输入流的消费位置都能重置到检查点生成那一刻，那么该检查点和恢复机制就能为整个应用的状态提供精确一次的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class is provided by the flink- queryable-state-client-java dependency, which you can add to your project as</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T124823Z" creationid="xccui" creationdate="20190706T124823Z">
        <seg>这个类由flink-queryable-state-client-java依赖提供，你可以像下面这样把它添加到你的项目里：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command submits the application to the master that runs on host myMasterHost</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T032318Z" creationid="xccui" creationdate="20190726T032318Z">
        <seg>上述命令会将应用提交到myMasterHost主机、9876端口上的主进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This conversion is based on the data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T050222Z" creationid="xccui" creationdate="20190705T050131Z">
        <seg>其装换过程基于状态的数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This deployment mode is common for microservice architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041101Z" creationid="xccui" creationdate="20190423T041101Z">
        <seg>该部署模式常用于微服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This deployment mode is common for microservices architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T063821Z" creationid="xccui" creationdate="20190606T144242Z">
        <seg>后者常用于微服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This deployment specifies that a single master container should be run (replicas: 1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025146Z" creationid="xccui" creationdate="20190720T025146Z">
        <seg>这个Deployment指定了我们需要运行一个主进程容器（replicas: 1）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This design can cause problems when applications need to evolve or scale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T163248Z" creationid="xccui" creationdate="20190226T163132Z">
        <seg>该设计模式在应用需要升级或扩容时，容易导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This differs from batch processing where user-defined functions, such as GroupReduceFunction, are called when all data to be processed has been collected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T034350Z" creationid="xccui" creationdate="20190630T034350Z">
        <seg>这和批处理情况不同。在批处理中，只有在全部所需处理的数据都收集完后才会调用用户自定义函数（如GroupReduceFunction）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This element signifies a general note.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210810Z" creationid="esouser" creationdate="20190603T210810Z">
        <seg>This element signifies a general note.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This element signifies a tip or suggestion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210809Z" creationid="esouser" creationdate="20190603T210809Z">
        <seg>This element signifies a tip or suggestion.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This element signifies a warning or caution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210811Z" creationid="esouser" creationdate="20190603T210811Z">
        <seg>This element signifies a warning or caution.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures first that the state is saved and persistent and second that it</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T155019Z" creationid="xingcan" creationdate="20190801T155019Z">
        <seg>这不但可以确保状态存储的持久化，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example shows a flatMap transformation commonly found in data processing tutorials.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060453Z" creationid="xccui" creationdate="20190613T061551Z">
        <seg>下方例子展示了数据处理教程中一个常见的flagMap转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This fea&lt;t0/&gt;‐&lt;t1/&gt; ture comes in handy when developing and testing Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T053736Z" creationid="xccui" creationdate="20190328T053645Z">
        <seg>这在开发和调试Flink应用的时候非常好用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature comes in handy when developing and testing Flink appli‐ cations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122111Z" creationid="xccui" creationdate="20190605T122111Z">
        <seg>这在开发和调试Flink应用的时候非常好用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function will be discussed in “Assigning Timestamps and Generating Watermarks” on page 111.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055317Z" creationid="xccui" creationdate="20190607T035526Z">
        <seg>这个函数会在111页"分配时间戳和生成水位线"中介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives the possibility to release cluster resources for higher-priority applications or when input data is not continuously produced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213217Z" creationid="xccui" creationdate="20190609T213202Z">
        <seg>这样可以为更高优先级的应用腾出集群资源，或者在输入数据不连续的情况下及时释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens when an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T064346Z" creationid="xccui" creationdate="20190702T064346Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes adding of stateful or stateless operators to the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035850Z" creationid="xccui" creationdate="20190705T035711Z">
        <seg>包括向应用中添加状态化或非状态化算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes handling of very large states, possibly exceeding memory, and ensuring that no state is lost in case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060207Z" creationid="xccui" creationdate="20190607T055446Z">
        <seg>这其中包括如何处理数量巨大、可能超出内存的状态，如何保证发生故障时状态不会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes modifica‐ tions due to appending writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T053807Z" creationid="xccui" creationdate="20190814T053807Z">
        <seg>此处的改动包括由追加写所引起的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes window operators and time-based joins as well as process functions that provide the most flexibility when dealing with time in streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T152845Z" creationid="esouser" creationdate="20190603T161606Z">
        <seg>其中包含窗口算子、基于时间的Join以及一系列处理函数，它们让流式应用中的时间处理变得十分灵活。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This information is requested from the Job‐ Manager that manages the key group assignment, and is cached once received.6 The client proxy retrieves the state from the state server of the respective Task‐ Manager and serves the result to the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T023827Z" creationid="xccui" creationdate="20190706T023827Z">
        <seg>该信息可以从负责键值组分配的JobManager上面获得，代理在一次请求过后就会将它们缓存下来。6 客户端代理从各自TaskManager的状态服务器上取得状态，然后把结果返给客户端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This information needs to be recovered in case of a master failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T043419Z" creationid="xccui" creationdate="20190720T043419Z">
        <seg>这些信息都需要在主进程发生故障时进行恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This information will come in handy when designing advanced stream‐ ing applications, setting up and configuring clusters, and operating streaming appli‐ cations as well as reasoning about their performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T071548Z" creationid="xccui" creationdate="20190610T031959Z">
        <seg>在设计高级流式应用，搭建和配置集群以及操纵流式应用并推断其性能时，这些内容都将派上用场。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interface provides the notifyCheckpointComplete(long chkpntId) method, which might be called when the JobManager registers a checkpoint as completed—when all operators successfully</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T193214Z" creationid="xccui" creationdate="20190702T202645Z">
        <seg>该接口提供的notifyCheckpointComplete(long chkpntId)方法，会在JobManager将检查点注册为已完成时（即所有算子都成功将其状态复制到远程存储后）被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a common strat‐ egy to produce (incomplete) low-latency results despite using a conservative water‐ marking strategy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184214Z" creationid="xccui" creationdate="20190626T183949Z">
        <seg>这是一个在保守的水位线策略下依然可以产生（非完整的）低延迟结果的常用方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a safety mechanism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T051548Z" creationid="xccui" creationdate="20190702T051548Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also the case if the unique identifier of an operator or the name of a state was changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043141Z" creationid="xccui" creationdate="20190705T043141Z">
        <seg>如果算子的唯一标识或状态名称发生了改变，也会出现这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also the reason it is not a good idea to override existing timestamps and watermarks in the middle of a streaming application, although this is possible with user-defined functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T041209Z" creationid="xccui" creationdate="20190607T041148Z">
        <seg>这也是为什么不建议在流式应用中途覆盖已有的时间戳和水位线（虽然这可以通过用户自定义函数实现）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also true for processing-time timers that are persisted in a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T065436Z">
        <seg>存入保存点中的处理时间计时器也是如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is batch processing regardless of whether the architecture is based on a data warehouse or components of the Hadoop ecosystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T035223Z" creationid="xccui" creationdate="20190605T043413Z">
        <seg>无论它们的架构是基于数据仓库还是Hadoop生态系统组件，这都属于批处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is done by closing the current in- progress file and discarding the invalid part at the file’s end, for example, by using the filesystem’s truncate operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T192713Z" creationid="xccui" creationdate="20190711T192146Z">
        <seg>该工作可以通过关闭当前进行写入的文件，并丢弃文件末尾的无效部分（例如通过文件系统的截断操作）来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is done by copying it from the ./opt folder of your installation into the ./lib folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T054236Z" creationid="xccui" creationdate="20190706T053019Z">
        <seg>为此，你可以直接将JAR文件从Flink安装路径的./opt目录拷贝到./lib目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is done by guarding the code in run() that advances</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T174313Z" creationid="xccui" creationdate="20190712T174313Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is done by running the following command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T035244Z" creationid="xccui" creationdate="20190720T035244Z">
        <seg>该工作可以通过以下命令完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is fine for some applications, but what if you are only interested in the most recent data?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043032Z" creationid="xccui" creationdate="20190406T042859Z">
        <seg>该操作对某些应用而言是可行的，但如果你只对最新的那部分数据感兴趣该怎么办？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is obviously a problem if pods need to communicate with each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T142836Z" creationid="xccui" creationdate="20190719T023733Z">
        <seg>显然，这在Pod需要相互通信时会导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is possible if the following two properties hold:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T043047Z" creationid="xccui" creationdate="20190714T043047Z">
        <seg>该类型的连接器有以下两个实施前提：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is required if multiple Flink clusters rely on the same ZooKeeper instance for failure recovery:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T050846Z" creationid="xccui" creationdate="20190721T050846Z">
        <seg>该配置只有在多个Flink集群依赖同一个ZooKeeper实例来进行故障恢复时才是必需的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to the maintenance techniques database sys‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155421Z" creationid="xccui" creationdate="20190605T044509Z">
        <seg>这有点类似于数据库系统为了更新物化视图而用到的维护技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to view maintenance techniques that database systems use to update materi&lt;t2/&gt;‐&lt;t3/&gt; alized views.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T060100Z" creationid="xccui" creationdate="20190317T060100Z">
        <seg>这有点类似于数据库系统为了更新物化视图而使用的视图维护技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is suffi‐ cient to recover from worker failures, which are handled by the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T061926Z" creationid="xccui" creationdate="20190721T061926Z">
        <seg>这足以让ResourceManager对工作进程进行故障恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the default behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T161027Z" creationid="xingcan" creationdate="20190709T154425Z">
        <seg>这也是默认的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the default behavior: FlinkKafkaConsumer.setStartFromGroupOffsets()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T035313Z" creationid="xccui" creationdate="20190709T035313Z">
        <seg>这也是默认的行为：FlinkKafkaConsumer.setStartFromGroupOffsets()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the default setting.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T210600Z" creationid="xccui" creationdate="20190709T210509Z">
        <seg>这是默认设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the last call in our example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005918Z" creationid="xccui" creationdate="20190613T005918Z">
        <seg>这是我们示例中最后一个方法调用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the same use case as in the keyed state example before, but the KeyedProcessFunction also clears the state for keys (i.e., sensors) that have not pro‐ vided any new temperature measurements within one hour of event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205827Z" creationid="xccui" creationdate="20190704T205500Z">
        <seg>这和之前使用键值分区状态的用例相同，但此处的KeyedProcessFunction会在某一键值超过1小时（事件时间）都没有新到的温度测量数据时将其对应的状态清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the strictest and most challenging to achieve type of guarantee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T043916Z" creationid="xccui" creationdate="20190416T043916Z">
        <seg>这是最严格也是最难实现的一类保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful if none of Flink’s binary distributions works with the Hadoop version deployed in your environment; for example, if you run a patched Hadoop version or a Hadoop version of a distribu‐ tor, such as Cloudera, Hortonworks, or MapR.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025459Z" creationid="xccui" creationdate="20190722T023816Z">
        <seg>该方法可用于你环境中的Hadoop版本和所有Flink二进制发行版都不匹配的情况。例如，你运行的是打过补丁的Hadoop版本或使用了某个发行商（如Cloudera、Hortonworks或MapR）的Hadoop版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very attractive especially in combination with Flink’s savepoint feature which can reset the state of an application to a previous consistent savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190313T005726Z" creationid="xccui" creationdate="20190312T214059Z">
        <seg>这在Flink保存点（savepoint）功能的加持下，尤为引人注目。所谓保存点功能是指在保证一致性的前提下，允许将应用状态重置到先前某个保存的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is what we call the framework style of deploying applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T210624Z" creationid="xccui" creationdate="20190729T202333Z">
        <seg>即我们称作框架模式的应用部署形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is why Flink is able to support all HCFSs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T044637Z" creationid="xccui" creationdate="20190722T044637Z">
        <seg>这也是为何Flink可以支持任意HCFS（Hadoop Compatible File System，兼容Hadoop的文件系统）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes development easier and sim‐ plifies cluster deployment, as you can run the exact same code in a cluster environ‐ ment without making any changes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T072825Z" creationid="xccui" creationdate="20190611T032127Z">
        <seg>这让开发过程变得更容易，也让集群部署更简单，因为你可以在不对代码进行任何修改的情况下直接切换到集群环境中运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes the JobManager a single point of failure for applications in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145839Z" creationid="xccui" creationdate="20190606T145818Z">
        <seg>这就导致JobManager成为Flink应用中的一个单点失效组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes the JobManager a single-point-of-failure for applications in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T044559Z" creationid="xccui" creationdate="20190502T043400Z">
        <seg>这就导致JobManager成为Flink应用中一个单点失效组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This matching is done in two steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T045125Z" creationid="xccui" creationdate="20190727T045125Z">
        <seg>具体匹配过程分为两步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means a file is completely reprocessed if</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T200312Z" creationid="xccui" creationdate="20190710T200312Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means an application should not run close to 100% resource consumption during regular processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T150948Z" creationid="xingcan" creationdate="20190801T150629Z">
        <seg>这意味着应用在常规处理时不应该接近100%的资源消耗。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means if the difference between an element’s event time and the maximum timestamp of all previous elements is greater than 10 seconds, the element might arrive for processing after its corresponding computation has completed and the result has been emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T060040Z" creationid="xccui" creationdate="20190620T053515Z">
        <seg>这意味着如果元素的事件时间和之前到达元素的最大时间戳相差超过10秒，那么当元素到达并开始处理时，它本应参与的计算可能已经完成并发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that all events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044724Z" creationid="xccui" creationdate="20190614T044724Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that all records processed by the same parallel task have access to the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062716Z" creationid="xccui" creationdate="20190607T060836Z">
        <seg>这意味着所有在同一个并行任务之内的记录都能访问到相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can‐ not easily evolve the data type of a state in your application, unless you designed your application with state evolution in mind from the start.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T205246Z" creationid="xccui" creationdate="20190727T054541Z">
        <seg>这意味着你除非从最开始就考虑应用状态后面可能会发生变化，否则无法轻易修改应用中状态的数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you should take application requirements and the properties of its input data, such as key domain, into account when designing and implementing stateful operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T200130Z" creationid="xccui" creationdate="20190704T200130Z">
        <seg>这意味着你在设计和实现状态化算子的时候，需要把应用需求和输入数据的属性（如键值域）都考虑在内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means the time needed to prepare a single beverage will increase, causing each person to spend more time in the coffees hop, thus lowering the overall throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054439Z" creationid="xccui" creationdate="20190605T235136Z">
        <seg>这意味着准备单杯咖啡的时间会延长，继而导致每位顾客在店里花费的时间增加，此时整体吞吐量将会下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method can decide to gen‐ erate a new watermark or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054317Z" creationid="xccui" creationdate="20190620T054317Z">
        <seg>它可以决定是否生成一个新的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method may also be called twice for a transaction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053601Z" creationid="xccui" creationdate="20190716T053549Z">
        <seg>该方法可能同样会针对一个事务调用多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method receives a Par titioner object that implements the partitioning logic and the field or key posi‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T024220Z" creationid="xccui" creationdate="20190616T050245Z">
        <seg>该方法接收一个Partitioner对象，你在其中可以实现分区逻辑，定义分区需要参照的字段或键值位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method returns a local or remote environment, depending on the con‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T045918Z" creationid="xccui" creationdate="20190612T045221Z">
        <seg>根据调用时所处上下文的不同，该方法可能会返回一个本地或远程环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method stores every event in a buffer until its processing has been acknowledged by all tasks in the pipeline, at which point the event can be discarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193901Z" creationid="xccui" creationdate="20190416T043634Z">
        <seg>该方法会将所有事件存在缓冲区中，直到处理管道中所有任务都确认某个事件已经处理完毕才会将事件丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method uses the current timestamp to generate watermarks, since no earlier timestamps can appear.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055803Z" creationid="xccui" creationdate="20190620T051801Z">
        <seg>基于时间戳不会回退的事实，该方法使用当前时间戳生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This might happen if</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T021644Z" creationid="xccui" creationdate="20190701T021644Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mode is used to execute a Flink program within an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T052637Z" creationid="xccui" creationdate="20190611T052637Z">
        <seg>该模式可用于在IDE中执行Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This needs to be taken into</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T203026Z" creationid="xccui" creationdate="20190702T203026Z">
        <seg>你在实现接口时需要考虑到这点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operation must be idem‐ potent—records must not be written twice to the output system if this method is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053342Z" creationid="xccui" creationdate="20190716T053257Z">
        <seg>该操作必须是幂等的，即在多次调用的情况下它不会将记录多次写入输出系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This parameter specifies that an application is only completely canceled if it exceeds its restart attempts within the val‐ idity interval, meaning attempts that predate the interval are not taken into account.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T060330Z" creationid="xccui" creationdate="20190721T053431Z">
        <seg>该参数指定应用只有在有效间隔内重启次数超过了最大尝试数才会被完全取消，换句话说，该时间间隔之前的尝试次数都不会被计算在内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This parame‐ ter also determines the number of started worker containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T044139Z" creationid="xccui" creationdate="20190730T044139Z">
        <seg>该参数还用于决定启动工作容器的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This partitioning strategy must be used with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045954Z" creationid="xccui" creationdate="20190616T045912Z">
        <seg>使用此分区策略时务必小心，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This prevents another checkpoint from completing after the savepoint, which would trigger exactly-once sinks to emit data after the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T205820Z" creationid="xccui" creationdate="20190727T055841Z">
        <seg>这可以防止在生成保存点后又出现一次检查点的情况，该情况会触发精确一次数据汇在保存点后发出额外数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This problem does not only exist for custom stateful functions but also for some of the built-in operators of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T033527Z" creationid="xccui" creationdate="20190704T183059Z">
        <seg>该问题不但存在于自定义的状态化函数中，还会影响DataStream API中的部分内置算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This problem is commonly solved by delegating state management to an external system, such as a database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T054012Z" creationid="xccui" creationdate="20190414T053952Z">
        <seg>该问题通常的解决方案是将状态管理交由某个外部系统（如：数据库）完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This problem is commonly solved by delegating state manage‐ ment to an external system, such as a database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032125Z" creationid="xccui" creationdate="20190606T032125Z">
        <seg>该问题通常的解决方案是将状态管理交由某个外部系统（如：数据库）完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property can be leveraged during checkpoints and when rescaling an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T063117Z" creationid="xccui" creationdate="20190607T185319Z">
        <seg>这种相同的特性将有利于检查点保存或算子扩缩容，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requires splitting or merging of state objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T055247Z" creationid="xccui" creationdate="20190701T055247Z">
        <seg>这就需要拆分或合并状态对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This setting offers very low latency because processing tasks do not have to wait for watermarks to advance the event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T045359Z" creationid="xccui" creationdate="20190619T070153Z">
        <seg>在该配置下，由于处理任务无须依靠等待水位线来驱动事件时间前进，所以可以提供极低的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should be done by exporting either the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T030751Z" creationid="xccui" creationdate="20190722T030751Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This situation can be problematic for time-based operators that rely on an advancing clock to perform computations and clean up   their state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T032609Z" creationid="xccui" creationdate="20190607T032609Z">
        <seg>这种情形会给那些靠时钟前进来执行计算或清除状态的时间相关算子带来麻烦。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This situation is commonly known as &lt;t6/&gt;backpressure&lt;t7/&gt; and there exist different strategies to deal with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T202658Z" creationid="xccui" creationdate="20190402T202106Z">
        <seg>这种情形通常被称为背压（backpressure），可以通过多种策略来处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This situation is commonly known as backpressure and there are different strategies to deal with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053732Z" creationid="xccui" creationdate="20190605T234829Z">
        <seg>这种情形通常被称为背压（backpressure），我们有多种可选策略来处理它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This special record is called a latency marker, and it bears a timestamp indicating when it was emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T054715Z" creationid="xccui" creationdate="20190806T054715Z">
        <seg>这些特殊的记录被称为延迟标记（latency marker），每个延迟标记都带有一个表明它们何时发出的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This state can be updated by incoming events and can be used in the processing logic of future events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T040548Z" creationid="xccui" creationdate="20190405T040313Z">
        <seg>它们的状态会根据传入的事件更新，并用于未来事件的处理逻辑中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This state can be upda‐ ted by incoming events and can be used in the processing logic of future events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235848Z" creationid="xccui" creationdate="20190605T235848Z">
        <seg>它们的状态会根据传入的事件更新，并用于未来事件的处理逻辑中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This state is completely controlled by the trigger and not maintained by the window operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T035220Z" creationid="xccui" creationdate="20190626T035125Z">
        <seg>该状态并非由窗口算子进行维护，而是完全由触发器来控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is fun&lt;t0/&gt;‐&lt;t1/&gt; damental to effectively utilize the networking resource and achieve high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041748Z" creationid="xccui" creationdate="20190504T041748Z">
        <seg>该技术是有效利用网络资源、实现高吞吐的基础。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is funda‐ mental to effectively using the networking resource and achieving high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195459Z" creationid="xccui" creationdate="20190606T195459Z">
        <seg>该技术是有效利用网络资源、实现高吞吐的基础。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is used to recover from failures but can also be leveraged to update an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T211855Z" creationid="esouser" creationdate="20190603T211855Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is used to recover from failures but can also be leveraged to update an application, fix bugs and repair previously emitted results, migrate an application to a different cluster, or perform A/B tests with different application versions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T145302Z" creationid="xccui" creationdate="20190305T145014Z">
        <seg>该技术不但可用于失败恢复，还可用于应用更新、bug修复、结果修正、集群迁移或针对不同版本应用执行A/B测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of application is called a data pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154547Z" creationid="xccui" creationdate="20190605T042611Z">
        <seg>我们将此类应用称为数据管道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is also known as “no guar‐ antee” since even a system that drops every event can provide this guarantee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T192128Z" creationid="xccui" creationdate="20190606T034419Z">
        <seg>这类保障也被称作"没有保障"，因为即便系统丢掉所有事件也能满足其条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is also known as “no-guarantee” since even a system that drops every event can fulfil it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T184916Z" creationid="xccui" creationdate="20190415T184739Z">
        <seg>这类保障也被称作"没有保障"，因为即便系统丢掉所有事件也能满足。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is called at-least-once and it means that all events will def&lt;t0/&gt;‐&lt;t1/&gt; initely be processed, even though some of them might be processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041957Z" creationid="xccui" creationdate="20190416T041845Z">
        <seg>这类保障称为至少一次。它意味着所有事件最终都会处理，即便有些可能会处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is called at-least-once, and it means that all events will be pro‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T192900Z" creationid="xccui" creationdate="20190606T034604Z">
        <seg>这类保障称为至少一次。它意味着所有事件最终都会处理，虽然有些可能会处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of parallelism is called data parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044632Z" creationid="xccui" creationdate="20190401T030647Z">
        <seg>这种并行称为数据并行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of parallelism is called task parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044813Z" creationid="xccui" creationdate="20190605T233305Z">
        <seg>这种并行称为任务并行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, it can ensure that the order guarantees on each partition are leveraged and no unnecessary late records are emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T042102Z" creationid="xccui" creationdate="20190713T041748Z">
        <seg>这样的话，它就可以充分利用每个分区的保序性，避免发出不必要的迟到记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, open source communities are constantly improving the capabilities of their projects and are pushing the technical boundaries of stream processing further.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T041353Z" creationid="xccui" creationdate="20190322T035856Z">
        <seg>这样，开源社区不断增强它们项目的功能并在流处理领域开疆拓土。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, the time to prepare a sin&lt;t0/&gt;‐&lt;t1/&gt; gle beverage will increase, causing each person to spend more time in the coffee shop, thus lowering the overall throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210136Z" creationid="xccui" creationdate="20190402T205924Z">
        <seg>这样的话，准备单杯咖啡的时间就会延长，继而导致每名顾客在店里花费的时间增加，整体吞吐量下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will generate a Maven project for Flink 1.7.1 in a folder called flink-scala-project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T094446Z" creationid="xccui" creationdate="20190612T005158Z">
        <seg>上述命令会在flink-scala-project文件夹内生成一个Flink 1.7.1版本的Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will initialize the state of the application to the state of the save‐ point and run the application from the point at which the savepoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T070309Z" creationid="xccui" creationdate="20190609T211509Z">
        <seg>这样就能用保存点内的数据初始化状态并从生成保存点的那一刻继续运行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will prevent the tasks of the opera‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203300Z" creationid="xccui" creationdate="20190730T203300Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This window type essentially represents a time interval between the two timestamps, where start is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T025444Z" creationid="xccui" creationdate="20190623T041614Z">
        <seg>该窗口类型实际上表示两个时间戳之间的时间区间（左闭右开）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This works because broadcasting state ensures that all tasks have the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061853Z" creationid="xccui" creationdate="20190608T061836Z">
        <seg>这样做的原因是广播状态能确保所有任务的状态相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This yields a self- contained, yet typically quite large, application JAR file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041513Z" creationid="xccui" creationdate="20190619T041513Z">
        <seg>这样会生成一个独立但通常很大的应用JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread.sleep(refreshInterval)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041428Z" creationid="xccui" creationdate="20190707T041428Z">
        <seg>Thread.sleep(refreshInterval)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Threads are more lightweight than separate processes and have lower communication costs but do not strictly isolate tasks from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063219Z" creationid="xccui" creationdate="20190424T063109Z">
        <seg>和独立进程相比，线程更加轻量并且通信开销更低，但无法严格地将任务彼此隔离。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Through Kafka 0.11, the API of the client library evolved and new features were added, such as record timestamp support with Kafka 0.10 and transactional writes with Kafka 0.11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T043456Z" creationid="xccui" creationdate="20190709T043423Z">
        <seg>Kafka在0.11版本以前，其客户端库的API一直在改变且经常添加一些新的功能，例如它在0.10版本开始支持记录时间戳，在0.11版本开始支持事务性写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Through Kafka 0.11, the API of the client library evolved and new features were added.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T204123Z" creationid="xccui" creationdate="20190708T203325Z">
        <seg>Kafka在0.11版本以前，其客户端库的API一直在改变且经常添加一些新的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195249Z" creationid="xccui" creationdate="20190401T195249Z">
        <seg>吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput is a measure of the system’s processing capacity, i.e. its &lt;t0/&gt;rate&lt;t1/&gt; of processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195449Z" creationid="xccui" creationdate="20190401T195333Z">
        <seg>吞吐是用来衡量系统处理能力（处理速率）的指标，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput is a measure of the system’s processing capacity—its rate of processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234345Z" creationid="xccui" creationdate="20190605T234345Z">
        <seg>吞吐是用来衡量系统处理能力（处理速率）的指标，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput is measured in events or operations per time unit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052333Z" creationid="xccui" creationdate="20190401T200345Z">
        <seg>吞吐的衡量方式是计算每个单位时间的事件或操作数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, an event might belong to multiple buckets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013221Z" creationid="xccui" creationdate="20190606T013145Z">
        <seg>这意味着每个事件可能会同时属于多个桶。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, an&lt;t1/&gt; &lt;t2/&gt;event might belong to multiple buckets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024049Z" creationid="xccui" creationdate="20190407T023736Z">
        <seg>这意味着每个事件可能会属于多个桶。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, for applications where speed is more important than accuracy, processing time comes handy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043219Z" creationid="xccui" creationdate="20190414T041302Z">
        <seg>因此对于那些更重视处理速度而非准确度的应用而言，处理时间用起来很方便。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, for applications where speed is more important than accuracy, processing time comes in handy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180646Z" creationid="xccui" creationdate="20190606T030938Z">
        <seg>因此针对那些更重视处理速度而非准确度的应用，处理时间就会派上用场。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, it is com‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045436Z" creationid="xccui" creationdate="20190619T045436Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the latency is bounded by the arrival time of the last event in each batch and naturally depends on the batch size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T200248Z" creationid="xccui" creationdate="20190401T193810Z">
        <seg>因此处理延迟受制于每个批次最迟事件的时间，且天然依赖批次大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, you wait in line and when it is your turn you make an order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T152842Z" creationid="xccui" creationdate="20190401T152507Z">
        <seg>这时候你就需要排队，等轮到你的时候再开始点单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, you wait in line and when it is your turn you place an order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233857Z" creationid="xccui" creationdate="20190605T233857Z">
        <seg>这时候你就需要排队，等轮到你的时候再开始点单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time Semantics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144012Z" creationid="esouser" creationdate="20190603T144012Z">
        <seg>时间语义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time Semantics | 27</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041436Z" creationid="xccui" creationdate="20190606T041436Z">
        <seg>时间语义 | 27</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time is perhaps the most important aspect of stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064032Z" creationid="xccui" creationdate="20190409T200209Z">
        <seg>时间可能是流处理中最重要的一个方面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time semantics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015458Z" creationid="xccui" creationdate="20190225T015458Z">
        <seg>时间语义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time to get our hands dirty and start developing Flink applications!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190224T174724Z" creationid="xccui" creationdate="20190224T174724Z">
        <seg>是时候撸起袖子着手开发Flink应用了！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time windows have a start and an end timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T033207Z" creationid="xccui" creationdate="20190623T033207Z">
        <seg>每个时间窗口都有一个开始时间戳和一个结束时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time- based tumbling windows define a time interval during which events are buffered in the bucket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063432Z" creationid="xccui" creationdate="20190606T013049Z">
        <seg>基于时间的（time-based）滚动窗口定义了在桶中缓冲数据的时间间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045937Z" creationid="xccui" creationdate="20190619T045937Z">
        <seg>基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-Based and Window Operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145657Z" creationid="esouser" creationdate="20190603T145657Z">
        <seg>基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based and Window Operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022953Z" creationid="xccui" creationdate="20190225T022953Z">
        <seg>基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based operators use this time to trigger computations and make progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T051735Z" creationid="xccui" creationdate="20190523T041707Z">
        <seg>基于时间的算子会使用这个时间来触发计算并推动进度前进。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based tumbling window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013123Z" creationid="xccui" creationdate="20190606T013122Z">
        <seg>基于时间的滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based tumbling window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023609Z" creationid="xccui" creationdate="20190407T023609Z">
        <seg>基于时间的滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based tumbling windows define a time interval during which events are buffered in the bucket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023258Z" creationid="xccui" creationdate="20190407T023053Z">
        <seg>基于时间的（time-based）滚动窗口定义在桶中缓冲数据的时间间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based window assigners assign an element based on its event-time timestamp or the current processing time to windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T041312Z" creationid="xccui" creationdate="20190623T033135Z">
        <seg>基于时间的窗口分配器会根据元素事件时间的时间戳或当前处理时间将其分配到一个或多个窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-related operators such as window operators and other specialized trans‐ formations are described in later chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T053506Z" creationid="xccui" creationdate="20190613T013033Z">
        <seg>基于时间的算子（如窗口算子）以及其他一些特殊转换会在后面章节介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time.of(30, TimeUnit.SECONDS) // delay between attempts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154512Z" creationid="xingcan" creationdate="20190801T154512Z">
        <seg>Time.of(30, TimeUnit.SECONDS) // 尝试之间的延迟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TimeCharacteristic.ProcessingTime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T014054Z" creationid="xccui" creationdate="20190620T014054Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TimerService and Timers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="esouser" creationdate="20190603T145847Z">
        <seg>时间服务和计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers are always asynchronously checkpointed, with one exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063240Z" creationid="xccui" creationdate="20190621T065600Z">
        <seg>计时器通常会以异步方式存入检查点，但有一个例外：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers are checkpointed along with any other state of the function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T065223Z">
        <seg>这些计时器会和其他状态一起写入检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers can be based on event time or processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205850Z" creationid="xccui" creationdate="20190704T205850Z">
        <seg>计时器可以基于事件时间或处理时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers can only be registered on keyed streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T061215Z">
        <seg>计时器只允许在按键值分区的数据流上注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers of a trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040431Z" creationid="xccui" creationdate="20190626T034200Z">
        <seg>触发器计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers on Nonkeyed Streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062942Z" creationid="xccui" creationdate="20190621T061036Z">
        <seg>在非键值分区流上设置计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers that are registered for a timestamp in the past are not silently dropped but processed as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063335Z" creationid="xccui" creationdate="20190621T070407Z">
        <seg>以过去的时间戳注册的计时器不会被静默地删除，而同样会被处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamp Assignment and Watermark Generation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144538Z" creationid="xccui" creationdate="20190225T021938Z">
        <seg>时间戳分配和水位线生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamp assigners behave like other transformation operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055036Z" creationid="xccui" creationdate="20190620T032959Z">
        <seg>时间戳分配器的工作原理和其他转换算子类似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamp assigners do not change the data type of a DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T033249Z" creationid="xccui" creationdate="20190620T033249Z">
        <seg>时间戳分配器不会改变DataStream的数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155747Z" creationid="xccui" creationdate="20190225T021851Z">
        <seg>时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and watermarks are specified in milliseconds since the epoch of 1970-01-01T00:00:00Z.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T020306Z" creationid="xccui" creationdate="20190620T020306Z">
        <seg>时间戳和水位线都是利用自1970-01-01 00:00:00以来的毫秒数指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and watermarks are usually assigned and generated when a stream is ingested by a streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033706Z" creationid="xccui" creationdate="20190607T033653Z">
        <seg>时间戳和水位线通常都是在数据流刚刚进入流处理应用的时候分配和生成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and watermarks can be assigned and generate by a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T035441Z" creationid="xccui" creationdate="20190713T035246Z">
        <seg>它们可以通过一个专门的TimestampAssigner（请参阅"分配时间戳和生成水位线"一节）或在数据源函数中完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and watermarks for event-time applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023039Z" creationid="xccui" creationdate="20190225T023039Z">
        <seg>事件时间应用中的时间戳和watermark</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and water‐ marks can be either assigned and generated by a SourceFunction or using an explicit user-defined timestamp assigner and watermark generator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T052712Z" creationid="xccui" creationdate="20190620T020916Z">
        <seg>时间戳分配和水位线生成既可以通过SourceFunction，也可以显式使用一个用户自定义时间戳分配和水位线生成器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps usually exist inside the event data before they enter the processing pipeline (e.g. event cre&lt;t2/&gt;‐&lt;t3/&gt; ation time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150102Z" creationid="xccui" creationdate="20190412T150102Z">
        <seg>这些时间戳通常在事件数据进入流处理管道之前就存在（例如：事件生成时间）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps usually exist inside the event data before they enter the processing pipeline (e.g., the event creation time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155915Z" creationid="xccui" creationdate="20190606T024140Z">
        <seg>这些时间戳通常在事件数据进入流处理管道之前就存在（例如事件的创建时间）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To   cancel  the  application  with  the JobID</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T184636Z" creationid="xccui" creationdate="20190726T184636Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To access the createTypeInformation macro function, make sure to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054745Z" creationid="xccui" creationdate="20190617T054731Z">
        <seg>为了使用createTypeInformation宏函数，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To assess end-to-end guarantees, one has to consider all the components of an application pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045840Z" creationid="xccui" creationdate="20190416T045830Z">
        <seg>为了评估它，需要考虑应用处理管道上的所有组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid long-running checkpoints, you can configure a timeout interval after which a checkpoint is canceled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T032916Z" creationid="xccui" creationdate="20190731T203717Z">
        <seg>为了避免检查点生成时间过长，你可以配置一个超时间隔，在该间隔过后生成操作会被取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid such behavior, a source function can generate watermarks for each stream partition independently and always emit the smallest watermark of its partitions as its watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T041943Z" creationid="xccui" creationdate="20190713T041729Z">
        <seg>为了避免该情况，数据源函数可以为每个数据流分区独立生成水位线，并将它们中的最小值作为整条数据流的水位线发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid such risk, you should make sure that scope identifiers per job are</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043927Z" creationid="xccui" creationdate="20190804T043927Z">
        <seg>为了避免类似状况，你需要确保每个作业的域标识都是唯一的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be able to catch up with the stream—reach its tail—the application must process the accumulated data at a higher rate than new data is arriving.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T145912Z" creationid="xingcan" creationdate="20190801T145912Z">
        <seg>为了能够追赶上数据流（到达其尾部），应用处理积累数据的速率必须要高于新数据到来的速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To better understand the con&lt;t4/&gt;‐&lt;t5/&gt; cept of peak throughput, let us consider that system resources are completely unused.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T204336Z" creationid="xccui" creationdate="20190401T204219Z">
        <seg>为了更好地理解峰值吞吐的概念，我们假设系统资源完全空闲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To better understand the con‐ cept of peak throughput, let’s consider a stream processing application that does not receive any incoming data and thus does not consume any system resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052628Z" creationid="xccui" creationdate="20190605T234611Z">
        <seg>为了更好地理解峰值吞吐的概念，我们先假设某个流处理应用没有在接收任何数据，也因此无需占用任何系统资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To build an image with Flink 1.7.1 that contains the example applications of this book, execute the script as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190730T034458Z">
        <seg>如果要构建一个包含了本书示例应用的Flink 1.7.1版本镜像，请执行以下脚本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To cancel a running application without taking a savepoint run the following command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T183308Z" creationid="xccui" creationdate="20190726T183308Z">
        <seg>如果要在不使用保存点的情况下取消当前运行的应用，请运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To change the properties of log4j loggers, modify the log4j.properties file in the conf/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034457Z" creationid="xccui" creationdate="20190807T034457Z">
        <seg>要修改log4j记录器的属性，请修改conf/目录中的log4j.properties文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To check if the request with the ID ebde90836b8b9dc2da90e9e7655f4179 was suc‐ cessful and to retrieve the path of the savepoint run:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T193624Z" creationid="xccui" creationdate="20190729T193624Z">
        <seg>可以通过以下命令检查ID为ebde90836b8b9dc2da90e9e7655f4179的请求是否成功并获取保存点的路径：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To comment or ask technical questions about this book, send email to bookques‐ tions@oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210844Z" creationid="esouser" creationdate="20190603T210844Z">
        <seg>To comment or ask technical questions about this book, send email to bookques‐ tions@oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a state object, we have to register a StateDescriptor with Flink’s runtime via the RuntimeContext, which is exposed by RichFunction (see “Implementing Functions” on page 105 for a discussion of the RichFunction interface).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T065152Z" creationid="xccui" creationdate="20190630T064840Z">
        <seg>为了创建一个状态对象，我们需要利用RichFunction（有关该接口的内容请参照105页"实现函数"）中的RuntimeContext在Flink运行时中注册一个StateDescriptor。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a window operator, you need to specify two window components:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T035330Z" creationid="xccui" creationdate="20190622T035330Z">
        <seg>为了新建一个窗口算子需要指定两个窗口组件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To date, more than five hundred individu‐ als have contributed to Flink, and it has evolved into one of the most sophisticated open source stream processing engines as proven by its widespread adoption.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T051658Z" creationid="esouser" creationdate="20190603T162900Z">
        <seg>截至目前，该项目已经有超过500名贡献者，并在不断普及的过程中逐渐发展为开源界最为先进的流处理引擎之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define time operations in a distributed stream processing application, it is impor‐ tant to understand the meaning of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T054852Z" creationid="xccui" creationdate="20190619T054843Z">
        <seg>为了在分布式流处理应用中定义时间操作，准确理解时间的含义非常关键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To disable chaining for a specific operator,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T010748Z" creationid="xccui" creationdate="20190730T203201Z">
        <seg>例如，可以通过调用算子的disableChaining()方法禁用其链接功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To dispose a savepoint use the REST call that is shown in Table 10-15 .</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T193826Z" creationid="xccui" creationdate="20190729T193826Z">
        <seg>请使用表10-15中的REST调用删除保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To dispose a savepoint with curl, run:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200832Z" creationid="xccui" creationdate="20190729T200832Z">
        <seg>要使用curl删除某个保存点，请运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable latency tracking, you need to configure how often latency markers are emitted from the sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T054824Z" creationid="xccui" creationdate="20190806T054824Z">
        <seg>为了启用延迟追踪，你需要配置从数据源发出延迟标记的频率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ensure an application can make enough progress, you can configure a minimum pause between checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T202335Z" creationid="xccui" creationdate="20190731T202019Z">
        <seg>为了保证应用可以取得足够多的进展，Flink允许你配置一个检查点之间的最小暂停时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ensure that event-time operations behave as expected, the assigner should be called before any event-time dependent transformation (e.g., before the first event- time window).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055013Z" creationid="xccui" creationdate="20190620T032816Z">
        <seg>为了保证事件时间相关操作能够正常工作，必须将分配器放在任何依赖事件时间的转换之前（例如在第一个事件时间窗口之前）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To guarantee exactly-once output, Flink must recover from the latest completed checkpoint or savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T181944Z" creationid="xccui" creationdate="20190726T181732Z">
        <seg>为了确保精确一次输出，Flink需要从最近一次的检查点或保存点恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To help users start a ZooKeeper cluster quickly for testing purposes, Flink provides a helper script for bootstrapping.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T161130Z" creationid="xccui" creationdate="20190720T161130Z">
        <seg>为了帮助用户快速启动ZooKeeper集群进行测试，Flink提供了一个自启动帮助脚本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To illustrate the use of the Cassandra sink connector, we use the simple example of a Cassandra table that holds data about sensor readings and consists of two columns,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T205857Z" creationid="xccui" creationdate="20190711T205756Z">
        <seg>为了说明Cassandra数据汇连接器的使用方法，我们以一个简单的Cassandra表为例，表中包含了两个列，分别用来保存传感器读数的传感器ID和温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To improve the out-of-the-box experience, Flink is preconfigured for a local setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T042356Z" creationid="xccui" creationdate="20190723T042356Z">
        <seg>为了让用户快速上手，Flink已经预先配置好本地运行模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To install either of both connectors, move the respective JAR file from the ./opt folder into the ./lib folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T043731Z" creationid="xccui" creationdate="20190722T043731Z">
        <seg>要安装它们中的一个，请将对应的JAR文件从./opt文件夹移动到./lib中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To keep the example concise, we create a new JDBC connection for each record, which is, of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T060042Z" creationid="xccui" creationdate="20190716T212226Z">
        <seg>出于简洁考虑，我们在示例中为每条记录都创建了一个新的JDBC连接，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To key the stream by sensor ID we can pass the field name id to the keyBy() func‐ tion:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040249Z" creationid="xccui" creationdate="20190618T042634Z">
        <seg>为了将传感器ID设为数据流的键值，我们可以把字段名称id传给keyBy()函数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To limit the state size, operators usually maintain some kind of summary or &lt;t0/&gt;synopsis&lt;t1/&gt; of the events seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055014Z" creationid="xccui" creationdate="20190414T054943Z">
        <seg>为了限制状态大小，算子通常都会只保留到目前为止所见事件的摘要或概览。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To limit the state size, operators usually maintain some kind of summary or synopsis of the events seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032413Z" creationid="xccui" creationdate="20190606T032413Z">
        <seg>为了限制状态大小，算子通常都会只保留到目前为止所见事件的摘要或概览。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To overcome this problem, Flink supports a high-availability mode that migrates the responsibility and metadata for a job to another JobManager in case that the original JobManager disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T044628Z" creationid="xccui" creationdate="20190502T044050Z">
        <seg>为了解决该问题，Flink提供了高可用模式，支持在原JobManager消失的情况下将作业的管理职责及元数据迁移到另一个JobManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To over‐ come this problem, Flink supports a high-availability mode that migrates the respon‐ sibility and metadata for a job to another JobManager in case the original JobManager disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145905Z" creationid="xccui" creationdate="20190606T145905Z">
        <seg>为了解决该问题，Flink提供了高可用模式，支持在原JobManager消失的情况下将作业的管理职责及元数据迁移到另一个JobManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To produce a result, a UDF accumulates state over a period or number of events, e.g. to compute an aggregation or detect a pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T051900Z" creationid="xccui" creationdate="20190414T051733Z">
        <seg>为了生成结果，UDF会在一段时间或基于一定个数的事件来累积状态，如：计算聚合或检测某个模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To produce a result, a function accumulates state over a period of time or number of events (e.g., to compute an aggregation or detect a pattern).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181304Z" creationid="xccui" creationdate="20190606T031435Z">
        <seg>为了生成结果，函数会在一段时间或基于一定个数的事件来累积状态（例如计算聚合或检测某个模式）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prop&lt;t0/&gt;‐&lt;t1/&gt; erly define window operator semantics, we need to answer two main questions: “&lt;t2/&gt;how&lt;t3/&gt; &lt;t4/&gt;are events assigned to buckets?&lt;t5/&gt;” and “&lt;t6/&gt;how often does the window produce a result?&lt;t7/&gt;”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022727Z" creationid="xccui" creationdate="20190406T045045Z">
        <seg>为了准确定义窗口算子语义，我们需要回答两个核心问题："事件如何分配到桶中"以及"窗口以什么频率产生结果"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prop‐ erly define window operator semantics we need to determine both how events are assigned to buckets and how often the window produces a result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012636Z" creationid="xccui" creationdate="20190606T012334Z">
        <seg>为了准确定义窗口算子语义，我们需要决定事件如何分配到桶中以及窗口以怎样的频率产生结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recap, processing time offers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031242Z" creationid="xccui" creationdate="20190606T031242Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recap, processing time offers low latency but results depend on the speed of processing and are not deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050354Z" creationid="xccui" creationdate="20190414T045432Z">
        <seg>总之，虽然处理时间提供了很低的延迟，但它的结果依赖处理速度，具有不确定性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recover from fail&lt;t0/&gt;‐&lt;t1/&gt; ures, the system needs to deal with two aspects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205059Z" creationid="xccui" creationdate="20190428T204311Z">
        <seg>为了从故障中恢复，系统需要做两手处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recover from fail‐ ures, the system first needs to restart failed processes, and second, restart the applica‐ tion and recover its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072106Z" creationid="xccui" creationdate="20190606T145331Z">
        <seg>为了从故障中恢复，系统首先要重启故障进程，随后需要重启应用并恢复其状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To register metrics you have to retrieve a MetricGroup by calling the getMetrics()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015205Z" creationid="xccui" creationdate="20190803T015205Z">
        <seg>为了注册指标，你需要像示例10-5那样调用RuntimeContext的getMetrics()方法获取一个MetricGroup对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To rescale an application with curl to a new default parallelism of 16 run:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201754Z" creationid="xccui" creationdate="20190729T201754Z">
        <seg>要使用curl将应用的默认并行度调整为16，请运行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To rescale the application with the jobId bc0b2ad61ecd4a615d92ce25390f61ad to a parallelism of 16, run the command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190728T071908Z" creationid="xccui" creationdate="20190728T071908Z">
        <seg>为了将JobId为bc0b2ad61ecd4a615d92ce25390f61ad的应用设置为并行度等于16，你可以运行以下命令：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To retrieve one or more metrics for a TaskManager, add the get query parameter with all the requested metrics to the request:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044844Z" creationid="xccui" creationdate="20190729T044844Z">
        <seg>为了得到一个或多个TaskManager指标，请将它们以get查询参数的形式加入到请求中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To set a custom filename and location of this file, pass the -Dlog4j.configuration= parameter to the JVM. Flink also provides the log4j-cli.properties file used by the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T035313Z" creationid="xccui" creationdate="20190807T035004Z">
        <seg>如果要使用自定义文件名和位置的配置文件，可以通过-Dlog4j.configuration=parameter的方式将参数传递给JVM。Flink还为命令行客户端提供了log4j-cli.properties文件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To some extent, the latency can be reduced by importing data into the data store with data pipeline applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032021Z" creationid="xccui" creationdate="20190317T032021Z">
        <seg>在某种程度上，使用数据管道应用来导入数据可以降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To some extent, the latency can be reduced by importing data into the datastore with a data pipeline application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T043556Z" creationid="xccui" creationdate="20190605T043556Z">
        <seg>在某种程度上，使用数据管道应用来导入数据可以降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To start an application, you first need to upload the application’s JAR file to the cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045659Z" creationid="xccui" creationdate="20190729T045411Z">
        <seg>要启动一个应用，你必须先将应用的JAR文件传到集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To start the application, run the main() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042857Z" creationid="xccui" creationdate="20190611T042842Z">
        <seg>直接运行它就能启动应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To structure a typical Flink streaming application:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T045708Z" creationid="xccui" creationdate="20190612T043456Z">
        <seg>构建一个典型的Flink流式应用需要以下几步：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To trigger a savepoint for the job bc0b2ad61ecd4a615d92ce25390f61ad and store it in the directory hdfs:///xxx:50070/savepoints, we call the command-line client:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033839Z" creationid="xccui" creationdate="20190726T033839Z">
        <seg>我们可以像下面那样调用命令行客户端来为作业bc0b2ad61ecd4a615d92ce25390f61ad生成一次保存点，并将其存储到hdfs:///xxx:50070/savepoints目录中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To understand latency intuitively, consider your daily visit to your favorite coffee shop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233829Z" creationid="xccui" creationdate="20190401T152125Z">
        <seg>为了直观地理解延迟，想一下你每天都会光顾自己喜欢的咖啡店。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use a Gauge you implement the org.apache.flink.metrics.Gauge interface and register it using the gauge(String name, Gauge gauge) method on MetricGroup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031640Z" creationid="xccui" creationdate="20190803T031640Z">
        <seg>要使用Gauge，你需要实现org.apache.flink.metrics.Gauge接口并利用MetricGroup的gauge(String name, Gauge gauge)方法将其注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use logback instead of log4j, you will need to remove log4j from the lib/ folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T035513Z" creationid="xccui" creationdate="20190807T035513Z">
        <seg>如果要用logback，需要从lib/文件夹中移除log4j。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use timers on a nonkeyed stream, you can create a keyed stream by</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063030Z" creationid="xccui" creationdate="20190621T062029Z">
        <seg>为了在一条非键值分区的数据流上使用计时器，你可以通过在KeySelector中返回一个"假冒的"常数键值来创建一条键值分区数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, components of the Apache Hadoop ecosystem are integral parts in the IT infrastructures of many enterprises and companies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T032150Z" creationid="xccui" creationdate="20190228T210817Z">
        <seg>时至今日，Apache Hadoop生态组件已经成为很多公司和企业IT基础架构中举足轻重的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, components of the Apache Hadoop ecosystem are integral parts in the IT infrastructures of many enterprises.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T204436Z" creationid="esouser" creationdate="20190603T203736Z">
        <seg>时至今日，Apache Hadoop生态组件已经成为很多公司和企业IT基础设施中举足轻重的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, distributed open source stream processors power business-critical applications in many enterprises across dif&lt;t2/&gt;‐&lt;t3/&gt; ferent industries such as (online) retail, social media, telecommunication, gaming, and banking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014807Z" creationid="xccui" creationdate="20190319T041711Z">
        <seg>如今，开源分布式流处理引擎已经支撑起包括（在线）零售、社交媒体、移动通信、游戏、银行等很多不同行业的核心业务应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, dis‐ tributed open source stream processors power business-critical applications in many</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050251Z" creationid="xccui" creationdate="20190605T050251Z">
        <seg>如今，开源分布式流处理引擎已经支撑起包括（在线）零售、社交媒体、移动通信、游戏、银行等很多不同行业的核心业务应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today’s IT architectures include many different data stores, such as relational and special-purpose database systems, event logs, distributed file systems, in-memory caches, and search indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T013908Z" creationid="xccui" creationdate="20190314T064734Z">
        <seg>今日的IT架构通常会涵盖多种不同的数据存储，例如：关系型或专用数据库系统、事件日志系统、分布式文件系统、内存缓存、搜索索引等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today’s IT architectures include many different datastores, such as relational and special-purpose database systems, event logs, distributed filesystems, in-memory caches, and search indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T153510Z" creationid="xccui" creationdate="20190604T053748Z">
        <seg>如今的IT架构通常会包含多种不同的数据存储，例如：关系型或专用数据库系统、事件日志系统、分布式文件系统、内存缓存及搜索索引等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today’s data infrastructures are diverse.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T135223Z" creationid="xccui" creationdate="20190717T031400Z">
        <seg>现如今，数据基础架构纷繁多样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tokyo</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210643Z" creationid="esouser" creationdate="20190603T210643Z">
        <seg>Tokyo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional Data Infrastructures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014533Z" creationid="xccui" creationdate="20190225T014533Z">
        <seg>传统数据处理架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional Data Infrastructures   | 3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203023Z" creationid="esouser" creationdate="20190603T203023Z">
        <seg>传统数据处理架构 | 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional analytics pipelines consist of several individual components such as an ETL process, a storage system, and in case of a Hadoop-based environment also a data processor and scheduler to trigger jobs or queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062950Z" creationid="xccui" creationdate="20190317T062820Z">
        <seg>传统分析流水线包含了很多独立组件，例如：ETL进程、存储系统等。即便是基于Hadoop的环境，也需要有数据处理器和用来触发作业或查询的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional analytics pipelines consist of several individual components such as an ETL process, a storage system, and in the case of a Hadoop-based environment, a data processor and scheduler to trigger jobs or queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T162112Z" creationid="xccui" creationdate="20190605T044756Z">
        <seg>传统分析流程包含了很多独立组件，例如ETL进程、存储系统等。即便是基于Hadoop的环境，也需要有数据处理器和用来触发作业或查询的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional batch oriented architectures are not able to address such use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T054141Z" creationid="xccui" creationdate="20190317T054141Z">
        <seg>面向批次的传统架构根本无力应对它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional design of transactional applications that store data in a remote database system</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T195357Z" creationid="esouser" creationdate="20190603T195332Z">
        <seg>将数据存储在远程数据库系统内的传统事务型应用设计</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142849Z" creationid="esouser" creationdate="20190603T142849Z">
        <seg>事务型处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional Sink Connectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055057Z" creationid="xccui" creationdate="20190225T025317Z">
        <seg>事务性数据汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional Writes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T055932Z" creationid="esouser" creationdate="20190603T151955Z">
        <seg>事务性写</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T061953Z" creationid="xccui" creationdate="20190226T161728Z">
        <seg>事务型应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional updates are one way to achieve this result, but they can incur substantial performance overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034940Z" creationid="xccui" creationdate="20190606T034907Z">
        <seg>事务性更新是实现该目标的一个方法，但它可能会带来极大的性能开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional updates is one way to achieve this result, however, it can incur substantial performance over&lt;t0/&gt;‐&lt;t1/&gt; head.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044921Z" creationid="xccui" creationdate="20190416T044551Z">
        <seg>事务性更新是达到该结果的一个方法，但它可能会带来极大的性能开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TransactionalFileSink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052409Z" creationid="xccui" creationdate="20190716T052409Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TransactionalFileSink in Example 8-15 creates a new transaction file and returns its name as the identifier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052715Z" creationid="xccui" creationdate="20190716T052715Z">
        <seg>示例8-15中的TransactionalFileSink会创建一个新的事务文件并返回它的名字作为标识符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformation operations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152748Z" creationid="xccui" creationdate="20190405T152748Z">
        <seg>转换操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformation operations are single-pass operations that process each event inde&lt;t0/&gt;‐&lt;t1/&gt; pendently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T153157Z" creationid="xccui" creationdate="20190405T152939Z">
        <seg>转换操作是一种"单向"操作，会独立处理每个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformation operations are single-pass operations that process each event inde‐ pendently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060526Z" creationid="xccui" creationdate="20190606T010742Z">
        <seg>转换操作是一类"单向"操作，它们会独立处理每个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022706Z" creationid="xccui" creationdate="20190225T022706Z">
        <seg>转换操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations and rolling aggregations process one event at a time to produce out&lt;t0/&gt;‐&lt;t1/&gt; put events and potentially update state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041821Z" creationid="xccui" creationdate="20190406T035950Z">
        <seg>转换操作和滚动聚合每次处理一个事件来产生输出并（可能）更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations and rolling aggregations process one event at a time to produce out‐ put events and potentially update state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011956Z" creationid="xccui" creationdate="20190606T011956Z">
        <seg>转换操作和滚动聚合每次处理一个事件来产生输出并（可能）更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations | 85</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045238Z" creationid="xccui" creationdate="20190619T045238Z">
        <seg>转换操作 | 85</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TriggerResult can take one of the following values:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052814Z" creationid="xccui" creationdate="20190626T184354Z">
        <seg>TriggerResult可以是以下值之一：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TriggerResult onElement(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190001Z" creationid="xccui" creationdate="20190626T190001Z">
        <seg>TriggerResult onElement(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TriggerResult.CONTINUE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200648Z" creationid="xccui" creationdate="20190626T200648Z">
        <seg>TriggerResult.CONTINUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TriggerResult.FIRE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200902Z" creationid="xccui" creationdate="20190626T200902Z">
        <seg>TriggerResult.FIRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TriggerResult.FIRE_AND_PURGE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200740Z" creationid="xccui" creationdate="20190626T200740Z">
        <seg>TriggerResult.FIRE_AND_PURGE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Triggering savepoint for job bc0b2ad61ecd4a615d92ce25390f61ad.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033855Z" creationid="xccui" creationdate="20190726T033855Z">
        <seg>Triggering savepoint for job bc0b2ad61ecd4a615d92ce25390f61ad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Triggers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T213643Z" creationid="xccui" creationdate="20190625T213643Z">
        <seg>触发器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Triggers define when a window is evaluated and its results are emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T181313Z" creationid="xccui" creationdate="20190626T181313Z">
        <seg>触发器用于定义何时对窗口进行计算并发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Triggers have access to time properties and timers, and can work with state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T182331Z" creationid="xccui" creationdate="20190626T182243Z">
        <seg>触发器不仅能够访问时间属性和计时器，还可以使用状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True stream processing does not introduce such artificial delays and therefore can achieve really low latencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T194716Z" creationid="xccui" creationdate="20190401T194107Z">
        <seg>真正的流处理不会引入人为推迟等要素，因此才能实现极低的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True stream processing does not intro‐ duce such artificial delays and thus can achieve really low latencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051857Z" creationid="xccui" creationdate="20190605T234321Z">
        <seg>真正的流处理不会引入人为延迟等要素，只有这样才能将延迟将至极低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tumbling &lt;t0/&gt;windows assign events into non-overlapping buckets of fixed size.&lt;t1/&gt; &lt;t2/&gt;When the window border is passed, all the events are sent to an evaluation func&lt;t3/&gt;‐&lt;t4/&gt; tion for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022909Z" creationid="xccui" creationdate="20190406T050614Z">
        <seg>滚动窗口（tumbling window）将事件分配到长度固定且互不重叠的桶中。在窗口边界通过后，所有事件会发送给计算函数处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tumbling windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041957Z" creationid="xccui" creationdate="20190623T041957Z">
        <seg>滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tumbling windows assign events into nonoverlapping buckets of fixed size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013019Z" creationid="xccui" creationdate="20190606T013011Z">
        <seg>滚动窗口（tumbling window）将事件分配到长度固定且互不重叠的桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuning Checkpointing and Recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025948Z" creationid="xccui" creationdate="20190225T030028Z">
        <seg>调整检查点及恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuning Checkpointing and Recovery | 263</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040248Z" creationid="xccui" creationdate="20190807T040248Z">
        <seg>调整检查点和恢复 | 263</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple fields are referenced either by their field name (1-offset for Scala tuples, 0-offset for Java tuples) or by their 0-offset field index:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040304Z" creationid="xccui" creationdate="20190618T043248Z">
        <seg>元组字段的引用既可以利用字段名称（Scala元组编号从1开始，Java元组编号从0开始），也可以利用从0开始的字段索引：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple fields can be accessed by the name of their public fields—f0, f1, f2, etc., as shown earlier—or by position using the getField(int pos) method, where indexes start at 0:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035616Z" creationid="xccui" creationdate="20190617T035415Z">
        <seg>元组中的各个字段可以向上面那样通过公有字段名称（f0、f1、f2等）访问，也可以使用getField(int pos)方法通过位置访问，位置下标从0开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple2.of("Sarah", 23));</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035201Z" creationid="xccui" creationdate="20190617T035201Z">
        <seg>Tuple2.of("Sarah", 23));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple2&lt;String, Integer&gt; personTuple = Tuple2.of("Alex", "42"); Integer age = personTuple.getField(1); // age = 42</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035820Z" creationid="xccui" creationdate="20190617T035820Z">
        <seg>Tuple2&lt;String, Integer&gt; personTuple = Tuple2.of("Alex", "42"); Integer age = personTuple.getField(1); // age = 42</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples are composite data types that consist of a fixed number of typed fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070645Z" creationid="xccui" creationdate="20190616T070645Z">
        <seg>元组是由固定数量的类型字段所组成的复合数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two tasks of a sum operator compute the running sums of all even and odd numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T030906Z" creationid="xccui" creationdate="20190609T030813Z">
        <seg>求和算子的两个任务会分别对它们求和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TwoPhaseCommitSinkFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T051456Z" creationid="xccui" creationdate="20190715T051456Z">
        <seg>TwoPhaseCommitSinkFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TwoPhaseCommitSinkFunction[IN, TXN, CONTEXT] has three type parameters:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042224Z" creationid="xccui" creationdate="20190716T042224Z">
        <seg>TwoPhaseCommitSinkFunction[IN, TXN, CONTEXT]需要三个类型参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Information in the Scala API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054635Z" creationid="xccui" creationdate="20190617T054635Z">
        <seg>Scala API中的类型信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TypeInformation&lt;Integer&gt; intType = Types.INT;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053613Z" creationid="xccui" creationdate="20190617T053613Z">
        <seg>TypeInformation&lt;Integer&gt; intType = Types.INT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TypeInformation&lt;Person&gt; personType = Types.POJO(Person.class);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053659Z" creationid="xccui" creationdate="20190617T053659Z">
        <seg>TypeInformation&lt;Person&gt; personType = Types.POJO(Person.class);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TypeInformation’s helper class is org.apache.flink.api.scala.typeutils.Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053810Z" creationid="xccui" creationdate="20190617T053746Z">
        <seg>Scala API中有关TypeInformation的辅助类是org.apache.flink.api.scala.typeutils.Types，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T055128Z" creationid="xccui" creationdate="20190225T022759Z">
        <seg>类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types that are not specially handled are treated as generic types and serialized using the Kryo serialization framework.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065415Z" creationid="xccui" creationdate="20190616T065247Z">
        <seg>那些无法特别处理的类型会被当做泛型类型交给Kryo序列化框架进行序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types | 101</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045301Z" creationid="xccui" creationdate="20190619T045301Z">
        <seg>类型系统 | 101</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical real-world setups can easily have hundreds of such tasks running in parallel on many physical machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185655Z" creationid="xccui" creationdate="20190415T041636Z">
        <seg>不少实际系统设置都可以轻松做到在很多物理机器上并行运行数以百计的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical use cases for event-driven applications include</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T024821Z" creationid="xccui" creationdate="20190307T024821Z">
        <seg>事件驱动型应用的典型应用场景有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical use cases for event-driven applications include:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213603Z" creationid="esouser" creationdate="20190603T213603Z">
        <seg>事件驱动型应用的典型应用场景有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical use cases for streaming analytics applications are</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033324Z" creationid="xccui" creationdate="20190319T033305Z">
        <seg>典型的流式分析用例包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, a database system serves multiple applications which often even access the same databases or tables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T184437Z" creationid="xccui" creationdate="20190226T163003Z">
        <seg>通常情况下，多个应用会共用一个数据库系统，更有甚者，这些应用会访问相同的数据库或表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, an external resource manager such as Kubernetes takes care of starting the images and ensures that containers are restarted in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190606T143951Z">
        <seg>通常情况下，外部资源管理器（如：Kubernetes）负责启动镜像，并确保在发生故障时可以重启容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, an external resource manager such as Kubernetes takes care of starting the images and ensuring that of each type a certain number of containers is running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T040551Z" creationid="xccui" creationdate="20190423T040305Z">
        <seg>通常情况下，是由外部资源管理器（如：Kubernetes）负责启动映像，并各类型容器都以指定数量运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, external systems, such as Kafka, only guarantee message order within a stream partition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T040408Z" creationid="xccui" creationdate="20190713T040408Z">
        <seg>通常情况下，像Kafka这样的外部系统只能保证单个数据流分区的消息顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, streaming applications store their result in an external data store that supports efficient updates, such as a database or key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155507Z" creationid="xccui" creationdate="20190317T060355Z">
        <seg>通常情况下，流式应用会把它们的结果保存在某种支持高效更新的外部数据存储中，例如数据库或键值存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, the state handle object is created in the open() method of RichFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T020654Z" creationid="xccui" creationdate="20190630T035356Z">
        <seg>通常情况下，状态句柄对象要在RichFunction的open()方法中创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, the timestamp assigner is called right after the source function because most assigners make assumptions about the order of elements with respect to their timestamps when generating watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T054548Z" creationid="xccui" creationdate="20190620T030818Z">
        <seg>通常情况下，应该在数据源函数后面立即调用时间戳分配器，因为大多数分配器在生成水位线的时候都会做出一些有关元素顺序相对时间戳的假设。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, there are multiple TaskManagers running in a Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061024Z" creationid="xccui" creationdate="20190606T142319Z">
        <seg>通常在Flink搭建过程中要启动多个TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, there are multiple&lt;t1/&gt; &lt;t2/&gt;TaskManager running in a Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T051413Z" creationid="xccui" creationdate="20190418T051413Z">
        <seg>通常在Flink设置过程中要启动多个TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, there are two classes of queries executed on a data warehouse.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T024914Z" creationid="xccui" creationdate="20190228T192320Z">
        <seg>通常数据仓库中的查询可以分为两类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typi‐ cally, these intervals are defined using time-based logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T023055Z" creationid="xccui" creationdate="20190622T033117Z">
        <seg>通常情况下，这些区间都是使用时间逻辑定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UDFs are written by the application programmer and implement custom computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T155205Z" creationid="xccui" creationdate="20190405T155205Z">
        <seg>UDF由应用开发人员编写，实现某些自定义的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UUID.randomUUID.toString) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064346Z" creationid="xccui" creationdate="20190715T064346Z">
        <seg>UUID.randomUUID.toString) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Under Overview you can see how many checkpoints have been trig‐ gered, are in progress, have completed successfully, or have failed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T151927Z" creationid="xingcan" creationdate="20190802T150137Z">
        <seg>在Overview中，你可以查看已触发正在进行中、已经成功完成和已经失败的检查点的数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, figuring out the memory consumption of RocksDB is not straightforward because it depends on the number of keyed states in an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T151728Z" creationid="xccui" creationdate="20190724T041331Z">
        <seg>但遗憾的是它的内存占用量没有什么直观的计算方法，因为具体值取会决于应用中键值分区状态的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, the Flink Docker image we used in the Docker and Kubernetes examples before does not support setting custom con‐ figuration parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190722T005028Z">
        <seg>很可惜，我们在先前Docker和Kubernetes示例中用到的Flink Docker镜像还不支持自定义配置参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, there are no standard interfaces for most of these storage systems, except JDBC for relational DBMS.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T193852Z" creationid="xccui" creationdate="20190708T193531Z">
        <seg>然而遗憾的是，除了关系型数据库系统有JDBC外，这些存储系统大都缺乏标准的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Union</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T063514Z" creationid="xccui" creationdate="20190614T063514Z">
        <seg>Union</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Union list state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T035905Z" creationid="xccui" creationdate="20190607T184319Z">
        <seg>联合列表状态（union list state）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unique identifiers should be specified for every operator of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015328Z" creationid="xccui" creationdate="20190703T015220Z">
        <seg>你应该为应用中的每个算子指定唯一标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless you opt for a very conservative watermark strategy that guarantees that all relevant records will be included at the cost of high latency, your application will most likely have to handle late elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T151659Z" creationid="xingcan" creationdate="20190628T145930Z">
        <seg>除非你选择一种非常保守的水位线生成策略，以高延迟为代价确保涵盖全部相关记录，否则你的应用将很有可能需要处理迟到的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless you specify a parallelism, a program is executed by as many threads as the number of CPU threads of your development machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T093225Z" creationid="xccui" creationdate="20190611T053929Z">
        <seg>除非手工指定并行度，否则程序的线程数会和你开发机器的CPU线程数一样多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike batch applications, which are built around the premise that all data is avail‐ able, the latency/completeness tradeoff is a fundamental characteristic of stream pro‐ cessing applications, which process unbounded data as it arrives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T061402Z" creationid="xccui" creationdate="20190621T042217Z">
        <seg>对于批处理应用而言，构建的前提是所有数据都处于可用状态。而流处理应用需要应对随时到来的无限数据，因此要在延迟和完整性之间进行取舍是它的一项基本特点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until Flink 1.7, the only sup‐ ported compression algorithm is Snappy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T033901Z" creationid="xccui" creationdate="20190731T204706Z">
        <seg>截至1.7版本，内置的压缩算法还只有Snappy。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until the rise of Apache Hadoop, specialized analytical database systems and data warehouses were the predominant solutions for data analytics workloads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T203754Z" creationid="xccui" creationdate="20190228T194848Z">
        <seg>在Apache Hadoop出现前，专业分析型数据库系统和数据仓库共同占据着数据分析的江山。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until today, more than 470 individuals have contributed to Flink and it has evolved into one of the most sophisticated open source stream processing engines as proven by its widespread adoption.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T222146Z" creationid="xccui" creationdate="20190225T220444Z">
        <seg>时至今日，它已经有超过470名贡献者，并在不断普及的过程中逐渐演变为开源界最为复杂的流处理引擎之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Up to this point, we have considered streaming concepts independently of Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T195220Z" creationid="xccui" creationdate="20190416T051823Z">
        <seg>到目前为止，我们考虑的流处理相关概念都还是独立于Apache Flink的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating Results by Including Late Events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150802Z" creationid="xccui" creationdate="20190225T023500Z">
        <seg>基于迟到事件更新结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating an Application without Modifying Existing State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="xccui" creationdate="20190225T024908Z">
        <seg>保持现有状态更新应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating or extending the logic of an application without changing or removing an existing state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T040022Z" creationid="xccui" creationdate="20190705T035553Z">
        <seg>在不对已有状态进行更改或删除的前提下更新或扩展应用逻辑，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating the event time of a task with watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025639Z" creationid="xccui" creationdate="20190607T025639Z">
        <seg>利用水位线更新任务的事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uploads a JAR file to the cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045633Z" creationid="xccui" creationdate="20190729T045633Z">
        <seg>将JAR文件上传到集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon completion of a check‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T150247Z" creationid="xccui" creationdate="20190606T150247Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon receiving a latency marker, all opera‐ tors except sinks forward it downstream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T055151Z" creationid="xccui" creationdate="20190806T055151Z">
        <seg>在收到延迟标记后，除数据汇以外的所有算子都会将它们转发到下游。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon the completion of a checkpoint, i.e., when all tasks have successfully written their state into the remote storage, the JobManager writes the state handles to the remote storage and a pointer to this location to ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051010Z" creationid="xccui" creationdate="20190502T050555Z">
        <seg>在checkpoint即将完成之际，如果所有任务已经将各自状态成功写入远程存储，JobManager就会将状态句柄写入远程存储，并将远程位置的指针写入ZooKeeper。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a binary distribution of Flink that was built for a particular Hadoop version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025442Z" creationid="xccui" creationdate="20190722T010348Z">
        <seg>使用针对特定Hadoop版本构建的Flink二进制发行版。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the information and instructions contained in this work is at your own risk.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210741Z" creationid="esouser" creationdate="20190603T210741Z">
        <seg>Use of the information and instructions contained in this work is at your own risk.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the Hadoop-free distribution of Flink and manually configure the classpath for Hadoop’s dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025555Z" creationid="xccui" creationdate="20190722T025432Z">
        <seg>使用不带Hadoop的Flink发行版并为Hadoop依赖手动配置Classpath。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used for program listings, as well as within paragraphs to refer to program ele‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210803Z" creationid="esouser" creationdate="20190603T210803Z">
        <seg>Used for program listings, as well as within paragraphs to refer to program ele‐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User functions can employ keyed state to store and access state in the context of a key attribute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T035526Z">
        <seg>用户函数可以使用键值分区状态来存储和访问当前键值上下文中的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-code class loaders are disposed of when the corresponding job terminates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T050648Z" creationid="xccui" creationdate="20190723T050648Z">
        <seg>用户代码类加载器会在相应的作业结束时销毁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-defined timestamp assignment functions are usually applied as close to a source operator as possible because it can be very difficult to reason about the order of records and their timestamps after they have been processed by an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T041030Z" creationid="xccui" creationdate="20190607T040633Z">
        <seg>用户自定义的时间戳分配函数通常都会尽可能地靠近数据源算子，因为在经过其他算子处理后，记录顺序和它们的时间戳会变得难以推断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users are organized in teams and the application collects a team’s activity and provides rewards in the game, such as extra lives and level-ups, based on how fast the team’s members meet the game’s goals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154428Z" creationid="xccui" creationdate="20190411T144758Z">
        <seg>该应用将用户组织成不同团队，并会收集每个团队的活动信息，这样就能基于团队成员完成游戏目标的速度，提供诸如额外生命或等级提升的游戏奖励</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users have reported applications with state sizes of multiple terabytes leveraging RocksDBStateBackend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025108Z" creationid="xccui" creationdate="20190704T025108Z">
        <seg>已经有用户介绍使用RocksDBStateBackend支撑起了状态大小为数个TB的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Code Examples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210812Z" creationid="esouser" creationdate="20190603T210812Z">
        <seg>Using Code Examples</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Connected Broadcast State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T205903Z" creationid="xccui" creationdate="20190225T024605Z">
        <seg>使用联结的广播状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a timestamp assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044614Z" creationid="xccui" creationdate="20190620T044614Z">
        <seg>使用时间戳分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using logging in a MapFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034106Z" creationid="xccui" creationdate="20190807T034106Z">
        <seg>在MapFunction中使用日志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210933Z" creationid="xccui" creationdate="20190609T063118Z">
        <seg>保存点的使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using task parallelism you can better uti&lt;t0/&gt;‐&lt;t1/&gt; lize the computing resources of a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034154Z" creationid="xccui" creationdate="20190401T032431Z">
        <seg>通过任务并行，可以更好地利用集群的计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using task parallelism, you can better utilize the computing resources of a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233318Z" creationid="xccui" creationdate="20190605T233318Z">
        <seg>通过任务并行，可以更好地利用集群的计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the CheckpointedFunction Interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024618Z" creationid="xccui" creationdate="20190225T024618Z">
        <seg>使用CheckpointedFunction接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the DataSet API you can also define iterative Flink programs that exe‐ cute a loop function for a fixed number of steps or until a convergence criterion is met.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T154201Z" creationid="xingcan" creationdate="20190807T154201Z">
        <seg>你还可以使用DataSet API定义用于迭代的Flink程序，它们可以以固定次数执行循环函数或直至满足收敛调节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the DropwizardHistogramWrapper</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033620Z" creationid="xccui" creationdate="20190803T033620Z">
        <seg>使用DropwizardHistogramWrapper</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the interval join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025827Z" creationid="xccui" creationdate="20190628T025827Z">
        <seg>使用基于间隔的Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using these exam‐ ples, we will show how Flink applications are executed and debugged in an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T040616Z" creationid="xccui" creationdate="20190610T040506Z">
        <seg>这些示例将向你展示如何在IDE中执行和调试Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually the RichSinkFunction interface is used because sink functions typically need to set up a connection to an external system in the RichFunction.open() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024655Z" creationid="xccui" creationdate="20190714T024537Z">
        <seg>通常我们会使用RichSinkFunction抽象类，因为数据汇函数经常需要在RichFunction.open()方法里建立和外部系统的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually, the master process has moderate memory requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T062952Z" creationid="xccui" creationdate="20190723T062915Z">
        <seg>通常，主进程对于内存的要求并不苛刻，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually, the program’s</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T051407Z" creationid="xccui" creationdate="20190611T051407Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>V), contains(key: K), remove(key: K), and iterators over the contained entries, keys, and values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T060004Z" creationid="xccui" creationdate="20190630T060004Z">
        <seg>以及用于遍历所含条目（entry）、键和值的遍历器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Valid options are:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T032225Z" creationid="xccui" creationdate="20190709T032119Z">
        <seg>可选的配置项有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T061436Z" creationid="xccui" creationdate="20190607T192625Z">
        <seg>单值状态（value state）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ValueState[Double]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T044243Z" creationid="xccui" creationdate="20190705T044243Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ValueState[T] holds a single value of type T. The value can be read using Value State.value() and updated with ValueState.update(value: T).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T021107Z" creationid="xccui" creationdate="20190630T041507Z">
        <seg>ValueState[T]用于保存类型为T的单个值。你可以利用ValueState.value()来读取该值并通过ValueState.update(value: T)来更新它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vasia is a PMC member of the Apache Flink project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T035031Z" creationid="xccui" creationdate="20190808T035031Z">
        <seg>瓦西里基同样是Apache Flink项目的PMC成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vasiliki Kalavri is a postdoctoral fellow in the Systems Group at ETH Zurich, where she uses Apache Flink extensively for streaming systems research and teaching.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T035006Z" creationid="xccui" creationdate="20190808T035006Z">
        <seg>瓦西里基·卡拉夫里是苏黎世联邦理工学院系统组的博士后研究员，平日里会将Apache Flink广泛用于流式系统研究及教学工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Virtually all data is created as continuous streams of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T034956Z" creationid="xccui" creationdate="20190301T034927Z">
        <seg>几乎所有数据都是以连续事件流的形式产生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>W window,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201906Z" creationid="xccui" creationdate="20190627T201906Z">
        <seg>W window,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>WAL sink         At-most-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170228Z" creationid="xccui" creationdate="20190708T170228Z">
        <seg>WAL数据汇         至多一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>WHERE sensor = ?")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045255Z" creationid="xccui" creationdate="20190714T045255Z">
        <seg>WHERE sensor = ?")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'};</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210042Z" creationid="xccui" creationdate="20190711T210042Z">
        <seg>WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'};</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wait for all in-flight data to be completely processed, meaning all tasks have pro‐ cessed all their input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223921Z" creationid="xccui" creationdate="20190608T223647Z">
        <seg>等待已经流入系统的数据被完全处理，即所有任务已经处理完所有的输入数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Waiting for response...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033900Z" creationid="xccui" creationdate="20190726T033900Z">
        <seg>Waiting for response...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watch us on YouTube: http://www.youtube.com/oreillymedia</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210847Z" creationid="esouser" creationdate="20190603T210847Z">
        <seg>Watch us on YouTube: http://www.youtube.com/oreillymedia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermark Propagation and Event Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144528Z" creationid="xccui" creationdate="20190225T021907Z">
        <seg>水位线传播和事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155415Z" creationid="xccui" creationdate="20190412T155415Z">
        <seg>水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are a powerful way to control the behavior of an application with respect to time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T042448Z" creationid="xccui" creationdate="20190621T042448Z">
        <seg>水位线是一种控制应用时间处理行为的强大方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are essential for both event-time win‐ dows and operators handling out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025515Z" creationid="xccui" creationdate="20190606T025515Z">
        <seg>水位线无论对于事件时间窗口还是处理乱序事件的算子都很关键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are essential to both event-time windows and operators handling out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205616Z" creationid="xccui" creationdate="20190412T205616Z">
        <seg>水位线无论对于事件时间窗口还是处理乱序事件的算子都很关键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are related to record timestamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042558Z" creationid="xccui" creationdate="20190523T042558Z">
        <seg>水位线和记录的时间戳紧密相关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are used to balance latency and result completeness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T024055Z" creationid="xccui" creationdate="20190620T055329Z">
        <seg>水位线可用于平衡延迟和结果的完整性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are used to derive the current event time at each task in an event-time application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T064847Z" creationid="xccui" creationdate="20190606T205105Z">
        <seg>水位线用于在事件时间应用中推断每个任务当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are used to derive the current event-time at each task in an event-time application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T041537Z" creationid="xccui" creationdate="20190523T040931Z">
        <seg>水位线用于推断事件时间应用中每个任务当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks flow in a stream of regular records with annotated timestamps as &lt;t0/&gt;Figure 3-8&lt;t1/&gt; shows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042250Z" creationid="xccui" creationdate="20190523T042250Z">
        <seg>如图3-8所示，它像带有注释时间戳的常规记录一样在数据流中移动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks flow in a stream of regular records with annotated time‐ stamps as Figure 3-8 shows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T051838Z" creationid="xccui" creationdate="20190606T205307Z">
        <seg>如图3-8所示，它们像带有额外时间戳的常规记录一样在数据流中移动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks have two basic properties.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042342Z" creationid="xccui" creationdate="20190523T042339Z">
        <seg>水位线拥有两个基本属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks have two basic properties:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205349Z" creationid="xccui" creationdate="20190606T205348Z">
        <seg>水位线拥有两个基本属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks must be monotonically increasing in order to ensure that the event-time clocks of tasks are progressing and not going backwards.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042533Z" creationid="xccui" creationdate="20190523T042505Z">
        <seg>水位线必须单调递增，这是为了确保任务中的事件时间时钟正确前进，不会倒退。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks provide a configurable trade-off between results confidence and latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210429Z" creationid="xccui" creationdate="20190412T210154Z">
        <seg>水位线允许我们在结果的准确性和延迟之间调整取舍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks provide a configurable tradeoff between results confidence and latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025633Z" creationid="xccui" creationdate="20190606T025603Z">
        <seg>水位线允许我们在结果的准确性和延迟之间做出取舍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks that are very tight, i.e., close to the record timestamps, result in low processing latency because a task will only briefly wait for more records to arrive before finalizing a computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040459Z" creationid="xccui" creationdate="20190529T040214Z">
        <seg>如果水位线很紧密（靠近记录时间戳），得到结果的处理延迟就会很低，因为任务无须等待多少记录到来就可以触发最终计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks that are very tight—close to the record timestamps—result in low processing latency because a task will only briefly wait for more records to arrive before finalizing a computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T052318Z" creationid="xccui" creationdate="20190606T205826Z">
        <seg>如果水位线和记录的时间戳非常接近，那结果的处理延迟就会很低，因为任务无须等待过多记录就可以触发最终计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks, Latency, and Completeness</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030551Z" creationid="xccui" creationdate="20190225T023059Z">
        <seg>水位线、延迟及完整性问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks”, the DataStream API provides two options to assign timestamps and generate watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T035234Z" creationid="xccui" creationdate="20190713T034830Z">
        <seg>DataStream API为分配时间戳和生成水位线提供了两种可选方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We already discussed some of the features of the Context object when introducing the process functions, such as access to the current processing and event-time and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011641Z" creationid="xccui" creationdate="20190624T011641Z">
        <seg>在介绍处理函数的时候，我们已经讨论过Context对象的一些功能，例如访问当前处理时间和事件时间，访问副输出等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also assume per&lt;t2/&gt;‐&lt;t3/&gt; fect failure detectors and that no task will intentionally act maliciously; that is, all non-failed tasks follow the above steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043852Z" creationid="xccui" creationdate="20190415T043600Z">
        <seg>我们还假设任何故障都会被检测到，没有任务故意捣乱。换言之，所有正常运行的任务都会遵循上述步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also assume perfect failure detectors and that no task will intentionally act mali‐ ciously, meaning all nonfailed tasks follow the above steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T200047Z" creationid="xccui" creationdate="20190606T033718Z">
        <seg>我们还假设任何故障都会被检测到，没有任务故意捣乱。换言之，所有正常运行的任务都会遵循上面提到的步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also discuss Flink’s unique savepoint feature, a “Swiss Army knife”-like tool that addresses many challenges of operating streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T063326Z" creationid="xccui" creationdate="20190608T154131Z">
        <seg>此外我们还会讨论Flink所独有的保存点（savepoint）机制，它就像一把瑞士军刀，解决了运行流式应用中的诸多挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also discuss performance aspects and how to control the size of function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T034111Z" creationid="xccui" creationdate="20190630T034111Z">
        <seg>此外，还将讨论性能方面的问题以及如何控制函数状态的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also discussed the semantics of watermarks, how to trade off result com‐ pleteness and result latency, and strategies for handling late events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T213006Z" creationid="xccui" creationdate="20190629T041816Z">
        <seg>我们还讨论了水位线的语义，如何在结果的完整性和延迟之间进行取舍，以及处理迟到事件的相关策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also looked into supported data types and different ways to specify keys and user-defined functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T044237Z" creationid="xccui" creationdate="20190619T044237Z">
        <seg>我们还了解了Flink支持的数据类型以及用于指定键值和用户自定义函数的多种方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also provide complete example applications implemented in Java and Scala in our GitHub repositories.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T034647Z" creationid="xccui" creationdate="20190612T034647Z">
        <seg>我们在Github仓库中同时提供了用Java和Scala实现的完整示例程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also show how to jointly apply incremental aggregation and full window functions in a window operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211919Z" creationid="xccui" creationdate="20190623T211919Z">
        <seg>此外我们还将展示如何在窗口算子上联合应用增量聚合及全量窗口函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We appreciate, but do not require, attribution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210822Z" creationid="esouser" creationdate="20190603T210822Z">
        <seg>We appreciate, but do not require, attribution.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We are grateful to everyone who has contributed to Flink through code, documentation, reviews, bug reports, feature requests, mailing list discussions, trainings, conference talks, meetup organization, and other activities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T143647Z" creationid="xccui" creationdate="20190605T131706Z">
        <seg>感谢所有通过代码、文档、评论、Bug报告、功能需求、邮件列表讨论、培训、会议演讲、聚会组织等一切活动为Flink做出过贡献的人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume reliable network connections, and that no records are dropped or duplicated and all events are eventually delivered to their destination in FIFO order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T190803Z" creationid="xccui" creationdate="20190606T033648Z">
        <seg>我们假设网络连接是可靠的，不存在记录丢失或重复，且所有事件最终都会以先进先出的顺序到达各自终点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume reliable network connections, such that no records are dropped or duplicated and all events are eventually delivered to their destination in FIFO order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043327Z" creationid="xccui" creationdate="20190415T043245Z">
        <seg>我们假设网络连接是可靠的，即不存在记录丢失或重复，所有事件最终都会以先进先出的顺序到达其终点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume the following software is installed as well, although it is not strictly required to develop Flink applications:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T072241Z" creationid="xccui" creationdate="20190611T020130Z">
        <seg>此外，虽不必需，但我们假设以下软件也已装好：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We briefly explain the main concepts of Kafka before we dive into the details of Flink’s Kafka connector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T201753Z" creationid="xccui" creationdate="20190708T201753Z">
        <seg>在深入了解Flink的Kafka连接器之前，我们首先来简单介绍一下Kafka的核心概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We call this type of applications data pipelines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T014229Z" creationid="xccui" creationdate="20190317T014229Z">
        <seg>我们将此类应用称为数据管道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can key the input stream by the second and third fields as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040225Z" creationid="xccui" creationdate="20190618T041209Z">
        <seg>可以像下面这样利用第二、三字段作为输入流的键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can parametrize the above example and pass the String "flink" as a parameter to the KeywordFilter constructor as shown below:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054636Z" creationid="xccui" creationdate="20190618T054636Z">
        <seg>我们为上述示例添加参数并将"flink"字符串以参数形式传给KeywordFilter：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can rewrite the filtering example in the Java DataStream API as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T025256Z" creationid="xccui" creationdate="20190617T015621Z">
        <seg>我们可以像下面这样利用Java DataStream API重写过滤示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We cover</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053544Z" creationid="xccui" creationdate="20190615T053544Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We covered basic streaming operations and how to compute meaningful results on unbounded input data using windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T040418Z" creationid="xccui" creationdate="20190606T040418Z">
        <seg>章节还涵盖了基本的流式操作以及如何利用窗口在无限输入上计算出有意义的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We define sliding windows by providing their length and their &lt;t3/&gt;slide&lt;t4/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024113Z" creationid="xccui" creationdate="20190407T024113Z">
        <seg>我们通过指定长度和滑动间隔来定义滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We define sliding windows by providing their length and their slide.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013255Z" creationid="xccui" creationdate="20190606T013255Z">
        <seg>我们通过指定长度和滑动间隔来定义滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe both interfaces in detail next.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045315Z" creationid="xccui" creationdate="20190620T045315Z">
        <seg>接下来我们详细讨论一下它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe both notions in the fol&lt;t0/&gt;‐&lt;t1/&gt; lowing sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143746Z" creationid="xccui" creationdate="20190412T143518Z">
        <seg>接下来的几节我们来介绍一下它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe both notions in the fol‐ lowing sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155531Z" creationid="xccui" creationdate="20190606T023752Z">
        <seg>我们将在接下来的几节对它们进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe how to assign operator identifiers in detail in “Specifying Unique Operator Identifiers” on page 168.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T030854Z" creationid="xccui" creationdate="20190610T030851Z">
        <seg>有关分配算子标识的详细内容会在168页"指定唯一算子标识"中介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the classes of applications as distinct patterns to emphasize the versatility of stateful stream processing, but most real-world applications share the properties of more than one class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T033527Z" creationid="esouser" creationdate="20190603T212509Z">
        <seg>为了突出状态化流处理的用途之多，我们将不同的应用类别区分地很明显，而事实上大多数真实应用都会同时具有多种类别的特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the classes of applications as distinct patterns to emphasize the versatility of stateful stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T072714Z" creationid="xccui" creationdate="20190305T155234Z">
        <seg>为了突出状态化流处理的不同用途，我们假设每种应用类别模式单一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the steps for a UNIX environment, but if you are running Windows, we recommend setting up a virtual machine with Linux, Cygwin (a Linux environment for Win‐ dows), or the Windows Subsystem for Linux, introduced with Windows 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T065236Z" creationid="xccui" creationdate="20190605T122711Z">
        <seg>我们假设以下步骤都是针对UNIX环境，如果你用Windows，我们建议你配置一个Linux虚拟机，也可以安装Cygwin（一个Windows下的Linux环境）或配置WSL（Windows Subsystem for Linux，Windows 10中新加的功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the steps for a UNIX environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060116Z" creationid="xccui" creationdate="20190328T055241Z">
        <seg>我们将以类UNIX环境为例介绍操作步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We did not provide a comprehensive configu‐ ration guide; instead, we refer you to the official documentation of Apache Flink for a complete list and detailed descriptions of all configuration options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T152403Z" creationid="xccui" creationdate="20190725T042222Z">
        <seg>虽然章节中没有提供完整的配置指南，但所有相关内容都可以从Apache Flink官方文档找到，在那里你可以获取完整配置列表以及所有配置项的详细说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss CoProcessFunction in Chapter 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045349Z" creationid="xccui" creationdate="20190615T045349Z">
        <seg>有关CoProcessFunction的内容会在第6章讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss Flink’s fault-tolerance algorithm in &lt;t2/&gt;Chapter 3&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045041Z" creationid="xccui" creationdate="20190416T045041Z">
        <seg>我们会在第3章讨论Flink的容错算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss Flink’s fault-tolerance algorithm in “Checkpoints, Save‐ points, and State Recovery” on page 58.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194306Z" creationid="xccui" creationdate="20190606T035001Z">
        <seg>我们会在第58页"检查点、保存点和状态恢复"一节讨论Flink的容错算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss all these matters in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042314Z" creationid="xccui" creationdate="20190415T042227Z">
        <seg>我们将在本节一一讨论这些问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss both cases separately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210504Z" creationid="xccui" creationdate="20190711T210504Z">
        <seg>我们会分别对二者进行讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss how a stream processor can provide accurate results with out-of-order events and how you can perform historical event processing and time travel with streaming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T061603Z" creationid="xccui" creationdate="20190409T210351Z">
        <seg>我们将讨论流处理引擎如何基于乱序事件产生精确结果，以及如何使用数据流进行历史事件处理及"时间旅行"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss in &lt;t8/&gt;Chapter 10&lt;t9/&gt; how to control the scheduling of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062903Z" creationid="xccui" creationdate="20190424T062903Z">
        <seg>我们将在第10章讨论如何控制任务调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss in “Tuning Checkpointing and Recovery” on page 263 how to use and configure state backends in your application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T030104Z" creationid="xccui" creationdate="20190704T025917Z">
        <seg>我们会在第263页"调整检查点及恢复"一节讨论具体如何在应用中使用和配置状态后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the consistency guarantees of a WAL sink in more detail in “GenericWriteAheadSink”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T074848Z" creationid="xccui" creationdate="20190708T074848Z">
        <seg>我们会在"GenericWriteAheadSink"一节更详细地讨论WAL数据汇的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the details of this interface later in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T185251Z" creationid="xccui" creationdate="20190710T185251Z">
        <seg>我们会在本章后面讨论此接口的详情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the implementation of a user-defined function in a later sec‐ tion of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054002Z" creationid="xccui" creationdate="20190612T032346Z">
        <seg>有关用户自定义函数的实现会在本章后面部分讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the importance of unique operator identifiers and the mapping of savepoint state in more detail in “Savepoints” on page 66.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023837Z" creationid="xccui" creationdate="20190703T023432Z">
        <seg>有关唯一算子标识的重要性及保存点状态的映射规则已经在第66页"保存点"一节详细讨论过了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the responsibilities of each component and how it interacts with the other components in the following.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033707Z" creationid="xccui" creationdate="20190418T033707Z">
        <seg>我们接下来讨论各组件的职责以及它们之间是如何交互的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the semantics of all operators available in Flink in &lt;t2/&gt;Chapter 5&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T160141Z" creationid="xccui" creationdate="20190405T160124Z">
        <seg>我们将在第5章讨论Flink中各算子的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the semantics of all operators available in Flink in Chapter 5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061013Z" creationid="xccui" creationdate="20190606T011752Z">
        <seg>我们将在第5章讨论Flink中每个算子的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the topic of application deployment in more detail in &lt;t2/&gt;Chap&lt;t3/&gt;‐&lt;t4/&gt; &lt;t5/&gt;ter 10&lt;t6/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041129Z" creationid="xccui" creationdate="20190423T041129Z">
        <seg>我们会在第10章节详细讨论应用部署的相关内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss these options in more detail in “Tuning Checkpointing and Recovery” on page 263.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T014548Z" creationid="xccui" creationdate="20190702T211306Z">
        <seg>我们会在第263页"调整检查点和恢复"一节详细讨论这些选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss this difference later in this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184754Z" creationid="xccui" creationdate="20190607T184716Z">
        <seg>详细内容将在本章稍后讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss this function in  detail in “Assigning Timestamps and Generating Watermarks” as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040454Z" creationid="xccui" creationdate="20190607T040402Z">
        <seg>我们同样会在"分配时间戳和生成水位线"一节详细讨论它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss two different styles of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141158Z" creationid="xccui" creationdate="20190606T141158Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discussed Flink’s strategies to scale stateful operators earlier in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T220025Z" creationid="xccui" creationdate="20190609T220025Z">
        <seg>我们已经在本章前面讨论过Flink对于状态化算子的扩缩容策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We dis‐ cuss the topic of application deployment in more detail in “Running and Managing Streaming Applications” on page 245.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144314Z" creationid="xccui" creationdate="20190606T144314Z">
        <seg>我们会在245页的"运行和管理流式应用"一节详细讨论应用部署的相关内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We dis‐ cussed how open source stream processing systems have evolved since their inception in the early 2010s and how stream processing became a viable solution for many use cases of today’s businesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T202100Z" creationid="xccui" creationdate="20190605T125312Z">
        <seg>我们讨论了开源流处理系统如何从二十世纪初逐步进化，成为针对目前很多企业用例的可行解决方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We don't use processing time timers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T053345Z" creationid="xccui" creationdate="20190626T200921Z">
        <seg>我们不使用处理时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We encourage you to become an active part of its community.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T055011Z" creationid="xccui" creationdate="20190807T040757Z">
        <seg>最后，欢迎加入社区，为项目添砖加瓦！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We examined the structure of Flink programs and learned how to combine data and partitioning trans‐ formations to build streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T044025Z" creationid="xccui" creationdate="20190619T044025Z">
        <seg>我们研究了Flink程序的结构，学习了如何将数据和分区转换结合来构建流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explain Flink setups for dif‐ ferent Hadoop versions and filesystems and discuss the most important configuration parameters of Flink’s master and worker processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T032240Z" creationid="xccui" creationdate="20190717T032054Z">
        <seg>我们将介绍基于不同Hadoop版本和文件系统的Flink搭建过程，并讨论Flink主进程及工作进程最为重要的配置参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explain how state is stored and maintained by state backends and how stateful applications can be scaled by redistributing state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T055824Z" creationid="xccui" creationdate="20190607T053446Z">
        <seg>我们将解释如何利用状态后端（state backend）对状态进行存储和维护，以及状态化应用如何通过状态再分配实现扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explain their semantics and show code examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T025327Z" creationid="xccui" creationdate="20190613T025327Z">
        <seg>我们将结合代码示例对它们的语义进行解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explained how to add connector dependen‐ cies in “Including External and Flink Dependencies” on page 107.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T200431Z" creationid="xccui" creationdate="20190708T200431Z">
        <seg>我们已经在第107页"导入外部和Flink依赖"中介绍了如何添加连接器依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explained how to configure the time characteristics of a streaming applica‐ tion and how to assign timestamps and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041548Z" creationid="xccui" creationdate="20190629T041449Z">
        <seg>我们解释了如何为流式应用配置时间特征以及如何分配时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explained how to enable support for various filesystems and how to integrate them with Hadoop and its components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T042018Z" creationid="xccui" creationdate="20190725T041942Z">
        <seg>随后我们解释了如何支持多种文件系统以及如何与Hadoop及其组件进行集成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explained the Flink component that collects and exposes system and application metrics, how to configure a logging system, and how to start, stop, resume, and rescale applications with the command-line client and the REST API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040107Z" creationid="xccui" creationdate="20190807T040107Z">
        <seg>我们介绍了用于收集和公开系统及应用指标的Flink组件，还向你展示了如何配置日志系统，如何使用命令行客户端和REST API来启动、停止、恢复应用和对其进行扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We express these performance requirements in terms of &lt;t4/&gt;latency &lt;t5/&gt;and&lt;t6/&gt; throughput&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151521Z" creationid="xccui" creationdate="20190401T151311Z">
        <seg>我们用延迟和吞吐来表示这两方面的性能需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We express these performance requirements in terms of latency and throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233804Z" creationid="xccui" creationdate="20190605T233804Z">
        <seg>我们用延迟和吞吐来表示这两方面的性能需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We first show the keyBy() case:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050002Z" creationid="xccui" creationdate="20190615T050002Z">
        <seg>我们首先来看一下keyBy()的情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have a web page for this book, where we list errata, examples, and any additional information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210842Z" creationid="esouser" creationdate="20190603T210842Z">
        <seg>We have a web page for this book, where we list errata, examples, and any additional information.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have to point out that Flink’s checkpointing and recovery mechanism only resets the internal state of a streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T053624Z" creationid="xccui" creationdate="20190609T053610Z">
        <seg>我们必须指出，Flink的检查点和恢复机制仅能重置流式应用内部的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We hope that after reading this chapter, you will be able to evaluate the features of modern stream processing systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T042948Z" creationid="xccui" creationdate="20190605T224722Z">
        <seg>希望阅读过后，你能对时下不同流处理系统的功能进行评估。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We hope that after reading this chapter, you will have gained a better understanding of stream applications requirements and you will be able to evaluate the features of modern stream processing systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T054105Z" creationid="xccui" creationdate="20190329T053836Z">
        <seg>我们希望你在读完本章后能对流处理应用的需求有一个更深刻的理解并可以对当下不同的流处理系统进行功能评估。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We know of a company that decided to built the backend of a social network based on an event log and event-driven applications because of these features.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190313T010445Z" creationid="xccui" creationdate="20190313T010445Z">
        <seg>据我们所知，正是因为上述功能，有公司决定基于事件日志和事件驱动型应用来构建社交网络后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We list some of these configuration options and their default val‐ ues in Table 10-17.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T042928Z" creationid="xccui" creationdate="20190804T042928Z">
        <seg>我们在表10-17中列出了一些配置选项和它们的默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We looked at the dataflow programming model and learned how streaming applications can be expressed as distributed dataflow graphs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035532Z" creationid="xccui" creationdate="20190606T035500Z">
        <seg>我们介绍了Dataflow编程模型以及如何将一个流式应用表示为分布式Dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We need to specify the key by calling keyBy() on the input stream before we apply the function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062633Z" creationid="xccui" creationdate="20190630T062633Z">
        <seg>即在应用函数之前需要在输入流上调用keyBy()方法来指定键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We now look at these parts in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044534Z" creationid="xccui" creationdate="20190612T044457Z">
        <seg>接下来我们详细介绍一下这些步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We now turn to another extremely important aspect of stream processing—state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031403Z" creationid="xccui" creationdate="20190606T031350Z">
        <seg>我们现在要转向流处理中另一个十分重要的方面——状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We now turn to examine another extremely important aspect of stream processing, state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050456Z" creationid="xccui" creationdate="20190414T050456Z">
        <seg>我们现在要转而研究流处理中另一个十分重要的方面——状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We present the transformations of the DataStream API in four categories:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024132Z" creationid="xccui" creationdate="20190613T024132Z">
        <seg>我们将DataStream API的转换分为四类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We present two different styles of deploying Flink applications and dis&lt;t0/&gt;‐&lt;t1/&gt; cuss how tasks are distributed and executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033310Z" creationid="xccui" creationdate="20190418T033020Z">
        <seg>随后，我们会给出部署Flink应用的两种类型，并讨论如何分配和执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We presented Flink’s most commonly used built-in source and sink connectors, which also serve as representatives for dif‐ ferent types of storage systems, such as message queues, filesystems, and key-value stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T214016Z" creationid="xccui" creationdate="20190716T214016Z">
        <seg>我们介绍了Flink中最为常用的内置数据源及数据汇连接器。事实上，它们还分别代表了不同类型的存储系统，例如消息队列、文件系统及键值存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We pre‐ sented the mode of operation and internals of Flink’s HA setup in more detail in “Highly Available Setup” on page 42.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T050042Z" creationid="xccui" creationdate="20190720T045358Z">
        <seg>有关操作模式及Flink HA设置的内部原理已经在第42页"高可用性设置"中详细介绍过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We recommend setting up Minikube if you would like to try to run Flink on Kubernetes and do not have a Kubernetes cluster at hand.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T023610Z" creationid="xccui" creationdate="20190720T023610Z">
        <seg>如果你想尝试在Kubernetes上运行Flink但手头没有Kubernetes集群，我们建议你搭建一个Minikube。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We recommend using IntelliJ IDEA.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T030642Z" creationid="xccui" creationdate="20190611T030642Z">
        <seg>本书建议使用IntelliJ IDEA。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We refer you to Apache Flink’s documentation for details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T043829Z" creationid="xccui" creationdate="20190718T043829Z">
        <seg>详细信息请参阅Apache Flink的官方文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We refer you to Flink’s documentation and the logback manual for details on how to set up and configure the backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T035648Z" creationid="xccui" creationdate="20190807T035625Z">
        <seg>有关如何搭建和配置logback后端的详细信息，请参阅Flink文档和logback用户手册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We refer you to the Kafka documentation for details about its con‐ figuration parameters and guidelines for a suitable configuration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T033651Z" creationid="xccui" creationdate="20190710T033651Z">
        <seg>我们建议你参阅Kafka文档来详细了解有关配置属性的信息以及配置指南。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We refer you to the official documentation for a comprehensive list and detailed descriptions of all parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T043506Z" creationid="xccui" creationdate="20190723T043506Z">
        <seg>你可以查看官方文档获取全部配置参数列表及详细说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We show the structure and components of a typical Flink streaming application, discuss Flink’s type systems and the supported data types, and present data and partitioning transformations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T035324Z" creationid="xccui" creationdate="20190612T032259Z">
        <seg>我们将展示常见Flink流式应用的结构及组件，讨论Flink的类型系统和支持的数据类型并介绍数据转换（data transformation）和分区转换（partitioning transformation）操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We start by reviewing conventional data application architectures and point out their limitations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T064612Z" creationid="esouser" creationdate="20190603T163025Z">
        <seg>我们首先将回顾传统数据应用架构并指出其局限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We start reviewing conventional data processing application architectures and point out their limitations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T040526Z" creationid="xccui" creationdate="20190225T222520Z">
        <seg>我们首先将回顾传统数据处理应用架构并指出其局限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We start the discussion of this interface with a question: “Isn’t the 2PC protocol too expensive?”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T195345Z" creationid="xccui" creationdate="20190715T195345Z">
        <seg>在详细讨论该接口之前，我们先来看一个问题："2PC协议代价是否过于昂贵？"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We started with a recap of traditional data infrastruc‐ tures, how business applications are commonly designed, and how data is collected and analyzed in most companies today.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T041116Z" creationid="xccui" creationdate="20190605T124846Z">
        <seg>我们首先回顾了传统的数据基础架构，业务应用的常规设计以及当今大多数公司如何收集和分析数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We strongly recommend assigning unique identifiers to every operator of an applica‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T024723Z" creationid="xccui" creationdate="20190703T023809Z">
        <seg>我们强烈建议你像示例7-10中那样利用uid()方法为应用中的每个算子都分配唯一标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We use an example of a simple streaming application to explain the algorithm step by step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061814Z" creationid="xccui" creationdate="20190609T061814Z">
        <seg>我们通过一个简单流式应用的示例来一步一步解释这个算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will be assuming a UNIX-based setup in the rest of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T071854Z" creationid="xccui" creationdate="20190610T054905Z">
        <seg>我们假设本章其余部分的设置都是基于类UNIX系统来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will be using the Scala repository for the setup, but you should be able to follow the same instructions if you prefer Java.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T091207Z" creationid="xccui" creationdate="20190611T035846Z">
        <seg>我们将选用Scala仓库进行设置，但如果你想用Java，也可以遵循同样的步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will briefly discuss the most common keyed state primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T192620Z">
        <seg>我们接下来简要讨论一下键值分区状态最常用的几个原语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will continue dis‐ cussing these common features by looking in detail at the KeyedProcessFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062135Z" creationid="xccui" creationdate="20190621T052436Z">
        <seg>接下来我们会以KeyedProcessFunction为例来讨论函数的通用功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the WAL mode in more detail later in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T203148Z" creationid="xccui" creationdate="20190711T203148Z">
        <seg>我们会在本节后面更详细地讨论WAL模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the con&lt;t4/&gt;‐&lt;t5/&gt; figuration and setup of Flink clusters in detail in &lt;t6/&gt;Chapter 9&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063849Z" creationid="xccui" creationdate="20190424T063840Z">
        <seg>我们会在第9章讨论搭建和配置Flink集群的详细内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the configuration and setup of Flink clusters in detail in Chapter 9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145157Z" creationid="xccui" creationdate="20190606T145157Z">
        <seg>我们会在第9章讨论搭建和配置Flink集群的详细内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the configuration of highly available Flink setups later in &lt;t4/&gt;Chapter 9&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T040756Z" creationid="xccui" creationdate="20190504T040756Z">
        <seg>我们稍后会在第9章节讨论Flink高可用相关配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the configuration of highly available Flink setups later in “Highly Available Setups”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T074314Z" creationid="xccui" creationdate="20190606T195259Z">
        <seg>我们稍后会在"高可用性设置"一节讨论Flink高可用相关配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the different state backends and their advantages and disadvantages in more detail in “Choosing a State Backend” on page 169.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T054246Z" creationid="xccui" creationdate="20190608T054230Z">
        <seg>我们会在169页"选择状态后端"一节详细讨论不同状态后端的区别以及它们各自的优劣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the recovery mechanism in more detail later in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205154Z" creationid="xccui" creationdate="20190710T205154Z">
        <seg>我们会在本节后面对其恢复机制进行更详细的讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss these</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T043214Z" creationid="xccui" creationdate="20190715T043214Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss this feature in more depth later in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T151825Z" creationid="xingcan" creationdate="20190709T151825Z">
        <seg>我们会在本节后面部分讨论这个功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss this topic in more detail in “Application Consistency Guarantees” on page 184.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T051940Z" creationid="xccui" creationdate="20190613T005758Z">
        <seg>我们会在184页"应用一致性保障"中详细讨论这一话题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will not go into the details of this mode, but among other things, a Docker Compose configuration needs to specify the network configuration so that Flink pro‐ cesses that run in isolated containers can communicate with each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T043801Z" creationid="xccui" creationdate="20190718T043801Z">
        <seg>在此我们不会对该模式进行深入探讨，但要说明一点——Docker Compose脚本内需要指定网络配置以便使运行在独立容器中的Flink进程可以互相通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will present Flink’s more sophisticated checkpointing algorithm later in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224913Z" creationid="xccui" creationdate="20190608T224902Z">
        <seg>而是使用了一种更加复杂的检查点算法，我们会在本节后面介绍该算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will provide you with a brief tour of the additional Flink function‐ ality not included in this book and give you some pointers to further Flink resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T042143Z" creationid="xccui" creationdate="20190807T042000Z">
        <seg>我们将向你简要介绍书中没有涵盖的Flink其他功能，并为你提供更多Flink相关资源的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will show you how to collect metrics and monitor your applications and how to preserve result consistency when you want to update application code or adjust the resources of your application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T051224Z" creationid="xccui" creationdate="20190725T051224Z">
        <seg>我们将向你展示如何收集指标（metrics）和监控应用，以及如何在更新应用代码或调整应用资源时保持结果的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will start by discussing the required software and where you can get the code examples of this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014744Z" creationid="xccui" creationdate="20190610T040332Z">
        <seg>我们会从所需软件以及怎样获取书中示例代码开始讲起。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will take a brief look into the past to see where open source stream processing came from and where it is today.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T040653Z" creationid="xccui" creationdate="20190322T040653Z">
        <seg>我们将通过简要地历史回顾来探索一下开源流处理技术的前世今生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will take a brief look into the past to see where open source stream pro‐ cessing came from and where it is today.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T192839Z" creationid="xccui" creationdate="20190605T050803Z">
        <seg>在此，我们将通过简要的历史回顾来探索一下开源流处理技术的前世今生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will use this example to show‐ case the basic structure of a Flink program and introduce some important features of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T040931Z" creationid="xccui" creationdate="20190612T035257Z">
        <seg>我们将使用该示例展示Flink程序的基本结构并引出DataStream API中的几个重要特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We would like to thank and acknowledge some of them here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T160115Z" creationid="xccui" creationdate="20190605T131312Z">
        <seg>在此由衷地感谢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Web UI.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T040839Z" creationid="xccui" creationdate="20190729T040839Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We’ve also like to thank our technical reviewers who made countless valuable sugges‐ tions helping us to improve the presentation of the content.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063028Z" creationid="xccui" creationdate="20190605T133326Z">
        <seg>我们还要感谢那些给予我们无数宝贵建议的技术评审员们：Adam Kawa、Aljoscha Krettek、Kenneth Knowles、Lea Giordano、Matthias J. Sax、Stephan Ewen、Ted Malaska以及Tyler Akidau，感谢你们为改善内容所做的帮助。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What Does One Minute Mean in Stream Processing?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T153019Z" creationid="esouser" creationdate="20190603T144036Z">
        <seg>流处理场景下一分钟的含义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What You Will Learn in This Book</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T042821Z" creationid="xccui" creationdate="20190225T042455Z">
        <seg>你能从本书学到什么</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What happens when a trigger fires depends on the configured functions of the win‐ dow operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053324Z" creationid="xccui" creationdate="20190625T053324Z">
        <seg>触发器成功触发后的行为取决于窗口算子所配置的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is a task failure?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042327Z" creationid="xccui" creationdate="20190415T042327Z">
        <seg>什么是任务故障？</seg>
      </tuv>
    </tu>
    <tu>
      <note>每分钟还是一分钟？</note>
      <tuv lang="EN-US">
        <seg>What is the meaning of one minute?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T205925Z" creationid="xccui" creationdate="20190225T015542Z">
        <seg>分钟的含义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What should the application do?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154810Z" creationid="xccui" creationdate="20190411T152000Z">
        <seg>此时应用该怎么办？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What we have not discussed yet is the effect that watermarks have on your streaming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T055305Z" creationid="xccui" creationdate="20190620T055232Z">
        <seg>但并没有涉及水位线对于流式应用的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What would &lt;t0/&gt;one minute&lt;t1/&gt; really mean in the context of our streaming application?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T144519Z" creationid="xccui" creationdate="20190409T211131Z">
        <seg>那么一分钟在流式应用的环境下到底是什么含义？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What would one minute really mean in the context of our streaming application?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T153519Z" creationid="xccui" creationdate="20190606T014710Z">
        <seg>那么一分钟在流式应用环境中的含义到底是什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, by reducing the stream history to a single aggre&lt;t0/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043806Z" creationid="xccui" creationdate="20190406T043701Z">
        <seg>此外，将整条历史流合并为单个聚合值会丢失数据随时间变化的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, by reducing the stream history to a single aggre‐ gate, you lose the information about how your data varies over time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012316Z" creationid="xccui" creationdate="20190606T012316Z">
        <seg>此外，将整条历史流合并为单个聚合值会丢失数据随时间变化的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, streaming applications that process events as they are produced should also be able to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052607Z" creationid="xccui" creationdate="20190409T202149Z">
        <seg>此外，处理实时事件的流处理应用还应以相同的方式处理历史事件，这样才能支持离线分析、甚至那些比较不同历史区间的分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, streaming applica‐ tions that process events as they are produced should also be able to process historical events in the same way, thus enabling offline analytics or even time travel analyses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T061459Z" creationid="xccui" creationdate="20190606T014415Z">
        <seg>此外，处理实时事件的流处理应用还应以相同的方式处理历史事件，这样才能支持离线分析，甚至时间旅行式分析（time travel analyse）（译者注：利用重放对不同历史区间的数据进行分析）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, when combined with re-playable streams, the determinism of time&lt;t0/&gt;‐&lt;t1/&gt; stamps gives you the ability to &lt;t2/&gt;fast-forward&lt;t3/&gt; the past.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T154731Z" creationid="xccui" creationdate="20190412T154437Z">
        <seg>而且结合可重放的数据流，时间戳的确定性允许你对历史数据"快进"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, when combined with replayable streams, the determinism of timestamps gives you the ability to fast forward the past.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160545Z" creationid="xccui" creationdate="20190606T025045Z">
        <seg>而且结合可重放的数据流，时间戳所带来的确定性允许你对历史数据"快进"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s the meaning of one minute in this case?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T142442Z" creationid="xccui" creationdate="20190411T152030Z">
        <seg>在上述示例中一分钟的含义又是什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Flink processes a data stream in event-time mode, it evaluates time-based operators based on the timestamps of records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T051122Z" creationid="xccui" creationdate="20190523T040149Z">
        <seg>当Flink以事件时间模式处理数据流时，会根据记录的时间戳触发时间相关算子的计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When GenericWriteAheadSink receives a notification about a completed checkpoint, it emits all records that are stored in the WAL in the segment corresponding to the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T051148Z" creationid="xccui" creationdate="20190715T051148Z">
        <seg>当GenericWriteAheadSink接收到检查点完成通知时，会将WAL内所有对应该检查点的记录发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a DataStream program is submitted to the JobManager for execution, the system creates a dataflow graph and prepares the operators for execu‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T024316Z" creationid="xccui" creationdate="20190616T051014Z">
        <seg>当提交一个DataStream程序到JobManager上执行时，系统会生成一个Dataflow图并准备好用于执行的算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a JobManager fails, all tasks that belong to its application are automatically  cancelled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195013Z" creationid="xccui" creationdate="20190606T194908Z">
        <seg>当JobManager发生故障时，其下应用的所有任务都会自动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a JobManager fails, all tasks that belong to its application are automatically cancelled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T052256Z" creationid="xccui" creationdate="20190502T052211Z">
        <seg>当JobManager发生故障，所有隶属其应用的任务都会自动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a JobManager requests TaskManager slots, the ResourceManager instructs a TaskManager with idle slots to offer them to the JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060731Z" creationid="xccui" creationdate="20190418T050502Z">
        <seg>当JobManager申请TaskManager处理槽时，ResourceManager会指示一个拥有空闲处理槽的TaskManager将其处理槽提供给JobManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a StreamingFileSink receives a record, the record is assigned to a bucket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T212830Z" creationid="xccui" creationdate="20190710T210035Z">
        <seg>在StreamingFileSink接收到一条记录后，会将它分配到一个桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a checkpoint is triggered, the state backend creates a local copy of the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202934Z" creationid="xccui" creationdate="20190609T202934Z">
        <seg>当检查点生成过程触发时，状态后端会为当前状态创建一个本地拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a checkpointed application fails, it will be restarted by bringing up its tasks, recovering their states, including the reading offsets of the source tasks, and continu‐ ing the processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T145530Z" creationid="xingcan" creationdate="20190801T145530Z">
        <seg>当一个生成过检查点的应用发生故障时，它会经过一系列步骤重启，具体包括：启动任务、恢复状态（包括数据源任务的读取偏移）和继续处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a check‐ point is taken, MemoryStateBackend sends the state to the JobManager, which stores it in its heap memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T020339Z" creationid="xccui" creationdate="20190704T020339Z">
        <seg>在生成检查点时，MemoryStateBackend会将状态发送至JobManager并保存到它的堆内存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a container is started from the image, it automatically launches the ResourceManager and JobManager and submits the bundled job for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190606T143716Z">
        <seg>当容器从镜像启动后会自动加载ResourceManager和JobManager，并将绑定的作业提交执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a container is started from this image, it automatically starts a TaskManager, which connects to the ResourceManager and registers its slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042604Z" creationid="xccui" creationdate="20190423T040144Z">
        <seg>当容器启动后会自动运行TaskManager，它负责连接ResourceManager并注册处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a data source task receives the message, it pauses emitting records, triggers a checkpoint of its local state at the state backend, and broadcasts checkpoint barriers with the checkpoint ID via all outgoing stream partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T065112Z" creationid="xccui" creationdate="20190609T063201Z">
        <seg>当一个数据源任务收到消息后，会暂停发出记录，利用状态后端触发生成本地状态的检查点，并把该检查点分隔符连同检查点编号广播至所有传出的数据流分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a file is completely ingested and a checkpoint completed, it can be removed from the directory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T200754Z" creationid="xccui" creationdate="20190710T200754Z">
        <seg>当文件读取完成且系统成功生成检查点后，你可以将文件从目录中删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function registers a StateDescriptor, Flink checks if the state backend has data for the function and a state with the given name and type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T021434Z" creationid="xccui" creationdate="20190701T021106Z">
        <seg>当函数注册StateDescriptor时，Flink会检查状态后端是否包含了函数的数据以及与给定名称、类型相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function registers state, the state store tries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T065110Z" creationid="xccui" creationdate="20190702T065047Z">
        <seg>在函数进行状态注册时，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a job fin&lt;t0/&gt;‐&lt;t1/&gt; ishes, the result is written to persistent storage, and all operator state is lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053639Z" creationid="xccui" creationdate="20190414T053558Z">
        <seg>当一个作业结束，其结果就会写入持久化存储中，同时所有算子的状态将不复存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a job finishes, the result is written to persistent storage, and all operator state is lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182140Z" creationid="xccui" creationdate="20190606T032106Z">
        <seg>每当一个作业结束，其结果都会写入持久化存储中，同时所有算子的状态将不复存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a job is submitted for execution, the Dispatcher starts a JobManager thread, which requests slots from Flink’s ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T214506Z" creationid="xccui" creationdate="20190718T214506Z">
        <seg>当接收到一个提交执行的任务时，Dispatcher会启动一个JobManager线程，负责从Flink的ResourceManager申请处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a job is submitted to the Dispatcher, it spawns a JobManager thread, which requests processing slots from the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T022645Z" creationid="xccui" creationdate="20190718T022645Z">
        <seg>Dispatcher在收到一个提交的作业后，会启动一个JobManager线程用以从ResourceManager请求处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a late element arrives within the allowed lateness period it is handled like an on-time element and handed to the trigger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164831Z" creationid="xingcan" creationdate="20190628T164831Z">
        <seg>在这段额外时间内到达的迟到元素会像按时到达的元素一样交给触发器处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a new element is received, the ReduceFunction is called with the new element and the current value that is read from the window’s state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T035545Z" creationid="xccui" creationdate="20190624T001105Z">
        <seg>每当收到一个新元素，算子都会以该元素和从窗口状态取出的当前聚合值为参数调用ReduceFunction，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a pod is restarted after a failure or when deployments are scaled up or down, the IP address can change.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T023656Z" creationid="xccui" creationdate="20190719T023656Z">
        <seg>当Pod从故障中重启或Deployment进行扩缩容后，它们的IP地址可能会发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a program is submitted for execution, all function objects are serialized using Java serialization and shipped to all parallel tasks of their corresponding operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040901Z" creationid="xccui" creationdate="20190618T054831Z">
        <seg>当程序提交执行时，所有参数对象都会利用Java自身的序列化机制进行序列化，然后发送到对应算子的所有并行任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a savepoint is taken, the states of all tasks are copied to a persistent storage location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215054Z" creationid="xccui" creationdate="20190609T214950Z">
        <seg>在生成保存点的时候，所有任务的状态都会拷贝到某个持久化存储位置上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a sender task and a receiver task run in the same TaskManager process, the sender task serializes the outgoing records into a byte buffer and puts the buffer into a queue once it is filled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193926Z" creationid="esouser" creationdate="20190513T191646Z">
        <seg>当发送任务和接收任务处于同一个TaskManager进程时，发送任务会将要发送的记录序列化到一个字节缓冲区中，一旦该缓冲区占满就会被放到一个队列里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a sink task receives a barrier, it performs a barrier alignment, checkpoints its own state, and acknowledges the reception of the barrier to the JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194118Z" creationid="xccui" creationdate="20190609T194118Z">
        <seg>数据汇任务在收到分隔符后会依次执行分隔符对齐，将自身状态写入检查点，向JobManager确认已接收分隔符等一系列动作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a sink task receives the barrier, it persists its state, prepares the current transaction for committing, and acknowledges the checkpoint at the JobMan‐ ager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T210017Z" creationid="xccui" creationdate="20190715T210000Z">
        <seg>当数据汇任务收到分隔符时，它会将内部状态持久化，为当前事务的提交做好准备，并向JobManager发送检查点的确认消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a sink task receives the notification, it commits all open transactions of previous checkpoints.8 Once a sink task acknowledges its checkpoint, it must be able to commit the corre‐ sponding transaction, even in the case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T212642Z" creationid="xccui" creationdate="20190715T211824Z">
        <seg>数据汇任务在收到通知后，会提交所有和之前检查点相关、处于开启状态的事务。8 一旦它确认完成了检查点就必须能够提交相应的事务，故障情况下也不例外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task processes a record, it automatically scopes the state access to the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191343Z" creationid="xccui" creationdate="20190607T190932Z">
        <seg>当任务在处理一个记录时，会自动把状态的访问范围限制为当前记录的键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a barrier for a new checkpoint, it waits for the arrival of barriers from all its input partitions for the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162050Z" creationid="xccui" creationdate="20190609T161207Z">
        <seg>当任务收到一个新检查点的分隔符时，会继续等待所有其它输入分区也发来这个检查点的分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a checkpoint completion notification, it writes the records of the completed checkpoints to the external system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T035556Z" creationid="xccui" creationdate="20190715T035507Z">
        <seg>当一个任务接收到检查点完成通知时，会将此次检查点周期内的所有记录写入外部系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a record that violates the watermark property and has smaller time&lt;t4/&gt;‐&lt;t5/&gt; stamps than a previously received watermark, it might be the case that the computa&lt;t6/&gt;‐&lt;t7/&gt; tion it would belong to has already been completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035531Z" creationid="xccui" creationdate="20190529T035229Z">
        <seg>当任务接收到一个违反水位线属性、时间戳小于前一个水位线的记录时，该记录本应参与的计算可能已经完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a record that violates the watermark property and has smaller time‐ stamps than a previously received watermark, it may be that the computation it belongs to has already been completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T052123Z" creationid="xccui" creationdate="20190606T205651Z">
        <seg>当任务收到一个违反水位线属性，即时间戳小于或等于前一个水位线的记录时，该记录本应参与的计算可能已经完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a watermark, the following actions take place.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042423Z" creationid="xccui" creationdate="20190529T041904Z">
        <seg>当任务接收到一条水位线记录时会执行以下操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a watermark, the following actions take place:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T070638Z" creationid="xccui" creationdate="20190606T212913Z">
        <seg>当任务接收到一个水位线时会执行以下操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a timer fires, the onTimer() callback function is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060732Z">
        <seg>计时器触发时会调用onTimer()回调函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a window is deleted, the window operator automatically clears the window content and discards the window object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052149Z" creationid="xccui" creationdate="20190626T040254Z">
        <seg>当窗口需要删除时，窗口算子会自动清除窗口内容并丢弃窗口对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a worker pod fails, Kubernetes will automatically restart the failed pod and the application will be recovered (given that checkpointing was activated and properly configured).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T040036Z" creationid="xccui" creationdate="20190720T040036Z">
        <seg>当工作进程Pod发生故障时，Kubernetes会自动重启故障的Pod并恢复应用（前提是已经配置好并激活检查点）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When all records have been successfully emitted, the corresponding checkpoint must be inter‐ nally committed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T051412Z" creationid="xccui" creationdate="20190715T051412Z">
        <seg>当所有记录成功发出后，数据汇需要在内部提交对应的检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is executed, all of its dependencies must be available to the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035540Z" creationid="xccui" creationdate="20190619T035540Z">
        <seg>应用在执行时，必须能够访问到所有依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is started from a savepoint, Flink redistributes the savepoint data to the tasks of the corresponding operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215608Z" creationid="xccui" creationdate="20190609T215601Z">
        <seg>当应用从保存点启动时，Flink会将保存点的数据分发到对应算子的任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is started from a savepoint, the identifiers are used to map a state in the savepoint to the corresponding operator of the started application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T022753Z" creationid="xccui" creationdate="20190703T022449Z">
        <seg>当应用从保存点启动时，会利用这些标识将保存点中的状态映射到目标应用对应的算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is started from a savepoint, the operators of the started applica‐ tion are initialized by looking up the corresponding states from the savepoint using operator identifiers and state names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035026Z" creationid="xccui" creationdate="20190705T034847Z">
        <seg>当应用从保存点启动时，它的算子会使用算子标识和状态名称从保存点中查找对应的状态进行初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is submitted for execution, Flink’s type system tries to automati‐ cally derive the TypeInformation for every data type that is processed by the frame‐ work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T051220Z" creationid="xccui" creationdate="20190617T051220Z">
        <seg>当应用提交执行时，Flink的类型系统会为框架所需处理的每种类型自动推断TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is submitted, the responsible Dispatcher starts a JobManager thread that stores its metadata in the configured persistent storage and a pointer in Zoo‐ Keeper as discussed before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T050147Z" creationid="xccui" creationdate="20190721T045941Z">
        <seg>在应用提交时，当前负责的Dispatcher会启动一个JobManager线程。该线程会像之前介绍的那样将它的元数据存储在配置好的持久化存储中，并将路径写入ZooKeeper。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application receives an event, it can perform arbitrary computations that involve reading data from or writing data to the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T030804Z" creationid="xccui" creationdate="20190305T030739Z">
        <seg>应用收到事件后可以执行包括读写状态在内的任意计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application receives an event, it can perform arbi‐ trary computations that involve reading data from or writing data to the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T205844Z" creationid="esouser" creationdate="20190603T205844Z">
        <seg>应用收到事件后可以执行包括读写状态在内的任意计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an container is started from the image, it automatically launches the ResourceManager and the JobMan&lt;t1/&gt;‐&lt;t2/&gt; ager and hands over the bundled job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T035802Z" creationid="xccui" creationdate="20190423T032325Z">
        <seg>当容器从映像启动后会自动加载ResourceManager和JobManager，并提交绑定的作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an element arrives at a window operator, it is handed to the WindowAssigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T051534Z" creationid="xccui" creationdate="20190625T051534Z">
        <seg>当一个元素进入窗口算子时会被移交给WindowAssigner。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an event is processed, an application reads its state or updates it by running transac‐ tions against the remote database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T064048Z" creationid="esouser" creationdate="20190603T195529Z">
        <seg>期间每处理一条事件，应用都会通过执行远程数据库系统的事务来读取或更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an event is processed, an application reads its state or updates its state by run&lt;t0/&gt;‐&lt;t1/&gt; ning transactions against the remote database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T162610Z" creationid="xccui" creationdate="20190226T162548Z">
        <seg>期间每处理一条事件，应用都会通过远程数据库系统的事务来读取或更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an operator receives a watermark with time T, it can assume that no further events with timestamp less than T will be received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205925Z" creationid="xccui" creationdate="20190412T205544Z">
        <seg>当一个算子接收到时间为T的水位线，就可以认为不会再收到任何时间戳小于或等于T的事件了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an operator receives a watermark with time T, it can assume that no further events with time‐ stamp less than T will be received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025434Z" creationid="xccui" creationdate="20190606T025434Z">
        <seg>当一个算子接收到时间为T的水位线，就可以认为不会再收到任何时间戳小于或等于T的事件了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an operator receives the bar‐ rier, it checkpoints it state and sends an acknowledgment message to the JobManager once it is done.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T205637Z" creationid="xccui" creationdate="20190715T205637Z">
        <seg>当算子收到到分隔符时，它会将内部状态写入检查点，并在工作完成后向JobManager发送确认消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When applied on a KeyedStream with an evolving key space, Global Windows will maintain some state for each key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045046Z" creationid="xccui" creationdate="20190626T045046Z">
        <seg>当把GlobalWindows应用于一个键值空间不断变化的KeyedStream时，它会为每个键值维持一些状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When applied on a windowed stream, ReduceFunction incrementally aggregates the elements that are assigned to a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T034235Z" creationid="xccui" creationdate="20190623T224934Z">
        <seg>当被用在窗口化数据流上时，ReduceFunction会对分配给窗口的元素进行增量聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When asked for a new watermark, the assigner returns a watermark with the maximum timestamp minus a 1-minute tolerance interval.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051015Z" creationid="xccui" creationdate="20190620T051015Z">
        <seg>当收到新水位线请求时，该分配器会返回一个时间戳等于最大时间戳减去1分钟容忍间隔的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When being deployed on a container orchestration framework, such as Kubernetes, the framework restarts failed contain‐ ers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T213534Z" creationid="xccui" creationdate="20190730T030456Z">
        <seg>当部署在容器编排框架（如Kubernetes）上时，框架会重启失败的容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When building applications with the DataStream API the sys‐ tem automatically chooses data partitioning strategies and routes data to the correct destination depending on the operation semantics and the configured parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T065209Z" creationid="xccui" creationdate="20190615T065209Z">
        <seg>在使用DataStream API构建程序时，系统会根据操作语义和配置的并行度自动选择数据分区策略并将数据转发到正确的目标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When configuring the memory setting of a TaskManager, you should size the JVM heap memory so there is enough memory left for the JVM nonheap memory (classes and metadata) and RocksDB if it is configured as a state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T041954Z" creationid="xccui" creationdate="20190724T041954Z">
        <seg>在为TaskManager配置内存时，你应该适当调整JVM堆内存的大小，以便为JVM非堆内存（用于类和元数据）和RocksDB（如果选它作状态后端）留下足够多的内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When dealing with a potentially unbounded stream of continuously arriving events, time becomes a central aspect of applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T153413Z" creationid="xccui" creationdate="20190409T210522Z">
        <seg>当处理一个持续到达且可能无穷的事件流时，时间便成了应用中最为核心的要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When discarding pending files it does not reuse</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T183845Z" creationid="xccui" creationdate="20190711T021123Z">
        <seg>它在丢弃一些处于等待阶段的文件时，将不会重用它们的ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When enabled, state backends also store a copy of the checkpoint data on the local disk of their worker node in addition to writing the data to the remote storage system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T160014Z" creationid="xingcan" creationdate="20190801T160014Z">
        <seg>在该功能启用后，状态后端除了将数据写入远程存储系统外，还会将检查点数据在工作进程所在节点的本地磁盘复制一份，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When instructed by the ResourceManager, the TaskManager offers one or more of its slots to a JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062127Z" creationid="xccui" creationdate="20190418T051847Z">
        <seg>当接收到ResourceManager的指示时，TaskManager会向JobManager提供一个或多个处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it receives a watermark from a partition, it updates the respective partition watermark to be the maximum of the received value and the current value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T054006Z" creationid="xccui" creationdate="20190607T024528Z">
        <seg>当收到某个分区传来的水位线后，任务会以接收值和当前值中较大的那个去更新对应分区水位线的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it receives the notification that a check‐ point completed, it commits the transaction and materializes the written results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T162409Z" creationid="xccui" creationdate="20190708T162409Z">
        <seg>直至收到检查点完成通知后，数据汇才会通过提交事务将结果物化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When iterating over the entry set of MapState, the seri‐ alized entries are prefetched from RocksDB and only deserialized when a key or value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T034033Z" creationid="xccui" creationdate="20190704T033458Z">
        <seg>在遍历MapState的条目集（entry set）时，状态后端会从RocksDB中预取出序列化好的所有条目，并只有在实际访问某个键或数据值的时候才会将其反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When merging windows, you need to ensure that the state of all merging windows and their triggers is also appropriately merged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045948Z" creationid="xccui" creationdate="20190626T045948Z">
        <seg>在合并窗口时，需要保证所有目标窗口的状态以及它们的触发器也能够正确合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When none of the predefined partitioning strategies is suitable, you can define your own by using the partitionCustom() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050123Z" creationid="xccui" creationdate="20190616T050123Z">
        <seg>如果所有预定义的分区策略都不合适，你可以利用partitionCustom()方法自己定义分区策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When operating in high- availability mode, the JobManager writes the JobGraph and all required metadata,  such as the application’s JAR file, into a remote persistent storage system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073026Z" creationid="xccui" creationdate="20190606T150048Z">
        <seg>JobManager在高可用模式下工作时，会将JobGraph以及所有所需的元数据（例如应用的JAR文件）写入一个远程持久化存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When operating in high-availability mode, the JobManager writes the JobGraph and all required metadata, such as the application’s JAR file, into a remote persistent storage system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T045712Z" creationid="xccui" creationdate="20190502T045505Z">
        <seg>JobManager在高可用模式下工作时，会将JobGraph以及所有所需的元数据（例如应用的JAR文件）写入到一个远程持久化存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When port forwarding is running, you can access the Web UI at http://localhost:8081.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T143941Z" creationid="xccui" creationdate="20190720T035626Z">
        <seg>在端口转发运行过程中，可以通过http://localhost:8081访问Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When presenting the transformations of the DataStream API, we show the interfaces for all function classes, but mostly use lambda functions instead of function classes in code examples for brevity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053453Z" creationid="xccui" creationdate="20190613T022648Z">
        <seg>在介绍DataStream API的转换时，我们会展示所有函数类的接口。但为了简洁，在绝大多数示例代码中我们会使用Lambda函数而不是函数类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When properly configured, you will find the following log message in the TaskManager logs:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T055827Z" creationid="xccui" creationdate="20190706T055827Z">
        <seg>正确配置后，你会在TaskManager的日志中看到以下信息：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When reading from Kafka version 0.10 or later, the consumer will automatically extract the message timestamp as an event-time timestamp if the application runs in event-time mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T031758Z" creationid="xccui" creationdate="20190709T031758Z">
        <seg>因此，当我们从0.10之后的版本读取数据时，如果应用运行在事件时间模式下，消费者会自动提取消息的时间戳作为事件时间的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When reading from multiple topics, the Kafka connector treats all partitions of all topics the same and multiplexes their events into a single stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T213246Z" creationid="xccui" creationdate="20190708T212838Z">
        <seg>当选择多个主题时，Kafka连接器会对所有主题的分区一直同仁，并将它们的事件混合成为一条数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When recovering from a fail‐ ure, the offsets are restored and the source instance continues reading from the checkpointed offset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T205321Z" creationid="xccui" creationdate="20190708T205321Z">
        <seg>在进行故障恢复时，数据源实例将恢复那些写入检查点的偏移，并从它们指示的位置继续读取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When run without additional parameters, the client prints a help message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T021639Z" creationid="xccui" creationdate="20190726T021639Z">
        <seg>如果在调用时没有提供额外运行参数，客户端会打印帮助消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running Flink on Kubernetes with a master deployment and a worker deploy‐ ment as described in “Kubernetes” on page 228, Kubernetes will automatically restart failed containers to ensure the right number of pods is up and running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T145426Z" creationid="xccui" creationdate="20190721T061832Z">
        <seg>正如我们在第228页"Kubernetes"一节中介绍的那样，当在Kubernetes上使用主进程Deployment及工作进程Deployment启动Flink时，Kubernetes将自动重启故障容器以确保Pod运行数目的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running a data processing system such as Flink in production, it is essential to monitor its behavior to be able to discover and diagnose the cause of performance degradations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T152702Z" creationid="xingcan" creationdate="20190802T152702Z">
        <seg>当你在生产环境中运行像Flink这样的数据处理系统时，必须监控其行为，以便能发现并诊断性能下降的原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running an application as a library deployment in a container environment, such as Kubernetes, failed JobManager or TaskManager containers are usually auto&lt;t0/&gt;‐&lt;t1/&gt; matically restarted by the container orchestration service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T035643Z" creationid="xccui" creationdate="20190504T035046Z">
        <seg>当在容器环境（如：Kubernetes）中将应用作为库部署运行时，容器编排服务通常会自动重启故障的JobManager或TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running an application as a library deployment in a container environment, such as Kubernetes, failed JobManager or TaskManager containers are usually auto‐ matically restarted by the container orchestration service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T190745Z" creationid="xccui" creationdate="20190606T195057Z">
        <seg>如果是在容器环境（如Kubernetes）中以库模式部署运行应用，容器编排服务（orchestration service）通常会自动重启故障的JobManager或TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running on YARN   or on Mesos, Flink’s remaining processes trigger the restart of JobManager or Task‐ Manager processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195152Z" creationid="xccui" creationdate="20190606T195108Z">
        <seg>当运行在YARN或Mesos上面时，Flink的其余进程会触发JobManager或TaskManager进程重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running on YARN or on Mesos, Flink’s remaining processes trigger the restart of JobManager or Task&lt;t2/&gt;‐&lt;t3/&gt; Manager processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T035754Z" creationid="xccui" creationdate="20190504T035708Z">
        <seg>当运行在YARN或Mesos上面时，Flink的剩余进程会触发JobManager或TaskManager进程重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running these commands, Kubernetes starts to deploy the requested contain‐ ers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T033805Z" creationid="xccui" creationdate="20190720T033805Z">
        <seg>运行这些命令会让Kubernetes开始部署所请求的容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When starting a Flink cluster in job mode, the cluster ID is automatically set to the ID of the started application and is therefore unique.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T061540Z" creationid="xccui" creationdate="20190721T061357Z">
        <seg>而在作业模式下启动Flink集群，集群ID会被自动设置为启动应用的ID，因此无须担心唯一性问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When submitting an application to a running Flink cluster, the environment parallelism is set to the default parallelism of the cluster unless it is explicitly specified via the submission client (see “Running and Managing Streaming Applications” on page 245 for more details).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T024446Z" creationid="xccui" creationdate="20190616T053312Z">
        <seg>如果应用是提交到Flink集群运行，那么除非提交客户端明确指定（详情请参阅第245页"运行和管理流式应用"一节），否则环境并行度将设置为集群默认并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When taking a checkpoint, a source operator persists its read‐ ing positions and restores these positions during recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T054116Z" creationid="xccui" creationdate="20190708T054116Z">
        <seg>在生成检查点时，数据源算子会将读取位置持久化并在故障恢复过程中将其还原。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the JAR file is in the classpath, the queryable state threads are automatically started and can</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T040116Z" creationid="xccui" creationdate="20190706T054218Z">
        <seg>如果Classpath中存在该JAR文件，可查询式状态的线程就会自动启动，以响应客户端的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the JobManager receives successful checkpoint notifications from all task instances, it sends the checkpoint completion notification to all interested tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T211513Z" creationid="xccui" creationdate="20190715T211306Z">
        <seg>JobManager在收到从所有任务实例返回的检查点成功的消息后，就会将检查点的完成通知发送至所有相关任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the RollingPolicy decides to roll a file, it is closed and moved into the pending state by renaming it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T190548Z" creationid="xccui" creationdate="20190711T190548Z">
        <seg>当RollingPolicy决定生成新文件时，原文件会被关闭，并通过重命名进入到等待状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the application has been completely defined, it can be executed by call‐ ing StreamExecutionEnvironment.execute().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T052027Z" creationid="xccui" creationdate="20190613T005845Z">
        <seg>在应用定义完成后，你就可以调用StreamExecutionEnvironment.execute()来执行它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the application is restarted, Flink tries to schedule the same tasks to the same worker nodes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T162520Z" creationid="xingcan" creationdate="20190801T162520Z">
        <seg>当应用需要重启时，Flink会尝试将相同的任务调度到和之前相同的工作节点执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the application is started from a savepoint or recovers from a failure, the reading offsets are retrieved from the latest checkpoint or save‐ point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T161935Z" creationid="xccui" creationdate="20190712T161759Z">
        <seg>当应用从某个保存点或故障重新恢复时，它再从最近一次的检查点或保存点中将读取偏移取出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the client submits a job for execution, it connects to the YARN ResourceMan‐ ager to start a new YARN application master process that consists of a JobManager thread and a ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T212643Z" creationid="xccui" creationdate="20190718T212643Z">
        <seg>客户端在提交作业执行时，会连接到YARN的ResourceManager来启动一个新的YARN应用主进程，该进程包括一个JobManager线程和一个ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the filesystem reaches its connection limit and tries to open a new connection, it will block and wait for another connection to close.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T050402Z" creationid="xccui" creationdate="20190722T050402Z">
        <seg>当文件系统已经达到最大连接数并还要尝试创建新连接时，请求会被阻塞，直到某个已有连接关闭。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the first event comes in, it will be immediately processed with the minimum latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052653Z" creationid="xccui" creationdate="20190605T234653Z">
        <seg>当首个事件进入时，系统会立刻以尽可能低的延迟进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the image is deployed as a JobMaster, the container starts a Flink master process that immediately picks up the bundled appli‐ cation to start it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190729T214608Z">
        <seg>当镜像作为JobMaster部署时，容器会启动一个Flink主进程，该进程会立即获取并启动绑定的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the job is started, Flink matches the individual state snapshots of the savepoint to all states of the started application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T045112Z" creationid="xccui" creationdate="20190727T042028Z">
        <seg>作业启动后，Flink会将保存点内的各个状态快照和应用所有状态进行匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the local copy is finished, the task continues its regular processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203350Z" creationid="xccui" creationdate="20190609T203350Z">
        <seg>在本地拷贝创建完成后，任务就可以继续它的常规处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the new version of the application is started from a save‐ point of the previous version, the savepoint contains state that cannot be mapped to the restarted application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043048Z" creationid="xccui" creationdate="20190705T043048Z">
        <seg>当新版本的应用从一个旧版本的保存点启动时，保存点中的部分状态将无法映射到重启的应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the processing method of a function with keyed input is called, Flink’s runtime auto‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T034103Z" creationid="xccui" creationdate="20190630T062841Z">
        <seg>对于一个作用在键值分区输入上的函数而言，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the replay starts, previously emitted results might be overridden by earlier results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T071708Z" creationid="xccui" creationdate="20190708T071708Z">
        <seg>当开始重放数据时，之前发出的结果可能会被更早的结果覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the slide interval is smaller than the window size, the windows overlap and elements can be assigned to more than one window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055232Z" creationid="xccui" creationdate="20190623T055127Z">
        <seg>如果滑动间隔小于窗口大小，则窗口会出现重叠，此时元素会被分配给多个窗口；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the state of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061208Z" creationid="xccui" creationdate="20190701T061208Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the task receives a new record, it accesses the state to get the current count, increments the count, updates the state, and emits the new count.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055111Z" creationid="xccui" creationdate="20190607T054625Z">
        <seg>当任务收到一个新的记录后，首先会访问状态获取当前统计的记录数目，然后把数目增加并更新状态，最后将更新后的数目发送出去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the temperature is over a given threshold and the smoke level is high, the application emits a fire alert.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T061555Z" creationid="xccui" creationdate="20190615T040129Z">
        <seg>当温度超过给定阈值且烟雾指数很高时，应用就会发出火灾警报。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the timer fires, a call‐ back method is called and the context of timer’s key is loaded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T033816Z" creationid="xccui" creationdate="20190704T203711Z">
        <seg>计时器在触发时，会调用回调方法并加载计时器键值的上下文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the timer fires, a new timer is regis‐ tered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195937Z" creationid="xccui" creationdate="20190626T195937Z">
        <seg>当一个计时器触发时又会注册一个新计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the timer of a window fires, the JoinFunction is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T052644Z" creationid="xccui" creationdate="20190628T052644Z">
        <seg>当窗口的计时器触发时，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the train exits the tunnel, she comes back online, and pending events are sent to the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154758Z" creationid="xccui" creationdate="20190411T151545Z">
        <seg>在地铁离开隧道，爱丽丝重新上线后，之前缓存的事件才会发送给应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the trigger condition is met, the bucket contents are sent to an evaluation func&lt;t12/&gt;‐&lt;t13/&gt; tion that applies the computation logic on the bucket elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T045744Z" creationid="xccui" creationdate="20190406T045620Z">
        <seg>当触发条件满足时，桶中的内容会发送给一个计算函数（evaluation function），由它来对桶内元素应用计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the trigger condition is met, the bucket contents are sent to an evaluation function that applies the computation logic on the bucket elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012858Z" creationid="xccui" creationdate="20190606T012803Z">
        <seg>当触发条件满足时，桶内数据会发送给一个计算函数（evaluation function），由它来对桶中的元素应用计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the watermark passes the window’s end timestamp plus the lateness interval, the window is finally deleted and all subsequent late elements are discarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165028Z" creationid="xingcan" creationdate="20190628T165028Z">
        <seg>当水位线超过了窗口结束时间加延迟容忍度间隔，窗口才会被最终删除，此后所有的迟到元素都将直接丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the window border is passed, all the events are sent to an evaluation func‐ tion for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063350Z" creationid="xccui" creationdate="20190606T013021Z">
        <seg>在窗口边界通过后，所有事件会发送给计算函数进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When triggers are merged, all descriptors of custom states must be provided to the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195340Z" creationid="xccui" creationdate="20190626T195318Z">
        <seg>在合并触发器时，需要把所有自定义状态的描述符传给OnMergeContext对象的mergePartitionedState()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using Properties, the list of brokers has to be provided as a "bootstrap.servers" property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T053331Z" creationid="xingcan" creationdate="20190709T151558Z">
        <seg>在使用Properties对象时，需要通过"bootstrap.servers"属性提供Broker列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using a rich function, you can implement two additional methods to the func‐ tion’s lifecycle:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060824Z" creationid="xccui" creationdate="20190618T060824Z">
        <seg>在使用富函数的时候，你可以针对函数生命周期实现两个额外的方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using event-time windows, you can specify an additional time period called allowed lateness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164252Z" creationid="xingcan" creationdate="20190628T164252Z">
        <seg>在使用事件时间窗口时，你可以指定一个名为延迟容忍度（allowed lateness）的额外时间段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using per-window state in a trigger, you need to ensure that this state is prop‐ erly deleted when the window is deleted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T053116Z" creationid="xccui" creationdate="20190626T194100Z">
        <seg>当在触发器中使用了单个窗口状态时，你需要保证它们会随着窗口删除而被正确地清理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using the Scala API or Java 8, the mapper can also be expressed as a lambda function:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053720Z" creationid="xccui" creationdate="20190613T051123Z">
        <seg>在使用Scala API或Java 8时，你还可以通过Lambda函数来表示映射器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When writing messages to a Kafka topic, a Flink Kafka sink task can choose to which partition of the topic to write.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T033938Z" creationid="xccui" creationdate="20190710T033938Z">
        <seg>在将消息写入Kafka某个主题时，Flink Kafka数据汇可以选择写入目标主题的哪个分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you create the deployments for the first time, it will take a while until the Flink container image is downloaded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190720T033928Z">
        <seg>在首次创建Deployment的时候需要花一些时间下载Flink容器镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you enable checkpointing for an application, you have to specify the check‐ pointing interval—the interval in which the JobManager will initiate checkpoints at the sources of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T031046Z" creationid="xccui" creationdate="20190731T030602Z">
        <seg>当你在应用中启用检查点后，必须为其指定生成间隔，即JobManager通过应用数据源初始化检查点的频率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you enter the coffee shop, there might be other customers inside already.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T152836Z" creationid="xccui" creationdate="20190401T152347Z">
        <seg>当你进门的时候，可能已经有别的顾客在里面了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you specify a window to collect events in one-minute buckets, which events exactly will each bucket contain?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T212830Z" creationid="xccui" creationdate="20190619T055110Z">
        <seg>当你指定一个窗口来收集每分钟的桶内事件时，每个桶中需要包含哪些事件？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you submit the application via a submission client and specify the parallelism to be 16, the source will run with a parallelism of 16, the mapper will run with 32 tasks, and the sink will run with 2 tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061928Z" creationid="xccui" creationdate="20190616T061928Z">
        <seg>当你通过提交客户端提交应用且将并行度设置为16时，数据源会以16的并行度运行，map将运行32个任务，数据汇将运行2个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever an idempotent sink connector is not suitable, either the characteristics of the application’s output, the properties of the required sink system, or due to stricter consistency requirements, transactional sink connectors can be an alternative.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T033842Z" creationid="xccui" creationdate="20190715T033842Z">
        <seg>无论是幂等性数据汇不适用于应用的输出特性或所需数据汇系统属性的情况，还是出于更严格的一致性要求，我们都可以选择事务性数据汇连接器作为替代方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where to Go from Here?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040359Z" creationid="xccui" creationdate="20190807T040359Z">
        <seg>还有什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where to Go from Here?.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152414Z" creationid="esouser" creationdate="20190603T152414Z">
        <seg>还有什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where to go from here?.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030219Z" creationid="xccui" creationdate="20190225T030219Z">
        <seg>还有什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether a data source can reset its input stream depends on its implementation and the external system or interface from which the stream is consumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044432Z" creationid="xccui" creationdate="20190609T044221Z">
        <seg>数据源能否重置其输入流取决于它的具体实现以及所消费外部系统是否提供相关接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether this happens with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T035851Z" creationid="xccui" creationdate="20190626T035851Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Alice’s phone loses connection when inside the tunnel, Bob’s phone remains connected and delivers events to the gaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T152314Z" creationid="xccui" creationdate="20190412T152302Z">
        <seg>当爱丽丝的手机在隧道里没信号的时候，鲍勃的手机依然能联网向后端游戏应用发送事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While a sink writes to a file, the file is in the in-progress state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T192239Z" creationid="xccui" creationdate="20190711T190216Z">
        <seg>当数据汇写入文件时，文件会处于进行状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While a task checkpoints its state, it is blocked and its input is buffered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T065533Z" creationid="xccui" creationdate="20190609T200005Z">
        <seg>任务在将其状态存入检查点的过程中，会处于阻塞状态，此时的输入会进入缓冲区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While adding or removing state from an application is rather easy and does not affect savepoint compatibility, modifying the state of an existing operator is more involved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043952Z" creationid="xccui" creationdate="20190705T043840Z">
        <seg>虽然从应用中增删状态非常容易，也不会影响保存点兼容性，但一旦涉及修改已有算子的状态，问题就会变得十分复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While being idle, Flink’s watermark propagation mechanism will</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T051503Z" creationid="xccui" creationdate="20190713T051503Z">
        <seg>在数据源空闲状态下，Flink的水位线传播机制会忽略掉所有空闲的数据流分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While developers have lots of flexibility to interact with state, Flink’s runtime manages tera‐ bytes of state and ensures exactly-once semantics in case of failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T051456Z" creationid="xccui" creationdate="20190707T051134Z">
        <seg>在为开发人员和状态之间提供大量灵活交互的基础上，Flink的运行时可以管理起TB级别的状态且在故障时保证精确一次语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While evictors are optional components, each window operator needs a trigger to decide when to evaluate its windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051634Z" creationid="xccui" creationdate="20190626T015004Z">
        <seg>虽然移除器并非必须，但每个窗口算子都需要一个触发器来决定何时对窗口进行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While in the logical dataflow graph the nodes represent operators, in the physical dataflow, the nodes are tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233139Z" creationid="xccui" creationdate="20190401T003341Z">
        <seg>在逻辑Dataflow图中，顶点代表算子；而在物理Dataflow图中，顶点代表任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it is waiting, it continues pro‐ cessing records from stream partitions that did not provide a barrier yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162506Z" creationid="xccui" creationdate="20190609T162226Z">
        <seg>在等待过程中，它会继续处理那些从还未提供分隔符的分区发来的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While period‐ ically loading data into a data analysis system has been the state of the art for many years, it adds considerable latency to the analytics pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T161829Z" creationid="xccui" creationdate="20190605T043429Z">
        <seg>虽然周期性地将数据导入分析系统在多年来一直是最先进的方法，但它会给分析流程带来相当大的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While previous stream processors only provided either high throughput or low latency, systems of the third generation are able to serve both ends of the spectrum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T134922Z" creationid="xccui" creationdate="20190327T134531Z">
        <seg>前几代的流处理引擎只能在高吞吐和低延迟之中取其一，而第三代的系统可以兼顾两者，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While previous stream processors only pro‐ vide either high throughput or low latency, systems of the third generation are able to serve both ends of the spectrum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T194617Z" creationid="xccui" creationdate="20190605T053538Z">
        <seg>前几代的流处理引擎只能在高吞吐和低延迟之间二选其一，而第三代的系统可以兼顾两者，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While processing the data, the task can read and update its state and compute its result based on its input data and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T060050Z" creationid="xccui" creationdate="20190607T054433Z">
        <seg>在处理这些数据的过程中，任务对其状态进行读取或更新，并根据状态和输入数据计算结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While processing time is easy to understand because it is based on the local time of the processing machine, it produces somewhat arbitrary, incon‐ sistent, and nonreproducible results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204212Z" creationid="xccui" creationdate="20190606T204212Z">
        <seg>虽然处理时间是基于处理机器的本地时间，相对容易理解，但它会产生一些较为随意、不一致且无法重现的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While processing-time is easy to understand because it is based on the local time of the processing machine, it produces somewhat arbitrary, inconsistent, and non-reproducible results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T160158Z" creationid="esouser" creationdate="20190514T160158Z">
        <seg>虽然处理时间是基于处理机器的本地时间，相对容易理解，但它会产生一些较为随意、不一致且无法重现的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While rebalance() will create communication channels between all sending tasks to all receiving tasks, rescale() will only cre‐ ate channels from each task to some of the tasks of the downstream operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T044438Z" creationid="xccui" creationdate="20190616T044438Z">
        <seg>rebalance()会在所有发送任务和接收任务之间建立通信通道；而rescale()中每个发送任务只会和下游算子的部分任务建立通道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While scaling stateless opera‐ tors is trivial, changing the parallelism of stateful operators is much more challenging because their state needs to be repartitioned and assigned to more or fewer parallel tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062723Z" creationid="xccui" creationdate="20190608T054626Z">
        <seg>对于无状态的算子，扩缩容很容易。但对于状态化算子，改变并行度就会复杂很多，因为我们需要把状态重新分组，分配到与之前数量不等的并行任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While some chapters are descriptive and aim to introduce concepts and high-level design, others are more hands-on and contain many code examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191213Z" creationid="xccui" creationdate="20190225T161953Z">
        <seg>书中部分章节会侧重描述概念或高层次的设计理念，而其余章节会更加侧重实践并包含很多示例代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While some chapters are descriptive and aim to introduce high-level design concepts, others are more hands-on and contain many code examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T153029Z" creationid="esouser" creationdate="20190603T152715Z">
        <seg>书中部分章节会侧重描述高层次的设计理念，而其余章节会更加注重实践并包含了很多示例代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While streaming applications are stateful and contin‐ uously running, batch applications are periodically executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T005701Z" creationid="xccui" creationdate="20190726T005526Z">
        <seg>流式应用需要连续运行和维护状态，而批处理应用则会定期执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the application is catching up, the processing latency—the time at which input is available until it is actually processed—increases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T150150Z" creationid="xingcan" creationdate="20190801T150150Z">
        <seg>应用在追赶进度期间，其处理延迟（输入从可用到实际处理的时间间隔）会有所增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the approach of periodically loading data into data analysis systems has been the state-of-the-art for many years, it suffers from a notable drawback.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T031044Z" creationid="xccui" creationdate="20190317T030912Z">
        <seg>虽然周期性地将数据导入分析系统多年来一直是最先进的方法，但它有个明显的缺点，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the first option gives very fast state access, it is limited by the size of the memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053100Z" creationid="xccui" creationdate="20190608T052828Z">
        <seg>前者状态访问会更快一些，但会受到内存大小的限制；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the interface of the AggregateFunction is much more flexible, it is also more complex to implement compared to the interface of the ReduceFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T003513Z" creationid="xccui" creationdate="20190624T003513Z">
        <seg>虽然AggregateFunction和ReduceFunction相比接口更加灵活，但同时实现也更为复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the publisher and the authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210740Z" creationid="esouser" creationdate="20190603T210740Z">
        <seg>While the publisher and the authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this approach is easy to implement, it suffers from a major issue: each request to the external datastore adds significant</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T192155Z" creationid="xccui" creationdate="20190716T192124Z">
        <seg>虽然该方法很容易实现，但它存在一个严重问题：每次请求外部数据库都会带来很多延迟（一次请求和回复过程包含两条网络消息），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this approach provides very low latencies to read or write state, it has</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T222108Z" creationid="xccui" creationdate="20190703T222108Z">
        <seg>虽然这种方法读写状态的延迟会很低，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this behavior seems to be exactly the same as recovering an application from a failure using a checkpoint, failure recovery is actually just a special case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211834Z" creationid="xccui" creationdate="20190609T211646Z">
        <seg>这个行为看上去和利用检查点将应用从故障中恢复完全一致，但其实故障恢复只是一种特殊情况，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this book is particularly focused on stream processing, Flink is in fact a general-purpose distributed data processing framework and can be used for other types of data analysis as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T052701Z" creationid="xccui" creationdate="20190807T052701Z">
        <seg>虽然本书的关注重点在于流处理，但Flink其实是一个通用的分布式数据处理框架，它同样可用于其他类型的数据分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this kind of delay may have been acceptable in the past, applications today must be able to collect data in real-time and immediately act on it (e.g., by adjusting to changing con‐ ditions in a mobile game or by personalizing user experiences for an online retailer).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044455Z" creationid="xccui" creationdate="20190605T043748Z">
        <seg>虽然从过去视角来看，这种延迟可以接受，但当今的应用必须能够实时收集数据并迅速响应（例如调整手游中的某个可变条件或使用户在网购过程中获得个性化体验）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this might yield incomplete or inaccurate results, the results are produced in a timely fashion with lower latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T061234Z" creationid="xccui" creationdate="20190621T040711Z">
        <seg>虽然这会导致结果不完整或不准确，但相应地可以做到以较低延迟及时生成结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we intended for the book to be read in chapter order when we were writing it, readers familiar with a chapter’s content might want to skip it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041545Z" creationid="esouser" creationdate="20190603T153220Z">
        <seg>尽管我们在写书的时候是按照预期阅读顺序进行的章节编排，但如果你已经对某些章节的内容很熟悉，仍可以选择跳过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While worker failures are handled by the ResourceManager, failures of the JobManager component require the configura‐ tion of a highly available (HA) setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T043135Z" creationid="xccui" creationdate="20190720T043135Z">
        <seg>虽然工作进程的故障可以由ResourceManager来解决，但JobManager组件的故障就需要额外的高可用（HA）配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While you might get annoyed by this delay, most other customers will still be happy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051338Z" creationid="xccui" creationdate="20190401T160314Z">
        <seg>虽然你可能因为这次耽搁而不高兴，但这丝毫不会影响其余大多数顾客的心情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While you want latency to be as low as possible, you generally want throughput to be as high as possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234525Z" creationid="xccui" creationdate="20190401T195813Z">
        <seg>通常情况下延迟是越低越好，而显然吞吐则是越高越好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151644Z" creationid="esouser" creationdate="20190603T150722Z">
        <seg>基于窗口的Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023138Z" creationid="xccui" creationdate="20190225T023138Z">
        <seg>窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators | 123</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042004Z" creationid="xccui" creationdate="20190629T042004Z">
        <seg>窗口算子 | 123</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators | 131</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042053Z" creationid="xccui" creationdate="20190629T042053Z">
        <seg>窗口算子 | 131</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators | 133</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042100Z" creationid="xccui" creationdate="20190629T042100Z">
        <seg>窗口算子 | 133</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators | 141</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042104Z" creationid="xccui" creationdate="20190629T042104Z">
        <seg>窗口算子 | 141</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators | 143</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042109Z" creationid="xccui" creationdate="20190629T042109Z">
        <seg>窗口算子| 143</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window assigners</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040902Z" creationid="xccui" creationdate="20190626T040902Z">
        <seg>窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window content</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033002Z" creationid="xccui" creationdate="20190626T033002Z">
        <seg>窗口内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window functions define the computation that is performed on the elements of a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T032101Z" creationid="xccui" creationdate="20190623T205944Z">
        <seg>窗口函数定义了针对窗口内元素的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window lifecycle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T030130Z" creationid="xccui" creationdate="20190626T030130Z">
        <seg>窗口的生命周期</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window object</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033421Z" creationid="xccui" creationdate="20190626T033421Z">
        <seg>窗口对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011951Z" creationid="xccui" creationdate="20190606T011951Z">
        <seg>窗口操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations are closely related to two dominant concepts in stream process&lt;t0/&gt;‐&lt;t1/&gt; ing: time semantics and state management.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T200140Z" creationid="xccui" creationdate="20190409T200114Z">
        <seg>窗口操作与流处理中两个核心概念密切相关：时间语义（time semantics）和状态管理（state management）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations are closely related to two dominant concepts in stream process‐ ing: time semantics and state management.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014214Z" creationid="xccui" creationdate="20190606T014214Z">
        <seg>窗口操作与流处理中两个核心概念密切相关：时间语义（time semantics）和状态管理（state management）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations continuously create finite sets of events called buckets from an unbounded event stream and let us perform computations on these finite sets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022718Z" creationid="xccui" creationdate="20190406T044746Z">
        <seg>窗口操作会持续创建一些称为桶（bucket）的有限事件集合，并允许我们基于这些有限集进行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operators can be applied on a keyed or a nonkeyed stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T023659Z" creationid="xccui" creationdate="20190622T034136Z">
        <seg>窗口算子可用在键值分区或非键值分区的数据流上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operators defined using Flink’s built-in window assigners can address many common use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045320Z" creationid="xccui" creationdate="20190625T045320Z">
        <seg>使用Flink内置窗口分配器定义的窗口算子可以应对许多常见用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operators provide a way to group events in buckets of finite size and apply computations on the bounded contents of these buckets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T023518Z" creationid="xccui" creationdate="20190622T033431Z">
        <seg>窗口算子提供了一种基于有限大小的桶对事件进行分组，并对这些桶中的有限内容进行计算的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operators, time-based transformations, stateful operators, and connectors are discussed in the next chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T035352Z" creationid="xccui" creationdate="20190612T032454Z">
        <seg>有关窗口算子、基于时间的转换、状态化算子以及连接器的内容将在接下来的几章讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window opera‐ tors on keyed windows are evaluated in parallel, and nonkeyed windows are processed in a single thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T035249Z" creationid="xccui" creationdate="20190622T035249Z">
        <seg>用于键值分区窗口的窗口算子可以并行计算，而非键值分区窗口只能单线程处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window policies decide when new buckets are created, which events are assigned to which buckets, and when the con&lt;t10/&gt;‐&lt;t11/&gt; tents of a bucket get evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022740Z" creationid="xccui" creationdate="20190406T045304Z">
        <seg>这些窗口策略决定了什么时间创建桶，事件如何分配到桶中以及桶中的内容什么时间参与计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window policies decide when new buckets are created, which events are assigned to which buckets, and when the contents of a bucket get evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012831Z" creationid="xccui" creationdate="20190606T012724Z">
        <seg>这些窗口策略决定了什么时间创建桶，事件如何分配到桶中以及桶内数据什么时间参与计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window transformations are described in detail in “Window Operators” on page 122.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053825Z" creationid="xccui" creationdate="20190612T053825Z">
        <seg>有关窗口转换的详细内容会在122页"窗口算子"一节介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>WindowFunction has been superseded by ProcessWindow Function and will not be discussed here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010332Z" creationid="xccui" creationdate="20190624T010332Z">
        <seg>但该接口已经被ProcessWindowFunction取代，所以此处我们不再讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035926Z" creationid="xccui" creationdate="20190406T035926Z">
        <seg>窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Windows are common operations in streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T023004Z" creationid="xccui" creationdate="20190622T032841Z">
        <seg>窗口是流式应用中一类十分常见的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Windows with time-based trig‐ gers (both processing time and event time) are not affected by this because they trig‐ ger and purge their state based on time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T195942Z" creationid="xccui" creationdate="20190704T195942Z">
        <seg>基于时间（无论是处理时间还是事件时间）触发的窗口则不受该问题的影响，因为它们会根据不断前进的时间触发计算并清除状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a shuffle or broadcast connection, each sending task needs a buffer for each receiving task; the number of required buffers is quadratic to the number of tasks of the involved operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193617Z" creationid="xccui" creationdate="20190606T201749Z">
        <seg>在Shuffle或广播连接的情况下，每个发送任务都需要为每个接收任务提供一个缓冲区，因此所需的缓冲区数量可达到相关算子任务数的平方级别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the default configuration, each column family requires about 200 MB to 240 MB of off- heap memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T041649Z" creationid="xccui" creationdate="20190724T041649Z">
        <seg>默认配置的情况下，每个列簇需要大约200MB到240MB的堆外内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the exception of being nonparallel and parallel, both interfaces are identical.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T145958Z" creationid="xccui" creationdate="20190712T145819Z">
        <seg>除了并行和非并行外，两个接口没什么区别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the io.tmp.dirs configu‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T042542Z" creationid="xccui" creationdate="20190724T042542Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this book, we hope to reach developers, engineers, and streaming enthusiasts around the world and grow the Flink community even larger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T062952Z" creationid="xccui" creationdate="20190605T132916Z">
        <seg>通过本书，我们期待能够吸引世界各地的开发者、工程师以及流处理爱好者加入，进一步扩大Flink社区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this in mind, you can use watermarks to balance result latency and result completeness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T060816Z" creationid="xccui" creationdate="20190621T033758Z">
        <seg>记住这些，你就可以使用水位线来平衡结果的延迟和完成整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a slot-sharing group, the tasks are assigned to slots as described in “Task Execution” on page 40—each slot processes up to one task of each operator that is a member.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T021619Z" creationid="xccui" creationdate="20190731T013542Z">
        <seg>同一处理槽共享组内的任务会像第40页"任务执行"一节中所介绍的那样分配到不同处理槽中——每个处理槽只能处理同一共享组内每个算子至多一个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within each instance, every dis‐ tinct state of the operator is stored in a separate column family (or table).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T041618Z" creationid="xccui" creationdate="20190724T041618Z">
        <seg>每个实例都会将其独有的算子状态存入单独的列簇（或表）中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing a DataStream into a queryable state sink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062119Z" creationid="xccui" creationdate="20190706T062119Z">
        <seg>将DataStream写入可查询式状态的数据汇中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing a Data‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T013925Z" creationid="xccui" creationdate="20190613T013925Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing a stream into files is a common requirement, for example, to prepare data with low latency for offline ad-hoc analysis.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T203802Z" creationid="xccui" creationdate="20190710T203802Z">
        <seg>将数据流写入文件是一种很常见的需求，例如我们可能需要为离线的即席分析准备延迟较低的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing the event-time timestamp of a record to Kafka is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T041133Z" creationid="xccui" creationdate="20190710T041133Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>YARN grants resources as containers3 that are distributed in the cluster and in which applications run their pro‐ cesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T141048Z" creationid="xccui" creationdate="20190718T210712Z">
        <seg>YARN以容器3 的形式发放资源，这些容器分布在集群之上并允许应用在其中运行自己的进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>YARN is a cluster resource and container manager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T051626Z" creationid="xccui" creationdate="20190721T051626Z">
        <seg>YARN是一个集群资源和容器的管理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>YARN is the resource manager component of Apache Hadoop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T204052Z" creationid="xccui" creationdate="20190718T204052Z">
        <seg>YARN是Apache Hadoop的资源管理器组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>YARN only counts the number of restarts due to application failures—restarts due to preemption, hardware failures, or reboots are not taken into account for the number of application attempts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T144947Z" creationid="xccui" creationdate="20190721T053201Z">
        <seg>YARN只会计算因为应用故障导致重启的次数，而由于抢占、硬件故障或重启等因素导致的重启将不会算在应用尝试次数内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>YARN session in detached mode using the -d flag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T030850Z" creationid="xccui" creationdate="20190719T014323Z">
        <seg>你还可以通过添加-d参数来启动一个分离（detached）模式的YARN会话，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You Should Define Unique Operator IDs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T204944Z" creationid="xccui" creationdate="20190727T045744Z">
        <seg>最好为每个算子定义唯一ID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also know a little bit about the evolution of the open source stream processing space and what a Flink streaming application looks like.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T042338Z" creationid="xccui" creationdate="20190605T224647Z">
        <seg>还了解了开源流处理领域的发展过程以及Flink流式应用的模样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You apply a function on the connected streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040931Z" creationid="xccui" creationdate="20190702T040931Z">
        <seg>在联结后的数据流上应用一个函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are probably not surprised that stateful stream processing is the right technology to build low-latency analytics pipelines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T054805Z" creationid="xccui" creationdate="20190317T054517Z">
        <seg>你应该会理所当然地想到状态化流处理就是构建低延迟分析流水线的恰当技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access it via YARN’s Web UI, which provides a link on the Application Overview page under “Tracking URL: ApplicationMaster.”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T013437Z" creationid="xccui" creationdate="20190719T013437Z">
        <seg>你可以通过YARN的Web UI对其进行访问，具体链接位置在"Tracking URL: ApplicationMaster"下的Application Overview页面上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access the Web UI by opening http://localhost:8081 in your browser.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T035549Z" creationid="xccui" creationdate="20190718T035549Z">
        <seg>你可以在浏览器中打开http://localhost:8081来访问Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access the dashboard</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T033923Z" creationid="xccui" creationdate="20190802T033923Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access the default paral‐ lelism of the environment as shown in the following example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T054220Z" creationid="xccui" creationdate="20190616T054220Z">
        <seg>你可以按照下面的示例来访问环境的默认并行度：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access this page at http://bit.ly/stream-proc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210843Z" creationid="esouser" creationdate="20190603T210843Z">
        <seg>You can access this page at http://bit.ly/stream-proc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can adjust RocksDB’s configuration and tweak its performance with many parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T151835Z" creationid="xccui" creationdate="20190724T041733Z">
        <seg>和调整RocksDB配置及性能相关的参数有很多，你可以自行尝试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T022406Z" creationid="xccui" creationdate="20190711T022406Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also apply a CoProcessFunction to ConnectedStreams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045325Z" creationid="xccui" creationdate="20190615T045325Z">
        <seg>你也可以对ConnectedStreams应用CoProcessFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also build the JAR file yourself by following the steps in the repository’s README file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123551Z" creationid="xccui" creationdate="20190605T123533Z">
        <seg>你也可以根据代码库中README文件的指示自行构建JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also configure the root directories at the remote storage to which checkpoints (state.checkpoints.dir) and savepoints (state.savepoints.dir) are written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T044608Z" creationid="xccui" creationdate="20190724T044608Z">
        <seg>你还可以配置用于写入检查点（state.checkpoints.dir）和保存点（state.savepoints.dir）的远程存储路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also configure the sink to log write only failures by calling setLogFailuresOnly(true) on the sink object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T053414Z" creationid="xingcan" creationdate="20190709T155322Z">
        <seg>还可以在数据汇对象上调用setLogFailuresOnly(true)让它仅将故障写入日志中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define a user scope for metrics by calling the addGroup() method of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T044728Z" creationid="xccui" creationdate="20190804T044728Z">
        <seg>你还可以像示例10-8那样，通过调用MetricGroup的addGroup()方法为指标定义一个用户域。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also delete them if you do not need them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T094817Z" creationid="xccui" creationdate="20190612T010135Z">
        <seg>如果不需要，也可以将它们删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also download the source code of the examples as a zip-archive from GitHub:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T091504Z" creationid="xccui" creationdate="20190611T040419Z">
        <seg>你也可以把示例代码以Zip压缩包的形式从GitHub上下载下来：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also explicitly choose the state backend of an application:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022052Z" creationid="xccui" creationdate="20190801T022052Z">
        <seg>你也可以针对某个应用显式指定状态后端：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also just take a savepoint to version and archive the state of an applica‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213419Z" creationid="xccui" creationdate="20190609T213419Z">
        <seg>你还可以为保存点设置不同版本并将应用状态归档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also override the default parallelism of the environment, but you will no longer be able to control the parallelism of your application via the submission client:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060440Z" creationid="xccui" creationdate="20190616T060440Z">
        <seg>你也可以覆盖环境的默认并行度，然而一旦如此，将再无法通过提交客户端控制应用并行度：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also provide a custom filesystem connector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T050715Z" creationid="xccui" creationdate="20190722T050715Z">
        <seg>你也可以提供自定义的文件系统连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also shutdown a cluster using the REST call that is shown in Table 10-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045051Z" creationid="xccui" creationdate="20190729T045036Z">
        <seg>你还可以使用表10-6中的REST调用关闭集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also specify a minimum (taskmanager.network.memory.min) and a maxi‐ mum (taskmanager.network.memory.max) amount of memory that is used for net‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T041157Z" creationid="xccui" creationdate="20190724T041054Z">
        <seg>你也可以指定一个用于网络缓冲区的最小（taskmanager.network.meamory.min）和最大（taskmanager.network.memory.max）内存量（二者的默认值分别是64MB和1G），从而可以为上述的相对配置加上绝对限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also take a savepoint of a running application via the REST call that is shown in Table 10-14 .</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T162550Z" creationid="xccui" creationdate="20190729T162550Z">
        <seg>你还可以利用表10-14中展示的REST调用为当前正在运行的应用生成一个保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply predefined options to RocksDBStateBackend as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030850Z" creationid="xccui" creationdate="20190801T030850Z">
        <seg>你可以像下面这样为RocksDBStateBackend配置预定义选项：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call it from the root directory of a Flink setup with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T021545Z" creationid="xccui" creationdate="20190726T021545Z">
        <seg>你可以在Flink安装根目录下通过命令./bin/flink来调用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can change the Flink version, group and artifact IDs, version, and generated package by changing the respective parameters of the above mvn command.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T094539Z" creationid="xccui" creationdate="20190612T005349Z">
        <seg>你可以通过改变mvn命令的相应参数来更改Flink版本、Maven的组标识符和项目标识符、项目版本以及生成的包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can check if the master process was started</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T203958Z" creationid="xccui" creationdate="20190717T203958Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can check the status of the rescale request using the request ID.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201926Z" creationid="xccui" creationdate="20190729T201926Z">
        <seg>你可以使用请求ID检查扩缩容请求的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can completely disable task chaining for an application via the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203025Z" creationid="xccui" creationdate="20190730T191748Z">
        <seg>你可以通过StreamExecutionEnvironment来完全禁用应用内的任务链接：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can configure a different port at the ./conf/flink-conf.yaml</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T040455Z" creationid="xccui" creationdate="20190729T040433Z">
        <seg>你可以通过./conf/flink-conf.yaml文件内的rest.port配置项对该端口进行修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can configure the RollingPolicy with the withRollingPolicy() method on the builder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T021655Z" creationid="xccui" creationdate="20190711T021355Z">
        <seg>你可以通过调用构建器的withRollingPolicy()方法来对它进行配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can configure the starting position from which the partitions of a topic are initially read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T032046Z" creationid="xccui" creationdate="20190709T032046Z">
        <seg>你可以配置主题分区开始读取数据的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can configure which context infor‐ mation the metric should contain by setting the corresponding metric options in the flink-conf.yaml file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T042910Z" creationid="xccui" creationdate="20190804T042910Z">
        <seg>你可以通过在flink-conf.yaml文件中设置对应的指标选项来配置指标所包含的上下文信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create a Flink deployment for Kubernetes by storing each definition in a sep‐ arate file, such as master-deployment.yaml, worker-deployment.yaml, or master- service.yaml.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T033302Z" creationid="xccui" creationdate="20190720T033302Z">
        <seg>为了创建Flink的Kubernetes Deployment，你可以将每个定义单独存为一个文件，例如master-deployment.yaml，worker-deployment.yaml或master-service.yaml。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define breakpoints in the code and debug your application as you would normally do.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T092944Z" creationid="xccui" creationdate="20190611T053048Z">
        <seg>如同往常一般，在代码里设置断点，开启调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define the default state backend of a cluster with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T152046Z" creationid="xccui" creationdate="20190724T044300Z">
        <seg>你可以使用state.backend参数定义集群的默认状态后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can develop and execute Flink applications on Linux, macOS, and Windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T054036Z" creationid="xccui" creationdate="20190610T040911Z">
        <seg>你可以在Linux、maxOS以及Windows等常见操作系统上开发和运行Flink应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can disable this behavior and let the application continue after a checkpointing error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T204131Z" creationid="xccui" creationdate="20190731T204131Z">
        <seg>你可以禁用此行为，让应用在检查点错误后继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can disable this safety check by adding the -n option</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T205126Z" creationid="xccui" creationdate="20190727T053749Z">
        <seg>可以通过在run命令后增加-n选项来禁用此安全检查。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do this by selecting the job in the web dashboard and clicking on the CANCEL button on the top of the page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045547Z" creationid="xccui" creationdate="20190329T045547Z">
        <seg>取消的方式是在Web仪表盘中选定作业，然后点击页面上方的CANCEL按钮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do this by selecting the job in the web dashboard and clicking the Cancel button at the top of the page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201525Z" creationid="xccui" creationdate="20190605T124408Z">
        <seg>取消的方式是在Web UI中选定作业，然后点击页面上方的Cancel按钮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do this by setting the latencyTrackingInterval in the ExecutionConfig as shown here:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T055029Z" creationid="xccui" creationdate="20190806T055029Z">
        <seg>该工作可以像下面这样，通过在ExecutionConfig中设置latencyTrackingInterval来完成：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can either download and extract a source distribution of Flink or clone the Git repository.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T033727Z" creationid="xccui" creationdate="20190730T033727Z">
        <seg>你可以下载并解压Flink源码发行版或将Git仓库克隆下来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can embed SQL queries into regular Flink DataSet and DataStream programs or directly submit SQL queries to a Flink cluster using the SQL CLI client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190807T161354Z" creationid="xingcan" creationdate="20190807T161354Z">
        <seg>你可以将SQL查询嵌入到常规的Flink DataSet或DataStream程序中，或使用SQL CLI客户端直接将SQL查询提交到Flink集群上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can enable and configure the Kerberos support for each service separately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T022601Z" creationid="xccui" creationdate="20190725T022601Z">
        <seg>你可以单独为每个服务启用和配置Kerberos。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can enable compressed checkpoints and savepoints as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T033910Z" creationid="xccui" creationdate="20190731T204734Z">
        <seg>你可以像下面这样为检查点和保存点启用压缩：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can expect improved support for these scenarios in future versions of Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T035516Z" creationid="xccui" creationdate="20190705T053708Z">
        <seg>你可以期待未来版本的Apache Flink会对这些场景有更好的支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can exploit parallelism in dataflow graphs in different ways.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233216Z" creationid="xccui" creationdate="20190401T022711Z">
        <seg>Dataflow图的并行性可以通过多种方式加以利用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can expose metrics to external backends through report‐ ers and Flink provides implementation for several of them (see Table 10-19 ).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055436Z" creationid="xccui" creationdate="20190804T055436Z">
        <seg>你可以通过汇报器（reporter）将指标暴露给外部后端，Flink内部为它们提供了几种实现（见表10-19）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the list by providing a whitelist of classname patterns that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T061031Z" creationid="xccui" creationdate="20190723T061031Z">
        <seg>你可以通过提供类名模式白名单的方式，来扩展优先从父类加载器中解析的类列表（classloader.parent-first-patterns.additional）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can find more information about the other connectors in the documentation for Apache Flink or Apache Bahir.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T201408Z" creationid="xccui" creationdate="20190708T201408Z">
        <seg>你可以从Apache Flink或Apache Bahir项目的文档中查找更多有关其他连接器的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can follow the instruc‐ tions at the IntelliJ IDEA website to download and install it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T072608Z" creationid="xccui" creationdate="20190611T030717Z">
        <seg>你可以参照IntelliJ IDEA官网的说明下载和安装它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can imagine how a precise implementation of this definition can get problematic in practice if we try to track the latency per event in a high-rate streaming job with a complex dataflow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T052933Z" creationid="xccui" creationdate="20190806T052204Z">
        <seg>但如果想在Dataflow十分复杂的高速流式作业中追踪每个事件的延迟，那么实现精准测量的难度可想而知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can import the project in your IDE following the steps we described in the previ‐ ous section or you can execute the following command to build a JAR file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010443Z" creationid="xccui" creationdate="20190612T010248Z">
        <seg>此时，你可以按照我们在上一节所介绍的步骤把项目导入IDE，也可以执行以下命令来构建一个JAR文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can inspect the duration, bytes, and records exchanged, and aggregate those per TaskManager if you prefer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T144239Z" creationid="xccui" creationdate="20190802T042349Z">
        <seg>你可以查看任务的持续时间、交换的字节和记录数，并根据需求对它们按照TaskManager进行聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can limit the number of connections that read from (input) and write to (output) a filesystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T045531Z" creationid="xccui" creationdate="20190722T045531Z">
        <seg>你可以限制读（输入）写（输出）文件系统的连接数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can look up its implementation in the repository that contains the examples of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T063821Z" creationid="xccui" creationdate="20190715T063821Z">
        <seg>你可以到本书示例代码库中找到它的具体实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can monitor and control the application by accessing the Web UI running a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T035325Z" creationid="xccui" creationdate="20190730T035325Z">
        <seg>你还可以通过运行在http://localhost:8081上面的Web UI来对应用进行监控。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can monitor the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130301Z" creationid="xccui" creationdate="20190605T130301Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can monitor the constantly produced output using the tail command for example as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042619Z" creationid="xccui" creationdate="20190329T042619Z">
        <seg>如下所示，你可以使用tail命令监控持续产生的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass additional parameters such as the job arguments, the entry class, the default parallelism, a savepoint path, and the allow-nonrestored-state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T050433Z" creationid="xccui" creationdate="20190729T050433Z">
        <seg>你还可以传入一些额外参数，例如作业参数、入口类、默认并行度、保存点路径以及以一个JSON对象形式的allow-nonrestored-state标志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass arguments to the main() method of an application by appending them at the end of the command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170103Z" creationid="xccui" creationdate="20190726T030415Z">
        <seg>你可以通过在命令末尾附加参数的方式将其传递给应用的main()方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can register a counter metric using the counter(String name, Counter counter) method on MetricGroup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T025109Z" creationid="xccui" creationdate="20190803T025109Z">
        <seg>你可以使用MetricGroup上的counter(String name, Counter counter)方法注册一个Counter指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can resume your program from this savepoint with the run command.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T034958Z" creationid="xccui" creationdate="20190726T034958Z">
        <seg>You can resume your program from this savepoint with the run command.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set the identifier with the uid() method as shown in Example 7-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T024727Z" creationid="xccui" creationdate="20190703T023949Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can show the status of all deployments by running the following command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T033842Z" creationid="xccui" creationdate="20190720T033842Z">
        <seg>你可以通过运行以下命令来查看所有Deployment的状态：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can shut down a Flink cluster running on Kubernetes by running the following commands:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T040226Z" creationid="xccui" creationdate="20190720T040226Z">
        <seg>你可以运行以下命令来关闭运行在Kubernetes之上的Flink集群：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify a FlinkKafkaPartitioner to control how records are mapped to Kafka partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T151733Z" creationid="xingcan" creationdate="20190709T151733Z">
        <seg>你可以指定一个FlinkKafkaPartitioner来控制记录如何映射到Kafka的不同分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify a default filesystem scheme (fs.default-scheme) that is automatically added as a prefix if a path does not provide a scheme.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T045236Z" creationid="xccui" creationdate="20190722T045236Z">
        <seg>如果指定了默认文件系统协议（fs.default-scheme），那么在路径本身不包含协议的情况下，Flink会自动将默认协议作为其前缀。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify the default parallelism of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170310Z" creationid="xccui" creationdate="20190726T031128Z">
        <seg>你可以通过-p参数指定某个应用的默认并行度：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can start a different but compatible application from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212000Z" creationid="xccui" creationdate="20190609T212000Z">
        <seg>你可以从保存点启动一个不同但相互兼容的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can start an application with the run command of the command-line client:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T025335Z" creationid="xccui" creationdate="20190726T025243Z">
        <seg>你可以使用命令行客户端的run命令来启动应用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can start the same application on a different cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212732Z" creationid="xccui" creationdate="20190609T212716Z">
        <seg>你可以在另一个集群上启动相同的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can start the same application with a different parallelism and scale the appli‐ cation out or in.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T062610Z" creationid="xccui" creationdate="20190609T212609Z">
        <seg>你可以用不同的并行度启动原应用，从而实现应用的扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can submit an application in detached mode with the -d flag as shown here:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T030611Z" creationid="xccui" creationdate="20190726T030611Z">
        <seg>你可以像下面那样使用-d参数以分离模式提交应用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can submit an application to a specific master process using the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T032159Z" creationid="xccui" creationdate="20190726T032159Z">
        <seg>你可以使用-m参数将应用提交到特定的主进程：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can then register a &gt;DropWizard histogram in your Flink program using the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033556Z" creationid="xccui" creationdate="20190803T033550Z">
        <seg>你可以像示例10-7中那样在Flink程序中使用DropwizardHistogramWrapper类注册DropWizard直方图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of keyed state as a key-value map that is partitioned (or sharded) on  the key across all parallel tasks of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T192001Z">
        <seg>你可以把键值分区状态想象成一个在算子所有并行任务上进行分区（或分片）的键值映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of state as a local or instance variable that is accessed by a task’s business logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054049Z" creationid="xccui" creationdate="20190607T054049Z">
        <seg>你可以把状态想象成任务的业务逻辑所需要访问的本地或实例变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a Meter metric to measure the rate (in events per second) at which certain events happen.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033739Z" creationid="xccui" creationdate="20190803T033739Z">
        <seg>你可以使用Meter指标来衡量某些事件发生的速率（每秒的事件数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a histogram to represent the distribution of numerical data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T032438Z" creationid="xccui" creationdate="20190803T032438Z">
        <seg>你可以使用直方图来表示数值类型数据的分布。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a savepoint to pause an application and resume it later.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212928Z" creationid="xccui" creationdate="20190609T212928Z">
        <seg>你可以利用保存点暂停某个应用，稍后再把它启动起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use broadcast state to connect a keyed and a broadcast stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210016Z" creationid="xccui" creationdate="20190615T052419Z">
        <seg>你可以使用广播状态来联结一个按键值分好区流和一个广播流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can visit Flink’s Web UI at http://localhost:8081 and check the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T175811Z" creationid="xccui" creationdate="20190717T175811Z">
        <seg>你可以通过http://localhost:8081地址访问Flink Web UI并检查相连的TaskManager及剩余处理槽的数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can, of course, also configure the state backend in your application, overriding the default values or cluster-wide configuration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025527Z" creationid="xccui" creationdate="20190801T025527Z">
        <seg>你当然也可以在应用中对状态后端进行配置，从而覆盖其默认值或针对整个集群的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You connect the BroadcastStream with a DataStream or KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040613Z" creationid="xccui" creationdate="20190702T040613Z">
        <seg>将BroadcastStream和一个DataStream或KeyedStream联结起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You create a BroadcastStream by calling DataStream.broadcast() and provid‐ ing one or more MapStateDescriptor objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040524Z" creationid="xccui" creationdate="20190702T040524Z">
        <seg>调用DataStream.broadcast()方法创建一个BroadcastStream并提供一个以上MapStateDescriptor对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not need to contact us for permission unless you’re reproducing a significant portion of the code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210817Z" creationid="esouser" creationdate="20190603T210817Z">
        <seg>You do not need to contact us for permission unless you’re reproducing a significant portion of the code.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You first need to tell Kubernetes to create a port forwarding from the master container to your local machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T143922Z" creationid="xccui" creationdate="20190720T035411Z">
        <seg>为此，首先需要让Kubernetes创建从主进程容器到本地机器的端口转发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have become familiar with the evolution of the open-source stream processing space and you have got a brief taste of what a Flink streaming application looks like.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T052906Z" creationid="xccui" creationdate="20190329T052313Z">
        <seg>你已经熟悉了开源流处理领域的发展过程，且对Flink流式应用有一个粗略的认识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have learned basic streaming operations and how you can compute meaningful results on unbounded input data using windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051247Z" creationid="xccui" creationdate="20190416T051207Z">
        <seg>你学习了基本的流式操作，并掌握了如何利用窗口在无限输入上计算出有意义的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have probably already noticed that Flink programs are defined and submitted for execution in regular Scala or Java methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T045524Z" creationid="xccui" creationdate="20190612T043039Z">
        <seg>你可能已经注意到了，用常规的Scala或Java方法就可以定义和提交Flink程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have seen how rolling aggregations encode the history of the whole stream in an aggregate value and provide us with a low-latency result for every event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T062530Z" creationid="xccui" creationdate="20190406T042607Z">
        <seg>你已经了解滚动聚合是如何将整条历史流压缩成一个聚合值，以及如何针对每个事件在极低延迟内产生结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have seen the dataflow programming model and learned how streaming applications can be expressed as distributed dataflow graphs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050548Z" creationid="xccui" creationdate="20190416T050539Z">
        <seg>你了解了dataflow编程模型以及如何将一个流式应用表示为分布式dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have wondered about the meaning of time in stream processing and you have compared the notions of event time and processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051413Z" creationid="xccui" creationdate="20190416T051333Z">
        <seg>你思考了流式应用中时间的含义，并比较了事件时间和处理时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You just installed and started your first local Flink cluster and ran your first Flink DataStream API program!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124508Z" creationid="xccui" creationdate="20190605T124440Z">
        <seg>恭喜你首次成功安装启动了Flink本地集群并运行了你的首个Flink DataStream程序！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You just installed and started your first local Flink cluster and ran your first Flink DataStream program!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T050049Z" creationid="xccui" creationdate="20190328T062213Z">
        <seg>恭喜你首次成功安装启动了Flink本地集群并运行了你第一个Flink DataStream程序！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You learned about time-based operators, including Flink’s process functions, built-in windows, and custom win‐ dows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T212938Z" creationid="xccui" creationdate="20190629T041533Z">
        <seg>你对Flink中基于时间的算子（包括处理函数、内置窗口以及自定义窗口）已经有所了解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You learned the mean‐ ing of time in stream processing and compared the notions of event time and pro‐ cessing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T040431Z" creationid="xccui" creationdate="20190606T040431Z">
        <seg>你学习了流式应用中时间的含义，并比较了事件时间和处理时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may be able to lower the latency in our coffee shop example by hiring a more skilled barista—one that prepares coffees faster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235353Z" creationid="xccui" creationdate="20190605T235258Z">
        <seg>为了降低延迟，可以雇佣更娴熟的咖啡师，他们制作咖啡会更快一些。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have been able to generate a result earlier but you had to wait for the water‐ mark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T060941Z" creationid="xccui" creationdate="20190621T034128Z">
        <seg>换言之，你可能早就能够生成结果，但却必须等待水位线来触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must not delete a savepoint before another checkpoint or save‐ point is completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035428Z" creationid="xccui" creationdate="20190726T035347Z">
        <seg>请不要在另一个检查点或保存点生成过程中删除保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need to adjust the configuration to successfully run Flink in distributed environ‐ ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T042456Z" creationid="xccui" creationdate="20190723T042456Z">
        <seg>如果想让它在分布式环境中运行，你需要调整部分配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need to build your own Docker image if you want to adjust some of the parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190718T043025Z">
        <seg>如果你想调整某些参数，需要自己构建Docker镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need to configure the number of maximum Appli‐ cationManager restarts in the YARN configuration file yarn-site.xml as shown:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052502Z" creationid="xccui" creationdate="20190721T052451Z">
        <seg>你需要像下面这样在YARN配置文件yarn-site.xml中配置ApplicationMaster的最大重启次数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need to manually remove them to free the consumed storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035103Z" creationid="xccui" creationdate="20190726T035103Z">
        <seg>为了释放存储空间，你需要手工删除它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need to take a savepoint, cancel the application, and restart it with an adjusted parallelism from the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T055046Z" creationid="xccui" creationdate="20190727T055046Z">
        <seg>你只需生成一个保存点，取消应用，然后再将并行度调整后的应用从保存点启动起来即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need to use whatever information you have about the sources, the network, and the partitions to estimate progress and an upper bound for the lateness of your input records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T033709Z" creationid="xccui" creationdate="20190621T032302Z">
        <seg>你需要尽可能地了解有关数据源、网络以及分区等一切信息，以此来估计进度和输入记录的延迟上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You only have to ensure that the TaskManagers are configured to start their queryable state services as discussed in the previous section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T063457Z" creationid="xccui" creationdate="20190706T063457Z">
        <seg>你只需要像上节讨论的那样，确保为TaskManager配置了可查询式状态的服务即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should carefully revise the configuration of your Kafka setup, paying special attention to the following parameters:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T033432Z" creationid="xccui" creationdate="20190710T033420Z">
        <seg>你需要仔细检查Kafka的设置，特别要留意以下参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not use Flink’s ZooKeeper script for production environments but instead carefully configure and deploy a Zoo‐ Keeper cluster yourself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T144530Z" creationid="xccui" creationdate="20190720T203454Z">
        <seg>请不要将Flink的ZooKeeper脚本用于生产环境，应该自己仔细配置并部署ZooKeeper集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should now be able to browse and inspect the code of the book exam‐ ples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041822Z" creationid="xccui" creationdate="20190611T041759Z">
        <seg>你现在应该就能浏览和研究书中示例的源码了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see a job listed under “Running Jobs.” If you click on that job, you will see the dataflow and live metrics about the opera‐ tors of the running job similar to the screenshot in Figure 1-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123742Z" creationid="xccui" creationdate="20190605T123657Z">
        <seg>你应该能看到"Running Jobs"列表中有一个作业。点击那个作业，你会看到和图1-9中的截图相类似的数据流程及运行作业中算子的实时指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see a job listed under “Running Jobs”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040122Z" creationid="xccui" creationdate="20190329T040122Z">
        <seg>你会发现"Running Jobs"列表中有一个作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see lines as the following ones being written to the file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042932Z" creationid="xccui" creationdate="20190329T042825Z">
        <seg>你会看到文件中写入了以下文本行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see lines like this being written to the file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123930Z" creationid="xccui" creationdate="20190605T123849Z">
        <seg>你会看到文件中写入了和下面类似的文本行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will also get an introduction to custom, user-defined window operations and core windowing constructs, such as assigners, triggers, and evictors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T053336Z" creationid="xccui" creationdate="20190619T053336Z">
        <seg>此外你还将了解用户自定义窗口操作以及窗口中的核心结构，例如：分配器、触发器和移除器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will find the source code in the src/ directory, grouped by chapter:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T091624Z" creationid="xccui" creationdate="20190611T040535Z">
        <seg>你可以在src/目录中找到按照章节组织的源代码：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will learn how to implement a DataStream application and which stream transforma‐ tions, functions, and data types are supported.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T061616Z" creationid="esouser" creationdate="20190603T161436Z">
        <seg>你将从中学到如何实现DataStream应用以及Flink所支持的流式转换、函数、数据类型等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will learn how to implement custom source and sink connectors and how to implement functions that send asynchronous read or write requests to external datastores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T053119Z" creationid="xccui" creationdate="20190708T051201Z">
        <seg>你将学到如何实现自定义的数据源和数据汇连接器，以及如何在函数中向外部数据存储发送异步的读写请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will learn more about stateful stream processing, failure scenarios, and consistency at the end of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T005148Z" creationid="xccui" creationdate="20190606T005148Z">
        <seg>在本章末尾，你将了解更多有关状态化流处理、错误场景和一致性的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will learn more about stateful stream processing, failure scenarios, and consistency in the end of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151708Z" creationid="xccui" creationdate="20190405T151603Z">
        <seg>在本章末尾，你将了解更多有关状态化流处理、错误场景和一致性的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will need to make another attempt at canceling the job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T034813Z" creationid="xccui" creationdate="20190727T034813Z">
        <seg>你需要再次尝试取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You would need to build custom Docker images with an adjusted configuration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034814Z" creationid="xccui" creationdate="20190720T042251Z">
        <seg>你需要使用调整后的配置构建自定义的Docker镜像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your service latency is the time you spend in the coffee shop, from the moment you enter until you have the first sip of coffee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T154418Z" creationid="xccui" creationdate="20190401T154008Z">
        <seg>你的服务延迟就是在店内买咖啡的时间，即从你进门的一刻到抿到第一口咖啡的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You’ve seen user-defined functions in action in the code examples of this chapter so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T040614Z" creationid="xccui" creationdate="20190618T052830Z">
        <seg>到目前位置，你已经在本章的代码示例中见到过如何使用用户自定义函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ZooKeeper elects a leader Dispatcher responsible for executing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T034954Z" creationid="xccui" creationdate="20190721T034954Z">
        <seg>ZooKeeper会在所有Dispatcher中选出一个负责执行应用的领导者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[(String, Double), (String, Double, Int), (String, Double)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005603Z" creationid="xccui" creationdate="20190624T005603Z">
        <seg>[(String, Double), (String, Double, Int), (String, Double)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[.evictor(...)]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014909Z" creationid="xccui" creationdate="20190626T014909Z">
        <seg>[.evictor(...)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[.trigger(...)]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014838Z" creationid="xccui" creationdate="20190626T014838Z">
        <seg>[.trigger(...)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[String, SensorReading, (String, Double, Double)]#Context, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210448Z" creationid="xccui" creationdate="20190704T210448Z">
        <seg>[String, SensorReading, (String, Double, Double)]#Context, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[String, SensorReading, (String, Double, Double)]#OnTimerContext, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210700Z" creationid="xccui" creationdate="20190704T210700Z">
        <seg>[String, SensorReading, (String, Double, Double)]#OnTimerContext, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[String, SensorReading, ThresholdUpdate, (String, Double, Double)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041333Z" creationid="xccui" creationdate="20190702T041333Z">
        <seg>[String, SensorReading, ThresholdUpdate, (String, Double, Double)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[String, SensorReading, ThresholdUpdate, (String, Double, Double)]#Context, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042536Z" creationid="xccui" creationdate="20190702T042536Z">
        <seg>[String, SensorReading, ThresholdUpdate, (String, Double, Double)]#Context, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[base-path]/[bucket-path]/part-[task-idx]-[id]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T213919Z" creationid="xccui" creationdate="20190710T213919Z">
        <seg>[base-path]/[bucket-path]/part-[task-idx]-[id]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004818Z" creationid="xccui" creationdate="20190612T004818Z">
        <seg>\</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a ProcessWindowFunction or the result of applying a ReduceFunction, a Process Function memorizes scheduled timers, and some sink functions maintain state about transactions to provide exactly-once functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T213224Z" creationid="xccui" creationdate="20190630T031718Z">
        <seg>举例而言，窗口算子会为ProcessWindowFunction收集输入记录或保存ReduceFunction所产生的结果；ProcessFunction需要记住设定的计时器；一些数据汇函数为了提供精确一次语义需要维护事务相关状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a WindowAssigner, a trigger decides when to evalute a window, and a window func‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T031548Z" creationid="xccui" creationdate="20190626T031548Z">
        <seg>触发器决定何时对窗口执行计算，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a broadcasted stream and storing the broadcasted events in man‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053023Z" creationid="xccui" creationdate="20190615T053023Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a filter operation that only preserves white squares.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T055726Z" creationid="xccui" creationdate="20190613T052257Z">
        <seg>图5-2展示的Filter操作仅保留了白色方块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a trigger needs to remove all custom per-window state and delete all processing-time and event-time timers using the TriggerContext object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194543Z" creationid="xccui" creationdate="20190626T194404Z">
        <seg>触发器的clear()方法需要删除全部自定义的单个窗口状态并使用TriggerContext对象删除所有处理时间和事件时间计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a window—when it is created, what information it consists of, and when it is deleted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032507Z" creationid="xccui" creationdate="20190626T032507Z">
        <seg>即它何时创建，包含了哪些信息以及何时删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>able field in the open() method or override the Java serialization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055447Z" creationid="xccui" creationdate="20190618T055342Z">
        <seg>或者覆盖Java的序列化反序列化方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>abort(txn: TXN): Unit aborts a transaction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053457Z" creationid="xccui" creationdate="20190716T053457Z">
        <seg>abort(txn: TXN): Unit终止给定事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>acceptable because a prompt reaction to new results or insights did not yield a signifi&lt;t0/&gt;‐&lt;t1/&gt; cant advantage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032923Z" creationid="xccui" creationdate="20190317T032923Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>access a keyed value and will throw an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054227Z" creationid="xccui" creationdate="20190702T054227Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>access intermediate data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T205838Z" creationid="esouser" creationdate="20190603T205838Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>accesses and fault tolerance in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T022639Z" creationid="xccui" creationdate="20190704T022425Z">
        <seg>又可以支持故障容错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>account when implementing the interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T203051Z" creationid="xccui" creationdate="20190702T203051Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>acks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T033436Z" creationid="xccui" creationdate="20190710T033436Z">
        <seg>acks</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>address: Address)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050018Z" creationid="xccui" creationdate="20190618T050018Z">
        <seg>address: Address)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aged state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053027Z" creationid="xccui" creationdate="20190615T053027Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ager and HDFS.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T030852Z" creationid="xccui" creationdate="20190722T030852Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aggregate the window content.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203840Z" creationid="xccui" creationdate="20190627T203840Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aggregates on a KeyedStream, either with the built-in aggregations functions such as min, max, sum, minBy, or maxBy or with a custom ReduceFunction or AggregateFunc tion, keeps the state for each key and never discards it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T183348Z" creationid="xccui" creationdate="20190704T183348Z">
        <seg>例如，当我们在一个KeyedStream上计算聚合时，无论采用的是内置聚合函数（例如min、max、sum、minBy或maxBy）还是自定义的ReduceFunction或AggregateFunction，都会为每个键值保存状态并且永不丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>all applications that run on the same cluster use the same authentication token.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190725T023240Z" creationid="xccui" creationdate="20190725T023221Z">
        <seg>在同一集群上运行的所有应用都会使用相同的验证令牌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>all members of the same group.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T014952Z" creationid="xccui" creationdate="20190731T014952Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allows reading and writing values per key—only those keys and values are de/serial‐ ized that are read or written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T033400Z" creationid="xccui" creationdate="20190704T033038Z">
        <seg>RocksDBStateBackend的MapState允许按照每个键对其数据值进行读写，并且只有那些读写的键和数据值才需要进行（反）序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>also disable any output guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T161502Z" creationid="xingcan" creationdate="20190709T161502Z">
        <seg>但这同样会失去任何输入保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>always add the following import statement to your Scala applica‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T035628Z" creationid="xccui" creationdate="20190617T054830Z">
        <seg>请确保将以下导入语句添加到你的Scala程序中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052302Z" creationid="xccui" creationdate="20190716T052302Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an OutOfMemoryError.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T222743Z" creationid="xccui" creationdate="20190703T222743Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an application with the -p flag:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T031150Z" creationid="xccui" creationdate="20190726T031150Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and all TaskManager were successfully registered by accessing the Web UI on the machine that runs the master process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T203955Z" creationid="xccui" creationdate="20190717T203955Z">
        <seg>你可以通过访问主进程所在机器的Web UI来检查主进程的启动以及TaskManager的注册情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and appended to a part file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T022738Z" creationid="xccui" creationdate="20190711T022738Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and deserialization methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055451Z" creationid="xccui" creationdate="20190618T055451Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and does so by calling the method SourceContext.markAsTemporarilyIdle().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T051731Z" creationid="xccui" creationdate="20190713T051731Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and emitting records in an endless loop (infinite stream).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T151647Z" creationid="xccui" creationdate="20190712T151647Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and finished, and that is based on Flink’s checkpointing mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T190113Z" creationid="xccui" creationdate="20190711T190113Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and is the only interface that gives access to operator list union state—the operator state that is fully replicated in the case of a recovery or savepoint restart.3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T153334Z" creationid="xccui" creationdate="20190702T063515Z">
        <seg>并且是唯一可以访问算子联合列表状态（在进行恢复或从保存点启动的情况下需要被完全复制的算子状态）的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and processes the elements that are assigned to a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T040102Z" creationid="xccui" creationdate="20190622T040102Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and provided sources and sinks, Flink’s DataStream API exposes interfaces to register, maintain, and access state in user-defined functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T032018Z" creationid="xccui" creationdate="20190630T032018Z">
        <seg>除了内置算子和提供的数据源及数据汇之外，Flink DataStream API也在用户自定义函数里暴露了状态的注册、维护及访问接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and repackage your application before submitting it for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190728T044052Z" creationid="xccui" creationdate="20190728T044052Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and restored using the methods of the ListCheckpointed interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T053912Z" creationid="xccui" creationdate="20190701T053912Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and that all input streams are reset to the position up to which they were consumed when the checkpoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044017Z" creationid="xccui" creationdate="20190609T044017Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and the onMerge() method needs to implement the logic to perform the merge.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195055Z" creationid="xccui" creationdate="20190626T195023Z">
        <seg>而相应地需要在onMerge()方法中实现合并逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and video from O’Reilly and 200+ other publishers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210833Z" creationid="esouser" creationdate="20190603T210833Z">
        <seg>and video from O’Reilly and 200+ other publishers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and when the trigger of the window fires, the aggregated result will be handed to ProcessWindowFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T045815Z" creationid="xccui" creationdate="20190625T035656Z">
        <seg>随后当窗口触发器触发时，再将聚合后的结果传给ProcessWindowFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and write data from and to RocksDB, it needs to be de/serialized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T030734Z" creationid="xccui" creationdate="20190704T023657Z">
        <seg>为了从RocksDB中读写数据，系统需要对数据进行序列化和反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apiVersion: extensions/v1beta1 kind: Deployment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024942Z" creationid="xccui" creationdate="20190720T024942Z">
        <seg>apiVersion: extensions/v1beta1 kind: Deployment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apiVersion: v1 kind: Service metadata:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T031942Z" creationid="xccui" creationdate="20190720T031942Z">
        <seg>apiVersion: v1 kind: Service metadata:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>app: flink component: master</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025000Z" creationid="xccui" creationdate="20190720T025000Z">
        <seg>app: flink component: master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>app: flink component: worker</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025724Z" creationid="xccui" creationdate="20190720T025724Z">
        <seg>app: flink component: worker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application and how its tasks are mapped to processing slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T020133Z" creationid="xccui" creationdate="20190731T020133Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application is represented by the StreamExecutionEnvironment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044952Z" creationid="xccui" creationdate="20190612T044952Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application to a halt if the application involves a shuffle operation (keyBy(),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T043606Z" creationid="xccui" creationdate="20190713T043606Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application, fix bugs and repair previously emitted results, migrate an application to a different cluster, or perform A/B tests with different application versions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T143904Z" creationid="esouser" creationdate="20190603T211838Z">
        <seg>该技术不但可用于失败恢复，还可用于应用更新、Bug修复、结果修正、集群迁移或针对不同版本应用执行A/B测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application, or provide dynamic properties.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T013812Z" creationid="xccui" creationdate="20190719T013812Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032948Z" creationid="xccui" creationdate="20190418T032948Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T152907Z" creationid="xccui" creationdate="20190729T152907Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apply a ReduceFunction or AggregateFunction to incrementally</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203838Z" creationid="xccui" creationdate="20190627T203838Z">
        <seg>且没有对窗口内容使用ReduceFunction或AggregateFunction进行增量聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>are first resolved from the parent classloader (classloader.parent-first-patterns.additional).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T061039Z" creationid="xccui" creationdate="20190723T061039Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>are moved into the finished state (again by renaming) when the next checkpoint completes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T190818Z" creationid="xccui" creationdate="20190711T190715Z">
        <seg>在下一次检查点完成后处于等待状态的文件将（通过再一次重命名）进入完成状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as an identifier for a window, such as the start and end timestamps in the case of a time window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011918Z" creationid="xccui" creationdate="20190624T011845Z">
        <seg>例如时间窗口中的开始和结束时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as shown in Example 10-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154358Z" creationid="xingcan" creationdate="20190801T154358Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>assignTimestampsAndWatermarks() method where we define the timestamp assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055129Z" creationid="xccui" creationdate="20190620T044558Z">
        <seg>然后调用assignTimestampsAndWatermarks()方法传入时间戳分配器MyAssigner。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>assigning timestamps if such operations do not induce a redistribution of elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T031947Z" creationid="xccui" creationdate="20190620T031947Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>asynchronously.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T214540Z" creationid="xccui" creationdate="20190716T214540Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>at port 9876.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T032322Z" creationid="xccui" creationdate="20190726T032322Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ated with the windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T050619Z" creationid="xccui" creationdate="20190626T050619Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ately configured, a job submission will fail with a java.io.IOException: Insufficient number of network buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T040137Z" creationid="xccui" creationdate="20190724T040034Z">
        <seg>如果缓冲区数量配置有问题，在提交作业时可能会因异常而失败：java.io.IOException: Insufficient number of network buffers（缓冲区数量不足）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ator does not have an incremental aggregation function, the new element is appended to a ListState that holds all assigned elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051208Z" creationid="xccui" creationdate="20190625T052516Z">
        <seg>如果窗口算子没有配置增量聚合函数，那么新加入的元素会附加到一个用于存储所有窗口分配元素的ListState上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>attribute of the records or a round-robin partitioner for even distribution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T035644Z" creationid="xccui" creationdate="20190710T035644Z">
        <seg>例如，你可以创建一个基于记录键值属性的分区器，或者是可以实现均匀分配的轮询分区器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ature per sensor and the end timestamp of each window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043445Z" creationid="xccui" creationdate="20190625T043304Z">
        <seg>为每个传感器每5秒发出一次最高和最低温度以及窗口的结束时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>avgTemp.print()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042827Z" creationid="xccui" creationdate="20190612T042827Z">
        <seg>avgTemp.print()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>backend and returns it to the requesting client proxy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T024120Z" creationid="xccui" creationdate="20190706T024120Z">
        <seg>然后将其返回给提交请求的客户端代理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>backend maintains application state in the local filesystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043648Z" creationid="xccui" creationdate="20190724T043648Z">
        <seg>最后，RocksDB状态后端会将应用状态维护在本地文件系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>backend.setPredefinedOptions(PredefinedOptions.SPINNING_DISK_OPTIMIZED)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030937Z" creationid="xccui" creationdate="20190801T030937Z">
        <seg>backend.setPredefinedOptions(PredefinedOptions.SPINNING_DISK_OPTIMIZED)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>balancing, retry, and reconnection policies; and provide access credentials.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T221636Z" creationid="xccui" creationdate="20190711T221515Z">
        <seg>定义负载均衡、重试及重连策略，提供访问凭据等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>based on a property of the input events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045149Z" creationid="xccui" creationdate="20190620T045149Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>batch storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051915Z" creationid="xccui" creationdate="20190605T051915Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>bc0b2ad61ecd4a615d92ce25390f61ad and store the savepoint at hdfs:///xxx:50070/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T184648Z" creationid="xccui" creationdate="20190726T184627Z">
        <seg>你可以使用以下命令取消JobID为bc0b2ad61ecd4a615d92ce25390f61ad的应用并在hdfs:///xxx:50070/savepoints位置生成一个保存点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the contents of the windows depend on the speed at which the elements arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T065849Z" creationid="xccui" creationdate="20190619T065849Z">
        <seg>这是因为窗口内容取决于元素到达的速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>before deploying Flink: minikube ssh 'sudo ip link set docker0 promisc on'.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024301Z" creationid="xccui" creationdate="20190720T024301Z">
        <seg>minikube ssh 'sudo ip link set docker() promisc on'。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>beginTransaction(): TXN starts a new transaction and returns the transaction identifier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052643Z" creationid="xccui" creationdate="20190716T052643Z">
        <seg>beginTransaction(): TXN用于启动一个新的事务并返回事务标识符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>between the events of both streams so events of both streams are randomly assigned to operator instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T062617Z" creationid="xccui" creationdate="20190615T045451Z">
        <seg>默认情况下，connect()方法不会在两条输入流的事件之间建立联系，因此所有事件都会随机分配给算子实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>birthday: (Int, Int, Int), // year, month, day</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050008Z" creationid="xccui" creationdate="20190618T050008Z">
        <seg>birthday: (Int, Int, Int), // 年、月、日</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ble to perform idempotent writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T042502Z" creationid="xccui" creationdate="20190714T042502Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ble.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T041101Z" creationid="xccui" creationdate="20190414T041101Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T063824Z" creationid="xccui" creationdate="20190715T063824Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>boolean sendValues(Iterable&lt;IN&gt; values, long chkpntId, long timestamp) GenericWriteAheadSink calls the sendValues() method to write the records of a completed checkpoint to the external storage system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T062917Z" creationid="xccui" creationdate="20190715T062828Z">
        <seg>boolean sendValues(Iterable&lt;IN&gt; values, long chkpntId, long timestamp) GenericWriteAheadSink会调用sendValues()方法将已完成检查点对应的记录写入外部存储系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>broadcast input does not specify a key, the state backend cannot</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054224Z" creationid="xccui" creationdate="20190702T054224Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>broadcasted stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024120Z" creationid="xccui" creationdate="20190702T024120Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>buffer channels and serialization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204046Z" creationid="xccui" creationdate="20190606T204046Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>buffers are allocated as off-heap memory, the JVM heap is reduced by that amount.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T040613Z" creationid="xccui" creationdate="20190724T040613Z">
        <seg>由于分配后会以堆外内存的方式使用，所以JVM堆内存会有相应的减少。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Fabian Hueske and Vasiliki Kalavri</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210709Z" creationid="esouser" creationdate="20190603T210709Z">
        <seg>by Fabian Hueske and Vasiliki Kalavri</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by a session gap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061314Z" creationid="xccui" creationdate="20190623T061314Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by using ./bin/flink run -m yarn-cluster and ./bin/yarn-session.sh.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T061121Z" creationid="xccui" creationdate="20190721T061121Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by visiting http://&lt;jobmanager-hostname&gt;:8081.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T033919Z" creationid="xccui" creationdate="20190802T033919Z">
        <seg>你可以通过地址http://&lt;jobmanager-hostname&gt;:8081访问仪表盘。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>called for each combination of elements from the first and the second input—the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T204425Z" creationid="xccui" creationdate="20190628T052848Z">
        <seg>算子会遍历两个输入中元素的每个组合（叉乘积）去调用JoinFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>called twice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053259Z" creationid="xccui" creationdate="20190716T053259Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can be redistributed if a worker node is lost or the application is rescaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T155247Z" creationid="xingcan" creationdate="20190801T155206Z">
        <seg>还允许在工作节点丢失或应用扩缩容时对状态进行重新分发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can join all A events with all B events that have timestamps between one and two hours more than the A event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T031015Z" creationid="xccui" creationdate="20190628T031015Z">
        <seg>例如：允许出现B中事件的时间戳相较A中事件的时间戳早1到2个小时这样的条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>canMerge() declares that a trigger supports merging</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194948Z" creationid="xccui" creationdate="20190626T194948Z">
        <seg>canMerge()声明了某个触发器支持合并，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>care, as routing all events to the same task might impact application perfor‐ mance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050002Z" creationid="xccui" creationdate="20190616T045949Z">
        <seg>因为将所有事件发往同一任务可能会影响程序性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case (in: SensorReading, None) =&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023022Z" creationid="xccui" creationdate="20190701T023022Z">
        <seg>case (in: SensorReading, None) =&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case (r: SensorReading, lastTemp: Some[Double]) =&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023141Z" creationid="xccui" creationdate="20190701T023141Z">
        <seg>case (r: SensorReading, lastTemp: Some[Double]) =&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case Failure(e) =&gt; resultFuture.completeExceptionally(e)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211955Z" creationid="xccui" creationdate="20190716T211955Z">
        <seg>case Failure(e) =&gt; resultFuture.completeExceptionally(e)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case Success(r) =&gt; resultFuture.complete(Seq((sensor, r)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211952Z" creationid="xccui" creationdate="20190716T211952Z">
        <seg>case Success(r) =&gt; resultFuture.complete(Seq((sensor, r)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class Address( address: String, zip: String country: String)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T045954Z" creationid="xccui" creationdate="20190618T045954Z">
        <seg>case class Address( address: String, zip: String country: String)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class MinMaxTemp(id: String, min: Double, max:Double, endTs: Long)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030650Z" creationid="xccui" creationdate="20190625T030650Z">
        <seg>case class MinMaxTemp(id: String, min: Double, max:Double, endTs: Long)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class MinMaxTemp(id: String, min: Double, max:Double, endTs: Long) val minMaxTempPerWindow2: DataStream[MinMaxTemp] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043552Z" creationid="xccui" creationdate="20190625T043552Z">
        <seg>case class MinMaxTemp(id: String, min: Double, max:Double, endTs: Long) val minMaxTempPerWindow2: DataStream[MinMaxTemp] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class Person( name: String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T045958Z" creationid="xccui" creationdate="20190618T045958Z">
        <seg>case class Person( name: String,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class Person(name: String, age: Int)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041136Z" creationid="xccui" creationdate="20190617T041136Z">
        <seg>case class Person(name: String, age: Int)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class SensorReading( id: String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035705Z" creationid="xccui" creationdate="20190612T035705Z">
        <seg>case class SensorReading( id: String,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case classes, or rows into a Cassandra table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210631Z" creationid="xccui" creationdate="20190711T210631Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case of a recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T194628Z" creationid="xccui" creationdate="20190716T194628Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T055509Z" creationid="xccui" creationdate="20190319T055509Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cations run continuously and the input is potentially unbounded, there is no notion of total execution time in data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150815Z" creationid="xccui" creationdate="20190401T150815Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cations” on page 245.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043512Z" creationid="xccui" creationdate="20190705T043512Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cd ./flink-container/docker</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T034500Z" creationid="xccui" creationdate="20190730T034500Z">
        <seg>cd ./flink-container/docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cessed, and there is a chance that some of them are processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034626Z" creationid="xccui" creationdate="20190606T034626Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cessing because it ensures watermarks are not overtaken by records even if out-of-</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T200217Z" creationid="xccui" creationdate="20190716T195940Z">
        <seg>因为即使允许结果乱序，它也能保证记录不会被之后的水位线超过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cessing time and watermark, state stores to manage per-window and per-key global</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024305Z" creationid="xccui" creationdate="20190624T011407Z">
        <seg>当前处理时间和水位线，用于管理单个窗口和每个键值全局状态的状态存储</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cessing time when they are written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T213032Z" creationid="xccui" creationdate="20190710T213032Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cessor, a speed store, a batch store, and tools to ingest data for the batch processor and scheduling batch jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032758Z" creationid="xccui" creationdate="20190327T032758Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T195756Z" creationid="xccui" creationdate="20190715T195756Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>choose the TypeInformation that generates the most efficient serializers and deserial‐ izers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061119Z" creationid="xccui" creationdate="20190617T061119Z">
        <seg>此外，某些情况下Flink选择的TypeInformation可能无法生成最高效的序列化和反序列化器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class AssignWindowEndProcessFunction extends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045134Z" creationid="xccui" creationdate="20190625T045134Z">
        <seg>class AssignWindowEndProcessFunction extends</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class AvgTempFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005551Z" creationid="xccui" creationdate="20190624T005551Z">
        <seg>class AvgTempFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class CountSource extends SourceFunction[Long] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152421Z" creationid="xccui" creationdate="20190712T152421Z">
        <seg>class CountSource extends SourceFunction[Long] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class DerbyAsyncFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T204231Z" creationid="xccui" creationdate="20190716T204231Z">
        <seg>class DerbyAsyncFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class DerbyUpsertSink extends RichSinkFunction[SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045100Z" creationid="xccui" creationdate="20190714T045100Z">
        <seg>class DerbyUpsertSink extends RichSinkFunction[SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class FlinkFilter extends FilterFunction[String] { override def filter(value: String): Boolean = { value.contains("flink")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054002Z" creationid="xccui" creationdate="20190618T054002Z">
        <seg>class FlinkFilter extends FilterFunction[String] { override def filter(value: String): Boolean = { value.contains("flink")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class FreezingMonitor extends ProcessFunction[SensorReading, SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023913Z" creationid="xccui" creationdate="20190622T023913Z">
        <seg>class FreezingMonitor extends ProcessFunction[SensorReading, SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class HighAndLowTempProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031907Z" creationid="xccui" creationdate="20190625T031907Z">
        <seg>class HighAndLowTempProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class HighTempCounter(val threshold: Double)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052316Z" creationid="xccui" creationdate="20190701T052316Z">
        <seg>class HighTempCounter(val threshold: Double)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class KeywordFilter(keyWord: String) extends FilterFunction[String] { override def filter(value: String): Boolean = { value.contains(keyWord)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054645Z" creationid="xccui" creationdate="20190618T054645Z">
        <seg>class KeywordFilter(keyWord: String) extends FilterFunction[String] { override def filter(value: String): Boolean = { value.contains(keyWord)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class LateReadingsFilter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155830Z" creationid="xingcan" creationdate="20190628T155830Z">
        <seg>class LateReadingsFilter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class MyFlatMap extends RichFlatMapFunction[Int, (Int, Int)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034245Z" creationid="xccui" creationdate="20190619T034245Z">
        <seg>class MyFlatMap extends RichFlatMapFunction[Int, (Int, Int)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class MyMapFunction extends MapFunction[Int, Int] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020905Z" creationid="xccui" creationdate="20190613T020905Z">
        <seg>class MyMapFunction extends MapFunction[Int, Int] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class MyMapFunction extends MapFunction[Int, String] { Logger LOG = LoggerFactory.getLogger(MyMapFunction.class) override def map(value: Int): String = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034117Z" creationid="xccui" creationdate="20190807T034117Z">
        <seg>class MyMapFunction extends MapFunction[Int, String] { Logger LOG = LoggerFactory.getLogger(MyMapFunction.class) override def map(value: Int): String = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class MyMapFunction extends MapFunction[SensorReading, String] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050721Z" creationid="xccui" creationdate="20190613T050721Z">
        <seg>class MyMapFunction extends MapFunction[SensorReading, String] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class OneSecondIntervalTrigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200215Z" creationid="xccui" creationdate="20190626T200215Z">
        <seg>class OneSecondIntervalTrigger</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class PeriodicAssigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051033Z" creationid="xccui" creationdate="20190620T051033Z">
        <seg>class PeriodicAssigner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class PositiveFilter extends RichFilterFunction[Int] { @transient private var counter: Counter = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015229Z" creationid="xccui" creationdate="20190803T015229Z">
        <seg>class PositiveFilter extends RichFilterFunction[Int] { @transient private var counter: Counter = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class PunctuatedAssigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054750Z" creationid="xccui" creationdate="20190620T054750Z">
        <seg>class PunctuatedAssigner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class ReadingFilter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032024Z" creationid="xccui" creationdate="20190622T032024Z">
        <seg>class ReadingFilter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class ResettableCountSource</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T033921Z" creationid="xccui" creationdate="20190713T033921Z">
        <seg>class ResettableCountSource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class SelfCleaningTemperatureAlertFunction(val threshold: Double)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205615Z" creationid="xccui" creationdate="20190704T205615Z">
        <seg>class SelfCleaningTemperatureAlertFunction(val threshold: Double)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class SensorReadings(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220252Z" creationid="xccui" creationdate="20190711T220252Z">
        <seg>class SensorReadings(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class SimpleSocketSink(val host: String, val port: Int) extends RichSinkFunction[SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024045Z" creationid="xccui" creationdate="20190714T024045Z">
        <seg>class SimpleSocketSink(val host: String, val port: Int) extends RichSinkFunction[SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class StdOutWriteAheadSink extends GenericWriteAheadSink[SensorReading](</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064241Z" creationid="xccui" creationdate="20190715T064241Z">
        <seg>class StdOutWriteAheadSink extends GenericWriteAheadSink[SensorReading](</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class TempIncreaseAlertFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071337Z" creationid="xccui" creationdate="20190621T071337Z">
        <seg>class TempIncreaseAlertFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class TemperatureAlertFunction(val threshold: Double)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064204Z" creationid="xccui" creationdate="20190630T064204Z">
        <seg>class TemperatureAlertFunction(val threshold: Double)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class ThirtySecondsWindows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042647Z" creationid="xccui" creationdate="20190626T042647Z">
        <seg>class ThirtySecondsWindows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class TransactionalFileSink(val targetPath: String, val tempPath: String) extends TwoPhaseCommitSinkFunction[(String, Double), String, Void]( createTypeInformation[String].createSerializer(new ExecutionConfig), createTypeInformation[Void].createSerializer(new ExecutionConfig)) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041119Z" creationid="xccui" creationdate="20190716T041119Z">
        <seg>class TransactionalFileSink(val targetPath: String, val tempPath: String) extends TwoPhaseCommitSinkFunction[(String, Double), String, Void]( createTypeInformation[String].createSerializer(new ExecutionConfig), createTypeInformation[Void].createSerializer(new ExecutionConfig)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class Tuple2ToPersonMapper extends MapFunction[(String, Int), Person] with ResultTypeQueryable[Person] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061912Z" creationid="xccui" creationdate="20190617T061912Z">
        <seg>class Tuple2ToPersonMapper extends MapFunction[(String, Int), Person] with ResultTypeQueryable[Person] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class UpdatableTemperatureAlertFunction() extends KeyedBroadcastProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041330Z" creationid="xccui" creationdate="20190702T041330Z">
        <seg>class UpdatableTemperatureAlertFunction() extends KeyedBroadcastProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class UpdatingWindowCountFunction extends ProcessWindowFunction[</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T033939Z" creationid="xccui" creationdate="20190629T033939Z">
        <seg>class UpdatingWindowCountFunction extends ProcessWindowFunction[</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>clearly define its behavior in a failure scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042849Z" creationid="xccui" creationdate="20190415T042849Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>client</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041611Z" creationid="xccui" creationdate="20190707T041611Z">
        <seg>client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>client.shutdownAndWait()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041554Z" creationid="xccui" creationdate="20190707T041554Z">
        <seg>client.shutdownAndWait()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>client: QueryableStateClient)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041604Z" creationid="xccui" creationdate="20190707T041604Z">
        <seg>client: QueryableStateClient)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cluster by adjusting the ./conf/zoo.cfg file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T161246Z" creationid="xccui" creationdate="20190720T161246Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cnt = if (null == it || !it.iterator().hasNext) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034523Z" creationid="xccui" creationdate="20190713T034523Z">
        <seg>cnt = if (null == it || !it.iterator().hasNext) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collectWithTimestamp() emits a record with its associated timestamp and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T035924Z" creationid="xccui" creationdate="20190713T035818Z">
        <seg>collectWithTimestamp()用来发出记录和与之关联的时间戳；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all events can become significantly larger than the state of a window whose</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034336Z" creationid="xccui" creationdate="20190625T034336Z">
        <seg>收集全部事件的窗口其状态要大得多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>command-line client and the log4j-yarn-session.properties file used by the command- line client when starting a YARN session.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T035316Z" creationid="xccui" creationdate="20190807T035316Z">
        <seg>为启用YARN会话的命令行客户端提供了log4j-yarn-session.properties文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>commit(txn: TXN): Unit commits a transaction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053124Z" creationid="xccui" creationdate="20190716T053124Z">
        <seg>commit(txn: TXN): Unit提交指定事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>communicate only through well-defined channels.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T014828Z" creationid="xccui" creationdate="20190718T014828Z">
        <seg>此外，容器之间处于相互隔离的状态，它们只会通过明确定义的通道进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>community@flink.apache.org : community news and meetups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040538Z" creationid="xccui" creationdate="20190807T040538Z">
        <seg>community@flink.apache.org：社区新闻和聚会</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>compared to event time as it does not provide deterministic results and has simi‐ lar performance as event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T050628Z" creationid="xccui" creationdate="20190619T071915Z">
        <seg>和事件时间相比，摄入时间（ingestion time）的价值不大，因为它的性能和事件时间类似，但却无法提供确定的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>component of a TaskManager collect records in buffers before they are shipped, i.e., records are not shipped one-by-one but batched into buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041706Z" creationid="xccui" creationdate="20190504T041706Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>component: master</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T032005Z" creationid="xccui" creationdate="20190720T032005Z">
        <seg>component: master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>configure an inactivity interval after which a part file is rolled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T022616Z" creationid="xccui" creationdate="20190711T022222Z">
        <seg>此外，你还可以配置一个非活动间隔（inactivity interval），并在该间隔过后滚动生成新的分块文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>conn = DriverManager.getConnection( "jdbc:derby:memory:flinkExample", new Properties())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045219Z" creationid="xccui" creationdate="20190714T045219Z">
        <seg>conn = DriverManager.getConnection( "jdbc:derby:memory:flinkExample", new Properties())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>connection pattern of the rescale distribution transformation is shown in Figure 5-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T044847Z" creationid="xccui" creationdate="20190616T044847Z">
        <seg>图5-7展示了重调分发转换的连接模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>console dashboard that queries the queryable state of the application shown in the previous section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035706Z" creationid="xccui" creationdate="20190707T035706Z">
        <seg>示例7-16展示了一个简单的控制台仪表盘，它会对上一节中应用的可查询式状态进行查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>constantly produced output using the tail command as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190812T163905Z" creationid="xccui" creationdate="20190605T123837Z">
        <seg>可以使用tail命令监控持续产生的结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>containerPort: 6121 name: data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025736Z" creationid="xccui" creationdate="20190720T025736Z">
        <seg>containerPort: 6121 name: data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>containerPort: 6122 name: rpc</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025739Z" creationid="xccui" creationdate="20190720T025739Z">
        <seg>containerPort: 6122 name: rpc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>containerPort: 6123 name: rpc</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025021Z" creationid="xccui" creationdate="20190720T025021Z">
        <seg>containerPort: 6123 name: rpc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>containerPort: 6124 name: blob</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025025Z" creationid="xccui" creationdate="20190720T025025Z">
        <seg>containerPort: 6124 name: blob</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>containerPort: 6125 name: query</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025029Z" creationid="xccui" creationdate="20190720T025029Z">
        <seg>containerPort: 6125 name: query</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>containerPort: 8081 name: ui</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025033Z" creationid="xccui" creationdate="20190720T025033Z">
        <seg>containerPort: 8081 name: ui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>containers:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025007Z" creationid="xccui" creationdate="20190720T025007Z">
        <seg>containers:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>contains the key-value pair.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T064803Z" creationid="xccui" creationdate="20190708T064803Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>context.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052312Z" creationid="xccui" creationdate="20190716T052312Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>context: Context[_]): Unit = { transactionWriter.write(value.toString) transactionWriter.write('\n')</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041555Z" creationid="xccui" creationdate="20190716T041555Z">
        <seg>context: Context[_]): Unit = { transactionWriter.write(value.toString) transactionWriter.write('\n')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>copied their state to the remote storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T202707Z" creationid="xccui" creationdate="20190702T202707Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>counter = getRuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T050221Z" creationid="xccui" creationdate="20190804T050221Z">
        <seg>counter = getRuntimeContext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>counter.inc()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T023458Z" creationid="xccui" creationdate="20190803T023458Z">
        <seg>counter.inc()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>course, quite inefficient and should be avoided.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T212347Z" creationid="xccui" creationdate="20190716T212236Z">
        <seg>这会非常耗时，需要在实际应用中避免。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cpConfig.setCheckpointTimeout(300000);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T203920Z" creationid="xccui" creationdate="20190731T203920Z">
        <seg>cpConfig.setCheckpointTimeout(300000);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cpConfig.setCheckpointingMode(CheckpointingMode.AT_LEAST_ONCE);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T031006Z" creationid="xccui" creationdate="20190731T031006Z">
        <seg>cpConfig.setCheckpointingMode(CheckpointingMode.AT_LEAST_ONCE);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cpConfig.setFailOnCheckpointingErrors(false);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T204451Z" creationid="xccui" creationdate="20190731T204451Z">
        <seg>cpConfig.setFailOnCheckpointingErrors(false);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cpConfig.setMaxConcurrentCheckpoints(3);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T203222Z" creationid="xccui" creationdate="20190731T203222Z">
        <seg>cpConfig.setMaxConcurrentCheckpoints(3);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cpConfig.setMinPauseBetweenCheckpoints(30000);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T202720Z" creationid="xccui" creationdate="20190731T202720Z">
        <seg>cpConfig.setMinPauseBetweenCheckpoints(30000);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>createTypeInformation[SensorReading]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064321Z" creationid="xccui" creationdate="20190715T064321Z">
        <seg>createTypeInformation[SensorReading]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cross-product.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T053144Z" creationid="xccui" creationdate="20190628T053144Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx.collect(cnt)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152451Z" creationid="xccui" creationdate="20190712T152451Z">
        <seg>ctx.collect(cnt)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx.getCheckpointLock.synchronized { cnt += 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034042Z" creationid="xccui" creationdate="20190713T034042Z">
        <seg>ctx.getCheckpointLock.synchronized { cnt += 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx.output(freezingAlarmOutput, s"Freezing Alarm for ${r.id}")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T024020Z" creationid="xccui" creationdate="20190622T024020Z">
        <seg>ctx.output(freezingAlarmOutput, s"Freezing Alarm for ${r.id}")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx.output(lateReadingsOut, r)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155937Z" creationid="xingcan" creationdate="20190628T155937Z">
        <seg>ctx.output(lateReadingsOut, r)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032604Z" creationid="xccui" creationdate="20190622T032604Z">
        <seg>ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]#Context, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032238Z" creationid="xccui" creationdate="20190622T032238Z">
        <seg>ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]#Context, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: Context,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031921Z" creationid="xccui" creationdate="20190625T031921Z">
        <seg>ctx: Context,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: KeyedBroadcastProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042531Z" creationid="xccui" creationdate="20190702T042531Z">
        <seg>ctx: KeyedBroadcastProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: KeyedProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210654Z" creationid="xccui" creationdate="20190704T210654Z">
        <seg>ctx: KeyedProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: KeyedProcessFunction[String, SensorReading, String]#Context, out: Collector[String]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071416Z" creationid="xccui" creationdate="20190621T071416Z">
        <seg>ctx: KeyedProcessFunction[String, SensorReading, String]#Context, out: Collector[String]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: KeyedProcessFunction[String, SensorReading, String]#OnTimerContext, out: Collector[String]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071739Z" creationid="xccui" creationdate="20190621T071739Z">
        <seg>ctx: KeyedProcessFunction[String, SensorReading, String]#OnTimerContext, out: Collector[String]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: ProcessFunction[SensorReading, SensorReading]#Context, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023936Z" creationid="xccui" creationdate="20190622T023936Z">
        <seg>ctx: ProcessFunction[SensorReading, SensorReading]#Context, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: SinkFunction.Context[_]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024737Z" creationid="xccui" creationdate="20190714T024737Z">
        <seg>ctx: SinkFunction.Context[_]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: Trigger.TriggerContext): TriggerResult = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200238Z" creationid="xccui" creationdate="20190626T200238Z">
        <seg>ctx: Trigger.TriggerContext): TriggerResult = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: Trigger.TriggerContext): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200930Z" creationid="xccui" creationdate="20190626T200930Z">
        <seg>ctx: Trigger.TriggerContext): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: WindowAssigner.WindowAssignerContext): java.util.List[TimeWindow] = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042723Z" creationid="xccui" creationdate="20190626T042723Z">
        <seg>ctx: WindowAssigner.WindowAssignerContext): java.util.List[TimeWindow] = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>curl -X &lt;HTTP-Method&gt; [-d &lt;parameters&gt;] http://hostname:port/v1/&lt;REST-point&gt; The v1 indicates the version of the REST API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T041212Z" creationid="xccui" creationdate="20190729T041120Z">
        <seg>curl -X &lt;HTTP-Method&gt; [-d &lt;parameters&gt;] http://hostname:port/v1/&lt;REST-point&gt; v1表示REST API的版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>curl -X GET http://hostname:port/v1/jobmanager/metrics?get=metric1,metric2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044534Z" creationid="xccui" creationdate="20190729T044534Z">
        <seg>curl -X GET http://hostname:port/v1/jobmanager/metrics?get=metric1,metric2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>curl -X GET http://hostname:port/v1/taskmanagers/&lt;tmId&gt;/metrics?get=metric1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T044926Z" creationid="xccui" creationdate="20190729T044926Z">
        <seg>curl -X GET http://hostname:port/v1/taskmanagers/&lt;tmId&gt;/metrics?get=metric1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>curl -X GET http://localhost:8081/v1/jobs/e99cdb41b422631c8ee2218caa6af1cc/\ savepoints/ebde90836b8b9dc2da90e9e7655f4179</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T193627Z" creationid="xccui" creationdate="20190729T193627Z">
        <seg>curl -X GET http://localhost:8081/v1/jobs/e99cdb41b422631c8ee2218caa6af1cc/\ savepoints/ebde90836b8b9dc2da90e9e7655f4179</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>curl -X GET http://localhost:8081/v1/overview</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T041921Z" creationid="xccui" creationdate="20190729T041921Z">
        <seg>curl -X GET http://localhost:8081/v1/overview</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>curl -X PATCH http://localhost:8081/v1/jobs/129ced9aacf1618ebca0ba81a4b222c6/rescaling\</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201756Z" creationid="xccui" creationdate="20190729T201756Z">
        <seg>curl -X PATCH http://localhost:8081/v1/jobs/129ced9aacf1618ebca0ba81a4b222c6/rescaling\</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>curl -X POST -H "Expect:" -F "jarfile=@path/to/flink-job.jar" \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045723Z" creationid="xccui" creationdate="20190729T045723Z">
        <seg>curl -X POST -H "Expect:" -F "jarfile=@path/to/flink-job.jar" \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>curl -d '{"parallelism":"4"}' -X POST \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T152620Z" creationid="xccui" creationdate="20190729T152620Z">
        <seg>curl -d '{"parallelism":"4"}' -X POST \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>curl -d '{"savepoint-path":"file:///savepoints/savepoint-e99cdb-34410597"}'\</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200834Z" creationid="xccui" creationdate="20190729T200834Z">
        <seg>curl -d '{"savepoint-path":"file:///savepoints/savepoint-e99cdb-34410597"}'\</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>curl -d '{"target-directory":"file:///savepoints", "cancel-job":"false"}'\</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T181402Z" creationid="xccui" creationdate="20190729T181402Z">
        <seg>curl -d '{"target-directory":"file:///savepoints", "cancel-job":"false"}'\</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>currentProcessingTime(): Long returns the current processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060006Z" creationid="xccui" creationdate="20190621T060006Z">
        <seg>currentProcessingTime(): Long返回当前的处理时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>currentTimer.update(timerTs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071727Z" creationid="xccui" creationdate="20190621T071727Z">
        <seg>currentTimer.update(timerTs)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>currentWatermark(): Long returns the timestamp of the current watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060023Z" creationid="xccui" creationdate="20190621T060023Z">
        <seg>currentWatermark(): Long返回当前水位线的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cuss how you can tweak the default behavior and control task chaining and the assignment of tasks to slots to improve the performance of your applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T010242Z" creationid="xccui" creationdate="20190730T161323Z">
        <seg>本节我们将讨论如何通过调整默认行为和控制任务链接及作业分配来提高应用的性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>custom</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052308Z" creationid="xccui" creationdate="20190716T052308Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>data with other TaskManagers that run tasks of the same application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061343Z" creationid="xccui" creationdate="20190606T142702Z">
        <seg>在执行期间，运行同一应用不同任务的TaskManager之间会产生数据交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>days.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042801Z" creationid="xccui" creationdate="20190623T042801Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dedicated TimestampAssigner (see “Assigning Timestamps and Generating Water‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T035445Z" creationid="xccui" creationdate="20190713T035445Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def asyncInvoke(input: IN, resultFuture: ResultFuture[OUT]): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T200750Z" creationid="xccui" creationdate="20190716T200750Z">
        <seg>def asyncInvoke(input: IN, resultFuture: ResultFuture[OUT]): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def collectWithTimestamp(T record, long timestamp): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T035642Z" creationid="xccui" creationdate="20190713T035642Z">
        <seg>def collectWithTimestamp(T record, long timestamp): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def emitWatermark(Watermark watermark): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T035646Z" creationid="xccui" creationdate="20190713T035646Z">
        <seg>def emitWatermark(Watermark watermark): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def getId: String = id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220309Z" creationid="xccui" creationdate="20190711T220309Z">
        <seg>def getId: String = id</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def getTemp: Float = temp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220316Z" creationid="xccui" creationdate="20190711T220316Z">
        <seg>def getTemp: Float = temp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def main(args: Array[String]) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041920Z" creationid="xccui" creationdate="20190612T041920Z">
        <seg>def main(args: Array[String]) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def main(args: Array[String]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040101Z" creationid="xccui" creationdate="20190707T040101Z">
        <seg>def main(args: Array[String]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def queryState( key: String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041600Z" creationid="xccui" creationdate="20190707T041600Z">
        <seg>def queryState( key: String,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def setId(id: String): Unit = this.id = id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220306Z" creationid="xccui" creationdate="20190711T220306Z">
        <seg>def setId(id: String): Unit = this.id = id</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def setTemp(temp: Float): Unit = this.temp = temp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220313Z" creationid="xccui" creationdate="20190711T220313Z">
        <seg>def setTemp(temp: Float): Unit = this.temp = temp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def this() = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220258Z" creationid="xccui" creationdate="20190711T220258Z">
        <seg>def this() = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default parallelism of their associated StreamExecutionEnvironment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190728T041901Z" creationid="xccui" creationdate="20190728T041848Z">
        <seg>默认情况下，算子会以其关联的StreamExecutionEnvironment中的默认并行度来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>define their own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070302Z" creationid="xccui" creationdate="20190615T070302Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>defined by calling setParallelism() on StreamExecutionEnvironment or on an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T170339Z" creationid="xccui" creationdate="20190726T031424Z">
        <seg>换言之，通过StreamExecutionEnvironment或算子的setParallelism()方法定义的并行度比默认值优先级更高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>definition files, you can register them to Kubernetes using the kubectl command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T033550Z" creationid="xccui" creationdate="20190720T033435Z">
        <seg>一旦有了这些定义文件，你就可以使用kubectl命令将它们注册到Kubernetes：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deleteEventTimeTimer(timestamp: Long): Unit deletes an event-time timer that was previously registered for the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062828Z" creationid="xccui" creationdate="20190621T060658Z">
        <seg>deleteEventTimeTimer(timestamp: Long): Unit针对当前键值删除一个注册过的事件时间计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deleteProcessingTimeTimer(timestamp: Long): Unit deletes a processing- time timer that was previously registered for the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062812Z" creationid="xccui" creationdate="20190621T060504Z">
        <seg>deleteProcessingTimeTimer(timestamp: Long): Unit针对当前键值删除一个注册过的处理时间计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deleted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194741Z" creationid="xccui" creationdate="20190626T194741Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>depend on the type of the operator and all previous operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T045924Z" creationid="xccui" creationdate="20190727T045924Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deploying Flink applications and the way each distributes and executes tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T045209Z" creationid="xccui" creationdate="20190606T141058Z">
        <seg>我们主要讨论两类部署Flink应用的方式以及它们如何分配和执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dev@flink.apache.org : development, release, and community discussions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040520Z" creationid="xccui" creationdate="20190807T040520Z">
        <seg>dev@flink.apache.org：开发，发布和社区讨论</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>different contexts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T052026Z" creationid="xccui" creationdate="20190621T052026Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>different pieces of state as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032948Z" creationid="xccui" creationdate="20190626T032948Z">
        <seg>窗口包含的不同状态如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>disks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030600Z" creationid="xccui" creationdate="20190801T030600Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>distribution behavior when the HighTempCounter function is rescaled, we can imple‐ ment the snapshotState() method so that it splits its count into multiple partial counts as shown in Example 7-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062416Z" creationid="xccui" creationdate="20190701T062256Z">
        <seg>为了让状态在HighTempCounter函数扩缩容时分布地更好，我们可以像示例7-5中那样，在实现snapshotState()方法时将计数值分成多个子部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not concern us right now.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052907Z" creationid="xccui" creationdate="20190612T052907Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>docker run -d --name flink-jobmanager \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T032420Z" creationid="xccui" creationdate="20190718T032420Z">
        <seg>docker run -d --name flink-jobmanager \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>docker-compose up -d</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T035234Z" creationid="xccui" creationdate="20190730T035234Z">
        <seg>docker-compose up -d</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does not automatically clean up savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210957Z" creationid="xccui" creationdate="20190609T210957Z">
        <seg>同时，Flink也不会自动清理保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dow does not exist yet, it is created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052115Z" creationid="xccui" creationdate="20190625T052115Z">
        <seg>如何目标窗口不存在，则会创建它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dows afterward.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045849Z" creationid="xccui" creationdate="20190626T045849Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>duces a new DataStream of the same type as the input DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052158Z" creationid="xccui" creationdate="20190613T052158Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>during recovery)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T170210Z" creationid="xccui" creationdate="20190708T170210Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>effectively executed with a parallelism of 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063114Z" creationid="xccui" creationdate="20190621T064006Z">
        <seg>从而强制算子以并行度1来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elements are incrementally aggregated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034355Z" creationid="xccui" creationdate="20190625T034355Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elements: Iterable[SensorReading],</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034006Z" creationid="xccui" creationdate="20190629T034006Z">
        <seg>elements: Iterable[SensorReading],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>else {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T023455Z" creationid="xccui" creationdate="20190803T023455Z">
        <seg>else {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>emitWatermark() emits the provided watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T035949Z" creationid="xccui" creationdate="20190713T035920Z">
        <seg>emitWatermark()用来发出传入的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>enableWriteAheadLog([CheckpointCommitter]): This enables the WAL to pro‐ vide exactly-once output guarantees in the case of nondeterministic application logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T223747Z" creationid="xccui" creationdate="20190711T223747Z">
        <seg>enableWriteAheadLog([CheckpointCommitter])：开启WAL，为非确定性的应用逻辑提供精确一次输出保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>enabled by calling setWriteTimestampToKafka(true) on the sink object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T041208Z" creationid="xccui" creationdate="20190710T041129Z">
        <seg>你可以在数据汇对象上调用setWriteTimestampToKafka(true)方法来将事件时间的时间戳写入Kafka记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>end timestamp of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030912Z" creationid="xccui" creationdate="20190625T030912Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>enriches the record, and emits the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T191850Z" creationid="xccui" creationdate="20190716T191850Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>enterprises across different industries such as (online) retail, social media, telecom‐ munication, gaming, and banking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050311Z" creationid="xccui" creationdate="20190605T050311Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.addSource(new SensorSource)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051430Z" creationid="xccui" creationdate="20190612T051430Z">
        <seg>env.addSource(new SensorSource)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.enableCheckpointing(10000);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T030724Z" creationid="xccui" creationdate="20190731T030724Z">
        <seg>env.enableCheckpointing(10000);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.enableCheckpointing(10000L)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204850Z" creationid="xccui" creationdate="20190702T204850Z">
        <seg>env.enableCheckpointing(10000L)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.execute("Compute average sensor temperature")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042809Z" creationid="xccui" creationdate="20190612T042809Z">
        <seg>env.execute("Compute average sensor temperature")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.getConfig.setAutoWatermarkInterval(5000)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045802Z" creationid="xccui" creationdate="20190620T045802Z">
        <seg>env.getConfig.setAutoWatermarkInterval(5000)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.getConfig.setLatencyTrackingInterval(500L)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T055032Z" creationid="xccui" creationdate="20190806T055032Z">
        <seg>env.getConfig.setLatencyTrackingInterval(500L)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.getConfig.setUseSnapshotCompression(true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T204819Z" creationid="xccui" creationdate="20190731T204819Z">
        <seg>env.getConfig.setUseSnapshotCompression(true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.setMaxParallelism(512)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025105Z" creationid="xccui" creationdate="20190703T025105Z">
        <seg>env.setMaxParallelism(512)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.setParallelism(32)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060510Z" creationid="xccui" creationdate="20190616T060510Z">
        <seg>env.setParallelism(32)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.setStateBackend(backend)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025736Z" creationid="xccui" creationdate="20190704T025736Z">
        <seg>env.setStateBackend(backend)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.setStateBackend(stateBackend)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022118Z" creationid="xccui" creationdate="20190801T022118Z">
        <seg>env.setStateBackend(stateBackend)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041940Z" creationid="xccui" creationdate="20190612T041940Z">
        <seg>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025038Z" creationid="xccui" creationdate="20190720T025038Z">
        <seg>env:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env: environment.StreamExecutionEnvironment): Trigger[Object, TimeWindow] = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044154Z" creationid="xccui" creationdate="20190626T044154Z">
        <seg>env: environment.StreamExecutionEnvironment): Trigger[Object, TimeWindow] = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>environment offers more configuration options, such as setting the program parallel‐ ism and enabling fault tolerance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T050029Z" creationid="xccui" creationdate="20190612T045857Z">
        <seg>执行环境还提供了很多配置选项，例如设置程序并行度，启用容错等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eters for the prepared statement.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212559Z" creationid="xccui" creationdate="20190711T212559Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>eval $(minikube docker-env)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T045105Z" creationid="xccui" creationdate="20190730T045105Z">
        <seg>eval $(minikube docker-env)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>event, the operator updates the corresponding aggregate value and emits an event with the updated value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190808T050750Z" creationid="xccui" creationdate="20190614T052132Z">
        <seg>每当有新事件到来，该算子都会更新相应的聚合结果，并将其以事件的形式发送出去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>events with the same key are processed by the same task of the subsequent operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T061142Z" creationid="xccui" creationdate="20190614T050540Z">
        <seg>这样一来有着相同键值的事件一定会在后续算子的同一个任务上处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>example is a stream of rules and a stream of events on which the rules are applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T202923Z" creationid="xccui" creationdate="20190701T202923Z">
        <seg>一个典型的例子是有一条规则流和一条需要应用这些规则的事件流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>examples are windows with count-based triggers, which process and clean their state when a certain number of records has been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T184154Z" creationid="xccui" creationdate="20190704T184154Z">
        <seg>其他例子还有像基于数量触发的窗口，它们只有在收到一定数量的记录时才会进行处理并清除状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>examples of finite, complete data sets that are generated all at once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T035813Z" creationid="xccui" creationdate="20190301T035813Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>executing machine reaches the provided timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060229Z" creationid="xccui" creationdate="20190621T060229Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>executionConfig: ExecutionConfig): TypeSerializer[TimeWindow] = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044229Z" creationid="xccui" creationdate="20190626T044229Z">
        <seg>executionConfig: ExecutionConfig): TypeSerializer[TimeWindow] = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exists, the method has no effect.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060540Z">
        <seg>如果该计时器不存在，则方法不会有任何作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>explicitly specified via the submission client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060228Z" creationid="xccui" creationdate="20190616T060228Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends AbstractRichFunction {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010452Z" creationid="xccui" creationdate="20190624T010452Z">
        <seg>extends AbstractRichFunction {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends AggregateFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005559Z" creationid="xccui" creationdate="20190624T005559Z">
        <seg>extends AggregateFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends AssignerWithPeriodicWatermarks[SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051037Z" creationid="xccui" creationdate="20190620T051037Z">
        <seg>extends AssignerWithPeriodicWatermarks[SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends AssignerWithPunctuatedWatermarks[SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054753Z" creationid="xccui" creationdate="20190620T054753Z">
        <seg>extends AssignerWithPunctuatedWatermarks[SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends AsyncFunction[SensorReading, (String, String)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T204235Z" creationid="xccui" creationdate="20190716T204235Z">
        <seg>extends AsyncFunction[SensorReading, (String, String)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends CoProcessFunction[SensorReading, (String, Long), SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032027Z" creationid="xccui" creationdate="20190622T032027Z">
        <seg>extends CoProcessFunction[SensorReading, (String, Long), SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends FlatMapFunction[SensorReading, (String, Long, Long)] with CheckpointedFunction {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T154751Z" creationid="xccui" creationdate="20190702T154751Z">
        <seg>extends FlatMapFunction[SensorReading, (String, Long, Long)] with CheckpointedFunction {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends KeyedProcessFunction[String, SensorReading, (String, Double, Double)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205618Z" creationid="xccui" creationdate="20190704T205618Z">
        <seg>extends KeyedProcessFunction[String, SensorReading, (String, Double, Double)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends KeyedProcessFunction[String, SensorReading, String] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071301Z" creationid="xccui" creationdate="20190621T071301Z">
        <seg>extends KeyedProcessFunction[String, SensorReading, String] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends ProcessFunction[SensorReading, SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155850Z" creationid="xingcan" creationdate="20190628T155850Z">
        <seg>extends ProcessFunction[SensorReading, SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends ProcessWindowFunction[SensorReading, MinMaxTemp, String, TimeWindow] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031913Z" creationid="xccui" creationdate="20190625T031913Z">
        <seg>extends ProcessWindowFunction[SensorReading, MinMaxTemp, String, TimeWindow] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends RichFlatMapFunction[SensorReading, (Int, Long)]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052319Z" creationid="xccui" creationdate="20190701T052319Z">
        <seg>extends RichFlatMapFunction[SensorReading, (Int, Long)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends RichFlatMapFunction[SensorReading, (String, Double, Double)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064210Z" creationid="xccui" creationdate="20190630T064210Z">
        <seg>extends RichFlatMapFunction[SensorReading, (String, Double, Double)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends SourceFunction[Long] with CheckpointedFunction {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T033924Z" creationid="xccui" creationdate="20190713T033924Z">
        <seg>extends SourceFunction[Long] with CheckpointedFunction {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends Trigger[SensorReading, TimeWindow] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200227Z" creationid="xccui" creationdate="20190626T200227Z">
        <seg>extends Trigger[SensorReading, TimeWindow] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends WindowAssigner[Object, TimeWindow] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042650Z" creationid="xccui" creationdate="20190626T042650Z">
        <seg>extends WindowAssigner[Object, TimeWindow] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>external sink system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T200623Z" creationid="xccui" creationdate="20190715T200623Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extractedTS: Long): Watermark = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054810Z" creationid="xccui" creationdate="20190620T054810Z">
        <seg>extractedTS: Long): Watermark = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fails if the savepoint folder is neither explicitly specified in the command nor avail‐ able  from  the  configuration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T204128Z" creationid="xccui" creationdate="20190726T183741Z">
        <seg>如果保存点文件夹既没有在命令中指定，也无法从配置中获取，则命令会执行失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T051249Z" creationid="xccui" creationdate="20190701T051249Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T023501Z" creationid="xccui" creationdate="20190803T023501Z">
        <seg>false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fashion, i.e., the data input of a query is fully available and the query terminates after it returned the computed result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194449Z" creationid="xccui" creationdate="20190228T194449Z">
        <seg>即，可以全量获取查询输入且查询会在返回结果后终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fers might become unavailable and data might get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234823Z" creationid="xccui" creationdate="20190605T234823Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fetched, the TypeInformation for the key, and the StateDescriptor of the queried state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T034441Z" creationid="xccui" creationdate="20190707T034441Z">
        <seg>键值的TypeInformation以及可查询式状态的StateDescriptor。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>field is the common key, the second field is the sum, and the third field is not defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T062218Z" creationid="xccui" creationdate="20190614T060228Z">
        <seg>结果中的第一个字段是键值，第二个字段是总和，第三个字段没有定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>file formats, such as Apache Orc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T183045Z" creationid="xccui" creationdate="20190711T183045Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>file with the configuration key rest.port.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T040436Z" creationid="xccui" creationdate="20190729T040436Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>files, and listing the contents of a directory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T041120Z" creationid="xccui" creationdate="20190722T041120Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first type are periodic report queries that compute business-relevant statistics such as revenue, user growth, or production output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T025119Z" creationid="esouser" creationdate="20190603T203039Z">
        <seg>第一类是定期报告查询。它可用于计算业务相关的统计数据，如收入、用户增长、产出等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>flag as a JSON object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T050436Z" creationid="xccui" creationdate="20190729T050436Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>flink.partition-discovery.interval-millis with a nonnegative value to the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T042441Z" creationid="xccui" creationdate="20190709T042441Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>flushes and closes the transaction file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T053052Z" creationid="xccui" creationdate="20190716T053052Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034500Z" creationid="xccui" creationdate="20190807T034500Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T124826Z" creationid="xccui" creationdate="20190706T124826Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (cnt &lt;- state.asScala) { highTempCnt += cnt</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052902Z" creationid="xccui" creationdate="20190701T052902Z">
        <seg>for (cnt &lt;- state.asScala) { highTempCnt += cnt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (i &lt;- 0 until numSensors) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041308Z" creationid="xccui" creationdate="20190707T041308Z">
        <seg>for (i &lt;- 0 until numSensors) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (r &lt;- readings.asScala) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064359Z" creationid="xccui" creationdate="20190715T064359Z">
        <seg>for (r &lt;- readings.asScala) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ascending timestamps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051915Z" creationid="xccui" creationdate="20190620T051915Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for the Scala API, and it is used as shown in the following:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053814Z" creationid="xccui" creationdate="20190617T053801Z">
        <seg>它的用法如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>forwardingEnabled.clear() disableTimer.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032656Z" creationid="xccui" creationdate="20190622T032656Z">
        <seg>forwardingEnabled.clear() disableTimer.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>forwardingEnabled.update(true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032320Z" creationid="xccui" creationdate="20190622T032320Z">
        <seg>forwardingEnabled.update(true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from a window by calling the remove() method on the Iterator that can be obtained from the Iterable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203426Z" creationid="xccui" creationdate="20190627T203426Z">
        <seg>从Iterable中可以取得Iterator对象，调用后者的remove()方法就能删除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from the JobManager about completed checkpoints (see “Receiving Notifications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T034958Z" creationid="xccui" creationdate="20190715T034958Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fs.&lt;scheme&gt;.limit.total: (number, 0/-1 mean no limit) fs.&lt;scheme&gt;.limit.input: (number, 0/-1 mean no limit) fs.&lt;scheme&gt;.limit.output: (number, 0/-1 mean no limit) fs.&lt;scheme&gt;.limit.timeout: (milliseconds, 0 means infinite) fs.&lt;scheme&gt;.limit.stream-timeout: (milliseconds, 0 means infinite)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T045812Z" creationid="xccui" creationdate="20190722T045812Z">
        <seg>fs.&lt;scheme&gt;.limit.total:（数字，0或-1表示无限制） fs.&lt;scheme&gt;.limit.input:（数字，0或-1表示无限制） fs.&lt;scheme&gt;.limit.output:（数字，0或-1表示无限制） fs.&lt;scheme&gt;.limit.timeout:（毫秒数，0表示无限） fs.&lt;scheme&gt;.limit.stream-timeout:（毫秒数，0表示无限）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function is restored, the parts of the state are distributed among all parallel instances of the function and handed to the restoreState() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T050355Z" creationid="xccui" creationdate="20190701T061204Z">
        <seg>在函数进行状态恢复时，Flink会将状态的各个部分分发到函数的所有并行实例上，并利用每个实例上的状态调用restoreState()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033454Z" creationid="xccui" creationdate="20190619T033454Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function: ProcessWindowFunction[IN, OUT, K, W])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040344Z" creationid="xccui" creationdate="20190625T040344Z">
        <seg>function: ProcessWindowFunction[IN, OUT, K, W])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T035616Z" creationid="xccui" creationdate="20190625T035616Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211002Z" creationid="xccui" creationdate="20190623T211002Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>futures(i) = queryState("sensor_" + (i + 1), client)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041311Z" creationid="xccui" creationdate="20190707T041311Z">
        <seg>futures(i) = queryState("sensor_" + (i + 1), client)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gate, you lose the information about how your data varies over time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043721Z" creationid="xccui" creationdate="20190406T043721Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ger the execution of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011950Z" creationid="xccui" creationdate="20190613T011950Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>get stronger semantics with weaker guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050116Z" creationid="xccui" creationdate="20190416T050116Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>git clone https://github.com/streaming-with-flink/examples-scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040428Z" creationid="xccui" creationdate="20190611T040428Z">
        <seg>git clone https://github.com/streaming-with-flink/examples-scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gives access to the element or timer timestamp, a TimerService, and side outputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T012329Z" creationid="xccui" creationdate="20190622T031158Z">
        <seg>在被调用时都会传入一个Context对象，用于访问当前元素或计时器时间戳、TimerService及副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hdfs:///xxx:50070/savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T033847Z" creationid="xccui" creationdate="20190726T033847Z">
        <seg>hdfs:///xxx:50070/savepoints</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hdfs:///xxx:50070/savepoints d5fdaff43022954f5f02fcd8f25ef855 Cancelling job bc0b2ad61ecd4a615d92ce25390f61ad</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T184655Z" creationid="xccui" creationdate="20190726T184655Z">
        <seg>hdfs:///xxx:50070/savepoints d5fdaff43022954f5f02fcd8f25ef855 Cancelling job bc0b2ad61ecd4a615d92ce25390f61ad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>hdfs:///xxx:50070/savepoints/savepoint-bc0b2a-63cf5d5ccef8</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T035205Z" creationid="xccui" creationdate="20190726T035205Z">
        <seg>hdfs:///xxx:50070/savepoints/savepoint-bc0b2a-63cf5d5ccef8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>heap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T064256Z" creationid="xccui" creationdate="20190621T064256Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>high-availability.cluster-id: /cluster-1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T051143Z" creationid="xccui" creationdate="20190721T051143Z">
        <seg>high-availability.cluster-id: /cluster-1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>high-availability.zookeeper.path.root: /flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T204954Z" creationid="xccui" creationdate="20190720T204954Z">
        <seg>high-availability.zookeeper.path.root: /flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>highTempCnt += 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052533Z" creationid="xccui" creationdate="20190701T052533Z">
        <seg>highTempCnt += 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>histogramWrapper.update(value)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033659Z" creationid="xccui" creationdate="20190803T033659Z">
        <seg>histogramWrapper.update(value)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>holds the information used to distinguish windows from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033853Z" creationid="xccui" creationdate="20190626T033853Z">
        <seg>因此窗口对象中保存着用于区分窗口的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>host.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T035513Z" creationid="xccui" creationdate="20190718T035513Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>host.taskmanager.512” where “localhost” and “512” are parameter values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043449Z" creationid="xccui" creationdate="20190804T043449Z">
        <seg>其中"localhost"和"512"是参数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://hostname:port/v1/jars/upload</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T045726Z" creationid="xccui" creationdate="20190729T045726Z">
        <seg>http://hostname:port/v1/jars/upload</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://localhost:8081.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T035328Z" creationid="xccui" creationdate="20190730T035328Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>http://localhost:8081/v1/jars/43e844ef-382f-45c3-aa2f-00549acd961e_App.jar/run</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T152624Z" creationid="xccui" creationdate="20190729T152624Z">
        <seg>http://localhost:8081/v1/jars/43e844ef-382f-45c3-aa2f-00549acd961e_App.jar/run</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://flink-forward.org</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040558Z" creationid="xccui" creationdate="20190807T040558Z">
        <seg>https://flink-forward.org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://flink.apache.org/blog</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040543Z" creationid="xccui" creationdate="20190807T040543Z">
        <seg>https://flink.apache.org/blog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://github.com/streaming-with-flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210814Z" creationid="esouser" creationdate="20190603T210814Z">
        <seg>https://github.com/streaming-with-flink.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://www.meetup.com/topics/apache-flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040627Z" creationid="xccui" creationdate="20190807T040627Z">
        <seg>https://www.meetup.com/topics/apache-flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://www.ververica.com/blog</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040546Z" creationid="xccui" creationdate="20190807T040546Z">
        <seg>https://www.ververica.com/blog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ices as the Context object of the processElement() method and also returns the time domain (processing time or event time) of the firing trigger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T055201Z">
        <seg>此外，它还会返回触发计时器的时间域（处理时间还是事件时间）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>identified by an OutputTag[X] object, where X is the type of the resulting side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T015021Z" creationid="xccui" creationdate="20190622T014937Z">
        <seg>每个副输出都由一个OutputTag[X]对象标识，其中X是副输出结果流的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!firstSeen.value()) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200415Z" creationid="xccui" creationdate="20190626T200415Z">
        <seg>if (!firstSeen.value()) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!isUpdate.value()) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034338Z" creationid="xccui" creationdate="20190629T034338Z">
        <seg>if (!isUpdate.value()) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (Files.exists(tFilePath)) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042120Z" creationid="xccui" creationdate="20190716T042120Z">
        <seg>if (Files.exists(tFilePath)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (in.temperature &gt; threshold) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052459Z" creationid="xccui" creationdate="20190701T052459Z">
        <seg>if (in.temperature &gt; threshold) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (key &lt; 0) 0 else r.nextInt(numPartitions)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050644Z" creationid="xccui" creationdate="20190616T050644Z">
        <seg>if (key &lt; 0) 0 else r.nextInt(numPartitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (prevTemp == 0.0 || r.temperature &lt; prevTemp) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071522Z" creationid="xccui" creationdate="20190621T071522Z">
        <seg>if (prevTemp == 0.0 || r.temperature &lt; prevTemp) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (r.id == "sensor_1") {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054813Z" creationid="xccui" creationdate="20190620T054813Z">
        <seg>if (r.id == "sensor_1") {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (r.temperature &lt; 32.0) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T024017Z" creationid="xccui" creationdate="20190622T024017Z">
        <seg>if (r.temperature &lt; 32.0) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (r.timestamp &lt; ctx.timerService().currentWatermark()) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155909Z" creationid="xingcan" creationdate="20190628T155909Z">
        <seg>if (r.timestamp &lt; ctx.timerService().currentWatermark()) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (t &lt; window.getEnd) { ctx.registerEventTimeTimer(t)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200827Z" creationid="xccui" creationdate="20190626T200827Z">
        <seg>if (t &lt; window.getEnd) { ctx.registerEventTimeTimer(t)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (tempDiff &gt; sensorThreshold) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042750Z" creationid="xccui" creationdate="20190702T042750Z">
        <seg>if (tempDiff &gt; sensorThreshold) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (tempDiff &gt; threshold) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064454Z" creationid="xccui" creationdate="20190630T064454Z">
        <seg>if (tempDiff &gt; threshold) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (thresholds.contains(reading.id)) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042743Z" creationid="xccui" creationdate="20190702T042743Z">
        <seg>if (thresholds.contains(reading.id)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (timerTimestamp &gt; curTimerTimestamp) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032344Z" creationid="xccui" creationdate="20190622T032344Z">
        <seg>if (timerTimestamp &gt; curTimerTimestamp) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (timestamp == window.getEnd) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200703Z" creationid="xccui" creationdate="20190626T200703Z">
        <seg>if (timestamp == window.getEnd) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (update.threshold != 0.0d) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042556Z" creationid="xccui" creationdate="20190702T042556Z">
        <seg>if (update.threshold != 0.0d) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (updateStmt.getUpdateCount == 0) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045748Z" creationid="xccui" creationdate="20190714T045748Z">
        <seg>if (updateStmt.getUpdateCount == 0) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (v.temperature &gt; threshold) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162303Z" creationid="xccui" creationdate="20190702T162303Z">
        <seg>if (v.temperature &gt; threshold) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (value &gt; 0) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015246Z" creationid="xccui" creationdate="20190803T015246Z">
        <seg>if (value &gt; 0) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if you changed the ValueState[String] to a ValueState[Double], Flink would cre‐ ate a DoubleSerializer to access the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T035140Z" creationid="xccui" creationdate="20190705T052252Z">
        <seg>举例而言，如果你将ValueState[String]改为ValueState[Double]，Flink将创建一个DoubleSerializer来访问状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if you need to ensure a function’s operator state can be evolved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035314Z" creationid="xccui" creationdate="20190701T063328Z">
        <seg>如果想确保函数的算子状态日后支持更新，请使用CheckpointedFunction接口替代ListCheckpointed。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if(in % 2 == subTaskIndex) { out.collect((subTaskIndex, in))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034505Z" creationid="xccui" creationdate="20190619T034505Z">
        <seg>if(in % 2 == subTaskIndex) { out.collect((subTaskIndex, in))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ify an offset as a second parameter in the assigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054244Z" creationid="xccui" creationdate="20190623T054157Z">
        <seg>或者你也可以通过第二个参数指定一个偏移量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ignore the idle stream partition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T051506Z" creationid="xccui" creationdate="20190713T051506Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035452Z" creationid="xccui" creationdate="20190418T035452Z">
        <seg>iii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>implement your own streaming sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T053011Z" creationid="xccui" creationdate="20190612T054219Z">
        <seg>你也可以选择自己实现流式数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>implements Serializable {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041558Z" creationid="xccui" creationdate="20190626T041558Z">
        <seg>implements Serializable {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>implications on the robustness of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T222144Z" creationid="xccui" creationdate="20190703T222144Z">
        <seg>但它会影响应用的鲁棒性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>import org.apache.flink.api.common.functions.MapFunction import org.slf4j.LoggerFactory</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034109Z" creationid="xccui" creationdate="20190807T034109Z">
        <seg>import org.apache.flink.api.common.functions.MapFunction import org.slf4j.LoggerFactory</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>import org.apache.flink.streaming.api.scala._</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054850Z" creationid="xccui" creationdate="20190617T054850Z">
        <seg>import org.apache.flink.streaming.api.scala._</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>import org.slf4j.Logger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034114Z" creationid="xccui" creationdate="20190807T034114Z">
        <seg>import org.slf4j.Logger</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in ./conf/flink-conf.yaml with a default value of 10 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T060605Z" creationid="xccui" creationdate="20190721T060605Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in Example 8-15 does not need the context and hence sets the type to Void.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052406Z" creationid="xccui" creationdate="20190716T052406Z">
        <seg>示例8-15中的TransactionalFileSink不需要该上下文对象，因此将其类型设置为Void。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the HADOOP_CLASSPATH environment variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T025803Z" creationid="xccui" creationdate="20190722T025803Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in time, usually the point in time at which the event that is represented by the record happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204807Z" creationid="xccui" creationdate="20190606T204807Z">
        <seg>时间戳将记录和特定时间点进行关联，这些时间点通常是记录所表示事件的发生时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in very specific cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T052759Z" creationid="xccui" creationdate="20190705T052759Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>inclusive and end is exclusive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041615Z" creationid="xccui" creationdate="20190623T041615Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>incrAggregator: AggregateFunction[IN, ACC, V], windowFunction: ProcessWindowFunction[V, OUT, K, W])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040523Z" creationid="xccui" creationdate="20190625T040523Z">
        <seg>incrAggregator: AggregateFunction[IN, ACC, V], windowFunction: ProcessWindowFunction[V, OUT, K, W])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>incrAggregator: ReduceFunction[IN],</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040341Z" creationid="xccui" creationdate="20190625T040341Z">
        <seg>incrAggregator: ReduceFunction[IN],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>increase the processing latency of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195732Z" creationid="xccui" creationdate="20190609T195732Z">
        <seg>但它仍会增加应用处理延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>increased the parallelism of this operator, some of the new subtasks would be initial‐ ized with an empty state, and start counting from zero.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061840Z" creationid="xccui" creationdate="20190701T061840Z">
        <seg>如果我们增加算子的并行度，那么部分新的子任务就只能得到空的状态，从而需要从零开始计数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>increases the number of buffers but can reduce the efficiency of the network stack.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T040902Z" creationid="xccui" creationdate="20190724T040837Z">
        <seg>降低单个网络缓冲区的大小可以增加其数量，但会降低网络栈整体的工作效率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>incremental aggregation function is specified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201556Z" creationid="xccui" creationdate="20190626T201556Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>individually configured.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043038Z" creationid="xccui" creationdate="20190724T043038Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>information between multiple windows on the same key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024913Z" creationid="xccui" creationdate="20190624T024913Z">
        <seg>全局状态可用于在键值相同的多个窗口之间共享信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ing: transactional processing and analytical processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T194515Z" creationid="esouser" creationdate="20190603T194515Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ingested elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052722Z" creationid="xccui" creationdate="20190620T052722Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>initCtx: FunctionInitializationContext): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034503Z" creationid="xccui" creationdate="20190713T034503Z">
        <seg>initCtx: FunctionInitializationContext): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040331Z" creationid="xccui" creationdate="20190625T040331Z">
        <seg>input</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input and redirects them to a side-output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155514Z" creationid="xingcan" creationdate="20190628T155514Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input split, read the file range that is defined by the split, and return all corresponding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T192301Z" creationid="xccui" creationdate="20190710T192301Z">
        <seg>按照划分中限定的范围读取文件并返回所有相应的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input.addSink(sink)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205930Z" creationid="xccui" creationdate="20190710T205930Z">
        <seg>input.addSink(sink)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025831Z" creationid="xccui" creationdate="20190628T025831Z">
        <seg>input1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input1.join(input2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T035951Z" creationid="xccui" creationdate="20190628T035951Z">
        <seg>input1.join(input2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>insertStmt = conn.prepareStatement(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045244Z" creationid="xccui" creationdate="20190714T045244Z">
        <seg>insertStmt = conn.prepareStatement(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>insertStmt.execute()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045834Z" creationid="xccui" creationdate="20190714T045834Z">
        <seg>insertStmt.execute()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instance of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T044645Z" creationid="xccui" creationdate="20190615T044645Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instance, ValueState is completely deserialized when it is accessed and serialized when it is updated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T031904Z" creationid="xccui" creationdate="20190704T031904Z">
        <seg>例如，ValueState需要在更新和访问时分别进行完整的序列化和反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instance, the default scope for TaskManager metrics might create the scope “local‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043443Z" creationid="xccui" creationdate="20190804T043443Z">
        <seg>例如，TaskManager指标的默认域可能是"localhost.taskmanager.512"，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instance, when you join or group by some key, TypeInformation allows Flink to per‐ form the semantic check of whether the fields used as keys are valid.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151948Z" creationid="xccui" creationdate="20190617T050559Z">
        <seg>例如：如果需要通过某个键值进行Join或分组，TypeInformation允许Flink对能否使用某字段作为键值进行语义检测。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instances of an operator, the proxy needs to identify the TaskManager that main‐ tains the state for the requested key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T023321Z" creationid="xccui" creationdate="20190706T022529Z">
        <seg>由于键值分区状态会分布在算子所有并行实例上面，所以代理需要识别请求键值对应的状态所在的TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>interface EvictorContext {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202127Z" creationid="xccui" creationdate="20190627T202127Z">
        <seg>interface EvictorContext {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>interface that extends WindowAssigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045237Z" creationid="xccui" creationdate="20190626T045237Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>internal state, will it update it again after it recovers?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033635Z" creationid="xccui" creationdate="20190606T033635Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>interval is set to two hundred milliseconds, but it can be configured using the Execu tionConfig.setAutoWatermarkInterval() method:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055335Z" creationid="xccui" creationdate="20190620T045716Z">
        <seg>默认的时间间隔为200毫秒，但你可以利用ExecutionConfig.setAutoWatermarkInterval()方法对其进行配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>invoke(txn: TXN, value: IN, context: Context[_]): Unit writes a value to the current transaction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052751Z" creationid="xccui" creationdate="20190716T052751Z">
        <seg>invoke(txn: TXN, value: IN, context: Context[_]): Unit将传入值写入当前事务中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is actually accessed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T034039Z" creationid="xccui" creationdate="20190704T034039Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is configured per operator using the setMaxParallelism() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T031609Z" creationid="xccui" creationdate="20190729T031609Z">
        <seg>为了设置该键值组的数值，我们可以针对每个算子调用setMaxParallelism()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T024915Z" creationid="xccui" creationdate="20190626T024915Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is forwarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T050306Z" creationid="xccui" creationdate="20190620T050306Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is started or when a task is restarted due to a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190813T154809Z" creationid="xccui" creationdate="20190702T064344Z">
        <seg>其触发时机是应用启动或由于故障而重启任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it is modified because its modification timestamp changes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T200310Z" creationid="xccui" creationdate="20190710T200310Z">
        <seg>这意味着文件如果发生改动（其修改时间发生变化），则会被完全重新处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>its preceding operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T023212Z" creationid="xccui" creationdate="20190610T023212Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iv</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035723Z" creationid="xccui" creationdate="20190418T035723Z">
        <seg>iv</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iv | Table of Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130312Z" creationid="xccui" creationdate="20190605T130312Z">
        <seg>iv | 目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ix</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040613Z" creationid="xccui" creationdate="20190418T040613Z">
        <seg>ix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ix 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145402Z" creationid="esouser" creationdate="20190603T145402Z">
        <seg>ix 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>java.util.Collections.singletonList(highTempCnt)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T053238Z" creationid="xccui" creationdate="20190701T053238Z">
        <seg>java.util.Collections.singletonList(highTempCnt)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>job-cluster-job.yaml.template configures the master container as a Kubernetes job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T043856Z" creationid="xccui" creationdate="20190730T043856Z">
        <seg>job-cluster-job.yaml.template将主容器配置为Kubernetes作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>jobmanager ports:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025015Z" creationid="xccui" creationdate="20190720T025015Z">
        <seg>jobmanager ports:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>join is defined as shown in Example 6-18.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025803Z" creationid="xccui" creationdate="20190628T025803Z">
        <seg>示例6-18中定义了一个基于间隔的Join。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>key of the current record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191732Z" creationid="xccui" creationdate="20190607T191732Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keyBy</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050132Z" creationid="xccui" creationdate="20190614T050132Z">
        <seg>keyBy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keyBy() method:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051732Z" creationid="xccui" creationdate="20190618T051732Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T141438Z" creationid="xccui" creationdate="20190704T141438Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>kubectl create -f job-cluster-service.yaml kubectl create -f job-cluster-job.yaml</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T044613Z" creationid="xccui" creationdate="20190730T044613Z">
        <seg>kubectl create -f job-cluster-service.yaml kubectl create -f job-cluster-job.yaml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>kubectl create -f master-deployment.yaml kubectl create -f worker-deployment.yaml kubectl create -f master-service.yaml</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T033531Z" creationid="xccui" creationdate="20190720T033531Z">
        <seg>kubectl create -f master-deployment.yaml kubectl create -f worker-deployment.yaml kubectl create -f master-service.yaml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>kubectl create -f task-manager-deployment.yaml</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T044617Z" creationid="xccui" creationdate="20190730T044617Z">
        <seg>kubectl create -f task-manager-deployment.yaml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>kubectl delete -f master-deployment.yaml kubectl delete -f worker-deployment.yaml kubectl delete -f master-service.yaml</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T040228Z" creationid="xccui" creationdate="20190720T040228Z">
        <seg>kubectl delete -f master-deployment.yaml kubectl delete -f worker-deployment.yaml kubectl delete -f master-service.yaml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>kubectl get deployments</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T033844Z" creationid="xccui" creationdate="20190720T033844Z">
        <seg>kubectl get deployments</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>kubectl port-forward deployment/flink-master 8081:8081</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T035417Z" creationid="xccui" creationdate="20190720T035417Z">
        <seg>kubectl port-forward deployment/flink-master 8081:8081</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>labels:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024956Z" creationid="xccui" creationdate="20190720T024956Z">
        <seg>labels:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lastTemp.update(r.temperature)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071516Z" creationid="xccui" creationdate="20190621T071516Z">
        <seg>lastTemp.update(r.temperature)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lastTempDescriptor.setQueryable("lastTemperature")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T061045Z" creationid="xccui" creationdate="20190706T061045Z">
        <seg>lastTempDescriptor.setQueryable("lastTemperature")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lastTempState = getRuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T061048Z" creationid="xccui" creationdate="20190706T061048Z">
        <seg>lastTempState = getRuntimeContext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lastTempState = getRuntimeContext.getState[Double](lastTempDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064327Z" creationid="xccui" creationdate="20190630T064327Z">
        <seg>lastTempState = getRuntimeContext.getState[Double](lastTempDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lastTimerState.update(newTimer)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210645Z" creationid="xccui" creationdate="20190704T210645Z">
        <seg>lastTimerState.update(newTimer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>latency (a request/response involves two network messages) and the MapFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T192143Z" creationid="xccui" creationdate="20190716T192143Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lazy val currentTimer: ValueState[Long] = getRuntimeContext.getState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071405Z" creationid="xccui" creationdate="20190621T071405Z">
        <seg>lazy val currentTimer: ValueState[Long] = getRuntimeContext.getState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lazy val disableTimer: ValueState[Long] = getRuntimeContext.getState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032228Z" creationid="xccui" creationdate="20190622T032228Z">
        <seg>lazy val disableTimer: ValueState[Long] = getRuntimeContext.getState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lazy val forwardingEnabled: ValueState[Boolean] = getRuntimeContext.getState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032058Z" creationid="xccui" creationdate="20190622T032058Z">
        <seg>lazy val forwardingEnabled: ValueState[Boolean] = getRuntimeContext.getState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lazy val freezingAlarmOutput: OutputTag[String] = new OutputTag[String]("freezing-alarms")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023931Z" creationid="xccui" creationdate="20190622T023931Z">
        <seg>lazy val freezingAlarmOutput: OutputTag[String] = new OutputTag[String]("freezing-alarms")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lazy val lastTemp: ValueState[Double] = getRuntimeContext.getState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071341Z" creationid="xccui" creationdate="20190621T071341Z">
        <seg>lazy val lastTemp: ValueState[Double] = getRuntimeContext.getState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>leaking state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040854Z" creationid="xccui" creationdate="20190626T040854Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>learned about Flink’s AsyncFunction, which can significantly improve the perfor‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T214524Z" creationid="xccui" creationdate="20190716T214410Z">
        <seg>最后，你学习了Flink的AsyncFunction，它可以通过异步处理请求显著提高与外界系统交互的性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>limited JobManager heap storage, it is not recommended for production environ‐ ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T021527Z" creationid="xccui" creationdate="20190801T021527Z">
        <seg>所以不建议将其用于生产环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local storage path of most components of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T042923Z" creationid="xccui" creationdate="20190724T042923Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>log.flush.*</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T033447Z" creationid="xccui" creationdate="20190710T033447Z">
        <seg>log.flush.*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>log.flush.interval.messages</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T033439Z" creationid="xccui" creationdate="20190710T033439Z">
        <seg>log.flush.interval.messages</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>log.flush.interval.ms</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T033444Z" creationid="xccui" creationdate="20190710T033444Z">
        <seg>log.flush.interval.ms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>log4j.rootLogger=WARN</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034555Z" creationid="xccui" creationdate="20190807T034555Z">
        <seg>log4j.rootLogger=WARN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long getCurrentProcessingTime();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192555Z" creationid="xccui" creationdate="20190626T192555Z">
        <seg>long getCurrentProcessingTime();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long getCurrentWatermark();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192617Z" creationid="xccui" creationdate="20190626T192617Z">
        <seg>long getCurrentWatermark();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190130Z" creationid="xccui" creationdate="20190626T190130Z">
        <seg>long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long timestamp, WindowAssignerContext context);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041651Z" creationid="xccui" creationdate="20190626T041651Z">
        <seg>long timestamp, WindowAssignerContext context);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>low latency but results depend on the speed of processing and are not deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181105Z" creationid="xccui" creationdate="20190606T031232Z">
        <seg>总而言之，虽然处理时间提供了很低的延迟，但它的结果依赖处理速度，具有不确定性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lowing format:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T213915Z" creationid="xccui" creationdate="20190710T213915Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lowing:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062207Z" creationid="xccui" creationdate="20190617T062207Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>main method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043220Z" creationid="xccui" creationdate="20190612T043220Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>main() method assembles the dataflow and submits it to a remote JobManager when the StreamExecutionEnvironment.execute() method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T092548Z" creationid="xccui" creationdate="20190611T051412Z">
        <seg>通常情况下程序的main()方法会把Dataflow组装好，然后在StreamExecutionEnvironment.execute()方法被调用时将其提交到远程的JobManager上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>maintain information that should be shared between multiple invocations of the pro cess() method on the same window, which can happen due to configuring allowed lateness or using a custom trigger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024428Z" creationid="xccui" creationdate="20190624T023815Z">
        <seg>单个窗口状态用于维护同一窗口内多次调用process()方法所需共享的信息，这种多次调用可能是由于配置了允许数据迟到或使用了自定义触发器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>manager.512.MyMetrics.myCounter.” You can change the default “.” delimiter by set‐ ting the metrics.scope.delimiter configuration option.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T034147Z" creationid="xccui" creationdate="20190804T034147Z">
        <seg>你可以通过metrics.scope.delimiter配置项对默认分隔符"."进行修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mance of interacting with external systems by performing and handling requests</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T214538Z" creationid="xccui" creationdate="20190716T214533Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>many sensor readings exceed a specified threshold.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T154652Z" creationid="xccui" creationdate="20190702T154652Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>map1() and flatMap1() are called to process an event of the first input and map2() and flat Map2() are invoked to process an event of the second input:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T062102Z" creationid="xccui" creationdate="20190615T041435Z">
        <seg>map1()和flatMap1()用来处理第一条输入流的事件，map2()和flatMap2()用来处理第二条输入流的事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>marks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T033233Z" creationid="xccui" creationdate="20190620T033233Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>marks” for details) or be assigned and generated by a source function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T035448Z" creationid="xccui" creationdate="20190713T035448Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>matically puts all keyed state objects of the function into the context of the key of the record that is passed by the function call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T034124Z" creationid="xccui" creationdate="20190630T063103Z">
        <seg>Flink运行时会在调用它的处理方法时自动将函数中的全部键值分区状态对象放入当前处理记录的键值上下文中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>max()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053408Z" creationid="xccui" creationdate="20190614T053408Z">
        <seg>max()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>maxBy()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053818Z" creationid="xccui" creationdate="20190614T053818Z">
        <seg>maxBy()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>maxTs = maxTs.max(r.timestamp)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051144Z" creationid="xccui" creationdate="20190620T051144Z">
        <seg>maxTs = maxTs.max(r.timestamp)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mentations for the different state primitives, such as ValueState, ListState, and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221556Z" creationid="xccui" creationdate="20190703T221556Z">
        <seg>每一种状态后端都为不同的状态原语（如ValueState、ListState和MapState）提供了不同的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ments such as variable or function names, databases, data types, environment variables, statements, and keywords.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210805Z" creationid="esouser" creationdate="20190603T210805Z">
        <seg>ments such as variable or function names, databases, data types, environment variables, statements, and keywords.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mergePartitionedState() method of the OnMergeContext object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195325Z" creationid="xccui" creationdate="20190626T195325Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>merges black and gray events into a single output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T065114Z" creationid="xccui" creationdate="20190614T065114Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>message Sampling in progress... for about five seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190802T152231Z" creationid="xingcan" creationdate="20190802T152231Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>metadata:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024946Z" creationid="xccui" creationdate="20190720T024946Z">
        <seg>metadata:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method (Example 10-2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203934Z" creationid="xccui" creationdate="20190730T203934Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method assembles the operator state from possibly multiple parts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T060711Z" creationid="xccui" creationdate="20190701T060517Z">
        <seg>而restoreState()方法也可以利用（一个或）多个部分对算子状态进行组装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method has no effect.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060718Z" creationid="xccui" creationdate="20190621T060718Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method is to ensure all state objects are updated before the checkpoint is done.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071731Z" creationid="xccui" creationdate="20190702T071538Z">
        <seg>snapshotState()方法的目的是确保检查点开始之前所有状态对象都已更新完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method on the RuntimeContext, as shown in Example 10-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015207Z" creationid="xccui" creationdate="20190803T015207Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method provides read-only access to the broadcast state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T051407Z" creationid="xccui" creationdate="20190702T051407Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method will replace existing values with the given list of values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T055530Z" creationid="xccui" creationdate="20190630T055530Z">
        <seg>该方法将使用给定列表的值替换已有值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method, Flink assigns default identifiers, which are hash values that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T050037Z" creationid="xccui" creationdate="20190727T045922Z">
        <seg>则Flink会根据算子类型和它所有前置算子计算一个哈希值作为其默认标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>metrics.reporters: my_reporter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055904Z" creationid="xccui" creationdate="20190804T055904Z">
        <seg>metrics.reporters: my_reporter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>metrics.scope.jm</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043027Z" creationid="xccui" creationdate="20190804T043027Z">
        <seg>metrics.scope.jm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>metrics.scope.jm.job</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043051Z" creationid="xccui" creationdate="20190804T043051Z">
        <seg>metrics.scope.jm.job</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>metrics.scope.operator   &lt;host&gt;.taskmanager.&lt;tm_id&gt;.&lt;job_name&gt;.&lt;operator_name&gt;.&lt;subtask_index&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043133Z" creationid="xccui" creationdate="20190804T043133Z">
        <seg>metrics.scope.operator   &lt;host&gt;.taskmanager.&lt;tm_id&gt;.&lt;job_name&gt;.&lt;operator_name&gt;.&lt;subtask_index&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>metrics.scope.task</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043121Z" creationid="xccui" creationdate="20190804T043121Z">
        <seg>metrics.scope.task</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>metrics.scope.tm.job</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043111Z" creationid="xccui" creationdate="20190804T043111Z">
        <seg>metrics.scope.tm.job</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>microservices are strictly decoupled from each other and only communicate over well-defined interfaces, each microservice can be implemented with a different tech‐ nology stack including a programming language, libraries, and datastores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T023410Z" creationid="esouser" creationdate="20190603T200753Z">
        <seg>由于微服务彼此间严格解耦且仅通过定义良好的接口通信，所以在实现微服务时可以选用不同的技术栈，包括编程语言、类库和数据存储等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>min()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052719Z" creationid="xccui" creationdate="20190614T052719Z">
        <seg>min()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>minBy()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053534Z" creationid="xccui" creationdate="20190614T053534Z">
        <seg>minBy()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>minMaxIt: Iterable[(String, Double, Double)], out: Collector[MinMaxTemp]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045141Z" creationid="xccui" creationdate="20190625T045141Z">
        <seg>minMaxIt: Iterable[(String, Double, Double)], out: Collector[MinMaxTemp]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>monitoredReadings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022911Z" creationid="xccui" creationdate="20190622T022911Z">
        <seg>monitoredReadings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>monly used for cleanup and releasing resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033155Z" creationid="xccui" creationdate="20190619T033155Z">
        <seg>因而它通常用于清理和释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>monotonically increasing, you can use the shortcut method assignAscending TimeStamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051808Z" creationid="xccui" creationdate="20190620T051620Z">
        <seg>则可以使用一个简便方法assignAscendingTimeStamps。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>more detail in “Transactional Sink Connectors” on page 209.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T224249Z" creationid="xccui" creationdate="20190711T224249Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>more processing slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205902Z" creationid="xccui" creationdate="20190428T205902Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>more than once:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065044Z" creationid="xccui" creationdate="20190715T065044Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>munication, the blob manager (to exchange large files), the queryable state server, and the Web UI and REST interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T143246Z" creationid="xccui" creationdate="20190720T025608Z">
        <seg>Blob管理器（用于交换大文件）、可查询式状态服务器以及Web UI（REST接口）的端口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mvn archetype:generate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T064642Z" creationid="xccui" creationdate="20190613T064642Z">
        <seg>mvn archetype:generate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mvn clean package -Pbuild-jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T064647Z" creationid="xccui" creationdate="20190613T064647Z">
        <seg>mvn clean package -Pbuild-jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name: JOB_MANAGER_RPC_ADDRESS</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025042Z" creationid="xccui" creationdate="20190720T025042Z">
        <seg>name: JOB_MANAGER_RPC_ADDRESS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name: blob port: 6124</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T031954Z" creationid="xccui" creationdate="20190720T031954Z">
        <seg>name: blob port: 6124</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name: flink-master spec:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024950Z" creationid="xccui" creationdate="20190720T024950Z">
        <seg>name: flink-master spec:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name: flink-worker spec:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025718Z" creationid="xccui" creationdate="20190720T025718Z">
        <seg>name: flink-worker spec:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name: master image: flink:1.7 args:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025011Z" creationid="xccui" creationdate="20190720T025011Z">
        <seg>name: master image: flink:1.7 args:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name: query port: 6125</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T031957Z" creationid="xccui" creationdate="20190720T031957Z">
        <seg>name: query port: 6125</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name: rpc port: 6123</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T031950Z" creationid="xccui" creationdate="20190720T031950Z">
        <seg>name: rpc port: 6123</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name: ui port: 8081 selector: app: flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T032001Z" creationid="xccui" creationdate="20190720T032001Z">
        <seg>name: ui port: 8081 selector: app: flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>name: worker image: flink:1.7 args:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025730Z" creationid="xccui" creationdate="20190720T025730Z">
        <seg>name: worker image: flink:1.7 args:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>need to update your application because Java serialization does not allow for migrating or configuring a custom serializer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="xccui" creationdate="20190701T063504Z">
        <seg>由于该序列化机制不支持目标迁移或配置自定义序列化器，所以可能会在你需要更新应用时导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>neither the ReduceFunction nor the AggregateFunction are suitable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T040408Z" creationid="xccui" creationdate="20190624T010013Z">
        <seg>对于此类应用，ReduceFunction和AggregateFunction都不适合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new AssignWindowEndProcessFunction()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043637Z" creationid="xccui" creationdate="20190625T043637Z">
        <seg>new AssignWindowEndProcessFunction()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new BoundedOutOfOrdernessTimestampExtractor[SensorReading]( Time.seconds(10))(e =&gt;.timestamp)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052900Z" creationid="xccui" creationdate="20190620T052900Z">
        <seg>new BoundedOutOfOrdernessTimestampExtractor[SensorReading]( Time.seconds(10))(e =&gt;.timestamp)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new DerbyAsyncFunction,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201727Z" creationid="xccui" creationdate="20190716T201727Z">
        <seg>new DerbyAsyncFunction,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new FileCheckpointCommitter(System.getProperty("java.io.tmpdir")),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064311Z" creationid="xccui" creationdate="20190715T064311Z">
        <seg>new FileCheckpointCommitter(System.getProperty("java.io.tmpdir")),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new FlinkKafkaConsumer[String]( "topic",</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T212409Z" creationid="xccui" creationdate="20190708T212409Z">
        <seg>new FlinkKafkaConsumer[String]( "topic",</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new MapStateDescriptor[String, Double]( "thresholds", classOf[String], classOf[Double])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024332Z" creationid="xccui" creationdate="20190702T024332Z">
        <seg>new MapStateDescriptor[String, Double]( "thresholds", classOf[String], classOf[Double])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new Path("/base/path"),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205919Z" creationid="xccui" creationdate="20190710T205919Z">
        <seg>new Path("/base/path"),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new Path("/base/path"), ParquetAvroWriters.forSpecificRecord(classOf[AvroPojo]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T024508Z" creationid="xccui" creationdate="20190711T024508Z">
        <seg>new Path("/base/path"), ParquetAvroWriters.forSpecificRecord(classOf[AvroPojo]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new Person("Alex", 42),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044923Z" creationid="xccui" creationdate="20190617T044923Z">
        <seg>new Person("Alex", 42),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new Person("Wendy", 23));</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044926Z" creationid="xccui" creationdate="20190617T044926Z">
        <seg>new Person("Wendy", 23));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new QueryableStateClient(tmHostname, proxyPort)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T125216Z" creationid="xccui" creationdate="20190706T125216Z">
        <seg>new QueryableStateClient(tmHostname, proxyPort)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new RichFilterFunction[String] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054235Z" creationid="xccui" creationdate="20190618T054235Z">
        <seg>new RichFilterFunction[String] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new SimpleStringEncoder[String]("UTF-8"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205922Z" creationid="xccui" creationdate="20190710T205922Z">
        <seg>new SimpleStringEncoder[String]("UTF-8"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new SimpleStringSchema(), properties))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T212412Z" creationid="xccui" creationdate="20190708T212412Z">
        <seg>new SimpleStringSchema(), properties))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new SimpleStringSchema)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T144822Z" creationid="xingcan" creationdate="20190709T144822Z">
        <seg>new SimpleStringSchema)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new TimeWindow.Serializer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044232Z" creationid="xccui" creationdate="20190626T044232Z">
        <seg>new TimeWindow.Serializer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[(String, Double)]( "", // state name not relevant here Types.TUPLE[(String, Double)]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041655Z" creationid="xccui" creationdate="20190707T041621Z">
        <seg>new ValueStateDescriptor[(String, Double)]( "", // 此处和状态名称无关 Types.TUPLE[(String, Double)]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Boolean]("filterSwitch", Types.of[Boolean]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032102Z" creationid="xccui" creationdate="20190622T032102Z">
        <seg>new ValueStateDescriptor[Boolean]("filterSwitch", Types.of[Boolean]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Boolean]("firstSeen", classOf[Boolean]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200338Z" creationid="xccui" creationdate="20190626T200338Z">
        <seg>new ValueStateDescriptor[Boolean]("firstSeen", classOf[Boolean]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Boolean]("firstSeen", classOf[Boolean])) firstSeen.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200944Z" creationid="xccui" creationdate="20190626T200944Z">
        <seg>new ValueStateDescriptor[Boolean]("firstSeen", classOf[Boolean])) firstSeen.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Boolean]("isUpdate", Types.of[Boolean]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034335Z" creationid="xccui" creationdate="20190629T034335Z">
        <seg>new ValueStateDescriptor[Boolean]("isUpdate", Types.of[Boolean]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Double]("lastTemp", Types.of[Double]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071345Z" creationid="xccui" creationdate="20190621T071345Z">
        <seg>new ValueStateDescriptor[Double]("lastTemp", Types.of[Double]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Double]("lastTemp", classOf[Double])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064315Z" creationid="xccui" creationdate="20190630T064315Z">
        <seg>new ValueStateDescriptor[Double]("lastTemp", classOf[Double])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Long]("timer", Types.of[Long]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071409Z" creationid="xccui" creationdate="20190621T071409Z">
        <seg>new ValueStateDescriptor[Long]("timer", Types.of[Long]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new Watermark(extractedTS - bound)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054840Z" creationid="xccui" creationdate="20190620T054840Z">
        <seg>new Watermark(extractedTS - bound)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new Watermark(maxTs - bound)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051129Z" creationid="xccui" creationdate="20190620T051129Z">
        <seg>new Watermark(maxTs - bound)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new and modified files are continuously read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T191143Z" creationid="xccui" creationdate="20190710T191143Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new com.codahale.metrics.Histogram(new SlidingWindowReservoir(500))) metricGroup.histogram("myHistogram", histogramWrapper)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T033647Z" creationid="xccui" creationdate="20190803T033647Z">
        <seg>new com.codahale.metrics.Histogram(new SlidingWindowReservoir(500))) metricGroup.histogram("myHistogram", histogramWrapper)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nism and aims to write each record exactly once to an external system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T042629Z" creationid="xccui" creationdate="20190715T042629Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonnull watermark that is larger than the latest emitted watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054519Z" creationid="xccui" creationdate="20190620T054519Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not change the type of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061521Z" creationid="xccui" creationdate="20190614T061521Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not have access to timestamps or the current event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T043253Z" creationid="xccui" creationdate="20190621T043253Z">
        <seg>MapFunction无法访问时间戳或当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>notification corresponds to the 2PC protocol’s commit command.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T212133Z" creationid="xccui" creationdate="20190715T211335Z">
        <seg>该完成通知相当于2PC协议中的提交指令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>null</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054858Z" creationid="xccui" creationdate="20190620T054858Z">
        <seg>null</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>null field handling.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T223024Z" creationid="xccui" creationdate="20190711T223024Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>number of connected TaskManagers and available slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T175814Z" creationid="xccui" creationdate="20190717T175814Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>object AverageSensorReadings {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041830Z" creationid="xccui" creationdate="20190612T041830Z">
        <seg>object AverageSensorReadings {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>object TemperatureDashboard {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035809Z" creationid="xccui" creationdate="20190707T035809Z">
        <seg>object TemperatureDashboard {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>object myPartitioner extends Partitioner[Int] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050633Z" creationid="xccui" creationdate="20190616T050633Z">
        <seg>object myPartitioner extends Partitioner[Int] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142522Z" creationid="esouser" creationdate="20190603T142522Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of an application that uses the in-memory or filesystem state backend is also stored on the JVM. Note that a single task can potentially consume the whole heap memory of the JVM that it is running on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T034603Z" creationid="xccui" creationdate="20190724T034418Z">
        <seg>应用中基于内存或文件系统后端的状态同样会存到JVM中。注意，单个任务可能会耗尽其所在JVM的所有内存，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of elements in the window (size), the window object, and an EvictorContext that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202748Z" creationid="xccui" creationdate="20190627T202748Z">
        <seg>窗口内的元素数量、窗口对象以及一个用于访问当前处理时间和水位线的EvictorContext。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of events per second, and get the current number of events marked on the meter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T215245Z" creationid="xccui" creationdate="20190803T215245Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of its key definition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T040710Z" creationid="xccui" creationdate="20190630T040710Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of state is custom for every stateful function, this cannot be automatically done for arbitrary types of state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T050106Z" creationid="xccui" creationdate="20190701T060035Z">
        <seg>由于每个函数都有自己的状态拆分及合并逻辑，所以这两个过程无法对任意状态类型都自动完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of the available configuration options:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025731Z" creationid="xccui" creationdate="20190801T025731Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of the parallel partitions of a DataStream is skewed, we might want to rebalance the data to evenly distribute the computation load of subsequent operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T065820Z" creationid="xccui" creationdate="20190615T065415Z">
        <seg>举例而言，如果我们知道DataStream的并行分区存在倾斜现象，那么可能就希望通过重新平衡数据来均匀分配后续算子的负载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>offsetState.add(cnt)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034205Z" creationid="xccui" creationdate="20190713T034205Z">
        <seg>offsetState.add(cnt)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>offsetState.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034124Z" creationid="xccui" creationdate="20190713T034124Z">
        <seg>offsetState.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>on port 8081, the following curl command submits a GET request to the /overview</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T043226Z" creationid="xccui" creationdate="20190729T041914Z">
        <seg>以下curl命令将向/overview的REST端点提交一个GET请求：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>on some of the operators, you might need to adjust the source code and recompile</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T210332Z" creationid="xccui" creationdate="20190728T044020Z">
        <seg>那么可能就需要修改源码、并重新编译打包后再将应用提交执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>on the number of open connections are enforced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T041624Z" creationid="xccui" creationdate="20190722T041624Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT]) is a callback function that is invoked when a previously registered timer triggers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T062607Z" creationid="xccui" creationdate="20190621T054245Z">
        <seg>onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT])是一个回调函数，它会在之前注册的计时器触发时被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one data source and one data sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000316Z" creationid="xccui" creationdate="20190401T000316Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opHighTempCnt += 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162503Z" creationid="xccui" creationdate="20190702T162503Z">
        <seg>opHighTempCnt += 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opHighTempCnt = opCntState.get().asScala.sum</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163340Z" creationid="xccui" creationdate="20190702T163340Z">
        <seg>opHighTempCnt = opCntState.get().asScala.sum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open transactions can block consumers from reading a partition and introduce sig‐ nificant delays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T222541Z" creationid="xccui" creationdate="20190709T213012Z">
        <seg>因此，开启事务可能会阻碍消费者从分区中读取消息并带来明显延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open() is called before any processing methods, such as flatMap() in the case of a FlatMapFunction, are called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T020455Z" creationid="xccui" creationdate="20190701T020327Z">
        <seg>该方法会在任意处理方法（例如FlatMapFunction中的flatMap()）之前调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open() is typically used for setup work that needs to be done only once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T061103Z" creationid="xccui" creationdate="20190618T061103Z">
        <seg>open()通常用于那些只需进行一次的设置工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>operator has precedence over the default value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T031536Z" creationid="xccui" creationdate="20190726T031536Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>operators depends on the default environment parallelism, you can simply scale an application by starting it from the same JAR file and specifying a new parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T210103Z" creationid="xccui" creationdate="20190728T042252Z">
        <seg>如果应用算子并行度是基于环境默认并行度计算而来，则你可以在使用相同JAR文件运行应用的同时指定一个新的并行度，从而实现对应用的扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>optional</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052306Z" creationid="xccui" creationdate="20190716T052306Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or broadcast connection, each sending task needs a buffer for each receiving task, i.e, the number of required buffers is quadratic to the parallelism of the involved opera&lt;t0/&gt;‐&lt;t1/&gt; tors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045238Z" creationid="xccui" creationdate="20190504T045238Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or purging a window without emitting a result if a certain condition is fulfilled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185710Z" creationid="xccui" creationdate="20190626T185710Z">
        <seg>还能够在某个条件满足时只清除窗口而不发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>order results are enabled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T195943Z" creationid="xccui" creationdate="20190716T195943Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>orderedWait() applies an asynchronous operator that emits results in the order of the input records, while the operator of unorderWait() only ensures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T202332Z" creationid="xccui" creationdate="20190716T202332Z">
        <seg>orderedWait()会启用一个按照数据记录顺序发出结果的异步算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>org.apache.flink.metrics.Histogram interface allows you to collect values, get</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T032810Z" creationid="xccui" creationdate="20190803T032810Z">
        <seg>你可以通过org.apache.flink.metrics.Histogram接口来收集数值，获取收集值的数量并为到目前为止收集的值生成统计信息（例如最小值、最大值、标准差、均值等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>org.apache.flink.metrics.datadog.DatadogHttpReporter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055532Z" creationid="xccui" creationdate="20190804T055532Z">
        <seg>org.apache.flink.metrics.datadog.DatadogHttpReporter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>org.apache.flink.metrics.graphite.GraphiteReporter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055508Z" creationid="xccui" creationdate="20190804T055508Z">
        <seg>org.apache.flink.metrics.graphite.GraphiteReporter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>org.apache.flink.metrics.jmx.JMXReporter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055502Z" creationid="xccui" creationdate="20190804T055502Z">
        <seg>org.apache.flink.metrics.jmx.JMXReporter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>org.apache.flink.metrics.prometheus.PrometheusReporter PrometheusPushGateway org.apache.flink.metrics.prometheus.PrometheusPushGatewayReporter StatsD</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055516Z" creationid="xccui" creationdate="20190804T055516Z">
        <seg>org.apache.flink.metrics.prometheus.PrometheusReporter PrometheusPushGateway org.apache.flink.metrics.prometheus.PrometheusPushGatewayReporter StatsD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>org.apache.flink.metrics.slf4j.Slf4jReporter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055539Z" creationid="xccui" creationdate="20190804T055539Z">
        <seg>org.apache.flink.metrics.slf4j.Slf4jReporter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>org.apache.flink.metrics.statsd.StatsDReporter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T055526Z" creationid="xccui" creationdate="20190804T055526Z">
        <seg>org.apache.flink.metrics.statsd.StatsDReporter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>org.apache.flink.runtime.concurrent.Executors.directExecutor())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T205742Z" creationid="xccui" creationdate="20190716T205742Z">
        <seg>org.apache.flink.runtime.concurrent.Executors.directExecutor())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect("Temperature of sensor '" + ctx.getCurrentKey + "' monotonically increased for 1 second.") currentTimer.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071743Z" creationid="xccui" creationdate="20190621T071743Z">
        <seg>out.collect("Temperature of sensor '" + ctx.getCurrentKey + "' monotonically increased for 1 second.") currentTimer.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect((id, ctx.window.getEnd, cnt, "update"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034448Z" creationid="xccui" creationdate="20190629T034448Z">
        <seg>out.collect((id, ctx.window.getEnd, cnt, "update"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect((reading.id, reading.temperature, tempDiff))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064511Z" creationid="xccui" creationdate="20190630T064511Z">
        <seg>out.collect((reading.id, reading.temperature, tempDiff))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect((subtaskIdx, highTempCnt))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052700Z" creationid="xccui" creationdate="20190701T052700Z">
        <seg>out.collect((subtaskIdx, highTempCnt))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect((v.id, keyHighTempCnt, opHighTempCnt))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162607Z" creationid="xccui" creationdate="20190702T162607Z">
        <seg>out.collect((v.id, keyHighTempCnt, opHighTempCnt))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect(MinMaxTemp(key, minMax._2, minMax._3, windowEnd))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045147Z" creationid="xccui" creationdate="20190625T045147Z">
        <seg>out.collect(MinMaxTemp(key, minMax._2, minMax._3, windowEnd))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect(MinMaxTemp(key, temps.min, temps.max, windowEnd))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031941Z" creationid="xccui" creationdate="20190625T031941Z">
        <seg>out.collect(MinMaxTemp(key, temps.min, temps.max, windowEnd))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect(r)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T024049Z" creationid="xccui" creationdate="20190622T024049Z">
        <seg>out.collect(r)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out: Collector[(Int, Long)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052446Z" creationid="xccui" creationdate="20190701T052446Z">
        <seg>out: Collector[(Int, Long)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064334Z" creationid="xccui" creationdate="20190630T064334Z">
        <seg>out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out: Collector[(String, Long, Int, String)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034010Z" creationid="xccui" creationdate="20190629T034010Z">
        <seg>out: Collector[(String, Long, Int, String)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out: Collector[(String, Long, Long)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162245Z" creationid="xccui" creationdate="20190702T162245Z">
        <seg>out: Collector[(String, Long, Long)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out: Collector[MinMaxTemp]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031927Z" creationid="xccui" creationdate="20190625T031927Z">
        <seg>out: Collector[MinMaxTemp]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def abort(transaction: String): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042205Z" creationid="xccui" creationdate="20190716T042205Z">
        <seg>override def abort(transaction: String): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def add(in: (String, Double), acc: (String, Double, Int)) = { (in._1, in._2 + acc._2, 1 + acc._3)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005610Z" creationid="xccui" creationdate="20190624T005610Z">
        <seg>override def add(in: (String, Double), acc: (String, Double, Int)) = { (in._1, in._2 + acc._2, 1 + acc._3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def assignWindows( o: Object,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042656Z" creationid="xccui" creationdate="20190626T042656Z">
        <seg>override def assignWindows( o: Object,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def asyncInvoke( reading: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T205921Z" creationid="xccui" creationdate="20190716T205921Z">
        <seg>override def asyncInvoke( reading: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def beginTransaction(): String = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041313Z" creationid="xccui" creationdate="20190716T041313Z">
        <seg>override def beginTransaction(): String = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def cancel() = isRunning = false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152455Z" creationid="xccui" creationdate="20190712T152455Z">
        <seg>override def cancel() = isRunning = false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def checkAndGetNextWatermark( r: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054807Z" creationid="xccui" creationdate="20190620T054807Z">
        <seg>override def checkAndGetNextWatermark( r: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def clear( window: TimeWindow,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200926Z" creationid="xccui" creationdate="20190626T200926Z">
        <seg>override def clear( window: TimeWindow,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def close(): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034524Z" creationid="xccui" creationdate="20190619T034524Z">
        <seg>override def close(): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def close(): Unit = { insertStmt.close() updateStmt.close() conn.close()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045838Z" creationid="xccui" creationdate="20190714T045838Z">
        <seg>override def close(): Unit = { insertStmt.close() updateStmt.close() conn.close()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def commit(transaction: String): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042019Z" creationid="xccui" creationdate="20190716T042019Z">
        <seg>override def commit(transaction: String): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def createAccumulator() = { ("", 0.0, 0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005607Z" creationid="xccui" creationdate="20190624T005607Z">
        <seg>override def createAccumulator() = { ("", 0.0, 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def extractTimestamp( r: SensorReading, previousTS: Long): Long = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051133Z" creationid="xccui" creationdate="20190620T051133Z">
        <seg>override def extractTimestamp( r: SensorReading, previousTS: Long): Long = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def filter(value: Int): Boolean = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015243Z" creationid="xccui" creationdate="20190803T015243Z">
        <seg>override def filter(value: Int): Boolean = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def filter(value: String): Boolean = { value.contains("flink")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054238Z" creationid="xccui" creationdate="20190618T054238Z">
        <seg>override def filter(value: String): Boolean = { value.contains("flink")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def flatMap( in: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052443Z" creationid="xccui" creationdate="20190701T052443Z">
        <seg>override def flatMap( in: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def flatMap( reading: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064331Z" creationid="xccui" creationdate="20190630T064331Z">
        <seg>override def flatMap( reading: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def flatMap( v: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162241Z" creationid="xccui" creationdate="20190702T162241Z">
        <seg>override def flatMap( v: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def flatMap(in: Int, out: Collector[(Int, Int)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034402Z" creationid="xccui" creationdate="20190619T034402Z">
        <seg>override def flatMap(in: Int, out: Collector[(Int, Int)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def getCurrentWatermark: Watermark = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051107Z" creationid="xccui" creationdate="20190620T051107Z">
        <seg>override def getCurrentWatermark: Watermark = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def getDefaultTrigger(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044150Z" creationid="xccui" creationdate="20190626T044150Z">
        <seg>override def getDefaultTrigger(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def getProducedType: TypeInformation[Person] = Types.CASE_CLASS[Person]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061940Z" creationid="xccui" creationdate="20190617T061940Z">
        <seg>override def getProducedType: TypeInformation[Person] = Types.CASE_CLASS[Person]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def getResult(acc: (String, Double, Int)) = { (acc._1, acc._2 / acc._3)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005613Z" creationid="xccui" creationdate="20190624T005613Z">
        <seg>override def getResult(acc: (String, Double, Int)) = { (acc._1, acc._2 / acc._3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def getWindowSerializer(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044223Z" creationid="xccui" creationdate="20190626T044223Z">
        <seg>override def getWindowSerializer(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def initializeState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034459Z" creationid="xccui" creationdate="20190713T034459Z">
        <seg>override def initializeState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def initializeState(initContext: FunctionInitializationContext): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162946Z" creationid="xccui" creationdate="20190702T162946Z">
        <seg>override def initializeState(initContext: FunctionInitializationContext): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def invoke( transaction: String, value: (String, Double),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041552Z" creationid="xccui" creationdate="20190716T041552Z">
        <seg>override def invoke( transaction: String, value: (String, Double),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def invoke( value: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024733Z" creationid="xccui" creationdate="20190714T024733Z">
        <seg>override def invoke( value: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def invoke(r: SensorReading, context: Context[_]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045314Z" creationid="xccui" creationdate="20190714T045314Z">
        <seg>override def invoke(r: SensorReading, context: Context[_]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def isEventTime = true</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044236Z" creationid="xccui" creationdate="20190626T044236Z">
        <seg>override def isEventTime = true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def map(r: SensorReading): String = r.id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050726Z" creationid="xccui" creationdate="20190613T050726Z">
        <seg>override def map(r: SensorReading): String = r.id</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def map(v: (String, Int)): Person = Person(v._1, v._2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061916Z" creationid="xccui" creationdate="20190617T061916Z">
        <seg>override def map(v: (String, Int)): Person = Person(v._1, v._2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def map(value: Int): Int = value + 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020909Z" creationid="xccui" creationdate="20190613T020909Z">
        <seg>override def map(value: Int): Int = value + 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def merge(acc1: (String, Double, Int), acc2: (String, Double, Int)) = { (acc1._1, acc1._2 + acc2._2, acc1._3 + acc2._3)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005617Z" creationid="xccui" creationdate="20190624T005617Z">
        <seg>override def merge(acc1: (String, Double, Int), acc2: (String, Double, Int)) = { (acc1._1, acc1._2 + acc2._2, acc1._3 + acc2._3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def onElement( r: SensorReading, timestamp: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200230Z" creationid="xccui" creationdate="20190626T200230Z">
        <seg>override def onElement( r: SensorReading, timestamp: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def onEventTime( timestamp: Long, window: TimeWindow,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200658Z" creationid="xccui" creationdate="20190626T200658Z">
        <seg>override def onEventTime( timestamp: Long, window: TimeWindow,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def onProcessingTime( timestamp: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200907Z" creationid="xccui" creationdate="20190626T200907Z">
        <seg>override def onProcessingTime( timestamp: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def onTimer( timestamp: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210651Z" creationid="xccui" creationdate="20190704T210651Z">
        <seg>override def onTimer( timestamp: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def onTimer( ts: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071736Z" creationid="xccui" creationdate="20190621T071736Z">
        <seg>override def onTimer( ts: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def open(config: Configuration): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024659Z" creationid="xccui" creationdate="20190714T024659Z">
        <seg>override def open(config: Configuration): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def open(configuration: Configuration): Unit = { subTaskIndex = getRuntimeContext.getIndexOfThisSubtask</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034254Z" creationid="xccui" creationdate="20190619T034254Z">
        <seg>override def open(configuration: Configuration): Unit = { subTaskIndex = getRuntimeContext.getIndexOfThisSubtask</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def open(parameters: Configuration): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064229Z" creationid="xccui" creationdate="20190630T064229Z">
        <seg>override def open(parameters: Configuration): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def open(parameters: Configuration): Unit = { counter = getRuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T015232Z" creationid="xccui" creationdate="20190803T015232Z">
        <seg>override def open(parameters: Configuration): Unit = { counter = getRuntimeContext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def partition(key: Int, numPartitions: Int): Int = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050641Z" creationid="xccui" creationdate="20190616T050641Z">
        <seg>override def partition(key: Int, numPartitions: Int): Int = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def process( id: String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034002Z" creationid="xccui" creationdate="20190629T034002Z">
        <seg>override def process( id: String,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def process( key: String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031916Z" creationid="xccui" creationdate="20190625T031916Z">
        <seg>override def process( key: String,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processBroadcastElement( update: ThresholdUpdate,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042524Z" creationid="xccui" creationdate="20190702T042524Z">
        <seg>override def processBroadcastElement( update: ThresholdUpdate,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processElement( r: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071412Z" creationid="xccui" creationdate="20190621T071412Z">
        <seg>override def processElement( r: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processElement( reading: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042650Z" creationid="xccui" creationdate="20190702T042650Z">
        <seg>override def processElement( reading: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processElement( reading: SensorReading, ctx: KeyedProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210444Z" creationid="xccui" creationdate="20190704T210444Z">
        <seg>override def processElement( reading: SensorReading, ctx: KeyedProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processElement1( reading: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032232Z" creationid="xccui" creationdate="20190622T032232Z">
        <seg>override def processElement1( reading: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processElement2( switch: (String, Long),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032304Z" creationid="xccui" creationdate="20190622T032304Z">
        <seg>override def processElement2( switch: (String, Long),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def restoreState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052705Z" creationid="xccui" creationdate="20190701T052705Z">
        <seg>override def restoreState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def run(ctx: SourceFunction.SourceContext[Long]) = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152442Z" creationid="xccui" creationdate="20190712T152442Z">
        <seg>override def run(ctx: SourceFunction.SourceContext[Long]) = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def sendValues(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064349Z" creationid="xccui" creationdate="20190715T064349Z">
        <seg>override def sendValues(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def snapshotState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163344Z" creationid="xccui" creationdate="20190702T163344Z">
        <seg>override def snapshotState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def snapshotState( chkpntId: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052938Z" creationid="xccui" creationdate="20190701T052938Z">
        <seg>override def snapshotState( chkpntId: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def snapshotState(snapshotCtx: FunctionSnapshotContext): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034107Z" creationid="xccui" creationdate="20190713T034107Z">
        <seg>override def snapshotState(snapshotCtx: FunctionSnapshotContext): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>own types and tell Flink how to handle them efficiently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053222Z" creationid="xccui" creationdate="20190617T053009Z">
        <seg>或者你可能需要定义自己的类型并告知Flink该如何高效地处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>own window with the element’s timestamp as the start time and the session gap as the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T062104Z" creationid="xccui" creationdate="20190623T062037Z">
        <seg>该窗口的起始时间是元素的时间戳，大小为会话间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>page 154.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033816Z" creationid="xccui" creationdate="20190619T033816Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>parallel instance of the function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052214Z" creationid="xccui" creationdate="20190701T052214Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>parameter is the size of the JVM heap memory, which is set with the key taskman ager.heap.size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T151251Z" creationid="xccui" creationdate="20190724T034142Z">
        <seg>其中所涉及最重要的参数是JVM堆内存大小，它可以通过taskmanager.heap.size配置项设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pared to maintaining state on the heap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025408Z" creationid="xccui" creationdate="20190704T025408Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perature of a sensor monotonically increases for a period of 1 second in processing time:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T070859Z" creationid="xccui" creationdate="20190621T070845Z">
        <seg>如果某个传感器的温度在1秒的处理时间内持续上升则发出警告：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>personTuple.f1 = 42;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T064531Z" creationid="xccui" creationdate="20190617T064531Z">
        <seg>personTuple.f1 = 42;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>personTuple.setField(43, 1); // set the 2nd field to 43</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040535Z" creationid="xccui" creationdate="20190617T040535Z">
        <seg>personTuple.setField(43, 1); // 将第二个字段设为43</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>persons.filter(p -&gt; p.f1 &gt; 18);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035205Z" creationid="xccui" creationdate="20190617T035205Z">
        <seg>persons.filter(p -&gt; p.f1 &gt; 18);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>persons.filter(p =&gt; p._2 &gt; 18)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T071131Z" creationid="xccui" creationdate="20190616T071131Z">
        <seg>persons.filter(p =&gt; p._2 &gt; 18)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>persons.filter(p =&gt; p.age &gt; 18)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041213Z" creationid="xccui" creationdate="20190617T041213Z">
        <seg>persons.filter(p =&gt; p.age &gt; 18)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>persons.keyBy("birthday._") // key by all fields of nested tuple</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050802Z" creationid="xccui" creationdate="20190618T050802Z">
        <seg>persons.keyBy("birthday._") // 以元组中的全部字段为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>persons.keyBy("birthday._1") // key by field of nested tuple</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050632Z" creationid="xccui" creationdate="20190618T050632Z">
        <seg>persons.keyBy("birthday._1") // 以嵌套元组的字段为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ple asynchronous queries and wait for their results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035213Z" creationid="xccui" creationdate="20190707T035213Z">
        <seg>因此，客户端可以同时发出多个异步请求并等待其返回结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>point barrier, it starts a new section and all the following records are appended to the new section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T045539Z" creationid="xccui" creationdate="20190715T045539Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194324Z" creationid="xccui" creationdate="20190626T194324Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pointed and recovered in the case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T035403Z" creationid="xccui" creationdate="20190715T035403Z">
        <seg>该状态会被写入检查点，并在故障时恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pointing and consume from resettable sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T163545Z" creationid="xingcan" creationdate="20190709T163545Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>points can implement the CheckpointListener interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T202327Z" creationid="xccui" creationdate="20190702T202327Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>points in an external datastore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T223848Z" creationid="xccui" creationdate="20190711T223848Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>point—when all tasks have successfully written their state into the remote storage— the JobManager writes the state handles to the remote storage and a pointer to this location to ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073305Z" creationid="xccui" creationdate="20190606T150217Z">
        <seg>在检查点即将完成的时候，如果所有任务已经将各自状态成功写入远程存储，JobManager就会将状态句柄写入远程存储，并将远程位置的路径地址写入ZooKeeper。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ports:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T031945Z" creationid="xccui" creationdate="20190720T031945Z">
        <seg>ports:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>preCommit(txn: TXN): Unit precommits a transaction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052833Z" creationid="xccui" creationdate="20190716T052833Z">
        <seg>preCommit(txn: TXN): Unit预提交事务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>precede a barrier are included in the barrier’s checkpoint and all modifications due to records that follow the barrier are included in a later checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T064855Z" creationid="xccui" creationdate="20190609T061206Z">
        <seg>所有先于分隔符的记录所引起的状态更改都会被包含在分隔符所对应的检查点之中；而所有晚于分隔符的记录所引起的状态更改都会被纳入之后的检查点中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>prepared statement and converts the fields of tuples, case classes, or rows into param‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T212543Z" creationid="xccui" creationdate="20190711T212543Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>present DataStream methods that enable users to control partitioning strategies or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070257Z" creationid="xccui" creationdate="20190615T070257Z">
        <seg>本节我们会介绍DataStream中用于控制分区策略或自定义分区策略的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>println(r)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064411Z" creationid="xccui" creationdate="20190715T064411Z">
        <seg>println(r)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private lazy val directExecCtx = ExecutionContext.fromExecutor(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T205738Z" creationid="xccui" creationdate="20190716T205738Z">
        <seg>private lazy val directExecCtx = ExecutionContext.fromExecutor(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private lazy val subtaskIdx = getRuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052352Z" creationid="xccui" creationdate="20190701T052352Z">
        <seg>private lazy val subtaskIdx = getRuntimeContext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private long currentWatermark = Long.MIN_VALUE;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031845Z" creationid="xccui" creationdate="20190803T031845Z">
        <seg>private long currentWatermark = Long.MIN_VALUE;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private var highTempCnt = 0L</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052439Z" creationid="xccui" creationdate="20190701T052439Z">
        <seg>private var highTempCnt = 0L</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private var lastTempState: ValueState[Double] = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064226Z" creationid="xccui" creationdate="20190630T064226Z">
        <seg>private var lastTempState: ValueState[Double] = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private var lastTimerState: ValueState[Long] = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210225Z" creationid="xccui" creationdate="20190704T210225Z">
        <seg>private var lastTimerState: ValueState[Long] = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>process historical events in the same way, thus enabling offline analytics or even time travel analyses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T203458Z" creationid="xccui" creationdate="20190409T203458Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>processElement(v: IN, ctx: Context, out: Collector[OUT]) is called for each record of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053527Z" creationid="xccui" creationdate="20190621T053527Z">
        <seg>processElement(v: IN, ctx: Context, out: Collector[OUT])会针对流中的每条记录都调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>processes can be started with custom Java options—for example, to fine-tune the garbage collector or to enable remote debugging, with the keys env.java.opts, env.java.opts.jobmanager, and env.java.opts.taskmanager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T150857Z" creationid="xccui" creationdate="20190723T044059Z">
        <seg>Flink的JVM进程支持在启动时自定义Java选项。例如，你可以使用env.java.opts、evn.java.opts.jobmanager及env.java.opts.taskmanager来对垃圾收集器进行微调或开启远程调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>processing-time or event-time semantics depends on the value returned by the Win dowAssigner.isEventTime() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T035849Z" creationid="xccui" creationdate="20190626T035751Z">
        <seg>该时间是处理时间还是事件时间语义取决于WindowAssigner.isEventTime()方法的返回值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>proof exactly-once guarantees but only at-least-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T043110Z" creationid="xccui" creationdate="20190715T043110Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>provides access to the current processing time and watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202838Z" creationid="xccui" creationdate="20190627T202838Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>proxy listens on port 9067, but the port can be configured in the ./conf/flink- conf.yaml file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T125209Z" creationid="xccui" creationdate="20190706T125209Z">
        <seg>客户端代理的默认监听端口是9067，你可以在./conf/flink- conf.yaml文件中对它进行配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public Long getValue() {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031857Z" creationid="xccui" creationdate="20190803T031857Z">
        <seg>public Long getValue() {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public Person() {}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044844Z" creationid="xccui" creationdate="20190617T044844Z">
        <seg>public Person() {}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public Person(String name, int age) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044851Z" creationid="xccui" creationdate="20190617T044851Z">
        <seg>public Person(String name, int age) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract &lt;X&gt; void output(OutputTag&lt;X&gt; outputTag, X value);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010951Z" creationid="xccui" creationdate="20190624T010951Z">
        <seg>public abstract &lt;X&gt; void output(OutputTag&lt;X&gt; outputTag, X value);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract Collection&lt;W&gt; assignWindows( T element,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041647Z" creationid="xccui" creationdate="20190626T041647Z">
        <seg>public abstract Collection&lt;W&gt; assignWindows( T element,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract KeyedStateStore globalState();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010916Z" creationid="xccui" creationdate="20190624T010916Z">
        <seg>public abstract KeyedStateStore globalState();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract KeyedStateStore windowState();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010840Z" creationid="xccui" creationdate="20190624T010840Z">
        <seg>public abstract KeyedStateStore windowState();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract TriggerResult onEventTime(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190127Z" creationid="xccui" creationdate="20190626T190127Z">
        <seg>public abstract TriggerResult onEventTime(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract W window();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010724Z" creationid="xccui" creationdate="20190624T010724Z">
        <seg>public abstract W window();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract boolean isEventTime();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041919Z" creationid="xccui" creationdate="20190626T041919Z">
        <seg>public abstract boolean isEventTime();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract class Context implements Serializable {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010714Z" creationid="xccui" creationdate="20190624T010714Z">
        <seg>public abstract class Context implements Serializable {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract class ProcessWindowFunction&lt;IN, OUT, KEY, W extends Window&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010449Z" creationid="xccui" creationdate="20190624T010449Z">
        <seg>public abstract class ProcessWindowFunction&lt;IN, OUT, KEY, W extends Window&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract class Trigger&lt;T, W extends Window&gt; implements Serializable {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185925Z" creationid="xccui" creationdate="20190626T185925Z">
        <seg>public abstract class Trigger&lt;T, W extends Window&gt; implements Serializable {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract class WindowAssigner&lt;T, W extends Window&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041554Z" creationid="xccui" creationdate="20190626T041554Z">
        <seg>public abstract class WindowAssigner&lt;T, W extends Window&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract long currentProcessingTime();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010735Z" creationid="xccui" creationdate="20190624T010735Z">
        <seg>public abstract long currentProcessingTime();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract long currentWatermark();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010752Z" creationid="xccui" creationdate="20190624T010752Z">
        <seg>public abstract long currentWatermark();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract long getCurrentProcessingTime();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041947Z" creationid="xccui" creationdate="20190626T041947Z">
        <seg>public abstract long getCurrentProcessingTime();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract static class WindowAssignerContext {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041943Z" creationid="xccui" creationdate="20190626T041943Z">
        <seg>public abstract static class WindowAssignerContext {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract void clear(W window, TriggerContext ctx);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192334Z" creationid="xccui" creationdate="20190626T192334Z">
        <seg>public abstract void clear(W window, TriggerContext ctx);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public boolean canMerge();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190153Z" creationid="xccui" creationdate="20190626T190153Z">
        <seg>public boolean canMerge();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public class Person {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044803Z" creationid="xccui" creationdate="20190617T044803Z">
        <seg>public class Person {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public class WatermarkGauge implements Gauge&lt;Long&gt; {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031842Z" creationid="xccui" creationdate="20190803T031842Z">
        <seg>public class WatermarkGauge implements Gauge&lt;Long&gt; {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public interface AggregateFunction&lt;IN, ACC, OUT&gt; extends Function, Serializable {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T003529Z" creationid="xccui" creationdate="20190624T003529Z">
        <seg>public interface AggregateFunction&lt;IN, ACC, OUT&gt; extends Function, Serializable {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public interface Evictor&lt;T, W extends Window&gt; extends Serializable {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201547Z" creationid="xccui" creationdate="20190627T201547Z">
        <seg>public interface Evictor&lt;T, W extends Window&gt; extends Serializable {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public interface OnMergeContext extends TriggerContext {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193026Z" creationid="xccui" creationdate="20190626T193026Z">
        <seg>public interface OnMergeContext extends TriggerContext {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public interface TriggerContext {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192552Z" creationid="xccui" creationdate="20190626T192552Z">
        <seg>public interface TriggerContext {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public void clear(Context ctx) throws Exception {}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010622Z" creationid="xccui" creationdate="20190624T010622Z">
        <seg>public void clear(Context ctx) throws Exception {}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public void onMerge(W window, OnMergeContext ctx);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190951Z" creationid="xccui" creationdate="20190626T190951Z">
        <seg>public void onMerge(W window, OnMergeContext ctx);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public void setCurrentWatermark(long watermark) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031848Z" creationid="xccui" creationdate="20190803T031848Z">
        <seg>public void setCurrentWatermark(long watermark) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>quently received records are written in the context of the transaction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T201042Z" creationid="xccui" creationdate="20190715T200919Z">
        <seg>所有针对接下来所接收记录的写出操作都会被纳入到这个事务中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>r.timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051158Z" creationid="xccui" creationdate="20190620T051158Z">
        <seg>r.timestamp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>r: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155839Z" creationid="xingcan" creationdate="20190628T155839Z">
        <seg>r: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ration key, you can specify one or more directories (separated by colons) that are</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T042540Z" creationid="xccui" creationdate="20190724T042540Z">
        <seg>利用io.tmp.dirs配置项，你可以指定一个或多个目录（英文冒号分割）用以在本地文件系统上存储数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>readOnlyCtx: KeyedBroadcastProcessFunction [String, SensorReading, ThresholdUpdate, (String, Double, Double)]#ReadOnlyContext,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042654Z" creationid="xccui" creationdate="20190702T042654Z">
        <seg>readOnlyCtx: KeyedBroadcastProcessFunction [String, SensorReading, ThresholdUpdate, (String, Double, Double)]#ReadOnlyContext,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reading per window and emits them together with the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031901Z" creationid="xccui" creationdate="20190625T030902Z">
        <seg>它会将读数连同窗口结束时间戳一起发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>readings.addSink(new DerbyUpsertSink)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045056Z" creationid="xccui" creationdate="20190714T045056Z">
        <seg>readings.addSink(new DerbyUpsertSink)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>readings.addSink(new SimpleSocketSink("localhost", 9191))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T023954Z" creationid="xccui" creationdate="20190714T023954Z">
        <seg>readings.addSink(new SimpleSocketSink("localhost", 9191))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>readings.print()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022929Z" creationid="xccui" creationdate="20190622T022929Z">
        <seg>readings.print()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>readings.transform(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064231Z" creationid="xccui" creationdate="20190715T064231Z">
        <seg>readings.transform(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>readings: Iterable[SensorReading], checkpointId: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064352Z" creationid="xccui" creationdate="20190715T064352Z">
        <seg>readings: Iterable[SensorReading], checkpointId: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rebalance(), etc.).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T043610Z" creationid="xccui" creationdate="20190713T043610Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>record via an HTTP POST call and not via its Collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T212611Z" creationid="xccui" creationdate="20190713T212611Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>records more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T042847Z" creationid="xccui" creationdate="20190715T042847Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T192304Z" creationid="xccui" creationdate="20190710T192304Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rect answers to these questions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025245Z" creationid="xccui" creationdate="20190606T025245Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>refer to the same class of entities, just like a join predicate in a SQL query.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T051155Z" creationid="xccui" creationdate="20190615T051155Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>registerEventTimeTimer(timestamp: Long): Unit registers an event-time timer for the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060320Z">
        <seg>registerEventTimeTimer(timestamp: Long): Unit针对当前键值注册一个事件时间计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>registerProcessingTimeTimer(timestamp: Long): Unit registers a processing time timer for the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060056Z">
        <seg>registerProcessingTimeTimer(timestamp: Long): Unit针对当前键值注册一个处理时间计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>relative configuration value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T041203Z" creationid="xccui" creationdate="20190724T041203Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>relevant data in the persistent storage and writes a pointer to the information—the storage path—to ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T045122Z" creationid="xccui" creationdate="20190720T043700Z">
        <seg>JobManager会将所有相关数据存储持久化存储并将这些信息的存储路径写入ZooKeeper。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>remove elements from the window state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044708Z" creationid="xccui" creationdate="20190626T044708Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>replaced by the ReduceFunction’s result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T001322Z" creationid="xccui" creationdate="20190624T001322Z">
        <seg>随后会用ReduceFunction的结果替换窗口状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>replicas: 1 template: metadata:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T024953Z" creationid="xccui" creationdate="20190720T024953Z">
        <seg>replicas: 1 template: metadata:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>replicas: 2 template: metadata:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025721Z" creationid="xccui" creationdate="20190720T025721Z">
        <seg>replicas: 2 template: metadata:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>repository to your local machine:1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040104Z" creationid="xccui" creationdate="20190611T040104Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>requires a KeyedSerializationSchema in order to extract the message keys and con‐ figure the FlinkKafkaPartitioner parameter with null to disable the default partitioner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T040745Z" creationid="xccui" creationdate="20190710T040745Z">
        <seg>为此，我们需要提供一个负责从消息中提取键值的KeyedSerializationSchema，并将FlinkKafkaPartitioner的参数设置为null以禁用默认的分区器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>restoreState(java.util.List[T] state): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T045523Z" creationid="xccui" creationdate="20190701T045523Z">
        <seg>restoreState(java.util.List[T] state): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T210937Z" creationid="xccui" creationdate="20190623T210937Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result.close() query.close() conn.close()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211740Z" creationid="xccui" creationdate="20190716T211740Z">
        <seg>result.close() query.close() conn.close()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>resultFuture: ResultFuture[(String, String)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T205925Z" creationid="xccui" creationdate="20190716T205925Z">
        <seg>resultFuture: ResultFuture[(String, String)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>results continuously, maybe every minute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014703Z" creationid="xccui" creationdate="20190606T014703Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>results(i) = futures(i).get().value()._2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041321Z" creationid="xccui" creationdate="20190707T041321Z">
        <seg>results(i) = futures(i).get().value()._2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>retries property to a value larger than zero (the default).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T155135Z" creationid="xingcan" creationdate="20190709T155135Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return currentWatermark;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031902Z" creationid="xccui" creationdate="20190803T031902Z">
        <seg>return currentWatermark;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return in a different order than the order in which they were sent out) or return the results in the order of the query results to further reduce the latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T193915Z" creationid="xccui" creationdate="20190716T192803Z">
        <seg>也可以为了追求更低的延迟按照请求结果的返回顺序处理记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rich function starts with Rich followed by the transformation name—RichMapFunc tion, RichFlatMapFunction, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T041124Z" creationid="xccui" creationdate="20190618T060721Z">
        <seg>它们的命名规则是以Rich开头，后面跟着普通转换函数的名字，例如：RichMapFunction、RichFlatMapFunction等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>room</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211853Z" creationid="xccui" creationdate="20190716T211853Z">
        <seg>room</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>room.onComplete {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211948Z" creationid="xccui" creationdate="20190716T211948Z">
        <seg>room.onComplete {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>round-robin distribution transformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043417Z" creationid="xccui" creationdate="20190616T043417Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>row with the given key exists.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T052007Z" creationid="xccui" creationdate="20190714T052007Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>running Flink on a cluster resource manager (YARN, Kubernetes, Mesos) makes it easy to spin up multiple TaskManagers (each with one slot) per compute node.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T062531Z" creationid="xccui" creationdate="20190723T062531Z">
        <seg>因为基于资源管理器（YARN、Kuberanetes、Mesos）运行Flink可以轻松在每个计算节点上启动多个（单处理槽的）TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s"SELECT room FROM SensorLocations WHERE sensor = '$sensor'")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211111Z" creationid="xccui" creationdate="20190716T211111Z">
        <seg>s"SELECT room FROM SensorLocations WHERE sensor = '$sensor'")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>savepoints, run the command:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T184630Z" creationid="xccui" creationdate="20190726T184630Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>scenarios in more detail later in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T043211Z" creationid="xccui" creationdate="20190715T043211Z">
        <seg>我们会在本节后面详细讨论这些场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>semantics (events that have no matching event will not be forwarded).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T203637Z" creationid="xccui" creationdate="20190628T025655Z">
        <seg>（无法发出未匹配成功的事件）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sensorId and temperature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T205900Z" creationid="xccui" creationdate="20190711T205900Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>separate tiers for data processing (the application itself) and data storage (a transac&lt;t0/&gt;‐&lt;t1/&gt; tional database system) as shown in &lt;t2/&gt;Figure 1-1&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T155712Z" creationid="xccui" creationdate="20190226T155712Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>serve requests of the queryable state client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T055131Z" creationid="xccui" creationdate="20190706T055131Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set to a default value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T162545Z" creationid="xccui" creationdate="20190712T162545Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>setClusterBuilder(ClusterBuilder): The ClusterBuilder builds a Cassandra Cluster that manages the connection to Cassandra.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T221334Z" creationid="xccui" creationdate="20190711T221334Z">
        <seg>setClusterBuilder(ClusterBuilder)：ClusterBuilder可以构建一个Cassandra Cluster，用以管理和Cassandra的连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>setHost(String, [Int]): This method is a shortcut for a simple Cluster Builder configured with the hostname and port of a single contact point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T222032Z" creationid="xccui" creationdate="20190711T222032Z">
        <seg>setHost(String, [Int])：是一个针对单个连接点的简单ClusterBuilder配置主机名和端口的快捷方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>setMapperOptions(MapperOptions): This provides options for Cassandra’s Object Mapper, such as configurations for consistency, time-to-live (TTL), and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T223020Z" creationid="xccui" creationdate="20190711T223020Z">
        <seg>setMapperOptions(MapperOptions)：该方法用于指定Cassandra Object Mapper的一些选项，例如一致性配置、TTL（time-to-live 生存时间）和空字段处理等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>setQuery(String): This specifies the CQL INSERT query to write tuples, case classes, or rows to Cassandra.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T222811Z" creationid="xccui" creationdate="20190711T222811Z">
        <seg>setQuery(String)：该方法用于指定向Cassandra插入元组、样例类或Row的CQL INSERT查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sharing groups: green, yellow, and blue.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T020052Z" creationid="xccui" creationdate="20190731T020052Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shown in &lt;t0/&gt;Figure 3-5&lt;t1/&gt; fulfills the requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152232Z" creationid="esouser" creationdate="20190514T152232Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shows all variables that are available to configure metrics scopes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T043543Z" creationid="xccui" creationdate="20190804T043543Z">
        <seg>表10-18展示了指标域配置中的所有变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>side outputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011643Z" creationid="xccui" creationdate="20190624T011643Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>single method that can be easily implemented.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T054201Z" creationid="xccui" creationdate="20190711T024428Z">
        <seg>Encoder接口非常简单，它只有一个方法，实现起来很容易。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sink sets transaction.timeout.ms to one hour, which means you probably need to adjust the transaction.max.timeout.ms property of your Kafka setup, which is set to 15 minutes by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T030939Z" creationid="xccui" creationdate="20190710T030939Z">
        <seg>默认情况下，Flink Kafka数据汇的transaction.timeout.ms为1小时，所以你可能需要调整Kafka中transaction.max.timeout.ms的设置，它的默认时间是15分钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sink task to a single Kafka partition—all records emitted by the same sink task are written to the same partition and a single partition may contain the records of multi‐ ple sink tasks if there are more tasks than partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T035047Z" creationid="xccui" creationdate="20190710T034433Z">
        <seg>在没有指定的情况下，默认的分区器（partitioner）会将每个数据汇任务映射到一个单独的Kafka分区，即单个任务的所有记录都会被发往同一分区。如果任务数多余分区数，则每个分区可能会包含多个任务发来的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sinkBuilder</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210810Z" creationid="xccui" creationdate="20190711T210810Z">
        <seg>sinkBuilder</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sitively applied to these sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011815Z" creationid="xccui" creationdate="20190613T011815Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>size in time units; this can be specified using the of(Time size) method of the assigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042707Z" creationid="xccui" creationdate="20190623T042501Z">
        <seg>以时间单元表示的窗口大小。它可以利用分配器的of(Time size)方法指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>size of the TaskManager memory and might suffer from garbage collection pau‐ ses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T022948Z" creationid="xccui" creationdate="20190704T022923Z">
        <seg>但它同样会受到TaskManager内存大小的限制，并且也可能导致垃圾回收停顿问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>snapshotContext: FunctionSnapshotContext): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163347Z" creationid="xccui" creationdate="20190702T163347Z">
        <seg>snapshotContext: FunctionSnapshotContext): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>snapshotState(checkpointId: Long, timestamp: Long): java.util.List[T]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T045509Z" creationid="xccui" creationdate="20190701T045509Z">
        <seg>snapshotState(checkpointId: Long, timestamp: Long): java.util.List[T]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>socket = new Socket(InetAddress.getByName(host), port) writer = new PrintStream(socket.getOutputStream)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024720Z" creationid="xccui" creationdate="20190714T024720Z">
        <seg>socket = new Socket(InetAddress.getByName(host), port) writer = new PrintStream(socket.getOutputStream)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>some records might have been written and others not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T065324Z" creationid="xccui" creationdate="20190715T065324Z">
        <seg>那么就会出现部分数据已经写入而部分数据没能写入的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sources are reset in the case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205039Z" creationid="xccui" creationdate="20190710T205039Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>spec:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025003Z" creationid="xccui" creationdate="20190720T025003Z">
        <seg>spec:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specific state before the window is purged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024801Z" creationid="xccui" creationdate="20190624T024801Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specifies that operators determine the current time by using information from</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070249Z" creationid="xccui" creationdate="20190619T070212Z">
        <seg>指定算子根据数据自身的信息决定当前时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specifies that operators determine the current time of the data stream according</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070216Z" creationid="xccui" creationdate="20190619T065107Z">
        <seg>指定算子根据处理机器的系统时钟决定数据流当前的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specifies the processing time of the source operator as an event time timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T045826Z" creationid="xccui" creationdate="20190619T071451Z">
        <seg>指定每个接收的记录都把在数据源算子的处理时间作为事件时间的时间戳，并自动生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specify a TypeSerializer to control how state is written into a state backend, check‐ point, and savepoint.2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T071605Z" creationid="xccui" creationdate="20190630T071605Z">
        <seg>或者，你也可以显式指定一个TypeSerializer来控制状态如何写入状态后端、检查点及保存点。2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>spends most of its time waiting for query results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T055848Z" creationid="xccui" creationdate="20190716T192141Z">
        <seg>因此MapFunction的大部分时间都在等待查询结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sponding input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T043715Z" creationid="xccui" creationdate="20190615T043715Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>src/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005738Z" creationid="xccui" creationdate="20190612T005738Z">
        <seg>src/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state backend stores the data serialized (like the RocksDBStateBackend) or as objects on the heap (like the FSStateBackend), this happens when the state is read by a func‐ tion or when an application is restarted from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T052002Z" creationid="xccui" creationdate="20190705T052002Z">
        <seg>根据状态后端是将数据序列化后存储（如RocksDBStateBackend）还是以堆中对象的形式存储（如FSStateBackend），反序列化过程可能发生在函数读取状态时或应用从保存点重启时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025643Z" creationid="xccui" creationdate="20190801T025643Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state depending on how the offsets should be distributed to parallel task instances in the case of a rescaled application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T162958Z" creationid="xccui" creationdate="20190712T162958Z">
        <seg>具体选择要根据应用扩缩容时偏移值在并行任务实例上的分配规则来决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state in the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T053709Z" creationid="xccui" creationdate="20190727T053709Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T034403Z" creationid="xccui" creationdate="20190630T034400Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state.backend.local-recovery: This flag enables or disables local recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T024821Z" creationid="xccui" creationdate="20190802T024821Z">
        <seg>state.backend.local-recovery：用于启用或禁用本地恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state: util.List[java.lang.Long]): Unit = { highTempCnt = 0</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052709Z" creationid="xccui" creationdate="20190701T052709Z">
        <seg>state: util.List[java.lang.Long]): Unit = { highTempCnt = 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>states, and side outputs to emit records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011523Z" creationid="xccui" creationdate="20190624T011523Z">
        <seg>以及用于发出数据的副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stopped by calling ./bin/stop-cluster.sh.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T214018Z" creationid="xccui" creationdate="20190717T214018Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T063016Z" creationid="xccui" creationdate="20190706T063016Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041331Z" creationid="xccui" creationdate="20190622T041331Z">
        <seg>stream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream of integers so that all negative numbers are sent to the first task and all other numbers are sent to a random task:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050616Z" creationid="xccui" creationdate="20190616T050616Z">
        <seg>以下示例对一个整数数据流进行了分区，所有负数会定向发往第一个任务，而其他数字会随机选择一个任务发送：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream partitions, such as parallelism changes, keyBy(), or other explicit redistribu‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T031345Z" creationid="xccui" creationdate="20190620T031345Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream processing benchmark, which is based on a stream of advertisement clicks that need to be enriched with details about their corresponding campaign that are stored in a key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T191425Z" creationid="xccui" creationdate="20190716T191012Z">
        <seg>一个例子就是著名的Yahoo!流处理基准测试，它需要使用键值存储中的广告详细信息去丰富一条广告点击数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T015026Z" creationid="xccui" creationdate="20190622T015026Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream.addSink(myProducer)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T145410Z" creationid="xingcan" creationdate="20190709T145410Z">
        <seg>stream.addSink(myProducer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>streaming applications in production.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T025824Z" creationid="xccui" creationdate="20190731T025824Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>streams can be ingested from sources such as message queues or files, or also be gen‐ erated on the fly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T050643Z" creationid="xccui" creationdate="20190612T051324Z">
        <seg>这些数据流的来源可以是消息队列或文件，也可以是实时生成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>streams to which the record is routed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061022Z" creationid="xccui" creationdate="20190615T061022Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substreams of events that share the same key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T043958Z" creationid="xccui" creationdate="20190614T043958Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>succeed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210830Z" creationid="esouser" creationdate="20190603T210830Z">
        <seg>succeed.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>successful checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T051150Z" creationid="xccui" creationdate="20190715T051150Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sum()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052601Z" creationid="xccui" creationdate="20190614T052601Z">
        <seg>sum()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>summary can be a count, a sum, a sample of the events seen so far, a window buffer, or a custom data structure that preserves some property interesting to the running application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055808Z" creationid="xccui" creationdate="20190414T055808Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>support to register timers are the Trigger interface for windows and the process function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T204246Z" creationid="xccui" creationdate="20190704T204246Z">
        <seg>只有窗口的Trigger接口以及处理函数才支持注册计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tain information about the events they have received before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T055209Z" creationid="xccui" creationdate="20190605T235835Z">
        <seg>相反，状态化算子可能需要维护之前接收的事件信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tar xfz ./flink-1.7.1-bin-scala_2.12.tgz</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190717T162627Z" creationid="xccui" creationdate="20190717T162627Z">
        <seg>tar xfz ./flink-1.7.1-bin-scala_2.12.tgz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>task-manager-deployment.yaml.template configures the worker container as a Kubernetes deployment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T043925Z" creationid="xccui" creationdate="20190730T043904Z">
        <seg>task-manager-deployment.yaml.template将工作容器配置为Kubernetes Deployment。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>taskmanager ports:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025733Z" creationid="xccui" creationdate="20190720T025733Z">
        <seg>taskmanager ports:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>taskmanager.state.local.root-dirs: This parameter specifies one or more local paths at which the local state copies are stored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190802T024922Z" creationid="xccui" creationdate="20190802T024922Z">
        <seg>taskmanager.state.local.root-dirs：该参数用于指定用于存储本地状态副本的一个或多个本地路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tasks but will be chained to succeeding tasks if the requirements for chaining are met.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T010957Z" creationid="xccui" creationdate="20190730T204049Z">
        <seg>但可以在满足链接条件时和链接到后续任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ted result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040025Z" creationid="xccui" creationdate="20190625T040025Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tem only provides a synchronous client, you can spawn threads to send requests and handle them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T200619Z" creationid="xccui" creationdate="20190716T200506Z">
        <seg>而如果外部系统只提供了同步客户端，你可以通过多线程的方式来发送请求并对其进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>temperature FLOAT, PRIMARY KEY(sensorId)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210049Z" creationid="xccui" creationdate="20190711T210049Z">
        <seg>temperature FLOAT, PRIMARY KEY(sensorId)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>temperature measured by a sensor changes by more than a threshold since the last measurement.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061940Z" creationid="xccui" creationdate="20190630T061940Z">
        <seg>该示例应用会在传感器测量的温度和前一个测量值相比变化超出一定阈值时发出警报。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>template files and configured required values, you can deploy the application to Kubernetes as before with kubectl:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T044605Z" creationid="xccui" creationdate="20190730T044605Z">
        <seg>一旦将模板文件复制好并完成必要配置，你就可以像之前那样使用kubectl将应用部署到Kubernetes上：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tems use to update materialized views.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044542Z" creationid="xccui" creationdate="20190605T044542Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tenSecsMaxTemps</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062304Z" creationid="xccui" creationdate="20190706T062304Z">
        <seg>tenSecsMaxTemps</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tering function state with Flink’s runtime and returning the state objects, such as ValueState, ListState, or BroadcastState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T064920Z" creationid="xccui" creationdate="20190702T064742Z">
        <seg>这两个状态存储（state store）对象能够使用Flink运行时来注册函数状态并返回状态对象（例如ValueState、ListState或BroadcastState）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>terminated using YARN’s application utilities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T014633Z" creationid="xccui" creationdate="20190719T014633Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>text in which the method is invoked.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045223Z" creationid="xccui" creationdate="20190612T045223Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>than one state object by registering multiple state descriptors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T070214Z" creationid="xccui" creationdate="20190630T070214Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is called a state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051432Z" creationid="xccui" creationdate="20190608T051432Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is used if no explicit trigger is specified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T052330Z" creationid="xccui" creationdate="20190626T042149Z">
        <seg>用于没有显式指定触发器的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that process them in order of the modification timestamp of the file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T203225Z" creationid="xccui" creationdate="20190710T203225Z">
        <seg>这些读取器会按照文件修改时间的顺序处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that returns exactly one output event, possibly of a different type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045224Z" creationid="xccui" creationdate="20190613T045224Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that, the method compares the temperatures, possibly emits an alert, and updates its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T213216Z" creationid="xccui" creationdate="20190704T213038Z">
        <seg>随后，方法就会比较两个相邻的温度值，依照逻辑决定是否发出警报，并更新最近一次温度的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the  state.backend key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T044331Z" creationid="xccui" creationdate="20190724T044331Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the JAR file to the master process, which distributes it to the worker nodes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T030259Z" creationid="xccui" creationdate="20190726T030259Z">
        <seg>客户端会将JAR包提交到主进程，随后再由主进程分发至工作节点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the JobManager’s memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T020537Z" creationid="xccui" creationdate="20190704T020537Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the Maximum Parallelism of Keyed State Operators”.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T031711Z" creationid="xccui" creationdate="20190729T031711Z">
        <seg>（见"为使用键值分区状态的算子定义最大并行度"。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the aggregation—a single value of the ReduceFunction’s input (and output) type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T225146Z" creationid="xccui" creationdate="20190623T225146Z">
        <seg>一个和ReduceFunction的输入及输出类型都相同的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the application logic might require that all tasks of an operation receive the same data or that events be distributed following a custom strategy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190810T023840Z" creationid="xccui" creationdate="20190615T070115Z">
        <seg>也可能是应用逻辑要求某操作的所有任务接收相同的数据，或按照自定义策略分发事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the checkpoint interval of a Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T031052Z" creationid="xccui" creationdate="20190710T031052Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the command./bin/flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T021553Z" creationid="xccui" creationdate="20190726T021553Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the current count of collected values, and create statistics, such as min, max, stan‐ dard deviation, and mean, for the values seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T032812Z" creationid="xccui" creationdate="20190803T032812Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the data itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070251Z" creationid="xccui" creationdate="20190619T070251Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the events of both inputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T052629Z" creationid="xccui" creationdate="20190628T052629Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the input elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054026Z" creationid="xccui" creationdate="20190620T054026Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the isolation.level property) to declare whether it can read uncommitted mes‐ sages (read_uncommitted, the default) or not (read_committed).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T212345Z" creationid="xccui" creationdate="20190709T212345Z">
        <seg>针对某一主题的消费者可以通过隔离级别配置（isolation.level属性）来声明自己可以读取未提交的消息（read_uncommitted，默认配置）还是不可以（read_committed）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the java binary is not on the PATH, the base folder of a Java installation can be speci‐ fied by exporting the JAVA_HOME environment variable or setting the env.java.home parameter in ./conf/flink-conf.yaml.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190814T140047Z" creationid="xccui" creationdate="20190717T175529Z">
        <seg>如果PATH环境变量中没有配置Java二进制文件所在目录，你可以通过导出（export）JAVA_HOME环境变量或在./conf/flink-conf.yaml中设置env.java.home参数的方式来指定Java安装根目录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the method updates the clean-up timer by deleting the previous timer and registering a new one.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T212649Z" creationid="xccui" creationdate="20190704T212546Z">
        <seg>该方法会通过删除已有计时器并注册新计时器的方法达到"延期清理"的目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the operator state as a list of serializable state objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T041339Z" creationid="xccui" creationdate="20190701T050259Z">
        <seg>该方法需要将算子状态以可序列化状态对象列表的形式返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the reading position and emits records in a block that synchronizes on a lock object,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T174412Z" creationid="xccui" creationdate="20190712T174310Z">
        <seg>为此，可以通过SourceContext.getCheckpointLock()方法获取一个锁对象，并用它对run()方法中推进偏移和发出数据的代码块进行同步处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T213104Z" creationid="xccui" creationdate="20190713T213104Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the reduced value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T060434Z" creationid="xccui" creationdate="20190630T060434Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the result of the function or an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201015Z" creationid="xccui" creationdate="20190716T201015Z">
        <seg>第二个参数是用来返回函数结果或异常的回调对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the same dependency as Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190723T060315Z" creationid="xccui" creationdate="20190723T060315Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the selection of nested fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T041634Z" creationid="xccui" creationdate="20190618T041634Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the socket could not be opened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T023635Z" creationid="xccui" creationdate="20190714T023635Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the stateful function is restarted to recover from a failure or when an application is started from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T035047Z" creationid="xccui" creationdate="20190701T021555Z">
        <seg>该情况可能在状态化函数进行故障恢复或应用从保存点开始执行时出现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the transaction file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T052158Z" creationid="xccui" creationdate="20190716T052158Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the watermark propagation protocol (see “Watermark Propagation and Event Time”).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T022347Z" creationid="xccui" creationdate="20190709T022347Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>their IDs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T021126Z" creationid="xccui" creationdate="20190711T021126Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>them in “Defining Keys and Referencing Fields” on page 102.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051537Z" creationid="xccui" creationdate="20190614T051537Z">
        <seg>我们会在102页"定义键值和引用字段中"介绍它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then start querying the state of the running streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T045934Z" creationid="xccui" creationdate="20190707T045934Z">
        <seg>这时候，仪表盘就会开始从运行的流式应用中查询状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this("", 0.0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T220301Z" creationid="xccui" creationdate="20190711T220301Z">
        <seg>this("", 0.0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.age = age;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044901Z" creationid="xccui" creationdate="20190617T044901Z">
        <seg>this.age = age;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.currentWatermark = watermark;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031851Z" creationid="xccui" creationdate="20190803T031851Z">
        <seg>this.currentWatermark = watermark;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.lastTempState.update(reading.temperature)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064715Z" creationid="xccui" creationdate="20190630T064715Z">
        <seg>this.lastTempState.update(reading.temperature)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.name = name;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044856Z" creationid="xccui" creationdate="20190617T044856Z">
        <seg>this.name = name;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.transactionWriter = Files.newBufferedWriter(tFilePath) println(s"Creating Transaction File: $tFilePath")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041434Z" creationid="xccui" creationdate="20190716T041434Z">
        <seg>this.transactionWriter = Files.newBufferedWriter(tFilePath) println(s"Creating Transaction File: $tFilePath")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>threshold.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T204926Z" creationid="xccui" creationdate="20190704T204926Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>thresholds.put(update.id, update.threshold)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042642Z" creationid="xccui" creationdate="20190702T042642Z">
        <seg>thresholds.put(update.id, update.threshold)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>thresholds.remove(update.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042645Z" creationid="xccui" creationdate="20190702T042645Z">
        <seg>thresholds.remove(update.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timeout interval, which is configured with the transaction.timeout.ms property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T222545Z" creationid="xccui" creationdate="20190709T222545Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timeout.9 Hence, it does not offer definitive exactly-once guarantees even though it implements the TwoPhaseCommitSinkFunction interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T061400Z" creationid="xccui" creationdate="20190716T061400Z">
        <seg>因此它即便实现了TwoPhaseCommitSinkFunction类，也无法完美地提供精确一次的保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timestamp is stored in an additional ValueState[Long] called lastTimerState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T212953Z" creationid="xccui" creationdate="20190704T212953Z">
        <seg>KeyedProcessFunction会使用一个名为lastTimerState的ValueState[Long]来记录它的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timestamp larger than the timestamp of the previous watermark, the new watermark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T055438Z" creationid="xccui" creationdate="20190620T050302Z">
        <seg>且它的时间戳大于上一个水位线的时间戳，那么算子就会发出一个新的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timestamp that is equal to or larger than the timer’s timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060426Z" creationid="xccui" creationdate="20190621T060426Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timestamp: Long): Boolean = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064355Z" creationid="xccui" creationdate="20190715T064355Z">
        <seg>timestamp: Long): Boolean = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timestamp: Long, temperature: Double)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035709Z" creationid="xccui" creationdate="20190612T035709Z">
        <seg>timestamp: Long, temperature: Double)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030751Z" creationid="xccui" creationdate="20190801T030751Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211423Z" creationid="xccui" creationdate="20190623T211423Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion must be Serializable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055235Z" creationid="xccui" creationdate="20190618T055235Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion on which the stream is to be partitioned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050340Z" creationid="xccui" creationdate="20190616T050340Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion pauses because it puts many long-lived objects on the heap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T020001Z" creationid="xccui" creationdate="20190704T020001Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion performs the actual window evaluation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T051757Z" creationid="xccui" creationdate="20190626T031606Z">
        <seg>而实际的计算逻辑则由窗口函数决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion state if the RocksDB state backend is configured.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T042440Z" creationid="xccui" creationdate="20190724T042440Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion via the StreamExecutionEnvironment or per operator using the setMaxParallel ism() method as shown in Example 7-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024950Z" creationid="xccui" creationdate="20190703T024950Z">
        <seg>如示例7-11所示，我们可以通过StreamExecutionEnvironment为应用的所有算子设置最大并行度或利用算子的setMaxParallelism()方法为每个算子单独设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054847Z" creationid="xccui" creationdate="20190617T054847Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tioned before, the connector might lose data if a transaction is rolled back due to a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T061100Z" creationid="xccui" creationdate="20190716T061050Z">
        <seg>如前所述，该连接器可能会因为事务超时回滚而丢失数据。9 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tions and reduce.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050128Z" creationid="xccui" creationdate="20190614T050128Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tions, mixes up the timestamp order of the elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T054733Z" creationid="xccui" creationdate="20190620T031401Z">
        <seg>都会导致元素的时间戳混乱。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to ResultFuture is a lightweight operation that does not require a dedicated thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T212709Z" creationid="xccui" creationdate="20190716T212623Z">
        <seg>因为将结果传递给ResultFuture对象是一个相对轻量级的操作，我们无须为它分配一个单独的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to connect to the source of the sensor measurements and create an initial DataStream of type SensorReading.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051601Z" creationid="xccui" creationdate="20190612T051601Z">
        <seg>来连接传感器测量源，并创建出SensorReading类型的初始DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to each ingested record and automatically generates watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071459Z" creationid="xccui" creationdate="20190619T071459Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to ensure the broadcast state holds the same information in all parallel instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T053159Z" creationid="xccui" creationdate="20190702T051544Z">
        <seg>这其实是一种安全机制，用于确保所有并行实例中广播状态所保存的信息完全相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to initialize the state by checking if the state backend holds state for the function reg‐ istered under the given name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T070144Z" creationid="xccui" creationdate="20190702T065114Z">
        <seg>状态存储首先会利用给定名称检查状态后端中是否存在一个为当前函数注册过的同名状态，并尝试用它对状态进行初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to instruct our program to interpret time semantics using event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T050325Z" creationid="xccui" creationdate="20190612T045805Z">
        <seg>来指定程序使用事件时间来解释时间语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to listen on localhost:9191.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T023912Z" creationid="xccui" creationdate="20190714T023912Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to read the file as a whole.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T192032Z" creationid="xccui" creationdate="20190710T192032Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to the run command.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T053751Z" creationid="xccui" creationdate="20190727T053751Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to the system clock of the machine where they are being executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T065121Z" creationid="xccui" creationdate="20190619T065121Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>topic to which the data is written, and the last is a SerializationSchema that con‐ verts the input types of the sink (String in Example 8-2) into a byte array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T150217Z" creationid="xingcan" creationdate="20190709T150158Z">
        <seg>最后一个参数SerializationSchema用于将数据汇的输入类型（示例8-2中的是String）转换为字节数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tor allows records to be emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T054911Z" creationid="xccui" creationdate="20190621T054911Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tor from being chained to preceding and succeeding tasks (Example 10-1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203257Z" creationid="xccui" creationdate="20190730T203257Z">
        <seg>这会让算子的任务不会和前后的其他任务进行链接（示例10-1）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tors collect and process records with possibly unordered timestamps and finalize a computation when their event-time clock, which is advanced by the received water‐ marks, indicates that no more records with relevant timestamps are expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T052104Z" creationid="xccui" creationdate="20190606T205535Z">
        <seg>对基于时间的算子任务而言，其收集和处理的记录可能会包含乱序的时间戳。这些算子只有当自己的事件时间时钟（由接收的水位线驱动）指示不必再等那些包含相关时间戳的记录时，才会最终触发计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tors, you can override the processLatencyMarker() method and retrieve the relevant information using the LatencyMarker’s methods getMarkedTime(), getVertexId(), and getSubTaskIndex().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190806T063606Z" creationid="xccui" creationdate="20190806T063606Z">
        <seg>可以覆盖processLatencyMarker()方法，在其中使用LatencyMarker的getMarkedTime()、getVertexId()和getSubTaskIndex()方法获取相关信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>trait AsyncFunction[IN, OUT] extends Function {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T200740Z" creationid="xccui" creationdate="20190716T200740Z">
        <seg>trait AsyncFunction[IN, OUT] extends Function {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transactionFile</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041528Z" creationid="xccui" creationdate="20190716T041528Z">
        <seg>transactionFile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transactionWriter.close()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041902Z" creationid="xccui" creationdate="20190716T041902Z">
        <seg>transactionWriter.close()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transactional writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T032224Z" creationid="xccui" creationdate="20190714T032224Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transformation-specific function interface:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020901Z" creationid="xccui" creationdate="20190613T020901Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>trigger does not support merging it cannot be used in combination with a Merging WindowAssigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195200Z" creationid="xccui" creationdate="20190626T195135Z">
        <seg>如果一个触发器不支持合并，则无法与MergingWindowAssigner组合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>true</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T064416Z" creationid="xccui" creationdate="20190715T064416Z">
        <seg>true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>truth because it persists the input events and can replay them in an deterministic order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T144509Z" creationid="xccui" creationdate="20190305T061121Z">
        <seg>这缘于于它可以持久化输入事件并以确定顺序将其重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ts: Long): java.util.List[java.lang.Long] = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052942Z" creationid="xccui" creationdate="20190701T052942Z">
        <seg>ts: Long): java.util.List[java.lang.Long] = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ts: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042700Z" creationid="xccui" creationdate="20190626T042700Z">
        <seg>ts: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type information to represent data types and generate specific serializers, deserializ‐ ers, and comparators for every data type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T064111Z" creationid="xccui" creationdate="20190616T063841Z">
        <seg>Flink利用类型信息的概念来表示数据类型，并且对于每种类型，都会为其生成特定的序列化器、反序列化器以及比较器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type of parallelism is called task parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032421Z" creationid="xccui" creationdate="20190401T032421Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type of the input stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061554Z" creationid="xccui" creationdate="20190614T061554Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type of the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T050155Z" creationid="xccui" creationdate="20190705T050155Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>types of filesystems, such as local filesystems (including locally mounted NFS or SAN shares, Hadoop HDFS, Amazon S3, and OpenStack Swift FS).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T184712Z" creationid="xccui" creationdate="20190710T184712Z">
        <seg>Flink支持多种类型的文件系统，例如：本地文件系统（包括挂载到本地的NFS或SAN），Hadoop HDFS，Amazon S3以及OpenStack Swift FS。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T052653Z" creationid="xccui" creationdate="20190617T052653Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>typically via a start offset and a length.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T191817Z" creationid="xccui" creationdate="20190710T191817Z">
        <seg>该范围通常由起始偏移和长度来决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undesirable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045748Z" creationid="xccui" creationdate="20190615T045748Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unique.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190804T044219Z" creationid="xccui" creationdate="20190804T044219Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unzip master.zip</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040435Z" creationid="xccui" creationdate="20190611T040435Z">
        <seg>unzip master.zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>up with the events happening now, it can continue as a real-time application using exactly the same program logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155347Z" creationid="xccui" creationdate="20190412T155347Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>updateStmt.execute()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045420Z" creationid="xccui" creationdate="20190714T045420Z">
        <seg>updateStmt.execute()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ured using the state.backend.rocksdb.localdir key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T043720Z" creationid="xccui" creationdate="20190724T043720Z">
        <seg>其维护目录可以利用state.backend.rocksdb.localdir参数来设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>used to store data in the local filesystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T042548Z" creationid="xccui" creationdate="20190724T042548Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>used with care.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045146Z" creationid="xccui" creationdate="20190626T045108Z">
        <seg>因此使用时要格外小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>user-defined function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T025350Z" creationid="xccui" creationdate="20190620T025350Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>user@flink.apache.org : user support and questions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T040456Z" creationid="xccui" creationdate="20190807T040456Z">
        <seg>user@flink.apache.org：用户支持和问题提问</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>using a KeySelector with a constant dummy key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T062031Z" creationid="xccui" creationdate="20190621T062031Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>v</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040010Z" creationid="xccui" creationdate="20190418T040010Z">
        <seg>v</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val a: DataStream[A] = env.createInput(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015237Z" creationid="xccui" creationdate="20190731T015237Z">
        <seg>val a: DataStream[A] = env.createInput(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val alerts: DataStream[(String, Double, Double)] = keyedData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062427Z" creationid="xccui" creationdate="20190630T062427Z">
        <seg>val alerts: DataStream[(String, Double, Double)] = keyedData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val alerts: DataStream[(String, Double, Double)] = keyedSensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024505Z" creationid="xccui" creationdate="20190702T024505Z">
        <seg>val alerts: DataStream[(String, Double, Double)] = keyedSensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val all: DataStream[(Int, String)] = splitted.select("small", "large")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064116Z" creationid="xccui" creationdate="20190615T064116Z">
        <seg>val all: DataStream[(Int, String)] = splitted.select("small", "large")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val allCities: DataStream[SensorReading] = parisStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064852Z" creationid="xccui" creationdate="20190614T064852Z">
        <seg>val allCities: DataStream[SensorReading] = parisStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val avgTemp = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042905Z" creationid="xccui" creationdate="20190623T042905Z">
        <seg>val avgTemp = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val avgTemp: DataStream[SensorReading] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042225Z" creationid="xccui" creationdate="20190612T042225Z">
        <seg>val avgTemp: DataStream[SensorReading] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val avgTempPerWindow: DataStream[(String, Double)] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005450Z" creationid="xccui" creationdate="20190624T005450Z">
        <seg>val avgTempPerWindow: DataStream[(String, Double)] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val b: DataStream[B] = a.map(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015248Z" creationid="xccui" creationdate="20190731T015248Z">
        <seg>val b: DataStream[B] = a.map(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val backend = new RocksDBStateBackend(checkpointPath)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025725Z" creationid="xccui" creationdate="20190704T025725Z">
        <seg>val backend = new RocksDBStateBackend(checkpointPath)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val backend: ConfigurableStateBackend = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030010Z" creationid="xccui" creationdate="20190801T030010Z">
        <seg>val backend: ConfigurableStateBackend = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val backend: RocksDBStateBackend = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030852Z" creationid="xccui" creationdate="20190801T030852Z">
        <seg>val backend: RocksDBStateBackend = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val bound: Long = 60 * 1000</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051040Z" creationid="xccui" creationdate="20190620T051040Z">
        <seg>val bound: Long = 60 * 1000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val bound: Long = 60 * 1000 // 1 min in ms</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054805Z" creationid="xccui" creationdate="20190620T054805Z">
        <seg>val bound: Long = 60 * 1000 // 1分钟的毫秒数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val broadcastStateDescriptor =</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024327Z" creationid="xccui" creationdate="20190702T024327Z">
        <seg>val broadcastStateDescriptor =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val broadcastThresholds: BroadcastStream[ThresholdUpdate] = thresholds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024336Z" creationid="xccui" creationdate="20190702T024336Z">
        <seg>val broadcastThresholds: BroadcastStream[ThresholdUpdate] = thresholds</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val byId: KeyedStream[SensorReading, String] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051748Z" creationid="xccui" creationdate="20190618T051748Z">
        <seg>val byId: KeyedStream[SensorReading, String] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val c: DataStream[C] = env.createInput(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015324Z" creationid="xccui" creationdate="20190731T015324Z">
        <seg>val c: DataStream[C] = env.createInput(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val cFilePath = Paths.get(s"$targetPath/$transaction") Files.move(tFilePath, cFilePath)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042143Z" creationid="xccui" creationdate="20190716T042143Z">
        <seg>val cFilePath = Paths.get(s"$targetPath/$transaction") Files.move(tFilePath, cFilePath)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val caseClassType: TypeInformation[Person] = Types.CASE_CLASS[Person]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053917Z" creationid="xccui" creationdate="20190617T053917Z">
        <seg>val caseClassType: TypeInformation[Person] = Types.CASE_CLASS[Person]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val celsius = (r.temperature - 32) * (5.0 / 9.0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042259Z" creationid="xccui" creationdate="20190612T042259Z">
        <seg>val celsius = (r.temperature - 32) * (5.0 / 9.0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val client = new QueryableStateClient(proxyHost, proxyPort)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040140Z" creationid="xccui" creationdate="20190707T040140Z">
        <seg>val client = new QueryableStateClient(proxyHost, proxyPort)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val client: QueryableStateClient =</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T125212Z" creationid="xccui" creationdate="20190706T125212Z">
        <seg>val client: QueryableStateClient =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val cnt = elements.count(_ =&gt; true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034120Z" creationid="xccui" creationdate="20190629T034120Z">
        <seg>val cnt = elements.count(_ =&gt; true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val configuredBackend = backend.configure(sbConfig)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030141Z" creationid="xccui" creationdate="20190801T030141Z">
        <seg>val configuredBackend = backend.configure(sbConfig)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val conn = DriverManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211035Z" creationid="xccui" creationdate="20190716T211035Z">
        <seg>val conn = DriverManager</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val connected: ConnectedStreams[Int, String] = first.connect(second)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040824Z" creationid="xccui" creationdate="20190615T040824Z">
        <seg>val connected: ConnectedStreams[Int, String] = first.connect(second)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val countPer10Secs: DataStream[(String, Long, Int)] = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154933Z" creationid="xingcan" creationdate="20190628T154933Z">
        <seg>val countPer10Secs: DataStream[(String, Long, Int)] = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val countPer10Secs: DataStream[(String, Long, Int, String)] = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165206Z" creationid="xingcan" creationdate="20190628T165206Z">
        <seg>val countPer10Secs: DataStream[(String, Long, Int, String)] = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val cpConfig: CheckpointConfig = env.getCheckpointConfig</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T030835Z" creationid="xccui" creationdate="20190731T030835Z">
        <seg>val cpConfig: CheckpointConfig = env.getCheckpointConfig</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val curTimer = lastTimerState.value()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210609Z" creationid="xccui" creationdate="20190704T210609Z">
        <seg>val curTimer = lastTimerState.value()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val curTimerTimestamp = currentTimer.value();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071518Z" creationid="xccui" creationdate="20190621T071518Z">
        <seg>val curTimerTimestamp = currentTimer.value();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val curTimerTimestamp = disableTimer.value()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032340Z" creationid="xccui" creationdate="20190622T032340Z">
        <seg>val curTimerTimestamp = disableTimer.value()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val d: DataStream[D] = b.connect(c.broadcast(...)).process(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015416Z" creationid="xccui" creationdate="20190731T015416Z">
        <seg>val d: DataStream[D] = b.connect(c.broadcast(...)).process(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val defaultP = env.env.getParallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060244Z" creationid="xccui" creationdate="20190616T060244Z">
        <seg>val defaultP = env.env.getParallelism</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val defaultP = env.getParallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061615Z" creationid="xccui" creationdate="20190616T061615Z">
        <seg>val defaultP = env.getParallelism</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val desc = new ListStateDescriptor[Long]("offset", classOf[Long]) offsetState = initCtx.getOperatorStateStore.getListState(desc)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034507Z" creationid="xccui" creationdate="20190713T034507Z">
        <seg>val desc = new ListStateDescriptor[Long]("offset", classOf[Long]) offsetState = initCtx.getOperatorStateStore.getListState(desc)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val div = highTempCnt / 10</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062728Z" creationid="xccui" creationdate="20190701T062728Z">
        <seg>val div = highTempCnt / 10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val e = d.addSink()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T015422Z" creationid="xccui" creationdate="20190731T015422Z">
        <seg>val e = d.addSink()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val endTime = startTime + windowSize</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044106Z" creationid="xccui" creationdate="20190626T044106Z">
        <seg>val endTime = startTime + windowSize</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041917Z" creationid="xccui" creationdate="20190612T041917Z">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment env.setRestartStrategy(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190801T154418Z" creationid="xingcan" creationdate="20190801T154418Z">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment env.setRestartStrategy(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045734Z" creationid="xccui" creationdate="20190620T045734Z">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment val checkpointPath: String = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025646Z" creationid="xccui" creationdate="20190704T025646Z">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment val checkpointPath: String = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env: StreamExecutionEnvironment = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190731T030652Z" creationid="xccui" creationdate="20190731T030652Z">
        <seg>val env: StreamExecutionEnvironment = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env: StreamExecutionEnvironment.getExecutionEnvironment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T054818Z" creationid="xccui" creationdate="20190616T054818Z">
        <seg>val env: StreamExecutionEnvironment.getExecutionEnvironment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val filterSwitches: DataStream[(String, Long)] = env</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031604Z" creationid="xccui" creationdate="20190622T031604Z">
        <seg>val filterSwitches: DataStream[(String, Long)] = env</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val filteredReadings: DataStream[SensorReading] = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155621Z" creationid="xingcan" creationdate="20190628T155621Z">
        <seg>val filteredReadings: DataStream[SensorReading] = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val filteredSensors = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053212Z" creationid="xccui" creationdate="20190613T053212Z">
        <seg>val filteredSensors = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val first: DataStream[(Int, Long)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T051655Z" creationid="xccui" creationdate="20190615T051655Z">
        <seg>val first: DataStream[(Int, Long)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val first: DataStream[Int] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040722Z" creationid="xccui" creationdate="20190615T040722Z">
        <seg>val first: DataStream[Int] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val firstSeen: ValueState[Boolean] = ctx.getPartitionedState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200332Z" creationid="xccui" creationdate="20190626T200332Z">
        <seg>val firstSeen: ValueState[Boolean] = ctx.getPartitionedState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val flinkTweets = tweets.filter(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054233Z" creationid="xccui" creationdate="20190618T054233Z">
        <seg>val flinkTweets = tweets.filter(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val flinkTweets = tweets.filter(_.contains("flink"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055915Z" creationid="xccui" creationdate="20190618T055915Z">
        <seg>val flinkTweets = tweets.filter(_.contains("flink"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val flinkTweets = tweets.filter(new FlinkFilter)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054129Z" creationid="xccui" creationdate="20190618T054129Z">
        <seg>val flinkTweets = tweets.filter(new FlinkFilter)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val flinkTweets = tweets.filter(new KeywordFilter("flink"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054642Z" creationid="xccui" creationdate="20190618T054642Z">
        <seg>val flinkTweets = tweets.filter(new KeywordFilter("flink"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val forwardedReadings = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031647Z" creationid="xccui" creationdate="20190622T031647Z">
        <seg>val forwardedReadings = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val fsBackend = new FsStateBackend("file:///tmp/ckp", true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022907Z" creationid="xccui" creationdate="20190801T022907Z">
        <seg>val fsBackend = new FsStateBackend("file:///tmp/ckp", true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val futures = new Array[</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040144Z" creationid="xccui" creationdate="20190707T040144Z">
        <seg>val futures = new Array[</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val header =</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040218Z" creationid="xccui" creationdate="20190707T040218Z">
        <seg>val header =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val input : DataStream[(Int, Int)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052152Z" creationid="xccui" creationdate="20190618T052152Z">
        <seg>val input : DataStream[(Int, Int)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val input: DataStream[(Int, String, Long)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T033254Z" creationid="xccui" creationdate="20190618T033254Z">
        <seg>val input: DataStream[(Int, String, Long)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val input: DataStream[(Int, String, Long)] = ... val keyed1 = input.keyBy("2") // key by 3rd field val keyed2 = input.keyBy("_1") // key by 1st field</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T043349Z" creationid="xccui" creationdate="20190618T043341Z">
        <seg>val input: DataStream[(Int, String, Long)] = ... val keyed1 = input.keyBy("2") // 以第3个字段为键值 val keyed2 = input.keyBy("_1") // 以第1个字段为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val input: DataStream[String] = …</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205907Z" creationid="xccui" creationdate="20190710T205907Z">
        <seg>val input: DataStream[String] = …</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val input: DataStream[X] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203555Z" creationid="xccui" creationdate="20190730T203555Z">
        <seg>val input: DataStream[X] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val inputStream: DataStream[(Int, Int, Int)] = env.fromElements( (1, 2, 2), (2, 3, 1), (2, 2, 4), (1, 5, 3))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054427Z" creationid="xccui" creationdate="20190614T054427Z">
        <seg>val inputStream: DataStream[(Int, Int, Int)] = env.fromElements( (1, 2, 2), (2, 3, 1), (2, 2, 4), (1, 5, 3))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val inputStream: DataStream[(Int, String)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064057Z" creationid="xccui" creationdate="20190615T064057Z">
        <seg>val inputStream: DataStream[(Int, String)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val inputStream: DataStream[(String, List[String])] = env.fromElements( ("en", List("tea")), ("fr", List("vin")), ("en", List("cake")))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062232Z" creationid="xccui" creationdate="20190614T062232Z">
        <seg>val inputStream: DataStream[(String, List[String])] = env.fromElements( ("en", List("tea")), ("fr", List("vin")), ("en", List("cake")))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val isUpdate = ctx.windowState.getState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034323Z" creationid="xccui" creationdate="20190629T034323Z">
        <seg>val isUpdate = ctx.windowState.getState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val it = offsetState.get()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034520Z" creationid="xccui" creationdate="20190713T034520Z">
        <seg>val it = offsetState.get()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val jobId = "d2447b1a5e0d952c372064c886d2220a"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040030Z" creationid="xccui" creationdate="20190707T040030Z">
        <seg>val jobId = "d2447b1a5e0d952c372064c886d2220a"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyCntDescriptor = new ValueStateDescriptor[Long]("keyedCnt", classOf[Long]) keyedCntState = initContext.getKeyedStateStore.getState(keyCntDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163315Z" creationid="xccui" creationdate="20190702T163315Z">
        <seg>val keyCntDescriptor = new ValueStateDescriptor[Long]("keyedCnt", classOf[Long]) keyedCntState = initContext.getKeyedStateStore.getState(keyCntDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyHighTempCnt = keyedCntState.value() + 1 keyedCntState.update(keyHighTempCnt)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162539Z" creationid="xccui" creationdate="20190702T162539Z">
        <seg>val keyHighTempCnt = keyedCntState.value() + 1 keyedCntState.update(keyHighTempCnt)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyed = input.keyBy(1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T033251Z" creationid="xccui" creationdate="20190618T033251Z">
        <seg>val keyed = input.keyBy(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyed2 = input.keyBy(1, 2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T041306Z" creationid="xccui" creationdate="20190618T041306Z">
        <seg>val keyed2 = input.keyBy(1, 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyed: KeyedStream[SensorReading, String] = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053550Z" creationid="xccui" creationdate="20190615T053550Z">
        <seg>val keyed: KeyedStream[SensorReading, String] = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedConnect1: ConnectedStreams[(Int, Long), (Int, String)] = one</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050145Z" creationid="xccui" creationdate="20190615T050145Z">
        <seg>val keyedConnect1: ConnectedStreams[(Int, Long), (Int, String)] = one</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedConnect2: ConnectedStreams[(Int, Long), (Int, String)] = one.keyBy(0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050432Z" creationid="xccui" creationdate="20190615T050432Z">
        <seg>val keyedConnect2: ConnectedStreams[(Int, Long), (Int, String)] = one.keyBy(0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedConnect: ConnectedStreams[(Int, Long), (Int, String)] = first</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053608Z" creationid="xccui" creationdate="20190615T053608Z">
        <seg>val keyedConnect: ConnectedStreams[(Int, Long), (Int, String)] = first</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedData: KeyedStream[SensorReading, String] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062059Z" creationid="xccui" creationdate="20190630T062059Z">
        <seg>val keyedData: KeyedStream[SensorReading, String] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedSensorData: KeyedStream[SensorReading, String] = sensorData.keyBy(_.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024311Z" creationid="xccui" creationdate="20190702T024311Z">
        <seg>val keyedSensorData: KeyedStream[SensorReading, String] = sensorData.keyBy(_.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedSensors = sensorStream.keyBy("id")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T042640Z" creationid="xccui" creationdate="20190618T042640Z">
        <seg>val keyedSensors = sensorStream.keyBy("id")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedStream = input.keyBy(value =&gt; math.max(value._1, value._2))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052156Z" creationid="xccui" creationdate="20190618T052156Z">
        <seg>val keyedStream = input.keyBy(value =&gt; math.max(value._1, value._2))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val large: DataStream[(Int, String)] = splitted.select("large")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064109Z" creationid="xccui" creationdate="20190615T064109Z">
        <seg>val large: DataStream[(Int, String)] = splitted.select("large")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lastTemp = lastTempState.value()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064433Z" creationid="xccui" creationdate="20190630T064433Z">
        <seg>val lastTemp = lastTempState.value()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lastTempDesc = new ValueStateDescriptor[Double]("lastTemp", classOf[Double]) lastTempState = getRuntimeContext.getState[Double](lastTempDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210329Z" creationid="xccui" creationdate="20190704T210329Z">
        <seg>val lastTempDesc = new ValueStateDescriptor[Double]("lastTemp", classOf[Double]) lastTempState = getRuntimeContext.getState[Double](lastTempDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lastTempDescriptor =</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064311Z" creationid="xccui" creationdate="20190630T064311Z">
        <seg>val lastTempDescriptor =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lastTempDescriptor = new ValueStateDescriptor[Double]( "lastTemp", classOf[Double])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190813T061053Z" creationid="xccui" creationdate="20190702T042520Z">
        <seg>val lastTempDescriptor = new ValueStateDescriptor[Double]("lastTemp", classOf[Double])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lastTimerDesc = new ValueStateDescriptor[Long]("lastTimer", classOf[Long]) lastTimerState = getRuntimeContext.getState(timestampDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210440Z" creationid="xccui" creationdate="20190704T210440Z">
        <seg>val lastTimerDesc = new ValueStateDescriptor[Long]("lastTimer", classOf[Long]) lastTimerState = getRuntimeContext.getState(timestampDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lateReadings: DataStream[SensorReading] = filteredReadings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155643Z" creationid="xingcan" creationdate="20190628T155643Z">
        <seg>val lateReadings: DataStream[SensorReading] = filteredReadings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lateReadingsOut = new OutputTag[SensorReading]("late-readings") override def processElement(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155835Z" creationid="xingcan" creationdate="20190628T155835Z">
        <seg>val lateReadingsOut = new OutputTag[SensorReading]("late-readings") override def processElement(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lateStream: DataStream[SensorReading] = countPer10Secs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155125Z" creationid="xingcan" creationdate="20190628T155125Z">
        <seg>val lateStream: DataStream[SensorReading] = countPer10Secs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val line = results.map(t =&gt; f"$t%1.3f").mkString("\t| ") println(line)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T041332Z" creationid="xccui" creationdate="20190707T041332Z">
        <seg>val line = results.map(t =&gt; f"$t%1.3f").mkString("\t| ") println(line)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lineReader = new TextInputFormat(null)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T184948Z" creationid="xccui" creationdate="20190710T184948Z">
        <seg>val lineReader = new TextInputFormat(null)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lineStream: DataStream[String] = env.readFile[String]( lineReader,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T184951Z" creationid="xccui" creationdate="20190710T184951Z">
        <seg>val lineStream: DataStream[String] = env.readFile[String]( lineReader,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val localEnv: StreamExecutionEnvironment.createLocalEnvironment()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T044907Z" creationid="xccui" creationdate="20190612T045612Z">
        <seg>val localEnv = StreamExecutionEnvironment.createLocalEnvironment()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val memBackend = new MemoryStateBackend()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022644Z" creationid="xccui" creationdate="20190801T022644Z">
        <seg>val memBackend = new MemoryStateBackend()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val minMax = minMaxIt.head</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045144Z" creationid="xccui" creationdate="20190625T045144Z">
        <seg>val minMax = minMaxIt.head</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val minMaxTempPerWindow: DataStream[MinMaxTemp] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030643Z" creationid="xccui" creationdate="20190625T030643Z">
        <seg>val minMaxTempPerWindow: DataStream[MinMaxTemp] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val minTempPerWindow: DataStream[(String, Double)] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002443Z" creationid="xccui" creationdate="20190624T002443Z">
        <seg>val minTempPerWindow: DataStream[(String, Double)] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val mod = (highTempCnt % 10).toInt</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062731Z" creationid="xccui" creationdate="20190701T062731Z">
        <seg>val mod = (highTempCnt % 10).toInt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val monitoredReadings: DataStream[SensorReading] = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022715Z" creationid="xccui" creationdate="20190622T022715Z">
        <seg>val monitoredReadings: DataStream[SensorReading] = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val myProducer = new FlinkKafkaProducer[String]( "localhost:9092",</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T144733Z" creationid="xingcan" creationdate="20190709T144733Z">
        <seg>val myProducer = new FlinkKafkaProducer[String]( "localhost:9092",</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val newTimer = ctx.timestamp() + (3600 * 1000)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210548Z" creationid="xccui" creationdate="20190704T210548Z">
        <seg>val newTimer = ctx.timestamp() + (3600 * 1000)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val numSensors = 5</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040043Z" creationid="xccui" creationdate="20190707T040043Z">
        <seg>val numSensors = 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val numbers: DataStream[(Int)] = ... numbers.partitionCustom(myPartitioner, 0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050629Z" creationid="xccui" creationdate="20190616T050629Z">
        <seg>val numbers: DataStream[(Int)] = ... numbers.partitionCustom(myPartitioner, 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val numbers: DataStream[Long] = env.fromElements(1L, 2L, 3L, 4L) numbers.map( n =&gt; n + 1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070457Z" creationid="xccui" creationdate="20190616T070457Z">
        <seg>val numbers: DataStream[Long] = env.fromElements(1L, 2L, 3L, 4L) numbers.map( n =&gt; n + 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val one: DataStream[(Int, Long)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053600Z" creationid="xccui" creationdate="20190615T053600Z">
        <seg>val one: DataStream[(Int, Long)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val opCntDescriptor = new ListStateDescriptor[Long]("opCnt", classOf[Long]) opCntState = initContext.getOperatorStateStore.getListState(opCntDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163320Z" creationid="xccui" creationdate="20190702T163320Z">
        <seg>val opCntDescriptor = new ListStateDescriptor[Long]("opCnt", classOf[Long]) opCntState = initContext.getOperatorStateStore.getListState(opCntDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val output = stream.assignTimestampsAndWatermarks(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052857Z" creationid="xccui" creationdate="20190620T052857Z">
        <seg>val output = stream.assignTimestampsAndWatermarks(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val parisStream: DataStream[SensorReading] = ... val tokyoStream: DataStream[SensorReading] = ... val rioStream: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064847Z" creationid="xccui" creationdate="20190614T064847Z">
        <seg>val parisStream: DataStream[SensorReading] = ... val tokyoStream: DataStream[SensorReading] = ... val rioStream: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val persons: DataStream[Person] = ... persons.keyBy("address.zip") // key by nested POJO field</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050133Z" creationid="xccui" creationdate="20190618T050133Z">
        <seg>val persons: DataStream[Person] = ... persons.keyBy("address.zip") // 以嵌套的POJO字段为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val persons: DataStream[Person] = env.fromElements(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041128Z" creationid="xccui" creationdate="20190617T041128Z">
        <seg>val persons: DataStream[Person] = env.fromElements(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val prevTemp = lastTemp.value()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071431Z" creationid="xccui" creationdate="20190621T071431Z">
        <seg>val prevTemp = lastTemp.value()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val properties = new Properties() properties.setProperty("bootstrap.servers", "localhost:9092") properties.setProperty("group.id", "test")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T212401Z" creationid="xccui" creationdate="20190708T212401Z">
        <seg>val properties = new Properties() properties.setProperty("bootstrap.servers", "localhost:9092") properties.setProperty("group.id", "test")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val proxyHost = "127.0.0.1"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035917Z" creationid="xccui" creationdate="20190707T035917Z">
        <seg>val proxyHost = "127.0.0.1"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val proxyPort = 9069</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T035921Z" creationid="xccui" creationdate="20190707T035921Z">
        <seg>val proxyPort = 9069</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val query = conn.createStatement()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211042Z" creationid="xccui" creationdate="20190716T211042Z">
        <seg>val query = conn.createStatement()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val r = scala.util.Random</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050636Z" creationid="xccui" creationdate="20190616T050636Z">
        <seg>val r = scala.util.Random</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[(String, Float)] = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210802Z" creationid="xccui" creationdate="20190711T210802Z">
        <seg>val readings: DataStream[(String, Float)] = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050713Z" creationid="xccui" creationdate="20190613T050713Z">
        <seg>val readings: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[SensorReading] = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154914Z" creationid="xingcan" creationdate="20190628T154914Z">
        <seg>val readings: DataStream[SensorReading] = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[SensorReading] = env</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044638Z" creationid="xccui" creationdate="20190620T044638Z">
        <seg>val readings: DataStream[SensorReading] = env</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[SensorReadings] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053208Z" creationid="xccui" creationdate="20190613T053208Z">
        <seg>val readings: DataStream[SensorReadings] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val refreshInterval = 10000</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040055Z" creationid="xccui" creationdate="20190707T040055Z">
        <seg>val refreshInterval = 10000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val remoteEnv = StreamExecutionEnvironment.createRemoteEnvironment( "host",</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051333Z" creationid="xccui" creationdate="20190612T051333Z">
        <seg>val remoteEnv = StreamExecutionEnvironment.createRemoteEnvironment( "host",</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val result = query.executeQuery(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211101Z" creationid="xccui" creationdate="20190716T211101Z">
        <seg>val result = query.executeQuery(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val result: = env.addSource(new CustomSource)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061619Z" creationid="xccui" creationdate="20190616T061619Z">
        <seg>val result: = env.addSource(new CustomSource)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val result: DataStream[Y] = input</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203559Z" creationid="xccui" creationdate="20190730T203559Z">
        <seg>val result: DataStream[Y] = input</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val resultStream: DataStream[(Int, Int, Int)] = inputStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054459Z" creationid="xccui" creationdate="20190614T054459Z">
        <seg>val resultStream: DataStream[(Int, Int, Int)] = inputStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val resultStream: DataStream[(String, List[String])] = inputStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062227Z" creationid="xccui" creationdate="20190614T062227Z">
        <seg>val resultStream: DataStream[(String, List[String])] = inputStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val rocksBackend = new RocksDBStateBackend("file:///tmp/ckp", true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025106Z" creationid="xccui" creationdate="20190801T025106Z">
        <seg>val rocksBackend = new RocksDBStateBackend("file:///tmp/ckp", true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val room = if (result.next()) { result.getString(1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211554Z" creationid="xccui" creationdate="20190716T211554Z">
        <seg>val room = if (result.next()) { result.getString(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val room: Future[String] = Future {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T210223Z" creationid="xccui" creationdate="20190716T210223Z">
        <seg>val room: Future[String] = Future {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sbConfig = new Configuration() sbConfig.setBoolean("state.backend.async", true) sbConfig.setString("state.savepoints.dir", "file:///tmp/svp")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T030043Z" creationid="xccui" creationdate="20190801T030043Z">
        <seg>val sbConfig = new Configuration() sbConfig.setBoolean("state.backend.async", true) sbConfig.setString("state.savepoints.dir", "file:///tmp/svp")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val second: DataStream[(Int, String)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T051658Z" creationid="xccui" creationdate="20190615T051658Z">
        <seg>val second: DataStream[(Int, String)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val second: DataStream[String] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040832Z" creationid="xccui" creationdate="20190615T040832Z">
        <seg>val second: DataStream[String] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensor = reading.id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T210100Z" creationid="xccui" creationdate="20190716T210100Z">
        <seg>val sensor = reading.id</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] =</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054743Z" creationid="xccui" creationdate="20190612T054743Z">
        <seg>val sensorData: DataStream[SensorReading] =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051745Z" creationid="xccui" creationdate="20190618T051745Z">
        <seg>val sensorData: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062019Z" creationid="xccui" creationdate="20190630T062019Z">
        <seg>val sensorData: DataStream[SensorReading] = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] = env</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042047Z" creationid="xccui" creationdate="20190612T042047Z">
        <seg>val sensorData: DataStream[SensorReading] = env</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] = env.addSource(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T072817Z" creationid="xccui" creationdate="20190619T072817Z">
        <seg>val sensorData: DataStream[SensorReading] = env.addSource(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorIds: DataStream[String] = readings.map(new MyMapFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050717Z" creationid="xccui" creationdate="20190613T050717Z">
        <seg>val sensorIds: DataStream[String] = readings.map(new MyMapFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorIds: DataStream[String] = readings.map(r =&gt; r.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T051126Z" creationid="xccui" creationdate="20190613T051126Z">
        <seg>val sensorIds: DataStream[String] = readings.map(r =&gt; r.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorLocations: DataStream[(String, String)] = AsyncDataStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T201720Z" creationid="xccui" creationdate="20190716T201720Z">
        <seg>val sensorLocations: DataStream[(String, String)] = AsyncDataStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorStream: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T042637Z" creationid="xccui" creationdate="20190618T042637Z">
        <seg>val sensorStream: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorThreshold: Double = thresholds.get(reading.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042746Z" creationid="xccui" creationdate="20190702T042746Z">
        <seg>val sensorThreshold: Double = thresholds.get(reading.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sentences: DataStream[String] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005237Z" creationid="xccui" creationdate="20190613T005237Z">
        <seg>val sentences: DataStream[String] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sessionWindows = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061438Z" creationid="xccui" creationdate="20190623T061438Z">
        <seg>val sessionWindows = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sink: StreamingFileSink[String] = StreamingFileSink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190710T205911Z" creationid="xccui" creationdate="20190710T205911Z">
        <seg>val sink: StreamingFileSink[String] = StreamingFileSink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sinkBuilder: CassandraSinkBuilder[(String, Float)] = CassandraSink.addSink(readings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210806Z" creationid="xccui" creationdate="20190711T210806Z">
        <seg>val sinkBuilder: CassandraSinkBuilder[(String, Float)] = CassandraSink.addSink(readings)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val slidingAvgTemp = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060024Z" creationid="xccui" creationdate="20190623T060024Z">
        <seg>val slidingAvgTemp = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val small: DataStream[(Int, String)] = splitted.select("small")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064112Z" creationid="xccui" creationdate="20190615T064112Z">
        <seg>val small: DataStream[(Int, String)] = splitted.select("small")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val splitted: SplitStream[(Int, String)] = inputStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064101Z" creationid="xccui" creationdate="20190615T064101Z">
        <seg>val splitted: SplitStream[(Int, String)] = inputStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val startTime = ts - (ts % windowSize)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044101Z" creationid="xccui" creationdate="20190626T044101Z">
        <seg>val startTime = ts - (ts % windowSize)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val stateBackend: StateBackend = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T022107Z" creationid="xccui" creationdate="20190801T022107Z">
        <seg>val stateBackend: StateBackend = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val stream: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051957Z" creationid="xccui" creationdate="20190620T051957Z">
        <seg>val stream: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val stream: DataStream[String] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190709T144730Z" creationid="xingcan" creationdate="20190709T144730Z">
        <seg>val stream: DataStream[String] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val stream: DataStream[String] = env.addSource(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190708T212405Z" creationid="xccui" creationdate="20190708T212405Z">
        <seg>val stream: DataStream[String] = env.addSource(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val stringType: TypeInformation[String] = Types.STRING</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053818Z" creationid="xccui" creationdate="20190617T053818Z">
        <seg>val stringType: TypeInformation[String] = Types.STRING</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 1000))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200824Z" creationid="xccui" creationdate="20190626T200824Z">
        <seg>val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 1000))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 1000)) ctx.registerEventTimeTimer(t)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200552Z" creationid="xccui" creationdate="20190626T200552Z">
        <seg>val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 1000)) ctx.registerEventTimeTimer(t)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tFilePath = Paths.get(s"$tempPath/$transaction")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042023Z" creationid="xccui" creationdate="20190716T042023Z">
        <seg>val tFilePath = Paths.get(s"$tempPath/$transaction")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tFilePath = Paths.get(s"$tempPath/$transaction") if (Files.exists(tFilePath)) { Files.delete(tFilePath)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T042208Z" creationid="xccui" creationdate="20190716T042208Z">
        <seg>val tFilePath = Paths.get(s"$tempPath/$transaction") if (Files.exists(tFilePath)) { Files.delete(tFilePath)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tFilePath = Paths.get(s"$tempPath/$transactionFile") Files.createFile(tFilePath)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041431Z" creationid="xccui" creationdate="20190716T041431Z">
        <seg>val tFilePath = Paths.get(s"$tempPath/$transactionFile") Files.createFile(tFilePath)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val taskIdx = this.getRuntimeContext.getIndexOfThisSubtask val transactionFile = s"$timeNow-$taskIdx"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041414Z" creationid="xccui" creationdate="20190716T041414Z">
        <seg>val taskIdx = this.getRuntimeContext.getIndexOfThisSubtask val transactionFile = s"$timeNow-$taskIdx"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tempDiff = (reading.temperature - lastTemp).abs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064449Z" creationid="xccui" creationdate="20190630T064449Z">
        <seg>val tempDiff = (reading.temperature - lastTemp).abs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val temps = vals.map(_.temperature)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031930Z" creationid="xccui" creationdate="20190625T031930Z">
        <seg>val temps = vals.map(_.temperature)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tenSecsMaxTemps: DataStream[(String, Double)] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190706T062122Z" creationid="xccui" creationdate="20190706T062122Z">
        <seg>val tenSecsMaxTemps: DataStream[(String, Double)] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val thresholds = ctx.getBroadcastState(thresholdStateDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042554Z" creationid="xccui" creationdate="20190702T042554Z">
        <seg>val thresholds = ctx.getBroadcastState(thresholdStateDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val thresholds = readOnlyCtx.getBroadcastState(thresholdStateDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042707Z" creationid="xccui" creationdate="20190702T042707Z">
        <seg>val thresholds = readOnlyCtx.getBroadcastState(thresholdStateDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val thresholds: DataStream[ThresholdUpdate] = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024307Z" creationid="xccui" creationdate="20190702T024307Z">
        <seg>val thresholds: DataStream[ThresholdUpdate] = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val timeNow = LocalDateTime.now(ZoneId.of("UTC"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041406Z" creationid="xccui" creationdate="20190716T041406Z">
        <seg>val timeNow = LocalDateTime.now(ZoneId.of("UTC"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val timerTimestamp = ctx.timerService().currentProcessingTime() + switch._2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032337Z" creationid="xccui" creationdate="20190622T032337Z">
        <seg>val timerTimestamp = ctx.timerService().currentProcessingTime() + switch._2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val timerTs = ctx.timerService().currentProcessingTime() + 1000 ctx.timerService().registerProcessingTimeTimer(timerTs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071711Z" creationid="xccui" creationdate="20190621T071711Z">
        <seg>val timerTs = ctx.timerService().currentProcessingTime() + 1000 ctx.timerService().registerProcessingTimeTimer(timerTs)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tupleType: TypeInformation[(Int, Long)] = Types.TUPLE[(Int, Long)]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053851Z" creationid="xccui" creationdate="20190617T053851Z">
        <seg>val tupleType: TypeInformation[(Int, Long)] = Types.TUPLE[(Int, Long)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tweets: DataStream[String] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055841Z" creationid="xccui" creationdate="20190618T055841Z">
        <seg>val tweets: DataStream[String] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tweets: DataStream[String] = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054638Z" creationid="xccui" creationdate="20190618T054638Z">
        <seg>val tweets: DataStream[String] = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val two: DataStream[(Int, String)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050041Z" creationid="xccui" creationdate="20190615T050041Z">
        <seg>val two: DataStream[(Int, String)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val warnings = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T070901Z" creationid="xccui" creationdate="20190621T070901Z">
        <seg>val warnings = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val windowEnd = ctx.window.getEnd</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031934Z" creationid="xccui" creationdate="20190625T031934Z">
        <seg>val windowEnd = ctx.window.getEnd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val windowSize: Long = 30 * 1000L</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042653Z" creationid="xccui" creationdate="20190626T042653Z">
        <seg>val windowSize: Long = 30 * 1000L</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val withTimestampsAndWatermarks = stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052001Z" creationid="xccui" creationdate="20190620T052001Z">
        <seg>val withTimestampsAndWatermarks = stream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val words: DataStream[String] = sentences</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005233Z" creationid="xccui" creationdate="20190613T005233Z">
        <seg>val words: DataStream[String] = sentences</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vals: Iterable[SensorReading],</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031924Z" creationid="xccui" creationdate="20190625T031924Z">
        <seg>vals: Iterable[SensorReading],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>value observed so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053815Z" creationid="xccui" creationdate="20190614T053815Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011820Z" creationid="xccui" creationdate="20190606T011820Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>value.toString</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190807T034124Z" creationid="xccui" creationdate="20190807T034124Z">
        <seg>value.toString</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>value: flink-master</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190720T025045Z" creationid="xccui" creationdate="20190720T025045Z">
        <seg>value: flink-master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T065725Z" creationid="xccui" creationdate="20190630T065725Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var cnt: Long = -1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152445Z" creationid="xccui" creationdate="20190712T152445Z">
        <seg>var cnt: Long = -1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var conn: Connection = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045104Z" creationid="xccui" creationdate="20190714T045104Z">
        <seg>var conn: Connection = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var insertStmt: PreparedStatement = _ var updateStmt: PreparedStatement = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T045108Z" creationid="xccui" creationdate="20190714T045108Z">
        <seg>var insertStmt: PreparedStatement = _ var updateStmt: PreparedStatement = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var isRunning: Boolean = true</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152424Z" creationid="xccui" creationdate="20190712T152424Z">
        <seg>var isRunning: Boolean = true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var isRunning: Boolean = true var cnt: Long = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T033927Z" creationid="xccui" creationdate="20190713T033927Z">
        <seg>var isRunning: Boolean = true var cnt: Long = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var keyedCntState: ValueState[Long] = _ var opCntState: ListState[Long] = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162238Z" creationid="xccui" creationdate="20190702T162238Z">
        <seg>var keyedCntState: ValueState[Long] = _ var opCntState: ListState[Long] = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var maxTs: Long = Long.MinValue // the maximum observed timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051105Z" creationid="xccui" creationdate="20190620T051105Z">
        <seg>var maxTs: Long = Long.MinValue // 观察到的最大时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var offsetState: ListState[Long] = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T033930Z" creationid="xccui" creationdate="20190713T033930Z">
        <seg>var offsetState: ListState[Long] = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var opHighTempCnt: Long = 0</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162235Z" creationid="xccui" creationdate="20190702T162235Z">
        <seg>var opHighTempCnt: Long = 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var socket: Socket = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024050Z" creationid="xccui" creationdate="20190714T024050Z">
        <seg>var socket: Socket = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var subTaskIndex = 0</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034249Z" creationid="xccui" creationdate="20190619T034249Z">
        <seg>var subTaskIndex = 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var transactionWriter: BufferedWriter = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T041125Z" creationid="xccui" creationdate="20190716T041125Z">
        <seg>var transactionWriter: BufferedWriter = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var writer: PrintStream = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190714T024106Z" creationid="xccui" creationdate="20190714T024106Z">
        <seg>var writer: PrintStream = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vi</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040256Z" creationid="xccui" creationdate="20190418T040256Z">
        <seg>vi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040515Z" creationid="xccui" creationdate="20190418T040515Z">
        <seg>vii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>viii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040559Z" creationid="xccui" creationdate="20190418T040559Z">
        <seg>viii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>viii | Table of Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130320Z" creationid="xccui" creationdate="20190605T130320Z">
        <seg>viii | 目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void cancel()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T150859Z" creationid="xccui" creationdate="20190712T150859Z">
        <seg>void cancel()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void deleteEventTimeTimer(long time);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192721Z" creationid="xccui" creationdate="20190626T192721Z">
        <seg>void deleteEventTimeTimer(long time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void deleteProcessingTimeTimer(long time);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192708Z" creationid="xccui" creationdate="20190626T192708Z">
        <seg>void deleteProcessingTimeTimer(long time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void evictAfter( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201926Z" creationid="xccui" creationdate="20190627T201926Z">
        <seg>void evictAfter( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void evictBefore( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201903Z" creationid="xccui" creationdate="20190627T201903Z">
        <seg>void evictBefore( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void invoke(IN value, Context ctx)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T212925Z" creationid="xccui" creationdate="20190713T212925Z">
        <seg>void invoke(IN value, Context ctx)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void mergePartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193115Z" creationid="xccui" creationdate="20190626T193115Z">
        <seg>void mergePartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void process(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010515Z" creationid="xccui" creationdate="20190624T010515Z">
        <seg>void process(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void registerEventTimeTimer(long time);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192652Z" creationid="xccui" creationdate="20190626T192652Z">
        <seg>void registerEventTimeTimer(long time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void registerProcessingTimeTimer(long time);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192631Z" creationid="xccui" creationdate="20190626T192631Z">
        <seg>void registerProcessingTimeTimer(long time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void run(SourceContext&lt;T&gt; ctx)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T150856Z" creationid="xccui" creationdate="20190712T150856Z">
        <seg>void run(SourceContext&lt;T&gt; ctx)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wait until they bring some from the supply room.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234106Z" creationid="xccui" creationdate="20190605T234106Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>watermarks and checkpoint barriers remain aligned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T202434Z" creationid="xccui" creationdate="20190716T202434Z">
        <seg>而unorderWait()中的异步算子只能让水位线和检查点分隔符保持对齐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>way to perform a lightweight load rebalance when the number of sender and receiver tasks is not the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T065356Z" creationid="xccui" creationdate="20190616T043851Z">
        <seg>本质上看，重调分区策略为发送端和接收端任务不等的情况提供了一种轻量级的负载均衡方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wget https://github.com/streaming-with-flink/examples-scala/archive/master.zip</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040424Z" creationid="xccui" creationdate="20190611T040424Z">
        <seg>wget https://github.com/streaming-with-flink/examples-scala/archive/master.zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>when to time out the asynchronous call for a record and how many concurrent requests to start.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T203636Z" creationid="xccui" creationdate="20190716T202614Z">
        <seg>其他参数包括异步调用的超时时间以及请求的并发上限等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whether a 2PC sink function provides such guarantees or not depends on the imple‐ mentation details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T195116Z" creationid="xccui" creationdate="20190715T194754Z">
        <seg>但这种2PC数据汇函数对于保障的支持与否并非取决于它的实现细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which exposes the current watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190803T031730Z" creationid="xccui" creationdate="20190803T031730Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is obtained from the SourceContext.getCheckpointLock() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T174317Z" creationid="xccui" creationdate="20190712T174317Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is used in the entry point of the container to adjust Flink’s configuration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190718T035331Z" creationid="xccui" creationdate="20190718T035331Z">
        <seg>该变量会以ENTRYPOINT的方式传给容器，用于调整Flink的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (isRunning &amp;&amp; cnt &lt; Long.MaxValue) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T033933Z" creationid="xccui" creationdate="20190713T033933Z">
        <seg>while (isRunning &amp;&amp; cnt &lt; Long.MaxValue) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (isRunning &amp;&amp; cnt &lt; Long.MaxValue) { cnt += 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T152448Z" creationid="xccui" creationdate="20190712T152448Z">
        <seg>while (isRunning &amp;&amp; cnt &lt; Long.MaxValue) { cnt += 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while (true) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T040241Z" creationid="xccui" creationdate="20190707T040241Z">
        <seg>while (true) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will move all data to a single task such that the operator would be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190811T063110Z" creationid="xccui" creationdate="20190621T062117Z">
        <seg>注意，该操作会使所有数据发送到单个任务上，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>window size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T062149Z" creationid="xccui" creationdate="20190623T062149Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>window to perform more complex computations, such as computing the median of values in a window or the most frequently occurring value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190812T040308Z" creationid="xccui" creationdate="20190624T005940Z">
        <seg>然而有些时候我们需要访问窗口内的所有元素来执行一些更加复杂的计算，例如计算窗口内数据的中值或出现频率最高的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>window using the timeWindow(size) method, which is a shortcut for either window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T053640Z" creationid="xccui" creationdate="20190623T051438Z">
        <seg>该方法是对window.(TumblingEventTimeWindows.of(size))或window.(TumblingProcessing TimeWindows.of(size))的简写，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>window: TimeWindow,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200233Z" creationid="xccui" creationdate="20190626T200233Z">
        <seg>window: TimeWindow,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>windows is defined by a set of policies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012709Z" creationid="xccui" creationdate="20190606T012709Z">
        <seg>窗口的行为是由一系列策略定义的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>windows of 5 seconds:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053745Z" creationid="xccui" creationdate="20190612T053745Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>window’s start and end timestamp and the minimum and maximum temperature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030535Z" creationid="xccui" creationdate="20190625T030535Z">
        <seg>其中包含了窗口的开始、结束时间以及窗口内的最低、最高温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with Flink’s checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T072256Z" creationid="xccui" creationdate="20190702T072256Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with ListCheckpointed[java.lang.Long] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052323Z" creationid="xccui" creationdate="20190701T052323Z">
        <seg>with ListCheckpointed[java.lang.Long] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with an asynchronous callback.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T205851Z" creationid="xccui" creationdate="20190716T205851Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with savepoint to hdfs:///xxx:50070/savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190726T184659Z" creationid="xccui" creationdate="20190726T184659Z">
        <seg>with savepoint to hdfs:///xxx:50070/savepoints.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with the -s option:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T040213Z" creationid="xccui" creationdate="20190727T040213Z">
        <seg>with the -s option:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with the same key access the same state and thus can be processed together.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190712T060813Z" creationid="xccui" creationdate="20190614T044414Z">
        <seg>这意味着所有键值相同的事件可以访问相同的状态，因此它们可以被一并处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>work buffers (by default 64 MB and 1 GB, respectively) to set absolute limits for the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190724T041200Z" creationid="xccui" creationdate="20190724T041200Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writes all following records to the sink system in the context of the current trans‐ action.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190715T035939Z" creationid="xccui" creationdate="20190715T035939Z">
        <seg>并以当前事务为上下文将所有后续记录写入数据汇系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x | Preface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130336Z" creationid="xccui" creationdate="20190605T130328Z">
        <seg>x | 序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>xii | Preface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130350Z" creationid="xccui" creationdate="20190605T130350Z">
        <seg>xii | 序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>yarn-cluster, the client submits the job to the YARN cluster as identified by the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T012419Z" creationid="xccui" creationdate="20190719T012419Z">
        <seg>如果加上关键字"yarn-cluster"，客户端会将作业提交到由Hadoop配置所指定的YARN集群上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>yarn.application-attempts: 4</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190721T052919Z" creationid="xccui" creationdate="20190721T052919Z">
        <seg>yarn.application-attempts: 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you can automatically set it with the following command if the hadoop command is accessible: export HADOOP_CLASSPATH=`hadoop classpath`.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T030228Z" creationid="xccui" creationdate="20190722T025858Z">
        <seg>则可以在能访问hadoop命令的前提下，通过以下指令自动设置该变量：export HADOOP_CLASSPATH=`hadoop classpath`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you can call its disableChaining() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190730T203204Z" creationid="xccui" creationdate="20190730T203204Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you do not manually assign operator identifiers using uid().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190727T050346Z" creationid="xccui" creationdate="20190727T050346Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you have to create a new backend object by passing a Configuration object to your</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190801T025804Z" creationid="xccui" creationdate="20190801T025638Z">
        <seg>为此，你必须在创建状态后端对象时将一个Configuration对象传给它</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you still need to generate watermarks and should apply an AssignerWithPeriodicWa termark or an AssignerWithPunctuatedWatermark that forwards the previously assigned Kafka timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190709T031932Z" creationid="xccui" creationdate="20190709T031932Z">
        <seg>这种情况下，你仍然需要生成水位线，并利用AssignerWithPeriodicWatermark或AssignerWithPunctuatedWatermark来转发之前分配的Kafka时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T042107Z" creationid="xccui" creationdate="20190729T042107Z">
        <seg>{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{"request-id":"217a4ffe935ceac2c281bdded76729d6"}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T200908Z" creationid="xccui" creationdate="20190729T200908Z">
        <seg>{"request-id":"217a4ffe935ceac2c281bdded76729d6"}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{"request-id":"39584c2f742c3594776653f27833e3eb"}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T201805Z" creationid="xccui" creationdate="20190729T201805Z">
        <seg>{"request-id":"39584c2f742c3594776653f27833e3eb"}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{"request-id":"ebde90836b8b9dc2da90e9e7655f4179"}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T181408Z" creationid="xccui" creationdate="20190729T181408Z">
        <seg>{"request-id":"ebde90836b8b9dc2da90e9e7655f4179"}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{"status":{"id":"COMPLETED"}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T193630Z" creationid="xccui" creationdate="20190729T193630Z">
        <seg>{"status":{"id":"COMPLETED"}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052353Z" creationid="xccui" creationdate="20190416T052353Z">
        <seg>|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>| 81</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045202Z" creationid="xccui" creationdate="20190619T045202Z">
        <seg>| 81</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042813Z" creationid="xccui" creationdate="20190612T042813Z">
        <seg>}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} )</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042307Z" creationid="xccui" creationdate="20190612T042307Z">
        <seg>} )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else if (r.temperature &gt; prevTemp &amp;&amp; curTimerTimestamp == 0) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071627Z" creationid="xccui" creationdate="20190621T071627Z">
        <seg>} else if (r.temperature &gt; prevTemp &amp;&amp; curTimerTimestamp == 0) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054844Z" creationid="xccui" creationdate="20190620T054844Z">
        <seg>} else {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else { "UNKNOWN ROOM"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211600Z" creationid="xccui" creationdate="20190716T211600Z">
        <seg>} else { "UNKNOWN ROOM"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else { it.iterator().next()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190713T034530Z" creationid="xccui" creationdate="20190713T034530Z">
        <seg>} else { it.iterator().next()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else { out.collect(r)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155940Z" creationid="xingcan" creationdate="20190628T155940Z">
        <seg>} else { out.collect(r)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}(cachingPoolExecCtx)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211856Z" creationid="xccui" creationdate="20190716T211856Z">
        <seg>}(cachingPoolExecCtx)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}(directExecCtx)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190716T211958Z" creationid="xccui" creationdate="20190716T211958Z">
        <seg>}(directExecCtx)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>})</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054242Z" creationid="xccui" creationdate="20190618T054242Z">
        <seg>})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>},</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043616Z" creationid="xccui" creationdate="20190625T043616Z">
        <seg>},</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>—hdfs://nnode1:50010 and hdfs://nnode2:50010 are separately tracked.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T050127Z" creationid="xccui" creationdate="20190722T045903Z">
        <seg>例如，hdfs://nnode1:50010和hdfs://nnode2:50010会分别追踪。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Checkpoint‐ ing and State Backends” on page 243 describes how you can configure a default state backend of a Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190815T034717Z" creationid="xccui" creationdate="20190801T021953Z">
        <seg>我们第243页"检查点和状态后端"一节介绍了如何为Flink集群配置默认状态后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Integration with Hadoop Components” on page 236 describes the required configuration in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190719T012023Z" creationid="xccui" creationdate="20190719T012023Z">
        <seg>配置详情请见第236页"集成Hadoop组件"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Integration with Hadoop Components” on page 236 explains how to ensure Hadoop depen‐ dencies are loaded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190722T042256Z" creationid="xccui" creationdate="20190722T042256Z">
        <seg>详细内容请参阅"集成Hadoop组件"一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Managing Applications with the Command-Line Client” on page 247 provides more details about some of the operations, such as upgrading or scaling an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190729T043014Z" creationid="xccui" creationdate="20190729T043014Z">
        <seg>第247页"通过命令行客户端管理应用"一节提供了有关某些操作的更多详情，例如升级应用或对应用进行扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Scaling Stateful Operators” on page 56 discusses key groups and how keyed state is scaled out and in.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190707T053126Z" creationid="xccui" creationdate="20190703T024744Z">
        <seg>第56页"状态化算子扩缩容"一节已经对键值组和键值状态的伸缩规则进行了介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“example” and a table “sensors” in that keyspace.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190711T210017Z" creationid="xccui" creationdate="20190711T210017Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>│</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040608Z" creationid="xccui" creationdate="20190611T040608Z">
        <seg>│</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040619Z" creationid="xccui" creationdate="20190611T040619Z">
        <seg>└── ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── AverageSensorReadings.scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040611Z" creationid="xccui" creationdate="20190611T040611Z">
        <seg>└── AverageSensorReadings.scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── StreamingJob.scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005810Z" creationid="xccui" creationdate="20190612T005810Z">
        <seg>└── StreamingJob.scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── apache</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005751Z" creationid="xccui" creationdate="20190612T005751Z">
        <seg>└── apache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005756Z" creationid="xccui" creationdate="20190612T005756Z">
        <seg>└── flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── github</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040556Z" creationid="xccui" creationdate="20190611T040556Z">
        <seg>└── github</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── io</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040552Z" creationid="xccui" creationdate="20190611T040552Z">
        <seg>└── io</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── log4j.properties</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005730Z" creationid="xccui" creationdate="20190612T005730Z">
        <seg>└── log4j.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── main</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040540Z" creationid="xccui" creationdate="20190611T040540Z">
        <seg>└── main</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── org</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005748Z" creationid="xccui" creationdate="20190612T005748Z">
        <seg>└── org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── quickstart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005800Z" creationid="xccui" creationdate="20190612T005800Z">
        <seg>└── quickstart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040543Z" creationid="xccui" creationdate="20190611T040543Z">
        <seg>└── scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── streamingwithflink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040559Z" creationid="xccui" creationdate="20190611T040559Z">
        <seg>└── streamingwithflink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── util</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040628Z" creationid="xccui" creationdate="20190611T040628Z">
        <seg>└── util</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040621Z" creationid="xccui" creationdate="20190611T040621Z">
        <seg>├── ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── BatchJob.scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005806Z" creationid="xccui" creationdate="20190612T005806Z">
        <seg>├── BatchJob.scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── chapter1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040604Z" creationid="xccui" creationdate="20190611T040604Z">
        <seg>├── chapter1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── chapter5</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040614Z" creationid="xccui" creationdate="20190611T040614Z">
        <seg>├── chapter5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── resources</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005721Z" creationid="xccui" creationdate="20190612T005721Z">
        <seg>├── resources</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
