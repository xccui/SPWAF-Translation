<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.1.5_3_10490" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>"path/to/jarFile.jar") // JAR file to ship to the JobManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045648Z" creationid="xccui" creationdate="20190612T045648Z">
        <seg>"path/to/jarFile.jar") // 需要传输到JobManager的JAR包</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/flink run \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040000Z" creationid="xccui" creationdate="20190329T040000Z">
        <seg>$ ./bin/flink run \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/start-cluster.sh</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045745Z" creationid="xccui" creationdate="20190329T045745Z">
        <seg>$ ./bin/start-cluster.sh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/start-cluster.sh Starting cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123207Z" creationid="xccui" creationdate="20190605T123146Z">
        <seg>$ ./bin/start-cluster.sh Starting cluster.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/stop-cluster.sh</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041911Z" creationid="xccui" creationdate="20190329T041911Z">
        <seg>$ ./bin/stop-cluster.sh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ cd flink-1.7.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025034Z" creationid="xccui" creationdate="20190329T025034Z">
        <seg>$ cd flink-1.7.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ tail -f ./log/flink-&lt;user&gt;-taskexecutor-&lt;n&gt;-&lt;hostname&gt;.out</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041713Z" creationid="xccui" creationdate="20190329T041713Z">
        <seg>$ tail -f ./log/flink-&lt;user&gt;-taskexecutor-&lt;n&gt;-&lt;hostname&gt;.out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ tar xvfz flink-1.7.1-bin-scala_2.12.tgz</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024954Z" creationid="xccui" creationdate="20190329T024954Z">
        <seg>$ tar xvfz flink-1.7.1-bin-scala_2.12.tgz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ wget https://streaming-with-flink.github.io/\ examples/download/examples-scala.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123520Z" creationid="xccui" creationdate="20190605T123520Z">
        <seg>$ wget https://streaming-with-flink.github.io/\ examples/download/examples-scala.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ wget https://streaming-with-flink.github.io/examples/download/examples-scala.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035706Z" creationid="xccui" creationdate="20190329T035706Z">
        <seg>$ wget https://streaming-with-flink.github.io/examples/download/examples-scala.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DarchetypeArtifactId=flink-quickstart-scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004831Z" creationid="xccui" creationdate="20190612T004831Z">
        <seg>-DarchetypeArtifactId=flink-quickstart-scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DarchetypeGroupId=org.apache.flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004826Z" creationid="xccui" creationdate="20190612T004826Z">
        <seg>-DarchetypeGroupId=org.apache.flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DarchetypeVersion=1.7.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004835Z" creationid="xccui" creationdate="20190612T004835Z">
        <seg>-DarchetypeVersion=1.7.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DartifactId=flink-scala-project</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004842Z" creationid="xccui" creationdate="20190612T004842Z">
        <seg>-DartifactId=flink-scala-project</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DgroupId=org.apache.flink.quickstart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004839Z" creationid="xccui" creationdate="20190612T004839Z">
        <seg>-DgroupId=org.apache.flink.quickstart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DinteractiveMode=false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004854Z" creationid="xccui" creationdate="20190612T004854Z">
        <seg>-DinteractiveMode=false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Dpackage=org.apache.flink.quickstart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004850Z" creationid="xccui" creationdate="20190612T004850Z">
        <seg>-Dpackage=org.apache.flink.quickstart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Dversion=0.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004846Z" creationid="xccui" creationdate="20190612T004846Z">
        <seg>-Dversion=0.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-c io.github.streamingwithflink.chapter1.AverageSensorReadings \ examples-scala.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040003Z" creationid="xccui" creationdate="20190329T040003Z">
        <seg>-c io.github.streamingwithflink.chapter1.AverageSensorReadings \ examples-scala.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T064032Z" creationid="xccui" creationdate="20190301T040155Z">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.&lt;t0/&gt; &lt;t1/&gt;ix 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035437Z" creationid="xccui" creationdate="20190418T035437Z">
        <seg>.&lt;t0/&gt; &lt;t1/&gt;ix 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.addSource(new SensorSource)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042142Z" creationid="xccui" creationdate="20190612T042142Z">
        <seg>.addSource(new SensorSource)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.apply(new TemperatureAverager)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042735Z" creationid="xccui" creationdate="20190612T042735Z">
        <seg>.apply(new TemperatureAverager)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.assignTimestampsAndWatermarks(new SensorTimeAssigner)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042218Z" creationid="xccui" creationdate="20190612T042218Z">
        <seg>.assignTimestampsAndWatermarks(new SensorTimeAssigner)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.filter( r =&gt; r.temperature &gt;= 25 )</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053216Z" creationid="xccui" creationdate="20190613T053216Z">
        <seg>.filter( r =&gt; r.temperature &gt;= 25 )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.flatMap(id =&gt; id.split(" "))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005229Z" creationid="xccui" creationdate="20190613T005229Z">
        <seg>.flatMap(id =&gt; id.split(" "))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(0) // key on first field of the tuple</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054716Z" creationid="xccui" creationdate="20190614T054452Z">
        <seg>.keyBy(0) // 以元组第1个字段为键值进行分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(_.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042408Z" creationid="xccui" creationdate="20190612T042408Z">
        <seg>.keyBy(_.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(r =&gt; r.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051709Z" creationid="xccui" creationdate="20190614T051709Z">
        <seg>.keyBy(r =&gt; r.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map( r =&gt; {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042255Z" creationid="xccui" creationdate="20190612T042255Z">
        <seg>.map( r =&gt; {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.sum(1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054503Z" creationid="xccui" creationdate="20190614T054503Z">
        <seg>.sum(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.seconds(5))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042713Z" creationid="xccui" creationdate="20190612T042713Z">
        <seg>.timeWindow(Time.seconds(5))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// O: the type of output elements FlatMapFunction[T, O]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T061027Z" creationid="xccui" creationdate="20190613T061027Z">
        <seg>// O：输出元素的类型 FlatMapFunction[T, O]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// O: the type of output elements MapFunction[T, O]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050340Z" creationid="xccui" creationdate="20190613T050340Z">
        <seg>// O输出元素的类型 MapFunction[T, O]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Scala object that defines the DataStream program in the main() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041823Z" creationid="xccui" creationdate="20190612T041823Z">
        <seg>// 在main()方法中定义DataStream程序的Scala对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// T: the type of elements FilterFunction[T]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053022Z" creationid="xccui" creationdate="20190613T053018Z">
        <seg>// T：元素类型 FilterFunction[T]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// T: the type of input elements</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050329Z" creationid="xccui" creationdate="20190613T050329Z">
        <seg>// T：输入元素的类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// assign timestamps and watermarks (required for event time)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042213Z" creationid="xccui" creationdate="20190612T042213Z">
        <seg>// 分配时间戳和水位线（事件时间所需)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compute average temperature using a user-defined function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042729Z" creationid="xccui" creationdate="20190612T042729Z">
        <seg>// 使用用户自定义函数计算平均温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// convert Fahrenheit to Celsius with an inline lambda function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053316Z" creationid="xccui" creationdate="20190612T042248Z">
        <seg>// 使用内联lambda函数把华氏温度转为摄氏温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a DataStream[SensorReading] from a stream source</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042034Z" creationid="xccui" creationdate="20190612T042034Z">
        <seg>// 从流式数据源中创建DataStream[SensorReading]对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a local stream execution environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045528Z" creationid="xccui" creationdate="20190612T045528Z">
        <seg>// 创建一个本地流式执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a remote stream execution environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045541Z" creationid="xccui" creationdate="20190612T045541Z">
        <seg>// 创建一个远程流式执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// execute application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044712Z" creationid="xccui" creationdate="20190612T042805Z">
        <seg>// 开始执行应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// group readings in 5 second tumbling windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042710Z" creationid="xccui" creationdate="20190612T042607Z">
        <seg>// 将读数按5秒的滚动窗口分组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// hostname of JobManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045601Z" creationid="xccui" creationdate="20190612T045601Z">
        <seg>// JobManager的主机名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ingest sensor readings with a SensorSource SourceFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042138Z" creationid="xccui" creationdate="20190612T042134Z">
        <seg>// 利用SensorSource SourceFunction获取传感器读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// main() defines and executes the DataStream program</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041854Z" creationid="xccui" creationdate="20190612T041854Z">
        <seg>// 通过main()方法定义并执行DataStream程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// organize readings by sensor id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042353Z" creationid="xccui" creationdate="20190612T042353Z">
        <seg>// 按照传感器id组织数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// port of JobManager process</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045623Z" creationid="xccui" creationdate="20190612T045623Z">
        <seg>// JobManager的端口号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// print result stream to standard out</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042754Z" creationid="xccui" creationdate="20190612T042754Z">
        <seg>// 将结果流打印到标准输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set up the streaming execution environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044717Z" creationid="xccui" creationdate="20190612T041910Z">
        <seg>// 设置流式执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// sum the second field of the tuple in place</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054727Z" creationid="xccui" creationdate="20190614T054550Z">
        <seg>// 滚动计算每个分区内元组第2个字段的总和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// use event time for the application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041934Z" creationid="xccui" creationdate="20190612T041934Z">
        <seg>// 在应用中使用事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144704Z" creationid="esouser" creationdate="20190603T144704Z">
        <seg>1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 Flink’s batch processing API, the DataSet API, and its operators are separate from their corresponding streaming counterparts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122153Z" creationid="xccui" creationdate="20190605T122123Z">
        <seg>1 虽然Flink用于批处理的DataSet API及其算子都独立于对应的流处理部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 We also provide an examples-Java repository with all the examples implemented in Java.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040200Z" creationid="xccui" creationdate="20190611T040200Z">
        <seg>1 我们同时提供了一个examples-Java库，里面的示例都是用Java完成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144730Z" creationid="esouser" creationdate="20190603T144730Z">
        <seg>10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 | Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130755Z" creationid="xccui" creationdate="20190605T130755Z">
        <seg>10 | 第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040413Z" creationid="xccui" creationdate="20190418T040413Z">
        <seg>10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>100</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035718Z" creationid="xccui" creationdate="20190418T035718Z">
        <seg>100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1005</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210838Z" creationid="esouser" creationdate="20190603T210838Z">
        <seg>1005</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>101</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035748Z" creationid="xccui" creationdate="20190418T035748Z">
        <seg>101</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>102</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035752Z" creationid="xccui" creationdate="20190418T035752Z">
        <seg>102</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>103</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145347Z" creationid="esouser" creationdate="20190603T145347Z">
        <seg>103</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>104</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145634Z" creationid="esouser" creationdate="20190603T145634Z">
        <seg>104</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>105</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035758Z" creationid="xccui" creationdate="20190418T035758Z">
        <seg>105</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>106</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145646Z" creationid="esouser" creationdate="20190603T145646Z">
        <seg>106</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>107</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145648Z" creationid="esouser" creationdate="20190603T145648Z">
        <seg>107</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>108</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035803Z" creationid="xccui" creationdate="20190418T035803Z">
        <seg>108</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>109</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145701Z" creationid="esouser" creationdate="20190603T145701Z">
        <seg>109</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040518Z" creationid="xccui" creationdate="20190418T040518Z">
        <seg>11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>111</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145756Z" creationid="esouser" creationdate="20190603T145756Z">
        <seg>111</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>113</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035807Z" creationid="xccui" creationdate="20190418T035807Z">
        <seg>113</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>115</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035811Z" creationid="xccui" creationdate="20190418T035811Z">
        <seg>115</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>116</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035815Z" creationid="xccui" creationdate="20190418T035815Z">
        <seg>116</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>117</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035819Z" creationid="xccui" creationdate="20190418T035819Z">
        <seg>117</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>119</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145851Z" creationid="esouser" creationdate="20190603T145851Z">
        <seg>119</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144741Z" creationid="esouser" creationdate="20190603T144741Z">
        <seg>12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>120</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035823Z" creationid="xccui" creationdate="20190418T035823Z">
        <seg>120</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>121</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035827Z" creationid="xccui" creationdate="20190418T035827Z">
        <seg>121</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>122</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035830Z" creationid="xccui" creationdate="20190418T035830Z">
        <seg>122</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>123</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150326Z" creationid="esouser" creationdate="20190603T150326Z">
        <seg>123</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1234,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054737Z" creationid="xccui" creationdate="20190612T054737Z">
        <seg>1234,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>124</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035833Z" creationid="xccui" creationdate="20190418T035833Z">
        <seg>124</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>125</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035837Z" creationid="xccui" creationdate="20190418T035837Z">
        <seg>125</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>126</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035840Z" creationid="xccui" creationdate="20190418T035840Z">
        <seg>126</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>127</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035847Z" creationid="xccui" creationdate="20190418T035847Z">
        <seg>127</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>129</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035856Z" creationid="xccui" creationdate="20190418T035856Z">
        <seg>129</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>13</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144752Z" creationid="esouser" creationdate="20190603T144752Z">
        <seg>13</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>131</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035859Z" creationid="xccui" creationdate="20190418T035859Z">
        <seg>131</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>134</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150328Z" creationid="esouser" creationdate="20190603T150328Z">
        <seg>134</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>135</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035903Z" creationid="xccui" creationdate="20190418T035903Z">
        <seg>135</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>136</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035913Z" creationid="xccui" creationdate="20190418T035913Z">
        <seg>136</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>137</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035917Z" creationid="xccui" creationdate="20190418T035917Z">
        <seg>137</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>14 | Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130837Z" creationid="xccui" creationdate="20190605T130837Z">
        <seg>14 | 10 | 第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>140</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035921Z" creationid="xccui" creationdate="20190418T035921Z">
        <seg>140</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>141</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035925Z" creationid="xccui" creationdate="20190418T035925Z">
        <seg>141</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>142</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035928Z" creationid="xccui" creationdate="20190418T035928Z">
        <seg>142</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>143</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035932Z" creationid="xccui" creationdate="20190418T035932Z">
        <seg>143</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>144</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035936Z" creationid="xccui" creationdate="20190418T035936Z">
        <seg>144</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>145</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150330Z" creationid="esouser" creationdate="20190603T150330Z">
        <seg>145</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>146</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210747Z" creationid="esouser" creationdate="20190603T210747Z">
        <seg>146</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>148</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210748Z" creationid="esouser" creationdate="20190603T210748Z">
        <seg>148</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>149</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035940Z" creationid="xccui" creationdate="20190418T035940Z">
        <seg>149</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>15</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014613Z" creationid="xccui" creationdate="20190225T014613Z">
        <seg>15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>150</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150822Z" creationid="esouser" creationdate="20190603T150822Z">
        <seg>150</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>152</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150824Z" creationid="esouser" creationdate="20190603T150824Z">
        <seg>152</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>153</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150825Z" creationid="esouser" creationdate="20190603T150825Z">
        <seg>153</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>154</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150827Z" creationid="esouser" creationdate="20190603T150827Z">
        <seg>154</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>156</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035944Z" creationid="xccui" creationdate="20190418T035944Z">
        <seg>156</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>158</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150921Z" creationid="esouser" creationdate="20190603T150921Z">
        <seg>158</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>16</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172722Z" creationid="xccui" creationdate="20190228T172722Z">
        <seg>16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>160</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150929Z" creationid="esouser" creationdate="20190603T150929Z">
        <seg>160</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>164</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151101Z" creationid="esouser" creationdate="20190603T151101Z">
        <seg>164</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>166</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151123Z" creationid="esouser" creationdate="20190603T151123Z">
        <seg>166</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>167</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035947Z" creationid="xccui" creationdate="20190418T035947Z">
        <seg>167</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>168</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151126Z" creationid="esouser" creationdate="20190603T151126Z">
        <seg>168</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>169</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035951Z" creationid="xccui" creationdate="20190418T035951Z">
        <seg>169</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>17</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045711Z" creationid="xccui" creationdate="20190329T045711Z">
        <seg>17</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>170</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035954Z" creationid="xccui" creationdate="20190418T035954Z">
        <seg>170</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>171</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035958Z" creationid="xccui" creationdate="20190418T035958Z">
        <seg>171</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>172</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040002Z" creationid="xccui" creationdate="20190418T040002Z">
        <seg>172</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>174</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040006Z" creationid="xccui" creationdate="20190418T040006Z">
        <seg>174</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>175</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040024Z" creationid="xccui" creationdate="20190418T040024Z">
        <seg>175</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>176</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040028Z" creationid="xccui" creationdate="20190418T040028Z">
        <seg>176</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>177</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151128Z" creationid="esouser" creationdate="20190603T151128Z">
        <seg>177</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>179</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151753Z" creationid="esouser" creationdate="20190603T151753Z">
        <seg>179</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>18</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014603Z" creationid="xccui" creationdate="20190225T014603Z">
        <seg>18</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>18 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041412Z" creationid="xccui" creationdate="20190606T041310Z">
        <seg>18 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>180</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040032Z" creationid="xccui" creationdate="20190418T040032Z">
        <seg>180</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>182</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040043Z" creationid="xccui" creationdate="20190418T040043Z">
        <seg>182</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>183</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151755Z" creationid="esouser" creationdate="20190603T151755Z">
        <seg>183</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>184</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151757Z" creationid="esouser" creationdate="20190603T151757Z">
        <seg>184</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>185</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040048Z" creationid="xccui" creationdate="20190418T040048Z">
        <seg>185</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>186</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152029Z" creationid="esouser" creationdate="20190603T152029Z">
        <seg>186</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>187</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040052Z" creationid="xccui" creationdate="20190418T040052Z">
        <seg>187</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>188</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040055Z" creationid="xccui" creationdate="20190418T040055Z">
        <seg>188</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>189</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040059Z" creationid="xccui" creationdate="20190418T040059Z">
        <seg>189</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>19</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045716Z" creationid="xccui" creationdate="20190329T045716Z">
        <seg>19</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>190</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040104Z" creationid="xccui" creationdate="20190418T040104Z">
        <seg>190</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>191</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040107Z" creationid="xccui" creationdate="20190418T040107Z">
        <seg>191</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>192</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040111Z" creationid="xccui" creationdate="20190418T040111Z">
        <seg>192</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>193</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040114Z" creationid="xccui" creationdate="20190418T040114Z">
        <seg>193</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>194</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210750Z" creationid="esouser" creationdate="20190603T210750Z">
        <seg>194</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>195</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040118Z" creationid="xccui" creationdate="20190418T040118Z">
        <seg>195</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>196</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040121Z" creationid="xccui" creationdate="20190418T040121Z">
        <seg>196</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>197</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040125Z" creationid="xccui" creationdate="20190418T040125Z">
        <seg>197</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>198</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040128Z" creationid="xccui" creationdate="20190418T040128Z">
        <seg>198</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>199</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040132Z" creationid="xccui" creationdate="20190418T040132Z">
        <seg>199</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1&gt; SensorReading(sensor_38,1515014051000,14.781835420242471)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043437Z" creationid="xccui" creationdate="20190611T043437Z">
        <seg>1&gt; SensorReading(sensor_38,1515014051000,14.781835420242471)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144708Z" creationid="esouser" creationdate="20190603T144708Z">
        <seg>2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035445Z" creationid="xccui" creationdate="20190418T035445Z">
        <seg>2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>20</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152503Z" creationid="xccui" creationdate="20190307T152503Z">
        <seg>20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>20 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041409Z" creationid="xccui" creationdate="20190606T041349Z">
        <seg>20 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>200</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040135Z" creationid="xccui" creationdate="20190418T040135Z">
        <seg>200</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2019-04-03: First Release</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210733Z" creationid="esouser" creationdate="20190603T210733Z">
        <seg>2019-04-03: First Release</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>202</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040138Z" creationid="xccui" creationdate="20190418T040138Z">
        <seg>202</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>203</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152055Z" creationid="esouser" creationdate="20190603T152055Z">
        <seg>203</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>204</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040141Z" creationid="xccui" creationdate="20190418T040141Z">
        <seg>204</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>205</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040153Z" creationid="xccui" creationdate="20190418T040153Z">
        <seg>205</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>206</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152112Z" creationid="esouser" creationdate="20190603T152112Z">
        <seg>206</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>207</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152114Z" creationid="esouser" creationdate="20190603T152114Z">
        <seg>207</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>208</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040157Z" creationid="xccui" creationdate="20190418T040157Z">
        <seg>208</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>209</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040201Z" creationid="xccui" creationdate="20190418T040201Z">
        <seg>209</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>21</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045720Z" creationid="xccui" creationdate="20190329T045720Z">
        <seg>21</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>212</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040206Z" creationid="xccui" creationdate="20190418T040206Z">
        <seg>212</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>216</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040209Z" creationid="xccui" creationdate="20190418T040209Z">
        <seg>216</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>218</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040212Z" creationid="xccui" creationdate="20190418T040212Z">
        <seg>218</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>219</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152116Z" creationid="esouser" creationdate="20190603T152116Z">
        <seg>219</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>22</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045724Z" creationid="xccui" creationdate="20190329T045724Z">
        <seg>22</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>22 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041429Z" creationid="xccui" creationdate="20190606T041429Z">
        <seg>22 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>221</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040216Z" creationid="xccui" creationdate="20190418T040216Z">
        <seg>221</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>223</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152140Z" creationid="esouser" creationdate="20190603T152140Z">
        <seg>223</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>224</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040219Z" creationid="xccui" creationdate="20190418T040219Z">
        <seg>224</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>225</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040223Z" creationid="xccui" creationdate="20190418T040223Z">
        <seg>225</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>227</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040226Z" creationid="xccui" creationdate="20190418T040226Z">
        <seg>227</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>228</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040230Z" creationid="xccui" creationdate="20190418T040230Z">
        <seg>228</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>23</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045729Z" creationid="xccui" creationdate="20190329T045729Z">
        <seg>23</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>230</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040234Z" creationid="xccui" creationdate="20190418T040234Z">
        <seg>230</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>231</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040244Z" creationid="xccui" creationdate="20190418T040244Z">
        <seg>231</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>232</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152149Z" creationid="esouser" creationdate="20190603T152149Z">
        <seg>232</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>233</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152208Z" creationid="esouser" creationdate="20190603T152208Z">
        <seg>233</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>234</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152229Z" creationid="esouser" creationdate="20190603T152229Z">
        <seg>234</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>235</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152242Z" creationid="esouser" creationdate="20190603T152242Z">
        <seg>235</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>236</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152243Z" creationid="esouser" creationdate="20190603T152243Z">
        <seg>236</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>237</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152254Z" creationid="esouser" creationdate="20190603T152254Z">
        <seg>237</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>238</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040248Z" creationid="xccui" creationdate="20190418T040248Z">
        <seg>238</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>239</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152259Z" creationid="esouser" creationdate="20190603T152259Z">
        <seg>239</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>24</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045734Z" creationid="xccui" creationdate="20190329T045734Z">
        <seg>24</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>240</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152301Z" creationid="esouser" creationdate="20190603T152301Z">
        <seg>240</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>241</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040252Z" creationid="xccui" creationdate="20190418T040252Z">
        <seg>241</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>242</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152303Z" creationid="esouser" creationdate="20190603T152303Z">
        <seg>242</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>243</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040304Z" creationid="xccui" creationdate="20190418T040304Z">
        <seg>243</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>244</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152336Z" creationid="esouser" creationdate="20190603T152336Z">
        <seg>244</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>245</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152338Z" creationid="esouser" creationdate="20190603T152338Z">
        <seg>245</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>246</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040311Z" creationid="xccui" creationdate="20190418T040311Z">
        <seg>246</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>247</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040319Z" creationid="xccui" creationdate="20190418T040319Z">
        <seg>247</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>25</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032750Z" creationid="xccui" creationdate="20190327T032750Z">
        <seg>25</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>251</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040329Z" creationid="xccui" creationdate="20190418T040329Z">
        <seg>251</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>252</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152340Z" creationid="esouser" creationdate="20190603T152340Z">
        <seg>252</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>255</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040332Z" creationid="xccui" creationdate="20190418T040332Z">
        <seg>255</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>256</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040336Z" creationid="xccui" creationdate="20190418T040336Z">
        <seg>256</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>257</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040340Z" creationid="xccui" creationdate="20190418T040340Z">
        <seg>257</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>258</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040344Z" creationid="xccui" creationdate="20190418T040344Z">
        <seg>258</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>259</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040347Z" creationid="xccui" creationdate="20190418T040347Z">
        <seg>259</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>26</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042440Z" creationid="xccui" creationdate="20190328T042440Z">
        <seg>26</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>260</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152342Z" creationid="esouser" creationdate="20190603T152342Z">
        <seg>260</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>261</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040350Z" creationid="xccui" creationdate="20190418T040350Z">
        <seg>261</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>262</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040354Z" creationid="xccui" creationdate="20190418T040354Z">
        <seg>262</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>263</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040357Z" creationid="xccui" creationdate="20190418T040357Z">
        <seg>263</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>264</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040400Z" creationid="xccui" creationdate="20190418T040400Z">
        <seg>264</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>265</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040404Z" creationid="xccui" creationdate="20190418T040404Z">
        <seg>265</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>266</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040408Z" creationid="xccui" creationdate="20190418T040408Z">
        <seg>266</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>267</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040417Z" creationid="xccui" creationdate="20190418T040417Z">
        <seg>267</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>268</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040422Z" creationid="xccui" creationdate="20190418T040422Z">
        <seg>268</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>269</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040426Z" creationid="xccui" creationdate="20190418T040426Z">
        <seg>269</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>27</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045740Z" creationid="xccui" creationdate="20190329T045740Z">
        <seg>27</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>270</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152403Z" creationid="esouser" creationdate="20190603T152403Z">
        <seg>270</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>273</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152405Z" creationid="esouser" creationdate="20190603T152405Z">
        <seg>273</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>274</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040430Z" creationid="xccui" creationdate="20190418T040430Z">
        <seg>274</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>278</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152406Z" creationid="esouser" creationdate="20190603T152406Z">
        <seg>278</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>279</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040434Z" creationid="xccui" creationdate="20190418T040434Z">
        <seg>279</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>28</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042035Z" creationid="xccui" creationdate="20190329T042035Z">
        <seg>28</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>28 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041447Z" creationid="xccui" creationdate="20190606T041447Z">
        <seg>28 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>280</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152407Z" creationid="esouser" creationdate="20190603T152407Z">
        <seg>280</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>281</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152417Z" creationid="esouser" creationdate="20190603T152417Z">
        <seg>281</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>282</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040438Z" creationid="xccui" creationdate="20190418T040438Z">
        <seg>282</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>283</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040442Z" creationid="xccui" creationdate="20190418T040442Z">
        <seg>283</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>285</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040446Z" creationid="xccui" creationdate="20190418T040446Z">
        <seg>285</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>288</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040449Z" creationid="xccui" creationdate="20190418T040449Z">
        <seg>288</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>289</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040453Z" creationid="xccui" creationdate="20190418T040453Z">
        <seg>289</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>29</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041918Z" creationid="xccui" creationdate="20190329T041918Z">
        <seg>29</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>292</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040457Z" creationid="xccui" creationdate="20190418T040457Z">
        <seg>292</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>295</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040501Z" creationid="xccui" creationdate="20190418T040501Z">
        <seg>295</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2&gt; SensorReading(sensor_31,1515014051000,23.924656183848732)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043428Z" creationid="xccui" creationdate="20190611T043428Z">
        <seg>2&gt; SensorReading(sensor_31,1515014051000,23.924656183848732)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144712Z" creationid="esouser" creationdate="20190603T144712Z">
        <seg>3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024959Z" creationid="xccui" creationdate="20190329T024959Z">
        <seg>3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>30</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041931Z" creationid="xccui" creationdate="20190329T041931Z">
        <seg>30</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>300</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040504Z" creationid="xccui" creationdate="20190418T040504Z">
        <seg>300</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>301</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040508Z" creationid="xccui" creationdate="20190418T040508Z">
        <seg>301</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>302</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040511Z" creationid="xccui" creationdate="20190418T040511Z">
        <seg>302</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>303</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040524Z" creationid="xccui" creationdate="20190418T040524Z">
        <seg>303</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>305</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040528Z" creationid="xccui" creationdate="20190418T040528Z">
        <seg>305</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>307</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040548Z" creationid="xccui" creationdate="20190418T040548Z">
        <seg>307</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>309</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040556Z" creationid="xccui" creationdate="20190418T040556Z">
        <seg>309</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>31</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144754Z" creationid="esouser" creationdate="20190603T144754Z">
        <seg>31</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>32</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144246Z" creationid="esouser" creationdate="20190603T144246Z">
        <seg>32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>33</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000312Z" creationid="xccui" creationdate="20190401T000312Z">
        <seg>33</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>34</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032117Z" creationid="xccui" creationdate="20190401T032117Z">
        <seg>34</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>34 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041516Z" creationid="xccui" creationdate="20190606T041516Z">
        <seg>34 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>35</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142146Z" creationid="xccui" creationdate="20190401T142146Z">
        <seg>35</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>36</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195532Z" creationid="xccui" creationdate="20190401T195532Z">
        <seg>36</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>37</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195520Z" creationid="xccui" creationdate="20190401T195520Z">
        <seg>37</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>38</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210323Z" creationid="xccui" creationdate="20190402T210323Z">
        <seg>38</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>38 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032532Z" creationid="xccui" creationdate="20190610T032532Z">
        <seg>38 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>39</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152744Z" creationid="xccui" creationdate="20190405T152744Z">
        <seg>39</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3&gt; SensorReading(sensor_34,1515014051000,23.871433252250583)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043441Z" creationid="xccui" creationdate="20190611T043441Z">
        <seg>3&gt; SensorReading(sensor_34,1515014051000,23.871433252250583)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144716Z" creationid="esouser" creationdate="20190603T144716Z">
        <seg>4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4 | Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130806Z" creationid="xccui" creationdate="20190605T130806Z">
        <seg>4 | 第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035634Z" creationid="xccui" creationdate="20190418T035634Z">
        <seg>4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>40</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035845Z" creationid="xccui" creationdate="20190406T035845Z">
        <seg>40</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>41</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043712Z" creationid="xccui" creationdate="20190406T043712Z">
        <seg>41</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>42</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023551Z" creationid="xccui" creationdate="20190407T023551Z">
        <seg>42</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>43</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052401Z" creationid="xccui" creationdate="20190416T052401Z">
        <seg>43</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>44</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052407Z" creationid="xccui" creationdate="20190416T052407Z">
        <seg>44</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>45</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152127Z" creationid="xccui" creationdate="20190411T152127Z">
        <seg>45</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>46</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150539Z" creationid="xccui" creationdate="20190412T150539Z">
        <seg>46</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>46 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032601Z" creationid="xccui" creationdate="20190610T032601Z">
        <seg>46 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>47</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150532Z" creationid="xccui" creationdate="20190412T150532Z">
        <seg>47</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>48</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155341Z" creationid="xccui" creationdate="20190412T155341Z">
        <seg>48</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>48 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032635Z" creationid="xccui" creationdate="20190610T032635Z">
        <seg>48 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>49</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T041055Z" creationid="xccui" creationdate="20190414T041055Z">
        <seg>49</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4&gt; SensorReading(sensor_32,1515014051000,4.118569049862492)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043432Z" creationid="xccui" creationdate="20190611T043432Z">
        <seg>4&gt; SensorReading(sensor_32,1515014051000,4.118569049862492)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035624Z" creationid="xccui" creationdate="20190329T035624Z">
        <seg>5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>50</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055624Z" creationid="xccui" creationdate="20190414T055624Z">
        <seg>50</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>51</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042843Z" creationid="xccui" creationdate="20190415T042843Z">
        <seg>51</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>52</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041533Z" creationid="xccui" creationdate="20190416T041533Z">
        <seg>52</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>53</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050113Z" creationid="xccui" creationdate="20190416T050113Z">
        <seg>53</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>54</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052001Z" creationid="xccui" creationdate="20190416T052001Z">
        <seg>54</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>54 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032746Z" creationid="xccui" creationdate="20190610T032746Z">
        <seg>54 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>55</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032942Z" creationid="xccui" creationdate="20190418T032942Z">
        <seg>55</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>56</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035459Z" creationid="xccui" creationdate="20190418T035459Z">
        <seg>56</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>57</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035503Z" creationid="xccui" creationdate="20190418T035503Z">
        <seg>57</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>58</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035507Z" creationid="xccui" creationdate="20190418T035507Z">
        <seg>58</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>59</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035514Z" creationid="xccui" creationdate="20190418T035514Z">
        <seg>59</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144719Z" creationid="esouser" creationdate="20190603T144719Z">
        <seg>6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035852Z" creationid="xccui" creationdate="20190418T035852Z">
        <seg>6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>60</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144757Z" creationid="esouser" creationdate="20190603T144757Z">
        <seg>60</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>60 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032806Z" creationid="xccui" creationdate="20190610T032806Z">
        <seg>60 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>61</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035518Z" creationid="xccui" creationdate="20190418T035518Z">
        <seg>61</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>62</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044716Z" creationid="xccui" creationdate="20190504T044716Z">
        <seg>62</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>63</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035522Z" creationid="xccui" creationdate="20190418T035522Z">
        <seg>63</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>64</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T154733Z" creationid="esouser" creationdate="20190514T154733Z">
        <seg>64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>65</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035526Z" creationid="xccui" creationdate="20190418T035526Z">
        <seg>65</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>66</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035530Z" creationid="xccui" creationdate="20190418T035530Z">
        <seg>66</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>67</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035534Z" creationid="xccui" creationdate="20190418T035534Z">
        <seg>67</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>69</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144652Z" creationid="esouser" creationdate="20190603T144652Z">
        <seg>69</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040015Z" creationid="xccui" creationdate="20190418T040015Z">
        <seg>7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>70</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035544Z" creationid="xccui" creationdate="20190418T035544Z">
        <seg>70</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>707-829-0104 (fax)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210841Z" creationid="esouser" creationdate="20190603T210841Z">
        <seg>707-829-0104 (fax)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>71</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035548Z" creationid="xccui" creationdate="20190418T035548Z">
        <seg>71</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>72</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035552Z" creationid="xccui" creationdate="20190418T035552Z">
        <seg>72</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>72 | Chapter 4: Setting Up a Development Environment for Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040223Z" creationid="xccui" creationdate="20190611T040223Z">
        <seg>72 | 第4章：设置Apaceh Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>73</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035600Z" creationid="xccui" creationdate="20190418T035600Z">
        <seg>73</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>74</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035605Z" creationid="xccui" creationdate="20190418T035605Z">
        <seg>74</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>74 | Chapter 4: Setting Up a Development Environment for Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012857Z" creationid="xccui" creationdate="20190612T012857Z">
        <seg>74 | 设置Apaceh Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>75</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144915Z" creationid="esouser" creationdate="20190603T144915Z">
        <seg>75</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>76</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035608Z" creationid="xccui" creationdate="20190418T035608Z">
        <seg>76</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>77</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035612Z" creationid="xccui" creationdate="20190418T035612Z">
        <seg>77</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>78</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035616Z" creationid="xccui" creationdate="20190418T035616Z">
        <seg>78</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>79</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035621Z" creationid="xccui" creationdate="20190418T035621Z">
        <seg>79</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144723Z" creationid="esouser" creationdate="20190603T144723Z">
        <seg>8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040147Z" creationid="xccui" creationdate="20190418T040147Z">
        <seg>8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>800-998-9938 (in the United States or Canada) 707-829-0515 (international or local)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210840Z" creationid="esouser" creationdate="20190603T210840Z">
        <seg>800-998-9938 (in the United States or Canada) 707-829-0515 (international or local)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>81</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145036Z" creationid="esouser" creationdate="20190603T145036Z">
        <seg>81</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>82</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145105Z" creationid="esouser" creationdate="20190603T145105Z">
        <seg>82</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>83</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145112Z" creationid="esouser" creationdate="20190603T145112Z">
        <seg>83</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>84</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035625Z" creationid="xccui" creationdate="20190418T035625Z">
        <seg>84</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>87</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035628Z" creationid="xccui" creationdate="20190418T035628Z">
        <seg>87</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>89</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035642Z" creationid="xccui" creationdate="20190418T035642Z">
        <seg>89</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144727Z" creationid="esouser" creationdate="20190603T144727Z">
        <seg>9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040300Z" creationid="xccui" creationdate="20190418T040300Z">
        <seg>9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>90</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035645Z" creationid="xccui" creationdate="20190418T035645Z">
        <seg>90</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>92</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035652Z" creationid="xccui" creationdate="20190418T035652Z">
        <seg>92</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>93</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035656Z" creationid="xccui" creationdate="20190418T035656Z">
        <seg>93</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>94</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035701Z" creationid="xccui" creationdate="20190418T035701Z">
        <seg>94</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>96</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145618Z" creationid="esouser" creationdate="20190603T145618Z">
        <seg>96</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>97</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035705Z" creationid="xccui" creationdate="20190418T035705Z">
        <seg>97</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>978-1-491-97429-2 [LSI]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210743Z" creationid="esouser" creationdate="20190603T210743Z">
        <seg>978-1-491-97429-2 [LSI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>98</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145619Z" creationid="esouser" creationdate="20190603T145619Z">
        <seg>98</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>99</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035714Z" creationid="xccui" creationdate="20190418T035714Z">
        <seg>99</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Eager &lt;t1/&gt;watermarks ensure low latency but provide lower confidence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210541Z" creationid="xccui" creationdate="20190412T210445Z">
        <seg>激进的水位线策略保证了低延迟，但随之而来的是低可信度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 1-4&lt;t1/&gt; shows a stateful Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T033047Z" creationid="xccui" creationdate="20190305T033047Z">
        <seg>图1-4展示了一个状态化的Flink应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 1-5&lt;t1/&gt; sketches a service architecture composed of event-driven streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152610Z" creationid="xccui" creationdate="20190307T152501Z">
        <seg>图1-5粗略展示了一个由事件驱动型应用组成的服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 2-1&lt;t1/&gt; shows a dataflow program that extracts and counts hashtags from an input stream of tweets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021625Z" creationid="xccui" creationdate="20190401T000354Z">
        <seg>图2-1展示了一个从推文输入流中提取并计算主题标签数目的dataflow程序，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 3-2&lt;t1/&gt; visualizes the relationship of TaskManag&lt;t2/&gt;‐&lt;t3/&gt; ers, slots, tasks, and operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042900Z" creationid="xccui" creationdate="20190423T042900Z">
        <seg>图3-2展示了TaskManager、处理槽、任务以及算子之间的关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Parallelization becomes complicated, since results depend on&lt;t1/&gt; &lt;t2/&gt;both the state and incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035629Z" creationid="xccui" creationdate="20190415T033359Z">
        <seg>由于结果需要同时依赖状态和到来的事件，状态并行化变得异常复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;The third and biggest challenge that comes with stateful opera&lt;t1/&gt;‐&lt;t2/&gt; &lt;t3/&gt;tors is ensuring that state can be recovered and results will be correct even in the presence of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035117Z" creationid="xccui" creationdate="20190415T034953Z">
        <seg>最后一个也是最大的挑战在于，状态化算子需要保证状态可以恢复，即便出现故障也要确保结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t13/&gt;Figure 2-9&lt;t14/&gt; shows a session win&lt;t15/&gt;‐&lt;t16/&gt; dow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193517Z" creationid="xccui" creationdate="20190409T193517Z">
        <seg>图2-9展示了一个会话窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t2/&gt;Figure 2-5 &lt;t3/&gt;shows a rolling minimum aggregation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035707Z" creationid="xccui" creationdate="20190406T035523Z">
        <seg>图2-5展示了一个求最小值的滚动聚合，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t2/&gt;Figure 3-7&lt;t3/&gt; show the same pipeline would be executed without task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155109Z" creationid="esouser" creationdate="20190514T154644Z">
        <seg>图3-7展示了同一个流水线如何非任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t3/&gt;The truth is that processing time can indeed&lt;t4/&gt; &lt;t5/&gt;be useful in some cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043840Z" creationid="xccui" creationdate="20190414T040757Z">
        <seg>事实上，处理时间在某些情况下确有其用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 2-13&lt;t5/&gt; shows that an event-time window would correctly place events in a window, reflecting the reality of how things happened, even though some events were &lt;t6/&gt;delayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150703Z" creationid="xccui" creationdate="20190412T150441Z">
        <seg>如图2-13所示，即便事件有延迟，事件时间窗口也能准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 2-2&lt;t5/&gt; shows a physical dataflow graph for the logical graph of &lt;t6/&gt;Figure 2-1&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T003231Z" creationid="xccui" creationdate="20190401T003231Z">
        <seg>图2-2展示了图2-1中逻辑图对应的物理dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 3-3&lt;t5/&gt; illustrates this design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051331Z" creationid="xccui" creationdate="20190502T051232Z">
        <seg>图3-3阐明了这一设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 3-4&lt;t5/&gt; visualizes this architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044158Z" creationid="xccui" creationdate="20190504T043809Z">
        <seg>图3-4展示了这一架构，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t5/&gt;Figure 2-6&lt;t6/&gt; shows a count-based tumbling window that discretizes the input stream into buckets of 4 elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023319Z" creationid="xccui" creationdate="20190407T022549Z">
        <seg>图2-6中基于数量的滚动窗口将输入流按每4个元素一组分配到不同的通中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t6/&gt;Figure 2-10&lt;t7/&gt; shows a parallel count-based tumbling window of length 2 which is partitioned by event color.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195846Z" creationid="xccui" creationdate="20190409T195846Z">
        <seg>图2-10展示了一个按事件颜色划分、基于数量2的并行滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t7/&gt;Figure 2-7&lt;t8/&gt; shows a time-based tumbling window that gathers events into buckets and triggers computation every 10 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023521Z" creationid="xccui" creationdate="20190407T023312Z">
        <seg>图2-7中基于时间的滚动窗口将事件汇集到桶中，每10分钟触发一次计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t8/&gt;Figure 1-2&lt;t9/&gt; depicts a microservice architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172840Z" creationid="xccui" creationdate="20190228T172718Z">
        <seg>图1-2描绘了微服务的架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; filter(T): Boolean</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052938Z" creationid="xccui" creationdate="20190613T052938Z">
        <seg>&gt; filter(T): Boolean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; flatMap(T, Collector[O]): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T061035Z" creationid="xccui" creationdate="20190613T061035Z">
        <seg>&gt; flatMap(T, Collector[O]): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; map(T): O</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050345Z" creationid="xccui" creationdate="20190613T050345Z">
        <seg>&gt; map(T): O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052010Z" creationid="xccui" creationdate="20190612T052010Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Bit of History</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030041Z" creationid="esouser" creationdate="20190603T143127Z">
        <seg>历史回顾</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink DataStream application can assign timestamps and generate watermarks to a stream in three ways:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033951Z" creationid="xccui" creationdate="20190607T033951Z">
        <seg>Flink DataStream应用可以通过三种方式分配时间戳和生成水位线：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink setup consists for four different components that work together to execute streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033459Z" creationid="xccui" creationdate="20190418T033431Z">
        <seg>Flink的设置包含4个不同组件，它们相互协作，共同执行流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink setup consists of four different components that work together to execute streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141214Z" creationid="xccui" creationdate="20190606T141214Z">
        <seg>Flink的设置包含4个不同组件，它们相互协作，共同执行流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink setup consists of multiple processes that typically run distributed across multiple machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140636Z" creationid="xccui" creationdate="20190418T030126Z">
        <seg>它的设置包含多个进程，这些进程通常会分布在多台机器上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Java JRE is not sufficient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T015648Z" creationid="xccui" creationdate="20190611T015626Z">
        <seg>只有Java JRE是不够的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyedStream can be processed using the map, flatMap, and filter transformations that you saw earlier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T045801Z" creationid="xccui" creationdate="20190614T045801Z">
        <seg>KeyedStream也支持使用你之前看到过的map、flatMap和filter等转换进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Quick Look at Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143155Z" creationid="esouser" creationdate="20190603T143155Z">
        <seg>Flink快览</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Quick Look at Flink | 13</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130830Z" creationid="xccui" creationdate="20190605T130830Z">
        <seg>Flink快览| 13</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager can execute several tasks at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041158Z" creationid="xccui" creationdate="20190423T041158Z">
        <seg>一个TaskManager可以同时执行多个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager executes its tasks multi-threaded in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062942Z" creationid="xccui" creationdate="20190424T062935Z">
        <seg>TaskManager会在同一个JVM进程内以多线程的方式执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager executes its tasks multithreaded in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144850Z" creationid="xccui" creationdate="20190606T144850Z">
        <seg>TaskManager会在同一个JVM进程内以多线程的方式执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager needs one dedicated network buffer for each receiving task that any of its tasks need to send data to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044911Z" creationid="xccui" creationdate="20190504T043448Z">
        <seg>对于每一个接收任务，TaskManager都需要一个特定的网络缓冲区，用于接收其上任意任务发来的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager offers a certain number of processing slots to control the number of tasks it is able to concurrently execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144403Z" creationid="xccui" creationdate="20190606T144350Z">
        <seg>TaskManager通过提供固定数量的处理槽来控制可以并发执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager process (and with it, all tasks running on it) may fail at any point in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053627Z" creationid="xccui" creationdate="20190608T053527Z">
        <seg>由于TaskManager进程以及它上面所有运行的任务都可能在任意时间出现故障，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager provides a certain number of processing slots to control the number of tasks that it can concurrently execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042642Z" creationid="xccui" creationdate="20190423T042443Z">
        <seg>TaskManager通过提供一定数量的处理槽来控制可以并发执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Taste of Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T063919Z" creationid="xccui" creationdate="20190225T014731Z">
        <seg>初识Flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Welcoming Community</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152601Z" creationid="esouser" creationdate="20190603T152601Z">
        <seg>欢迎加入社区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A background thread asynchronously copies the local snapshot to the remote storage and notifies the task once it completes the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203709Z" creationid="xccui" creationdate="20190609T203432Z">
        <seg>后台进程会异步将本地状态快照拷贝到远程存储，然后在完成检查点后通知任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A checkpoint barrier carries a checkpoint ID to identify the checkpoint it belongs to  and logically splits a stream into two parts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060953Z" creationid="xccui" creationdate="20190609T060708Z">
        <seg>为了标识所属的检查点，每个检查点分隔符都会带有一个检查点编号，这样就把一条数据流从逻辑上分成了两个部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A checkpoint is initiated by the JobManager by sending a message with a new check‐ point ID to each data source task as shown in Figure 3-20.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T063006Z" creationid="xccui" creationdate="20190609T062451Z">
        <seg>如图3-20所示，JobManager会向每个数据源任务发送一个新的检查点编号，以此来启动检查点生成流程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common case is when a task per&lt;t0/&gt;‐&lt;t1/&gt; forms idempotent operations, like maximum or minimum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050227Z" creationid="xccui" creationdate="20190416T050227Z">
        <seg>一个常见情况就是某个任务执行一些诸如求最大值或最小值的幂等操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common case is when a task performs idempotent operations, like maximum or min‐ imum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035358Z" creationid="xccui" creationdate="20190606T035358Z">
        <seg>一个常见情况就是某个任务执行一些诸如求最大值或最小值的幂等操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common requirement for streaming applications is to adjust the parallelism of operators due to increasing or decreasing input rates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T054428Z" creationid="xccui" creationdate="20190608T054343Z">
        <seg>流式应用的一项基本需求是根据输入数据到达速率的变化调整算子并发度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common requirement of many applications is to process groups of events that share a certain property together.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044428Z" creationid="xccui" creationdate="20190614T043547Z">
        <seg>在很多应用中需要将事件按照某个属性分组后再进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consistent checkpoint of a stateful streaming application is a copy of the state of each of its tasks at a point when all tasks have processed exactly the same input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223148Z" creationid="xccui" creationdate="20190608T155358Z">
        <seg>状态化流式应用的一致性检查点是在所有任务处理完等量的原始输入后对全部任务状态进行的一个拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consistent checkpoint of a streaming application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T225015Z" creationid="xccui" creationdate="20190608T225008Z">
        <seg>某流式应用的一致性检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A container that is started from this image automati‐ cally starts a TaskManager, which connects to the ResourceManager and registers its slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143929Z" creationid="xccui" creationdate="20190606T143759Z">
        <seg>容器通过映像启动后会自动运行TaskManager，用来连接ResourceManager并注册处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A data source can ingest data from a TCP socket, a file, a Kafka topic, or a sensor data interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152258Z" creationid="xccui" creationdate="20190405T152258Z">
        <seg>数据源可以从TCP套接字、文件、某Kafka主题、传感数据接口接收数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A data stream is a potentially unbounded sequence of events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142859Z" creationid="xccui" creationdate="20190401T142812Z">
        <seg>数据流是一个可能无限的事件序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A data warehouse is a specialized database system for analytical query workloads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T184243Z" creationid="xccui" creationdate="20190228T184243Z">
        <seg>数据仓库是一个用来执行分析类查询的专业化数据库系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dataflow graph must have at least</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000307Z" creationid="xccui" creationdate="20190401T000240Z">
        <seg>一个dataflow图至少要有一个数据源和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dataflow graph must have at least one data source and one data sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224932Z" creationid="xccui" creationdate="20190605T224929Z">
        <seg>一个Dataflow图至少要有一个数据源和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failure can occur during any of these steps and the system has to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042813Z" creationid="xccui" creationdate="20190415T042639Z">
        <seg>上述任何一个步骤都可能发生故障，系统必须在故障场景下明确定义其行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failure can occur during any of these steps and the system has to clearly define its behavior in a failure scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033607Z" creationid="xccui" creationdate="20190606T033607Z">
        <seg>上述任何一个步骤都可能发生故障，系统必须在故障场景下明确定义其行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A filter operation that only retains white values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052343Z" creationid="xccui" creationdate="20190613T052343Z">
        <seg>仅保留白色值的filter操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A filter transformation is specified by calling the DataStream.filter() method and pro‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052155Z" creationid="xccui" creationdate="20190613T052155Z">
        <seg>通过调用DataStream.filter()方法可以指定filter转换产生一个相同数据类型的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A flatMap operation that outputs white squares, duplicates black squares, and drops gray squares</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054751Z" creationid="xccui" creationdate="20190613T054718Z">
        <seg>输出白色方块，复制黑色方块，丢弃灰色方块的flatMap操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A highly available Flink setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T194903Z" creationid="xccui" creationdate="20190606T194859Z">
        <seg>Flink高可用设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A highly-available Flink Setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051925Z" creationid="xccui" creationdate="20190502T051925Z">
        <seg>Flink高可用设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key group is a partition of keys and Flink’s  way of assigning keys to   tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060044Z" creationid="xccui" creationdate="20190608T055919Z">
        <seg>键值组包含了部分键值，Flink以此为单位把键值分配给不同任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A keyBy operation that partitions events based on color</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051146Z" creationid="xccui" creationdate="20190614T051146Z">
        <seg>基于颜色对事件进行分区的keyBy操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A logical dataflow graph to continuously count hashtags (nodes represent operators and edges denote data dependencies)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224959Z" creationid="xccui" creationdate="20190605T224959Z">
        <seg>一个持续计算主题标签数量的Dataflow逻辑图（顶点表示算子，边表示数据依赖）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A logical dataflow graph to continuously count hashtags.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T001230Z" creationid="xccui" creationdate="20190401T001056Z">
        <seg>持续计算主题标签数量的dataflow逻辑图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A map operation that transforms every square into a circle of the same color</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045716Z" creationid="xccui" creationdate="20190613T045716Z">
        <seg>将方形转换为相同颜色圆形的map操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A microservice architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172821Z" creationid="xccui" creationdate="20190228T172821Z">
        <seg>微服务架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A microservices architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T201100Z" creationid="esouser" creationdate="20190603T201100Z">
        <seg>微服务架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more challenging problem than TaskManager failures are JobManager failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T043044Z" creationid="xccui" creationdate="20190502T042522Z">
        <seg>和TaskManager相比，JobManager发生故障会更为棘手。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new JobManager that takes over the work of the failed master performs the following steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190503T192209Z" creationid="xccui" creationdate="20190502T052425Z">
        <seg>新接手工作的JobManager会执行以下步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new JobManager that takes over the work of the failed master performs the following steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195042Z" creationid="xccui" creationdate="20190606T195042Z">
        <seg>新接手工作的JobManager会执行以下步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parallel count-based tumbling window of length 2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014208Z" creationid="xccui" creationdate="20190606T014058Z">
        <seg>基于数量2的并行滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parallel count-based tumbling window of length 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195913Z" creationid="xccui" creationdate="20190409T195913Z">
        <seg>基于数量2的并行滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A physical dataflow plan for counting hashtags (nodes represent tasks)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233201Z" creationid="xccui" creationdate="20190605T233201Z">
        <seg>主题标签计数的物理Dataflow计划（顶点代表任务）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A physical dataflow plan for counting hashtags.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021747Z" creationid="xccui" creationdate="20190401T021452Z">
        <seg>主题标签计数的物理dataflow计划，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing slot can execute one slice of an application—one parallel task of each operator of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144414Z" creationid="xccui" creationdate="20190606T144414Z">
        <seg>每个处理槽可以执行应用的一部分，即应用内算子的一个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing slot is able to execute one slice of an application, i.e., one parallel task of each operator of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042814Z" creationid="xccui" creationdate="20190423T042808Z">
        <seg>每个处理槽可以执行应用的一部分，即应用内算子的一个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window continues counting time even after Alice’s phone gets disconnected</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023919Z" creationid="xccui" creationdate="20190606T023909Z">
        <seg>在爱丽丝手机离线后继续计时的处理时间窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window continues counting time when Alice’s phone gets disconnected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145324Z" creationid="xccui" creationdate="20190412T145316Z">
        <seg>在爱丽丝手机离线后继续计时的处理时间窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window includes all events that happen to have arrived at the window operator within a time period, as meas&lt;t2/&gt;‐&lt;t3/&gt; ured by the wall-clock of its machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T144411Z" creationid="xccui" creationdate="20190412T144411Z">
        <seg>基于处理时间的窗口包含了那些恰好在一段时间内到达窗口算子的事件，这里的时间段是按照机器时间测量的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window includes all events that happen to have arrived at the window operator within a time period, as meas‐ ured by the wall clock of its machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023838Z" creationid="xccui" creationdate="20190606T023838Z">
        <seg>基于处理时间的窗口包含了那些恰好在一段时间内到达窗口算子的事件，这里的时间段是按照机器时间测量的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A project import wizard will guide you though the next steps, such as selecting the Maven project to import (there should only be one), selecting the SDK, and naming the project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041529Z" creationid="xccui" creationdate="20190611T041529Z">
        <seg>根据导入向导的指示完成后续步骤，例如：选择要导入的Maven项目（应该只有一个），选择SDK，为项目命名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A receiving task grants some credit to a sending task, i.e., a number of network buffers that are reserved to receive its data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T143724Z" creationid="esouser" creationdate="20190513T210814Z">
        <seg>一个接收任务会给一个发送任务授予一定的信用度，其实就是保留一些用来接收它数据的网络缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A receiving task grants some credit to a sending task, the number of network buffers that are reserved to receive its data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202744Z" creationid="xccui" creationdate="20190606T202733Z">
        <seg>一个接收任务会给一个发送任务授予一定的信用值，其实就是保留一些用来接收它数据的网络缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recent approach to overcome the tight bundling of applications is the microservice design pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190227T233935Z" creationid="xccui" creationdate="20190227T042104Z">
        <seg>近些年提出的微服务模式可以克服这种应用紧耦合情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recent approach to overcoming the tight bundling of applications is the microservices design pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200619Z" creationid="esouser" creationdate="20190603T200240Z">
        <seg>近些年提出的微服务设计模式可以克服这种应用紧耦合情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reduce transformation does</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061533Z" creationid="xccui" creationdate="20190614T061516Z">
        <seg>reduce转换不会改变数据流的类型，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A return value of true preserves the input event and forwards it to the output, and false results in dropping the event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052016Z" creationid="xccui" creationdate="20190613T052016Z">
        <seg>如果返回值为true则会保留并输入事件并将其转发到输出，否则会把事件丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling aggregation does not require a user-defined func‐ tion but receives an argument that specifies on which field the aggregate is computed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052539Z" creationid="xccui" creationdate="20190614T052539Z">
        <seg>虽然滚动聚合不需要用户自定义函数，但需要接收一个用于指定聚合计算字段的参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling aggregation is an aggregation, such as sum, minimum, and maximum, that is continuously updated for each input event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035610Z" creationid="xccui" creationdate="20190406T034203Z">
        <seg>滚动聚合（例如：求和、求最小值、求最大值）会根据每个到来的事件持续更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling aggre‐ gate operator keeps an aggregated value for every observed key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052118Z" creationid="xccui" creationdate="20190614T052118Z">
        <seg>滚动聚合算子会对每一个遇到的键值保存一个聚合结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling maximum of the input stream on the specified field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053531Z" creationid="xccui" creationdate="20190614T053531Z">
        <seg>滚动计算输入流中指定字段的最大值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling maximum of the input stream that returns the event with the highest</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053838Z" creationid="xccui" creationdate="20190614T053838Z">
        <seg>滚动计算输入流中迄今为止最大值，返回该值所在事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum aggregation operation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011943Z" creationid="xccui" creationdate="20190606T011943Z">
        <seg>求最小值的滚动聚合操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum aggregation operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035912Z" creationid="xccui" creationdate="20190406T035912Z">
        <seg>求最小值的滚动聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum of the input stream on the specified field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052715Z" creationid="xccui" creationdate="20190614T052715Z">
        <seg>滚动计算输入流中指定字段的最小值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum of the input stream that returns the event with the lowest</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053812Z" creationid="xccui" creationdate="20190614T053741Z">
        <seg>滚动计算输入流中迄今为止最小值，返回该值所在事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling sum of the input stream on the specified field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052657Z" creationid="xccui" creationdate="20190614T052657Z">
        <seg>滚动计算输入流中指定字段的和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A second, job-independent image is used to deploy TaskManager containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143748Z" creationid="xccui" creationdate="20190606T143748Z">
        <seg>另一个和作业无关的映像负责部署TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A second, job-independent image is used to deploy TaskManagers containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T035719Z" creationid="xccui" creationdate="20190423T035719Z">
        <seg>另一个和作业无关的映像负责部署TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A similar effect appears for operators with two input streams whose watermarks sig‐ nificantly diverge.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033052Z" creationid="xccui" creationdate="20190607T033031Z">
        <seg>算子两个输入流的水位线差距很大时，也会产生类似影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple example is a task that continuously counts how many records it receives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054633Z" creationid="xccui" creationdate="20190607T054544Z">
        <seg>我们以一个持续计算接收到多少条记录的简单任务为例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A source function emits a stream of records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034220Z" creationid="xccui" creationdate="20190607T034220Z">
        <seg>源函数会发出一条记录流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A state backend is responsible for two things: local state management and checkpointing state to a remote location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155046Z" creationid="xccui" creationdate="20190608T051505Z">
        <seg>状态后端主要负责两件事：本地状态管理和将状态检查点写入远程存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A state backend takes care of checkpointing the state of a task to a remote and persistent storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155107Z" creationid="xccui" creationdate="20190608T053657Z">
        <seg>状态后端负责将任务状态以检查点形式写入远程持久化存储，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stateful stream processing task</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054231Z" creationid="xccui" creationdate="20190607T054231Z">
        <seg>带有状态的流处理任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stateful streaming application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T033106Z" creationid="xccui" creationdate="20190305T033106Z">
        <seg>状态化流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream processor that operates a data pipeline should also feature many source and sink connectors to read data from and write data to various storage sys‐ tems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T042729Z" creationid="xccui" creationdate="20190605T042729Z">
        <seg>执行数据管道的流处理引擎为了支持不同外部系统的数据读写，还需要提供多样化的数据源、汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream processor that operates data pipelines should also fea&lt;t0/&gt;‐&lt;t1/&gt; ture many source and sink connectors to read data from and write data to various storage systems and formats.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014637Z" creationid="xccui" creationdate="20190317T015024Z">
        <seg>执行数据管道的流处理引擎为了支持不同格式或外部系统的数据读写，还需要提供多样化的数据源、汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream that is written to an event log can be read many times by the same or different consumers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T054850Z" creationid="xccui" creationdate="20190305T054850Z">
        <seg>写入事件日志的数据流可以被相同或不同的消费者重复读取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream transformation is applied on one or more streams and converts them into one or more output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T013355Z" creationid="xccui" creationdate="20190613T013226Z">
        <seg>流式转换会将一个或多个输入流转换成一个或多个输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream with timestamped records and watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T015017Z" creationid="xccui" creationdate="20190606T205321Z">
        <seg>包含带有时间戳的记录和水位线的数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream with timestamped records and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042320Z" creationid="xccui" creationdate="20190523T042320Z">
        <seg>带有时间戳记录和水位线的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming analytics application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044651Z" creationid="xccui" creationdate="20190605T044651Z">
        <seg>流式分析应用示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming analytics application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062137Z" creationid="xccui" creationdate="20190317T062137Z">
        <seg>流式分析应用示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming applica&lt;t0/&gt;‐&lt;t1/&gt; tion cannot continue processing if the responsible JobManager process disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T043208Z" creationid="xccui" creationdate="20190502T043155Z">
        <seg>如果负责管理的JobManager进程消失，流式应用将无法继续处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming applica‐ tion cannot continue processing if the responsible JobManager process disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145814Z" creationid="xccui" creationdate="20190606T145814Z">
        <seg>如果负责管理的JobManager进程消失，流式应用将无法继续处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming operator with a UDF that turns each incoming event into a black event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T155750Z" creationid="xccui" creationdate="20190405T155317Z">
        <seg>带有UDF的流式算子会将每个到来的事件变黑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming operator with a function that turns each incoming event into a darker event</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011709Z" creationid="xccui" creationdate="20190606T011608Z">
        <seg>带有函数的流式算子会将每个到来的事件变黑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task maintains a partition watermark for each input partition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T024125Z" creationid="xccui" creationdate="20190607T024100Z">
        <seg>一个任务会为它的每个输入分区都维护一个分区水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task of a stateful operator typically reads and updates its state for each incoming record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051142Z" creationid="xccui" creationdate="20190607T230111Z">
        <seg>状态化算子的任务通常会对每一条到来的记录读写状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task receives some input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054300Z" creationid="xccui" creationdate="20190607T054300Z">
        <seg>任务首先会接收一些输入数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A textbook setup consists of a stream processor, a batch pro&lt;t4/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032914Z" creationid="xccui" creationdate="20190327T032745Z">
        <seg>一个典型的配置需要包含流处理引擎、批处理引擎、"提速"存储、批量存储和一系列负责向批处理引擎中加载数据及调度任务的工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A traditional approach to synchronize data in different storage systems is periodic ETL jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T062152Z" creationid="xccui" creationdate="20190604T055001Z">
        <seg>在不同存储系统间同步数据的传统方式是定期执行ETL作业，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A traditional data warehouse architecture for data analytics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203717Z" creationid="esouser" creationdate="20190603T203647Z">
        <seg>用于数据分析的传统数据仓库架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A traditional data warehouse architecture for data analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194730Z" creationid="xccui" creationdate="20190228T194625Z">
        <seg>用于数据分析的传统数据仓库架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark is a global progress metric that indicates a certain point in time when we are confident that no more delayed events will arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205155Z" creationid="xccui" creationdate="20190412T204632Z">
        <seg>水位线是一个全局进度指标，表示我们确信再不会有延迟事件到来的某个时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark is a global progress metric that indicates the point in time when we are confident that no more delayed events will arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025336Z" creationid="xccui" creationdate="20190606T025336Z">
        <seg>水位线是一个全局进度指标，表示我们确信再不会有延迟事件到来的某个时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark with a timestamp T indi‐ cates that all subsequent records should have timestamps &gt; T.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205434Z" creationid="xccui" creationdate="20190606T205434Z">
        <seg>一个拥有时间戳t的水位线表示，接下来所有记录的时间戳一定都大于t。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark with a timestamp t indicates that all subsequent records should have timestamps &gt; t.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042656Z" creationid="xccui" creationdate="20190523T042649Z">
        <seg>一个拥有时间戳t的水位线表示，接下来所有记录的时间戳一定都大于t。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A welcoming community</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030250Z" creationid="xccui" creationdate="20190225T030250Z">
        <seg>欢迎加入社区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040532Z" creationid="xccui" creationdate="20190418T040532Z">
        <seg>A.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ability to run streaming applications 24/7 with very little downtime due to its highly available setup (no single point of failure), tight integration with Kuber‐ netes, YARN, and Apache Mesos, fast recovery from failures, and the ability to dynamically scale jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T121543Z" creationid="xccui" creationdate="20190605T121543Z">
        <seg>支持高可用性配置（无单点失效），和Kubernetes、YARN、Apache Mesos紧密集成，快速故障恢复，动态扩容作业等。基于上述特点，它可以7*24小时运行流式应用，几乎无须停机。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ability to update the application code of jobs and migrate jobs to different Flink clusters without losing the state of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T121551Z" creationid="xccui" creationdate="20190605T121551Z">
        <seg>允许在不丢失应用状态的前提下更新作业的程序代码或进行跨Flink集群的作业迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access to timestamps and watermarks through the API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042406Z" creationid="xccui" creationdate="20190529T042406Z">
        <seg>通过API访问时间戳和水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing state stored by the RocksDB state back‐ end is slower but its state may grow very large.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053243Z" creationid="xccui" creationdate="20190608T053046Z">
        <seg>后者状态访问会慢一些，但允许状态变得很大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acknowledgments</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210942Z" creationid="esouser" creationdate="20190603T210849Z">
        <seg>致谢</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acquisitions Editor: Rachel Roumeliotis Development Editor: Alicia Young Production Editor: Katherine Tozer Copyeditor: Christina Edwards Proofreader: Charles Roumeliotis</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210719Z" creationid="esouser" creationdate="20190603T210719Z">
        <seg>Acquisitions Editor: Rachel Roumeliotis Development Editor: Alicia Young Production Editor: Katherine Tozer Copyeditor: Christina Edwards Proofreader: Charles Roumeliotis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ad-hoc analysis of live data in consumer technology</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045434Z" creationid="xccui" creationdate="20190605T045434Z">
        <seg>消费者技术中的实时数据即席分析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ad-hoc analysis of live data in consumer technology.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033630Z" creationid="xccui" creationdate="20190319T033607Z">
        <seg>消费者技术中的实时数据即席分析等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional require&lt;t2/&gt;‐&lt;t3/&gt; ments to successfully support streaming analytics applications are support for event-time processing in order to produce correct and deterministic results and the ability to process large amounts of data in little time, i.e., high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033210Z" creationid="xccui" creationdate="20190319T033109Z">
        <seg>为了成功支持流式分析应用，还有一些额外需求：支持事件时间处理以便产生正确及确定的结果，能够在短时间内处理大量数据（高吞吐）等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional requirements for data pipelines are the ability to process large amounts of data in short time, i.e., support for high throughput, and the capability to scale an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T014732Z" creationid="xccui" creationdate="20190317T014732Z">
        <seg>它的额外需求是能够在短时间内处理大批量数据，即高吞吐和支持应用扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the stream processor needs to ensure internal state consistency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044439Z" creationid="xccui" creationdate="20190416T044427Z">
        <seg>此外，流处理引擎需要确保内部状态的一致性，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you can fast forward the computation to the present so that once your program catches up with the events happening now, it can continue as a real-time application using exactly the same program logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025218Z" creationid="xccui" creationdate="20190606T025120Z">
        <seg>此外，你可以把计算"快进"到现在，这样一旦你的程序赶上了当前事件产生的进度，它能够以完全相同的程序逻辑作为实时应用继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you can fast-forward the computation to the present so that once your program catches</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155334Z" creationid="xccui" creationdate="20190412T154959Z">
        <seg>此外，你可以把计算"快进"到现在，这样一旦你的程序赶上了当前事件产生的进度，它能够以相同的程序逻辑作为实时应用继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all barriers are sent out, the source continues its regu‐ lar operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T154506Z" creationid="xccui" creationdate="20190609T154335Z">
        <seg>在将所有分隔符发出后，数据源将恢复常规工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all buffered records have been emitted, the task continues processing its input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193332Z" creationid="xccui" creationdate="20190609T193332Z">
        <seg>待所有缓冲的记录处理完后，任务就会继续处理输入流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After an application is restarted from a checkpoint, its internal state is exactly the same as when the checkpoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T051833Z" creationid="xccui" creationdate="20190609T051324Z">
        <seg>在应用从检查点恢复以后，它的内部状态会和生成检查点的时候完全一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After it has been started, a TaskManager registers its slots at the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062107Z" creationid="xccui" creationdate="20190418T051651Z">
        <seg>在TaskManager启动后，会将它的处理槽在ResourceManager中注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After it has been started, a TaskManager registers its slots to the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142555Z" creationid="xccui" creationdate="20190606T142555Z">
        <seg>在TaskManager启动后，会将它的处理槽在ResourceManager中注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After reading this chapter, you will know how to implement a stream processing application with basic functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T032952Z" creationid="xccui" creationdate="20190612T032952Z">
        <seg>本章过后，你将了解如何实现一个具有基本功能的流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, Flink does all of this.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T042759Z" creationid="xccui" creationdate="20190605T042752Z">
        <seg>Flink同样可以做到上述一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, Flink provides all required features to success&lt;t2/&gt;‐&lt;t3/&gt; fully operate data pipelines and includes many connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T024845Z" creationid="xccui" creationdate="20190317T024845Z">
        <seg>Flink 同样为执行数据管道提供了全部所需特性以及多种连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregation operations are stateful and combine the current state with the incoming event to produce an updated aggregate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011759Z" creationid="xccui" creationdate="20190606T011759Z">
        <seg>这些聚合操作是状态化的，它们通过将新到来的事件合并到已有状态来生成更新后的聚合值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregation operations are stateful and combine the current state with the incoming event to produce an updated aggregate value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T034808Z" creationid="xccui" creationdate="20190406T034634Z">
        <seg>这些聚合操作是状态化的，它们通过将新到来的事件合并到已有状态来生成更新后的聚合值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alice is a devoted player who plays the game every morning during her commute to work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T150319Z" creationid="xccui" creationdate="20190411T150319Z">
        <seg>爱丽丝是个铁杆玩家，每天早晨上班路上都会玩这个游戏。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alice keeps on playing and the game events are buffered in her phone.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151613Z" creationid="xccui" creationdate="20190411T151259Z">
        <seg>爱丽丝继续玩她的，此时游戏产生的事件会缓存在手机里，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All functions are evaluated by an individual task running in a dedicated thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155122Z" creationid="esouser" creationdate="20190514T154729Z">
        <seg>每个函数都交由单独的任务，在特定线程内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All issues related to state consistency, failure handling, and efficient storage and access are taken care of by Flink so that developers can focus on the logic of their applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055747Z" creationid="xccui" creationdate="20190607T055712Z">
        <seg>所有和状态一致性，故障处理，高效存取相关的问题都由Flink负责搞定，这样开发人员就可以专注于自己的应用逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the previously mentioned use cases for savepoints follow the same pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214212Z" creationid="xccui" creationdate="20190609T214125Z">
        <seg>所有之前提到的保存点相关用例都遵循同一个模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these systems are typically designed with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T155645Z" creationid="xccui" creationdate="20190226T155406Z">
        <seg>如图1-1所示，上述类型的应用系统通常都会设置独立的数据处理层（应用程序自身）和数据存储层（事务性数据库系统）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these systems store data in different formats and data structures that provide the best performance for their specific access pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T053910Z" creationid="xccui" creationdate="20190604T053820Z">
        <seg>为了再各自访问模式下都能达到最佳性能，上述系统会以不同格式或数据结构存储数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these systems store data in different representations and data structures that provide the best performance for their specific purpose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T065328Z" creationid="xccui" creationdate="20190314T065141Z">
        <seg>为了达到各自场景下的最佳性能，上述系统会以不同表示形式或数据结构存储数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All records that are processed by a Flink event-time streaming application must be accompanied by a timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035343Z" creationid="xccui" creationdate="20190523T035328Z">
        <seg>所有利用Flink基于事件时间的流式应用进行处理的记录都必须包含时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All rights reserved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210712Z" creationid="esouser" creationdate="20190603T210712Z">
        <seg>All rights reserved.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All state modifications due to records that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061818Z" creationid="xccui" creationdate="20190609T061818Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far are &lt;t0/&gt;global&lt;t1/&gt; windows and operate on the full stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193652Z" creationid="xccui" creationdate="20190409T193652Z">
        <seg>至今为止你所见到的所有窗口都是基于全流数据的全局窗口（global window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far are windows that operate on the full stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013831Z" creationid="xccui" creationdate="20190606T013831Z">
        <seg>至今为止你所见到的所有窗口都是基于全流数据的全局窗口（global window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far need to buffer data before performing an operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T204023Z" creationid="xccui" creationdate="20190409T203631Z">
        <seg>至今为止所有你看到的窗口类型都要在执行实际操作前缓冲数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far need to buffer data before producing a result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014527Z" creationid="xccui" creationdate="20190606T014514Z">
        <seg>至今为止所有你看到的窗口类型都要在生成结果前缓冲数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All these use cases require collecting real-time data, analyzing it with low latency, and immediately reacting to the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T054203Z" creationid="xccui" creationdate="20190317T053847Z">
        <seg>所有这些用例都需要收集实时数据、进行低延迟地分析并立即响应结果，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also the internals of a stream processor that supports event-time are more involved than the internals of a system that purely operates in processing-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T033738Z" creationid="xccui" creationdate="20190523T033738Z">
        <seg>此外，相比纯粹使用处理时间，支持事件时间的流处理引擎内部要更加复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also used for module and package names, and to show commands or other text that should be typed literally by the user and the output of commands.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210806Z" creationid="esouser" creationdate="20190603T210806Z">
        <seg>Also used for module and package names, and to show commands or other text that should be typed literally by the user and the output of commands.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the internals of a stream processor that supports event time are more involved than the internals of a system that purely operates in processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204405Z" creationid="xccui" creationdate="20190606T204405Z">
        <seg>此外，相比纯粹使用处理时间，支持事件时间的流处理引擎内部要更加复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alterna&lt;t4/&gt;‐&lt;t5/&gt; tively, Flink provides a feature called queryable state which allows users to expose the state of an application as a key-lookup table and make it accessible for external appli&lt;t6/&gt;‐&lt;t7/&gt; cations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T060943Z" creationid="xccui" creationdate="20190317T060535Z">
        <seg>而Flink提供了一项名为可查询状态（queryable state）的功能，允许用户将应用的状态以键查表（key-lookup table）的形式发布出去，供其他外部应用访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, a 95th-percentile latency value of 10 ms means that 95% of events are processed within 10 ms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234036Z" creationid="xccui" creationdate="20190605T234036Z">
        <seg>而第95百分位延迟在10毫秒意味着95%的事件会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although a program is executed in a single JVM, records are serialized for cross- thread communication and possibly state persistance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T054835Z" creationid="xccui" creationdate="20190611T054835Z">
        <seg>虽然程序运行在单个JVM内，但出于跨线程通信或可能存在的状态持久化考虑，记录都会被序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although not being covered in this book but certainly worth mentioning is that Flink also provides support for analytical SQL queries over streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T040637Z" creationid="xccui" creationdate="20190319T040637Z">
        <seg>虽然本书中并未涉及，但值得一提的是，Flink还支持基于数据流的分析型SQL查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this means Flink processes some messages twice (before and after the failure), the mechanism still achieves exactly-once state consistency because the state of all operators was reset to a point that had not seen this data yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T053520Z" creationid="xccui" creationdate="20190609T053400Z">
        <seg>虽然这意味着Flink进程会重复处理部分消息，但上述机制仍然可以实现精确一次的状态一致性，因为所有算子的状态都会重置到过去还没有处理过那些数据的时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although we don’t cover it here, Flink also provides support for analytical SQL quer‐ ies over streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045441Z" creationid="xccui" creationdate="20190605T045441Z">
        <seg>虽然本书中并未涉及，但值得一提的是，Flink还支持基于数据流的分析型SQL查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An ETL process extracts data from a transactional database, transforms it into a common representation that might include validation, value normalization, encoding, deduplication, and schema trans‐ formation, and finally loads it into the analytical database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T202833Z" creationid="esouser" creationdate="20190603T202811Z">
        <seg>ETL的基本流程是：从事务型数据库中提取数据，将其转换为通用表示形式（可能包含数据验证、数据归一化、编码、去重、格式转换等工作），最终写入到分析型数据库中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An ETL process extracts data from a transactional database, transforms it into a common representation which might include validation, value normalization, encoding, de-duplication, and schema transformation, and finally loads it into the analytical database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192143Z" creationid="xccui" creationdate="20190228T190902Z">
        <seg>ETL的基本流程是：从事务型数据库中提取数据，将其转换为通用表示形式（可能包含数据验证、数据归一化、编码、去重、格式转换等工作），最终写入到分析型数据库中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An IDE for Java and/or Scala development.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T020738Z" creationid="xccui" creationdate="20190611T020738Z">
        <seg>用于Java/Scala开发的IDE。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative is to use an event log to distribute updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T062315Z" creationid="xccui" creationdate="20190604T062308Z">
        <seg>另一个替代方案是使用事件日志系统来分发更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application consists of multiple operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214439Z" creationid="xccui" creationdate="20190609T214422Z">
        <seg>每个应用都会包含很多算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application is recovered in three steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040030Z" creationid="xccui" creationdate="20190609T040030Z">
        <seg>应用恢复要经过3个步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application receiving game events would experience a gap when the train goes through a tunnel and network con&lt;t0/&gt;‐&lt;t1/&gt; nection is lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152946Z" creationid="xccui" creationdate="20190411T152813Z">
        <seg>当地铁进入隧道断网时，应用接收游戏事件会经历一段间隙。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application receiving online mobile game events played on the subway would experience a gap when the network connection is lost, but events are buffered in the player’s phone and delivered when the connection is restored</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023511Z" creationid="xccui" creationdate="20190606T015305Z">
        <seg>当地铁进入隧道断网时，应用接收游戏事件会中断一会，此时事件会缓存在玩家手机中，并在网络恢复后发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An attribution usually includes the title, author, publisher, and ISBN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210823Z" creationid="esouser" creationdate="20190603T210823Z">
        <seg>An attribution usually includes the title, author, publisher, and ISBN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An embedded execution mode starts Flink applications as a single JVM process which can be used to run and debug Flink jobs within an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T053733Z" creationid="xccui" creationdate="20190328T053510Z">
        <seg>Flink的嵌入式执行模式可将应用以单个JVM进程的方式启动，方便在IDE里运行和调试Flink作业，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event log stores and distributes event streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T054357Z" creationid="xccui" creationdate="20190305T054122Z">
        <seg>事件日志负责存储事件流并将其分布式化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event time window computation will yield the same result no matter how fast the stream is pro‐ cessed or when the events arrive at the operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024326Z" creationid="xccui" creationdate="20190606T024326Z">
        <seg>无论数据流的处理速度如何、事件到达算子的顺序怎样，基于事件时间的窗口都会生成同样的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-driven application architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213914Z" creationid="esouser" creationdate="20190603T213914Z">
        <seg>事件驱动型应用架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-driven application architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152556Z" creationid="xccui" creationdate="20190307T152556Z">
        <seg>事件驱动型应用架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-time window computation will yield the same result no matter how fast the stream is pro&lt;t0/&gt;‐&lt;t1/&gt; cessed or when the events arrive at the operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T151505Z" creationid="xccui" creationdate="20190412T151505Z">
        <seg>无论数据流的处理速度如何、事件到达算子的顺序怎样，基于事件时间的窗口都会生成同样的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example application would be a real-time monitoring dashboard that displays event aggregates as they are received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031104Z" creationid="xccui" creationdate="20190414T043802Z">
        <seg>一个常见示例应用是实时监控仪表盘，它会接收并展示事件聚合结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interesting property of watermarks is that they allow an application to control result completeness and latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035910Z" creationid="xccui" creationdate="20190529T035835Z">
        <seg>水位线的一个有趣之处在于，它们允许应用控制结果的完整性和延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An on-going effort of the Flink community is to evolve Flink towards a system with a unified batch and streaming API and runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T061543Z" creationid="xccui" creationdate="20190328T061256Z">
        <seg>社区正在努力的一个方向就是将Flink发展成为在API及运行时层面都能做到批流统一的系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An ongoing effort of the Flink community is to evolve Flink toward a system with a truly unified batch and streaming API and runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122304Z" creationid="xccui" creationdate="20190605T122304Z">
        <seg>社区正在努力的一个方向就是将Flink发展成为在API及运行时层面都能做到批流统一的系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An online retailer is able to recommend products to users while they are browsing on the retailer’s website; mobile games can give virtual gifts to users to keep them in a game or offer in-game purchases at the right moment; manufacturers can monitor the behavior of machines and trigger maintenance actions to reduce production outages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T053555Z" creationid="xccui" creationdate="20190317T053555Z">
        <seg>在线商家可以在用户浏览店铺页面的同时为其推荐产品；移动游戏为了提高用户粘性可以适时为其发放虚拟礼品或提供内购折扣；制造商可以通过监测机器行为及时触发维护，从而减少生产中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator pipeline that complies with the requirements of task chaining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203432Z" creationid="xccui" creationdate="20190606T203431Z">
        <seg>满足任务链接需求的算子流水线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator pipeline that complies with the requirements of task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152418Z" creationid="esouser" creationdate="20190514T152418Z">
        <seg>满足任务链接需求的算子流水线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Analytical Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142900Z" creationid="esouser" creationdate="20190603T142900Z">
        <seg>分析型处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Analyzing user behavior in mobile applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045426Z" creationid="xccui" creationdate="20190605T045425Z">
        <seg>移动应用中的用户行为分析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Analyzing user behavior in mobile applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033623Z" creationid="xccui" creationdate="20190319T033421Z">
        <seg>移动应用中的用户行为分析，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And everyone knows that the mobile inter&lt;t0/&gt;‐&lt;t1/&gt; net connection in the Berlin subway is lousy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151131Z" creationid="xccui" creationdate="20190411T150417Z">
        <seg>而众所周知，柏林地铁上手机网络信号很差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And everyone knows that the mobile internet connection in the Berlin subway is lousy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T015018Z" creationid="xccui" creationdate="20190606T014954Z">
        <seg>而众所周知，柏林地铁上手机上网信号很差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And how do we even know that data will be delayed?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T203758Z" creationid="xccui" creationdate="20190412T161851Z">
        <seg>此外，我们如何得知数据会产生延迟？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And in those cases, will the output be deterministic?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043528Z" creationid="xccui" creationdate="20190415T043222Z">
        <seg>在上述情况下，结果是否确定？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And in those cases, will the out‐ put be deterministic?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033643Z" creationid="xccui" creationdate="20190606T033643Z">
        <seg>在上述情况下，结果是否确定？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anomaly detection (e.g., to detect attempts to intrude a computer network)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213713Z" creationid="esouser" creationdate="20190603T213713Z">
        <seg>异常检测（例如：计算机网络入侵检测）等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anomaly detection, e.g., to detect attempts to intrude a computer network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T151741Z" creationid="xccui" creationdate="20190307T151741Z">
        <seg>异常检测（例如：计算机网络入侵检测）等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another approach that works for many storage systems is idempotent updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054318Z" creationid="xccui" creationdate="20190609T054237Z">
        <seg>另一种适用于很多存储系统的方法是幂等更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another case is when you need to periodically report results in real time, independently of their accuracy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031009Z" creationid="xccui" creationdate="20190606T031009Z">
        <seg>另一种情况是，你需要周期性地实时报告结果，而不考虑其准确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another case is when you need to periodically report results in real-time, independently of their accuracy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043410Z" creationid="xccui" creationdate="20190414T043410Z">
        <seg>另一种情况是，你需要周期性地实时报告结果，而不考虑其准确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another factor that affects latency and consequently throughput is the time it takes to process an event, or the time it takes for each customer to be served in the coffee shop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T205647Z" creationid="xccui" creationdate="20190402T205438Z">
        <seg>影响延迟和相应吞吐的另一因素是处理单个事件的时间，即在咖啡店服务每一名顾客所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another improvement was the dissolution of the latency-throughput trade-off.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T134512Z" creationid="xccui" creationdate="20190327T134512Z">
        <seg>系统另一方面的改进是消除了延迟和吞吐的代价权衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another improvement was the dissolu‐ tion of the latency/throughput tradeoff.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053531Z" creationid="xccui" creationdate="20190605T053453Z">
        <seg>它的另一项改进是消除了延迟和吞吐的代价权衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another state backend serializes state objects and puts them into RocksDB, which writes them to local hard disks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T052613Z" creationid="xccui" creationdate="20190608T052302Z">
        <seg>另一类状态后端会把状态对象序列化后存到RocksDB里面，RocksDB负责将它们写到本地硬盘上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another technique to reduce the checkpointing algorithm’s impact on the processing latency is to tweak the barrier alignment step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T204202Z" creationid="xccui" creationdate="20190609T204102Z">
        <seg>我们还可以调整分隔符对齐这一步，来降低检查点算法对处理延迟的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve equivalent functionality is using record acknowledgements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T043605Z" creationid="xccui" creationdate="20190416T043447Z">
        <seg>另一个实现同样功能的途径是启用记录确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve equivalent functionality is using record acknowledgments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034729Z" creationid="xccui" creationdate="20190606T034729Z">
        <seg>另一个实现同样功能的途径是启用记录确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve the same result is to hire a second barista and exploit parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235436Z" creationid="xccui" creationdate="20190605T235436Z">
        <seg>另一个殊途同归的办法是再雇一个咖啡师，即利用并发解决问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve the same result is to hire a second barista, that is, to exploit parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211453Z" creationid="xccui" creationdate="20190402T211202Z">
        <seg>另一个殊途同归的办法是再雇一个咖啡师，即利用并发解决问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Answering a question by citing this book and quoting example code does not require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210820Z" creationid="esouser" creationdate="20190603T210820Z">
        <seg>Answering a question by citing this book and quoting example code does not require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any application that processes a stream of events and does not just perform trivial record-at-a-time transformations needs to be stateful, i.e., have the ability to store and access intermediate data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T030539Z" creationid="xccui" creationdate="20190305T030539Z">
        <seg>任何需要处理事件流的应用程序，如果支持跨多条记录的转换操作，则必须是状态化的，因为需要存储和访问中间结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any application that processes a stream of events and does not just perform trivial record-at-a-time transformations needs to be stateful, with the ability to store and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T205831Z" creationid="esouser" creationdate="20190603T205538Z">
        <seg>任何需要处理事件流的应用程序，如果支持跨多条记录的转换操作，都需要是状态化的，能够存储和访问中间结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Cassandra Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025211Z" creationid="xccui" creationdate="20190225T025211Z">
        <seg>Apache Cassandra汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T042850Z" creationid="xccui" creationdate="20190606T042850Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink checks all these boxes and is a very good choice to run event-driven applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T064114Z" creationid="xccui" creationdate="20190314T062533Z">
        <seg>Apache Flink 能够同时涵盖上述全部特性，是运行事件驱动型应用的一个非常好的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink checks all these boxes and is a very good choice to run this class of applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T053737Z" creationid="xccui" creationdate="20190604T053710Z">
        <seg>Apache Flink 能够同时涵盖上述全部特性，是运行该类应用的一个非常好的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink is a distributed stream processor of the third generation with a compet&lt;t0/&gt;‐&lt;t1/&gt; itive feature set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T041127Z" creationid="xccui" creationdate="20190328T002907Z">
        <seg>Apache Flink是一个集众多具有竞争力的特性于一身的第三代流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink is a distributed stream processor with intuitive and expressive APIs to implement stateful stream processing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014455Z" creationid="xccui" creationdate="20190225T191847Z">
        <seg>Apache Flink是一个分布式流处理引擎，它提供了直观且极富表达力的API来实现状态化流处理应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink is a third-generation distributed stream processor with a competitive feature set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054018Z" creationid="xccui" creationdate="20190605T054018Z">
        <seg>Apache Flink是一个集众多具有竞争力的特性于一身的第三代流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink stores application state locally in memory or in an embedded database and not in a remote database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T031826Z" creationid="xccui" creationdate="20190305T031826Z">
        <seg>Apache Flink使用本地内存和嵌入式数据库（而非远程数据库）存储状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink stores the application state locally in memory or in an embedded data‐ base.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210000Z" creationid="esouser" creationdate="20190603T205946Z">
        <seg>Apache Flink使用本地内存和嵌入式数据库存储状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Hadoop YARN</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040315Z" creationid="xccui" creationdate="20190418T040315Z">
        <seg>Apache Hadoop YARN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Kafka Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025141Z" creationid="xccui" creationdate="20190225T025141Z">
        <seg>Apache Kafka汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Kafka Source Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025132Z" creationid="xccui" creationdate="20190225T025132Z">
        <seg>Apache Kafka源连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Maven 3.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T020152Z" creationid="xccui" creationdate="20190611T020152Z">
        <seg>Apache Maven 3.x版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from having a practical value, windows also enable semantically interesting queries on streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T042412Z" creationid="xccui" creationdate="20190406T042112Z">
        <seg>除了产生单个有用的结果，窗口操作还支持数据流上一些语义很有趣的查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appendix Title.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040542Z" creationid="xccui" creationdate="20190418T040542Z">
        <seg>附录标题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application Consistency Guarantees</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025111Z" creationid="xccui" creationdate="20190225T025111Z">
        <seg>应用的一致性保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application Deployment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021747Z" creationid="xccui" creationdate="20190225T021747Z">
        <seg>应用部署</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application submission and component interactions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143131Z" creationid="xccui" creationdate="20190606T143129Z">
        <seg>应用提交及组件交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application submission and component interactions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024603Z" creationid="xccui" creationdate="20190423T024603Z">
        <seg>应用提交及组件交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications are usually connected to external services or face human users and con‐ tinuously process incoming events such as orders, email, or clicks on a website.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T195503Z" creationid="esouser" creationdate="20190603T195414Z">
        <seg>它们通常会连接外部服务或真人用户，并持续处理诸如订单、邮件、网站点击等传入的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications can also be individually operated and scaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214115Z" creationid="esouser" creationdate="20190603T214115Z">
        <seg>同时，全部应用都支持独立操作和扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications can be individually operated and scaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T073447Z" creationid="xccui" creationdate="20190308T073358Z">
        <seg>同时，全部应用都支持独立操作和扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications consume the results by merging approximated results from the speed table and the accurate results from the batch table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052646Z" creationid="xccui" creationdate="20190605T052414Z">
        <seg>为了获取最终结果，应用需要将"提速表"中的近似结果以及批处理表中的精确结果合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications consume the results from the Serving Layer by merging the most recent but only approximated results from the speed table and the older but accurate result from the batch table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T045050Z" creationid="xccui" creationdate="20190322T053047Z">
        <seg>应用通过合并"提速表"中的较新的近似结果以及批处理表中较旧的精确结果来从服务层获取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145100Z" creationid="esouser" creationdate="20190603T145053Z">
        <seg>应用转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply streaming transformations to implement the application logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043619Z" creationid="xccui" creationdate="20190612T043619Z">
        <seg>通过一系列流式转换来实现应用逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022606Z" creationid="xccui" creationdate="20190225T022606Z">
        <seg>应用转换操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying Functions on Windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023223Z" creationid="xccui" creationdate="20190225T023223Z">
        <seg>在窗口上应用函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>April 2019:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210727Z" creationid="esouser" creationdate="20190603T210727Z">
        <seg>April 2019:</seg>
      </tuv>
    </tu>
    <tu>
      <note>后面加了一个service</note>
      <tuv lang="EN-US">
        <seg>Architecture and Enabling Queryable State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151548Z" creationid="xccui" creationdate="20190225T025000Z">
        <seg>可查询式状态服务的架构及启用方式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguably, one could use an external system to also manage streaming state, even though this design choice might introduce additional latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T054652Z" creationid="xccui" creationdate="20190414T054541Z">
        <seg>讲道理，虽然可能引入额外延迟，但完全可以同样用一个外部系统来管理流式状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguably, we could use an external system to also manage streaming state, even though this design choice might introduce additional latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032425Z" creationid="xccui" creationdate="20190606T032201Z">
        <seg>按理说，虽然可能引入额外延迟，但我们完全可以同样用一个外部系统来管理流式状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a Windows user you can use the Windows subsystem for Linux (WSL), Cygwin, or a Linux virtual machine to run Flink in a UNIX environ‐ ment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T014711Z" creationid="xccui" creationdate="20190611T014711Z">
        <seg>如果你是Windows用户，可以使用自带的（译者注：Win10版本以上）Linux子系统（WSL）、Cygwin或Linux虚拟机来在类UNIX环境下运行Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a con‐ sequence, an application with default operator identifiers is very limited in how it can be evolved without losing state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T030644Z" creationid="xccui" creationdate="20190610T025637Z">
        <seg>因此使用默认算子标识的应用如果不想丢失状态，那么改动空间比较有限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed before, Flink requires a sufficient amount of processing slots in order to execute all tasks of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205357Z" creationid="xccui" creationdate="20190428T205349Z">
        <seg>如前所述，为了执行应用的全部任务，Flink需要足够数量的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed before, Flink requires a sufficient number of processing slots in order to execute all tasks of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145426Z" creationid="xccui" creationdate="20190606T145426Z">
        <seg>如前所述，为了执行应用的全部任务，Flink需要足够数量的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in “A Quick Look at Flink” on page 12, the program generates read events for multiple thermal sensors, converts the temperature of the events from Fahrenheit to Celsius, and computes the average temperature of each sensor every second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053343Z" creationid="xccui" creationdate="20190611T042330Z">
        <seg>我们在第12页"Flink快览"中讲过，这个程序会模拟生成多个热传感器的读数事件，将其中的温度由华氏度改为摄氏度，然后计算每个传感器每秒钟的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As explained in “Com‐ ponents of a Flink Setup” on page 38, a Flink application is submitted to the JobMan‐ ager (master), which distributes execution tasks to one or more TaskManagers (workers).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T051138Z" creationid="xccui" creationdate="20190611T051138Z">
        <seg>正如之前第38页"Flink设置组件"中所介绍的，Flink应用会提交至JobManager（master），后者负责将需要执行的任务分配给一个或多个TaskManager（worker）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As motivated in &lt;t2/&gt;Chapter 2&lt;t3/&gt;, a certain degree of timestamp out-of-orderness is given in basically all real-world use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040054Z" creationid="xccui" creationdate="20190523T040054Z">
        <seg>正如第2章所述，基本上所有现实世界的应用场景都会出现一定程度的时间戳乱序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As one could imagine, supporting stateful operators comes with a few implementa&lt;t0/&gt;‐&lt;t1/&gt; tion challenges:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T033138Z" creationid="xccui" creationdate="20190414T055834Z">
        <seg>不难想象，支持状态化算子将面临很多实现上的挑战：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As previously stated, stateful stream processing is a versatile and flexible design archi‐ tecture that can be used for many different use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T211912Z" creationid="esouser" creationdate="20190603T211912Z">
        <seg>如上所述，状态化流处理是一种用途广泛、灵活多变的设计模式，可用来解决很多不同的用例问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As previously stated, stateful streaming processing is a versatile and flexible design pattern and can be used to address many different use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T145813Z" creationid="xccui" creationdate="20190305T145258Z">
        <seg>如上所述，状态化流处理是一种用途广泛、灵活多变的设计模式，可用来解决很多不同的用例问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As seen in “Time Semantics”, a certain degree of timestamp out-of- orderness is given in basically all real-world use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204914Z" creationid="xccui" creationdate="20190606T204903Z">
        <seg>正如"时间语义"一节所述，基本上所有现实世界的应用场景都会出现一定程度的时间戳乱序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in &lt;t3/&gt;Figure 1-8&lt;t4/&gt;, you will see some statistics about the local Flink cluster you just started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035221Z" creationid="xccui" creationdate="20190329T035158Z">
        <seg>如图1-8所示，你会看到一些有关刚刚启动的本地Flink集群的统计信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in &lt;t4/&gt;Figure 2-12&lt;t5/&gt;, in Alice’s case, a processing-time window would continue counting time when her phone gets discon&lt;t6/&gt;‐&lt;t7/&gt; nected, thus not accounting for her game activity during that time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145241Z" creationid="xccui" creationdate="20190412T144815Z">
        <seg>如图2-12所示，在爱丽丝的例子中，处理时间窗口在她手机离线后会继续计时，因此不会把她在那段时间的活动考虑在内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in Figure 1-8, you will see some statistics about the local Flink cluster you just started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123250Z" creationid="xccui" creationdate="20190605T123250Z">
        <seg>如图1-8所示，你会看到一些有关刚刚启动的本地Flink集群的统计信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in Figure 2-12, in Alice’s case, a processing-time window would continue counting time when her phone gets discon‐ nected, thus not accounting for her game activity during that time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023852Z" creationid="xccui" creationdate="20190606T023852Z">
        <seg>如图2-12所示，在爱丽丝的例子中，处理时间窗口在她手机离线后会继续计时，因此不会把她在那段时间的活动考虑在内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in Figure 3-4, each of the four sender tasks needs at least four network buf‐ fers to send data to each of the receiver tasks and each receiver task requires at least four buffers to receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T200858Z" creationid="xccui" creationdate="20190606T200713Z">
        <seg>如图3-4所示，每个发送端任务至少需要4个网络缓冲区来向任一接收端任务发送数据，而同样每个接收端任务也需要至少4个缓冲区来接收数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as a task has received barriers from all its input partitions, it initiates a check‐ point at the state backend and broadcasts the checkpoint barrier to all of its down‐ stream connected tasks as shown in Figure 3-23.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T192605Z" creationid="xccui" creationdate="20190609T175243Z">
        <seg>如图3-23所示，任务在收齐全部输入分区发送的分隔符后，就会通知状态后端开始生成检查点，同时把检查点分隔符广播到下游相连的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as one parti‐ tion does not advance its watermarks or becomes completely idle and does not ship any records or watermarks, the event-time clock of a task will not advance and the timers of the task will not trigger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T032427Z" creationid="xccui" creationdate="20190607T032231Z">
        <seg>只要有一个分区的水位线没有前进或分区完全空闲下来不再发送任何记录或水位线，任务的事件时间时钟就不会前进，继而导致定时器无法触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the first event comes in, it will be immediately processed with the minimum latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T205859Z" creationid="xccui" creationdate="20190401T204654Z">
        <seg>当第一个事件到来，系统会立刻以尽可能低的延迟进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the name suggests, a dataflow program describes how data flows between opera&lt;t0/&gt;‐&lt;t1/&gt; tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T175511Z" creationid="xccui" creationdate="20190329T175404Z">
        <seg>顾名思义，dataflow程序描述了数据如何在操作之间流动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the name suggests, a dataflow program describes how data flows between opera‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224746Z" creationid="xccui" creationdate="20190605T224746Z">
        <seg>顾名思义，Dataflow程序描述了数据如何在操作之间流动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you might imagine, supporting stateful operators comes with a few implementa‐ tion challenges:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032848Z" creationid="xccui" creationdate="20190606T032848Z">
        <seg>不难想象，支持状态化算子将面临很多实现上的挑战：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you saw in “Data Parallelism and Task Parallelism” on page 18, Flink splits data streams into partitions and processes each partition in parallel by a separate operator task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T014811Z" creationid="xccui" creationdate="20190607T014501Z">
        <seg>正如第18页"数据并行和任务并行"一节所述，Flink会将数据流划分为不同的分区，交由不同的算子任务来并行执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning Timestamps and Generating Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040510Z" creationid="esouser" creationdate="20190603T145731Z">
        <seg>分配时间戳和生成水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Asynchronous checkpointing significantly reduces the time until a task continues to process data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203815Z" creationid="xccui" creationdate="20190609T203754Z">
        <seg>异步生成检查点可以有效降低任务恢复数据处理所需等待的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Asynchronously Accessing External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025331Z" creationid="xccui" creationdate="20190225T025331Z">
        <seg>异步访问外界系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At high load, this change will also increase through&lt;t2/&gt;‐&lt;t3/&gt; put, because more customers will be served in the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211113Z" creationid="xccui" creationdate="20190402T210925Z">
        <seg>这样在高峰时段，相同时间内可以服务的顾客数量多了，吞吐量也自然会提高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At high load, this change will also increase throughput, because more customers will be served in the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235407Z" creationid="xccui" creationdate="20190605T235407Z">
        <seg>这样在高峰时段，相同时间内可以服务的顾客数量多了，吞吐量也自然会提高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the book’s GitHub page, you will find one repository with Scala examples and one repository with Java exam‐ ples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T035852Z" creationid="xccui" creationdate="20190611T035708Z">
        <seg>在书籍的GitHub页面上，你会看到两个分别包含Scala示例和Java示例的代码仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the same time, the result completeness might suffer because relevant records might not be included in the result and would be considered as late records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040404Z" creationid="xccui" creationdate="20190529T040337Z">
        <seg>但同时结果的完整性可能受到影响，因为会有部分相关记录被视为迟到记录，没能参与运算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the source: Timestamps and watermarks can be assigned and generated by a SourceFunction when a stream is ingested into an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034107Z" creationid="xccui" creationdate="20190607T034006Z">
        <seg>在数据源完成：可以利用SourceFunction在应用读入数据流的时候分配时间戳和生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point the system has reached the peak throughput and further increasing the event rate will only result in worse latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T201509Z" creationid="xccui" creationdate="20190402T201054Z">
        <seg>此时系统吞吐已到极限，一味提高事件到达速率只会让延迟更糟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, it should be clear that latency and throughput are not independent met‐ rics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234939Z" creationid="xccui" creationdate="20190605T234918Z">
        <seg>至此你应该已经明白，延迟和吞吐并非相互独立的指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, it should be quite clear that latency and throughput are not independ&lt;t0/&gt;‐&lt;t1/&gt; ent metrics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T203113Z" creationid="xccui" creationdate="20190402T203103Z">
        <seg>至此你应该很清楚，延迟和吞吐并非相互独立的指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, the system has reached its peak throughput and further increasing the event rate will only result in worse latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234736Z" creationid="xccui" creationdate="20190605T234736Z">
        <seg>此时系统吞吐已到极限，一味提高事件到达速率只会让延迟更糟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, you might be wondering why we would even bother with processing time if event time solves all of our problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T030646Z" creationid="xccui" creationdate="20190606T030452Z">
        <seg>此刻你可能会有些疑惑：既然事件时间能够解决所有问题，为什么还去"劳烦"处理时间呢？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, you might be wondering: &lt;t0/&gt;Since event time solves all of our problems, why&lt;t1/&gt; &lt;t2/&gt;even bother considering processing time?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T040412Z" creationid="xccui" creationdate="20190414T040247Z">
        <seg>此刻你可能会有些疑惑：既然事件时间能够解决所有问题，为什么还去费劲地考虑处理时间呢？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-Least-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050818Z" creationid="xccui" creationdate="20190415T050818Z">
        <seg>至少一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-Most-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050811Z" creationid="xccui" creationdate="20190415T050757Z">
        <seg>至多一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-least-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034515Z" creationid="xccui" creationdate="20190606T034515Z">
        <seg>至少一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-most-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034320Z" creationid="xccui" creationdate="20190606T034320Z">
        <seg>至多一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-most-once is the trivial case that guarantees processing of each event at most once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034341Z" creationid="xccui" creationdate="20190606T034341Z">
        <seg>至多一次也是最简单的情况，它保证每个事件至多被处理一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-most-once is the trivial case that guarantees processing of each event at-most-once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T184428Z" creationid="xccui" creationdate="20190415T184345Z">
        <seg>至多一次也是最简单的情况，它保证每个事件至多被处理一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Average values hide the true distribution of processing delays and might make it hard to detect problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T155538Z" creationid="xccui" creationdate="20190401T155435Z">
        <seg>平均值会掩盖处理延迟的真实分布，继而导致难以发现问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Based on the key, the events of the stream are assigned to partitions, so that all</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050345Z" creationid="xccui" creationdate="20190614T050345Z">
        <seg>根据键值，流中的事件会被分配到不同分区，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022712Z" creationid="xccui" creationdate="20190225T022712Z">
        <seg>基本转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic transformations are transformations on individual events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T065149Z" creationid="xccui" creationdate="20190613T024209Z">
        <seg>基本转换是作用于单条事件的转换；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic transformations process individual events, meaning that each output record was produced from a single input record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T025056Z" creationid="xccui" creationdate="20190613T024932Z">
        <seg>基本转换用于单独处理每个事件，也就是说每条输出记录都是由单条输入记录所生成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Batch applications can - in addition to pipelined communication - exchange data by collecting outgoing data at the sender.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045346Z" creationid="xccui" creationdate="20190504T045346Z">
        <seg>批处理应用除了流水线式通信，还可以在发送端收集全部需要发出的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Batch applications can—in addition to pipelined communication—exchange data by collecting outgoing data at the sender.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T200625Z" creationid="xccui" creationdate="20190606T200625Z">
        <seg>批处理应用除了流水线式通信，还可以在发送端收集全部需要发出的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200742Z" creationid="esouser" creationdate="20190603T200742Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because efficient state access is crucial to processing records with low latency, each parallel task locally maintains its state to ensure fast state accesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051223Z" creationid="xccui" creationdate="20190608T051037Z">
        <seg>因此高效的状态访问对于记录处理的低延迟而言至关重要。为了保证快速访问状态，每个并行任务都会把状态维护在本地。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because microservices are strictly decoupled from each other and only communicate over well defined inter&lt;t4/&gt;‐&lt;t5/&gt; faces, each microservice can be implemented with a custom technology stack includ&lt;t6/&gt;‐&lt;t7/&gt; ing programming language, libraries, and data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172603Z" creationid="xccui" creationdate="20190227T234310Z">
        <seg>由于微服务彼此间严格解耦且仅通过定义良好的接口通信，因此每个微服务可以选用不同的技术栈，即编程语言、类库和数据存储等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the choice of the timestamp is application-specific and the watermarks depend on the timestamps and characteris‐ tics of the stream, applications have to explicitly assign timestamps and generate watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033908Z" creationid="xccui" creationdate="20190607T033908Z">
        <seg>由于不同的应用会选择不同的时间戳，而水位线依赖于时间戳和数据流本身的特征，应用必须显式地分配时间戳和生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this strategy replicates data and involves network communication, it is fairly expensive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233449Z" creationid="xccui" creationdate="20190401T135000Z">
        <seg>该策略会把数据复制多份且涉及网络通信，因此代价十分昂贵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before execution, these are translated into physical dataflow graphs of connected parallel tasks, each running some operator logic, consuming input streams and producing output streams for other tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033440Z" creationid="xccui" creationdate="20190606T033145Z">
        <seg>在执行之前，它们需要被翻译为物理Dataflow图，其中包含很多相连的并行任务。每个任务都要运行一部分算子逻辑，消费输入流并为其他任务生成输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before execution, these are translated into physical dataflow graphs of many connected parallel tasks, each running some operator logic, consuming input streams and producing output streams for other tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T041429Z" creationid="xccui" creationdate="20190415T041131Z">
        <seg>在执行之前，他们需要被翻译为连接很多并行任务的物理dataflow图。其中每个任务都要运行一部分算子逻辑，消费输入流并为其他任务生成输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before the rise of modern stream processors, a common approach to process unbounded data was to repeatedly schedule jobs over small batches of incoming events on a batch processing system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032032Z" creationid="xccui" creationdate="20190606T031812Z">
        <seg>在当今流处理引擎出现之前，处理无限数据的通用办法是将到来事件分成小批次，不停地调度任务在批处理系统上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we delve into the fundamentals of stream processing, let’s look at the back‐ ground on dataflow programming and the terminology we will use throughout this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224735Z" creationid="xccui" creationdate="20190605T224735Z">
        <seg>在深入研究流处理的基础知识之前，我们需要先介绍Dataflow编程的必要背景并建立起贯穿整书的术语体系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we delve into the fundamentals of stream processing, we must first introduce the necessary background on &lt;t0/&gt;dataflow&lt;t1/&gt; programming and establish the terminology that we will use throughout this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T175319Z" creationid="xccui" creationdate="20190329T054324Z">
        <seg>在深入研究流处理的基本知识之前，我们需要先介绍dataflow编程的必要背景，建立起贯穿整书的术语体系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we describe the different types of guarantees, we need to clarify a few points that are often the source of confusion when discussing task failures in stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044835Z" creationid="xccui" creationdate="20190415T044718Z">
        <seg>在讨论不同类型的保障之前，我们需要澄清一些在讨论流处理引擎任务故障时容易导致困惑的点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we describe the different types of guarantees, we need to clarify a few points that are often the source of confusion when discussing task failures in stream pro‐ cessors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034159Z" creationid="xccui" creationdate="20190606T034159Z">
        <seg>在讨论不同类型的保障之前，我们需要澄清一些在讨论流处理引擎任务故障时容易导致困惑的点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we discuss its use cases, we briefly explain how stateful stream process&lt;t2/&gt;‐&lt;t3/&gt; ing works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T203558Z" creationid="xccui" creationdate="20190301T203506Z">
        <seg>在讨论这些用例之前，我们首先简要解释一下状态化流处理的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we discuss its use cases, we briefly explain how stateful stream processing works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T205531Z" creationid="esouser" creationdate="20190603T205531Z">
        <seg>在讨论这些用例之前，我们首先简要解释一下状态化流处理的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beijing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210636Z" creationid="esouser" creationdate="20190603T210636Z">
        <seg>Beijing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the much shorter time needed for an event to be incorporated into an analyt‐ ics result, there is another, less obvious, advantage of streaming analytics applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044746Z" creationid="xccui" creationdate="20190605T044658Z">
        <seg>除了将事件整合到分析结果的用时更短，流式分析应用还有另一个不太显眼的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the much smaller time for an event to be incorporated into an analytics result, there is another, less obvious, advantage of streaming analytics applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062434Z" creationid="xccui" creationdate="20190317T062251Z">
        <seg>除了将事件整合到分析结果用时较短，流式分析应用还有另一个不太显眼的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Black squares are duplicated, and gray squares are filtered out.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054533Z" creationid="xccui" creationdate="20190613T054410Z">
        <seg>如果是黑色方块会将其复制；如果是灰色方块会将其过滤掉。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bob and Alice play the same game but have different mobile pro‐ viders.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024443Z" creationid="xccui" creationdate="20190606T024443Z">
        <seg>鲍勃和爱丽丝虽然玩的游戏相同，但他们的移动网络供应商不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bob and Alice play the same game but they have different mobile providers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T152216Z" creationid="xccui" creationdate="20190412T152216Z">
        <seg>鲍勃和爱丽丝虽然玩的游戏相同，但他们的移动网络供应商不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bootstrap a Flink Maven Project</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004254Z" creationid="esouser" creationdate="20190603T145025Z">
        <seg>创建Flink Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bootstrap a Flink Maven project</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022358Z" creationid="xccui" creationdate="20190225T022358Z">
        <seg>启用Flink Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boston</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210638Z" creationid="esouser" creationdate="20190603T210638Z">
        <seg>Boston</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both aspects are discussed in later sections of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T185654Z" creationid="xccui" creationdate="20190607T185654Z">
        <seg>我们同样会在本章稍后讨论它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both kinds of queries are executed by a data warehouse in a batch processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194232Z" creationid="xccui" creationdate="20190228T194049Z">
        <seg>无论哪一类查询，都是在数据仓库中以批处理的方式执行，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both kinds of queries are executed by a data warehouse in a batch processing fashion, as shown in Figure 1-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203619Z" creationid="esouser" creationdate="20190603T203548Z">
        <seg>如图1-3所示，无论哪一类查询，都是在数据仓库中以批处理的方式执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184737Z" creationid="xccui" creationdate="20190607T184737Z">
        <seg>广播状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffering is a mandatory technique to fully utilize the bandwidth of network connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T210224Z" creationid="esouser" creationdate="20190513T210224Z">
        <seg>若想充分利用网络连接带宽，缓冲是一项必要技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffering is needed to fully utilize the bandwidth of network connec‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202609Z" creationid="xccui" creationdate="20190606T202532Z">
        <seg>若想充分利用网络连接带宽，就需要用到数据缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffers that need to be sent to the other TaskManager are multiplexed over the same network connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T201324Z" creationid="xccui" creationdate="20190606T200905Z">
        <seg>所有需要向对方TaskManager传输数据的缓冲区会复用同一个网络连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffers which need to be sent to the other Task&lt;t0/&gt;‐&lt;t1/&gt; Manager are multiplexed over the same network connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044411Z" creationid="xccui" creationdate="20190504T044411Z">
        <seg>需要发往同一个TaskManager的缓冲区数据会复用同一个网络连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-in Window Assigners</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023153Z" creationid="xccui" creationdate="20190225T023153Z">
        <seg>内置窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bundling and Deploying Applications in Containers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025949Z" creationid="xccui" creationdate="20190225T025949Z">
        <seg>在容器中打包并部署应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But first, let’s define the term data stream: a data stream is a potentially unbounded sequence of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233637Z" creationid="xccui" creationdate="20190605T233637Z">
        <seg>在此之前先要给出数据流的定义：数据流是一个可能无限的事件序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But first, we define the term &lt;t0/&gt;data stream&lt;t1/&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142649Z" creationid="xccui" creationdate="20190401T142637Z">
        <seg>在此之前需要先定义数据流：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But in practice you might want to partition a stream into multiple logical streams and define parallel windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013841Z" creationid="xccui" creationdate="20190606T013841Z">
        <seg>但在实际应用中，你可能会想将数据流划分为多条逻辑流并定义一些并行窗口（parallel window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But it differs from regular list state in how it is restored in the case of a failure or when an application is started from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184651Z" creationid="xccui" creationdate="20190607T184610Z">
        <seg>但在进行故障恢复或从某个保存点启动应用时，状态的恢复方式和普通列表状态有所不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But there are much more time-critical applications whose semantics we need to guarantee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T154442Z" creationid="xccui" creationdate="20190411T154442Z">
        <seg>但还有更多时间敏感应用，我们需要保证其处理语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By computing results only based on the actual data, these systems are also able to process historical data in the same way as “live” data, i.e., data which is inges&lt;t0/&gt;‐&lt;t1/&gt; ted as soon as it is produced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T134332Z" creationid="xccui" creationdate="20190327T051803Z">
        <seg>由于只需依靠实际数据本身计算结果，此类系统可以将历史数据当做"实时"数据进行处理，如同它们一产生就传入系统一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By configuring only a single slot per TaskManager, you can isolate applications across TaskManagers, i.e., run only tasks of a single application on a TaskManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063739Z" creationid="xccui" creationdate="20190424T063555Z">
        <seg>通过将每个TaskManager配置成只有一个处理槽，可以将应用在TaskManager级别进行隔离，即每个TaskManager只运行单个应用的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By configuring only a single slot per TaskManager, you can isolate applications across TaskManagers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145000Z" creationid="xccui" creationdate="20190606T144935Z">
        <seg>通过将每个TaskManager配置成只有一个处理槽，可以控制应用在TaskManager级别进行隔离，即每个TaskManager只运行单个应用的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Flink assigns unique operator identifiers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T023152Z" creationid="xccui" creationdate="20190609T220319Z">
        <seg>默认情况下，Flink会给每个算子分配一个唯一标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By injecting the barrier into its output stream, the source function defines the stream position on which the checkpoint is taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T154906Z" creationid="xccui" creationdate="20190609T154731Z">
        <seg>通过向输出流中注入分隔符，数据源函数定义了需要在流中哪些位置生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By lever&lt;t0/&gt;‐&lt;t1/&gt; aging thread-parallelism inside of a TaskManager and the option to deploy several TaskManager processes per host, Flink offers a lot of flexibility to trade off perfor&lt;t2/&gt;‐&lt;t3/&gt; mance and resource isolation when deploying applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T064328Z" creationid="xccui" creationdate="20190424T063958Z">
        <seg>通过在TaskManager内部采用线程并行以及支持在每个主机上部署多个TaskManager进程，Flink为部署应用时性能和资源隔离的取舍提供了极大的自由度，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By leveraging thread parallelism inside a TaskManager and deploying several TaskMan‐ ager processes per host, Flink offers a lot of flexibility to trade off performance and resource isolation when deploying applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145045Z" creationid="xccui" creationdate="20190606T145021Z">
        <seg>通过在TaskManager内部采用线程并行以及在每个主机上部署多个TaskManager进程，Flink为部署应用时性能和资源隔离的取舍提供了极大的自由度，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By only computing results based on actual data, these systems are also able to process historical data in the same way as “live” data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053445Z" creationid="xccui" creationdate="20190605T053408Z">
        <seg>由于只需依靠实际数据本身计算结果，此类系统可以将历史数据当做"实时"数据进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By processing several streams in parallel, you can lower the latency while processing more events at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T212443Z" creationid="xccui" creationdate="20190402T212226Z">
        <seg>通过并行处理多条数据流，你可以在处理更多事件的同时降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By processing several streams in parallel, you lower the latency while processing more events at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235732Z" creationid="xccui" creationdate="20190605T235730Z">
        <seg>通过并行处理多条数据流，可以在处理更多事件的同时降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By relying on event time, we can guarantee result correctness even in cases of out-of- order data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025039Z" creationid="xccui" creationdate="20190606T024500Z">
        <seg>依靠事件时间，我们可以保证在数据乱序的情况下结果依然正确，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By relying on event time, we can guarantee result correctness even in such cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T154750Z" creationid="xccui" creationdate="20190412T154249Z">
        <seg>依靠事件时间，我们可以保证上述情况中结果正确，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By resetting the state of a (possibly modified) application and replaying the input, it is possible to fix a bug of the applica&lt;t2/&gt;‐&lt;t3/&gt; tion and repair its effects, deploy new versions of an application without losing its state, or run what-if or A/B tests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T063011Z" creationid="xccui" creationdate="20190312T215231Z">
        <seg>通过重置（变更后）应用的状态并重放输入，可以修复应用bug或消除影响，在不丢失状态的情况下部署新版本，进行假设验证或A/B测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191706Z" creationid="xccui" creationdate="20190225T191706Z">
        <seg>第1章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053436Z" creationid="xccui" creationdate="20190329T045754Z">
        <seg>第2章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053535Z" creationid="xccui" creationdate="20190416T053535Z">
        <seg>第3章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 4</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T042834Z" creationid="xccui" creationdate="20190606T042834Z">
        <seg>第4章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 5</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014844Z" creationid="xccui" creationdate="20190612T014822Z">
        <seg>第5章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CPU</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025545Z" creationid="xccui" creationdate="20190225T025545Z">
        <seg>CPU</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chained task execution with fused function in a single thread and data pass&lt;t0/&gt;‐&lt;t1/&gt; ing via method calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153822Z" creationid="esouser" creationdate="20190514T153152Z">
        <seg>在结合多个函数的链接任务执行过程中，数据通过方法调用传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chained task execution with fused functions in a single thread and data passing via method calls</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203847Z" creationid="xccui" creationdate="20190606T203806Z">
        <seg>在融合多个函数的链接任务执行过程中，数据通过方法调用传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 1 gives an overview of stateful stream processing, data processing appli‐ cation architectures, application designs, and the benefits of stream processing over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T042041Z" creationid="esouser" creationdate="20190603T155541Z">
        <seg>第1章是概览，我们在其中粗略地介绍了状态化流处理、数据处理应用的架构和设计以及流处理和传统方法相比的优势所在，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 1 is an overview of stateful stream processing, data processing application architectures, application designs, and benefits over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T165303Z" creationid="xccui" creationdate="20190225T163756Z">
        <seg>第1章是概览，我们在其中回顾了状态化流处理、数据处理应用的架构和设计以及和传统方法相比的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 covers operation, monitoring, and maintenance of streaming applications that run 24/7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T170937Z" creationid="xccui" creationdate="20190225T170900Z">
        <seg>第10章涵盖了针对7*24小时运行的流处理任务的操作、监控和运维等内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 covers operation, monitoring, and maintenance of streaming applica‐ tions that run 24/7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162607Z" creationid="esouser" creationdate="20190603T162607Z">
        <seg>第10章涵盖了针对7*24小时运行的流处理任务的操作、监控和运维等内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 describes how to trigger and dispose savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211146Z" creationid="xccui" creationdate="20190609T211058Z">
        <seg>第10章介绍了如何触发生成和销毁保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 will discuss how the DataStream API allows to control the assignment and grouping of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210039Z" creationid="xccui" creationdate="20190428T210014Z">
        <seg>在第10章会讨论如何通过DataStream API控制任务分配及分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172807Z" creationid="xccui" creationdate="20190228T172807Z">
        <seg>第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2 discussed important concepts of distributed stream processing, such as parallelization, time, and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T135925Z" creationid="xccui" creationdate="20190606T135925Z">
        <seg>第2章主要讨论了分布式流处理中的一些重要概念，例如：并行、时间、状态等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2 discusses fundamental concepts and challenges of stream processing and its content is rather independent of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T165317Z" creationid="xccui" creationdate="20190225T164744Z">
        <seg>第2章主要讨论流处理的基本概念和挑战，这些内容都是独立于Flink而存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2 discusses the fundamental concepts and challenges of stream process‐ ing, independent of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T160057Z" creationid="esouser" creationdate="20190603T155834Z">
        <seg>第2章主要讨论流处理的基本概念和挑战，这些内容都是独立于Flink而存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032105Z" creationid="xccui" creationdate="20190401T032105Z">
        <seg>第二章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 3 describes Flink’s system architecture and internals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T161310Z" creationid="xccui" creationdate="20190225T164833Z">
        <seg>第3章介绍Flink的系统架构和内部实现，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053634Z" creationid="xccui" creationdate="20190416T053630Z">
        <seg>第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 4 explains how to set up an environment to develop and debug Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T161023Z" creationid="esouser" creationdate="20190603T161023Z">
        <seg>第4章介绍如何配置用于开发和调试Flink应用的环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 5 introduces you to the basics of the Flink’s DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031541Z" creationid="esouser" creationdate="20190603T161252Z">
        <seg>第5章介绍Flink DataStream API的基础知识，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 5 will introduce you to the basics of the DataStream API, and Chapters 6, 7, and 8 will introduce everything you need to know about time-based operators, state‐ ful functions, and source and sink connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012744Z" creationid="xccui" creationdate="20190612T011507Z">
        <seg>我们会在第5章介绍DataStream API的基础知识，在第6、7、8章介绍有关基于时间的算子、状态化函数以及数据源（汇）连接器的全部内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 6 discusses the time-based operators of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T161611Z" creationid="esouser" creationdate="20190603T161540Z">
        <seg>第6章主要讨论DataStream API中基于时间的算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 7 explains how to implement stateful functions and discusses everything around this topic, such as the performance, robustness, and evolution of stateful functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T042435Z" creationid="esouser" creationdate="20190603T162033Z">
        <seg>第7章介绍如何实现有状态的函数，以及其他一些与之相关的诸如性能、健壮性、状态函数演变等方面的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 8 presents Flink’s most commonly used source and sink connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162402Z" creationid="esouser" creationdate="20190603T162256Z">
        <seg>第8章介绍Flink中最常用的数据源和数据汇连接器，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 9 discusses how to set up and configure Flink clusters in various environments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162601Z" creationid="esouser" creationdate="20190603T162601Z">
        <seg>第9章讨论如何针对不同环境搭建和配置Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 9 discusses how to setup and configure Flink clusters in various environ&lt;t0/&gt;‐&lt;t1/&gt; ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T170602Z" creationid="xccui" creationdate="20190225T170602Z">
        <seg>第9章讨论如何针对不同环境搭建和配置Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapters 4 to 8 is where you get our hands dirty and start developing Flink applica&lt;t0/&gt;‐&lt;t1/&gt; tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191540Z" creationid="xccui" creationdate="20190225T165503Z">
        <seg>第4到8章会带你着手开发Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpointing and State Backends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154914Z" creationid="xccui" creationdate="20190225T025624Z">
        <seg>检查点和状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints are periodically taken and automatically discarded according to a configurable policy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T205603Z" creationid="xccui" creationdate="20190609T205454Z">
        <seg>检查点会周期性地生成，而且会根据配置的策略自动丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints, Savepoints, and State Recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154749Z" creationid="xccui" creationdate="20190225T022126Z">
        <seg>检查点、保存点及状态恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints, Savepoints, and State Recovery | 59</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032759Z" creationid="xccui" creationdate="20190610T032759Z">
        <seg>检查点、保存点及状态恢复 | 59</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choosing a State Backend</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024757Z" creationid="xccui" creationdate="20190225T024742Z">
        <seg>状态后端选择</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choosing a State Primitive</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024815Z" creationid="xccui" creationdate="20190225T024815Z">
        <seg>选择状态原语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CoProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210745Z" creationid="esouser" creationdate="20190603T210745Z">
        <seg>CoProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining events of two streams is a very common requirement in stream process‐ ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T160725Z" creationid="xccui" creationdate="20190613T160725Z">
        <seg>在流处理中，合并两条数据流中的事件是一个非常普遍的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common challenges that distributed systems need to address are allocation and man&lt;t0/&gt;‐&lt;t1/&gt; agement of compute resources in a cluster, process coordination, durable and avail&lt;t2/&gt;‐&lt;t3/&gt; able data storage, and failure recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T031359Z" creationid="xccui" creationdate="20190418T031209Z">
        <seg>分布式系统需要应对的常见挑战包括分配和管理集群计算资源、进程协调、持久化及可用数据存储、故障恢复等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common challenges that distributed systems need to address are allocation and man‐ agement of compute resources in a cluster, process coordination, durable and highly available data storage, and failure recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140641Z" creationid="xccui" creationdate="20190606T140641Z">
        <seg>分布式系统需要应对的常见挑战包括分配和管理集群计算资源、进程协调、持久化及可用数据存储、故障恢复等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common choices are IntelliJ IDEA, Eclipse, or Netbeans with the appropriate plugins (such as for Maven, Git, and Scala support).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T030527Z" creationid="xccui" creationdate="20190611T030527Z">
        <seg>常见选项有IntelliJ IDEA、Eclipse或Netbeans，它们都需要相应安装一些插件（例如Maven插件、Git插件以及Scala插件）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Companies employ many different applications to run their business, such as enter&lt;t0/&gt;‐&lt;t1/&gt; prise resource planning (ERP) systems, customer relationship management (CRM) software, or web-based applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T184326Z" creationid="xccui" creationdate="20190226T155328Z">
        <seg>一般公司都会使用很多不同种类的应用来运营业务，例如企业资源规划（ERP）系统、客户关系管理（CRM）软件、基于web的应用等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Companies use all kinds of applications for their day-to-day business activities, such as enterprise resource planning (ERP) systems, customer relationship management (CRM) software, and web-based applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T051250Z" creationid="esouser" creationdate="20190603T194537Z">
        <seg>公司在日常业务运营过程中会用到各类应用，例如企业资源规划（ERP）系统、客户关系管理（CRM）软件、基于web的应用等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Complex data structures can also be stored as value state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T215859Z" creationid="xccui" creationdate="20190607T215731Z">
        <seg>该值也可以是某个复杂数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components of a Flink Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T051459Z" creationid="xccui" creationdate="20190225T021731Z">
        <seg>Flink设置组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compute the average temperature every 5 seconds for a stream of sensors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041632Z" creationid="xccui" creationdate="20190612T041632Z">
        <seg>针对传感器数据流每5秒计算一次平均温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concep‐ tually, the list entries of all parallel operator tasks are collected and evenly redistrib‐ uted to a smaller or larger number of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060531Z" creationid="xccui" creationdate="20190608T060433Z">
        <seg>理论上，所有并行算子任务的列表项目会被统一收集起来，随后均匀分配到数量改变的任务之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Checkpointing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035400Z" creationid="xccui" creationdate="20190225T030042Z">
        <seg>配置checkpointing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030108Z" creationid="xccui" creationdate="20190225T030108Z">
        <seg>配置故障恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring State Backends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030054Z" creationid="xccui" creationdate="20190225T030054Z">
        <seg>配置状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Time Characteristics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023020Z" creationid="xccui" creationdate="20190225T023020Z">
        <seg>配置时间特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring the Logging Behavior</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030154Z" creationid="xccui" creationdate="20190225T030154Z">
        <seg>配置日志行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connecting a stateful streaming application running on Flink and an event log is interesting for multiple reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T211646Z" creationid="xccui" creationdate="20190305T060607Z">
        <seg>出于很多原因，将某个运行于Flink之上的状态化流处理应用和事件日志系统连接会非常有趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connectors to the most commonly used storage systems such as Apache Kafka, Apache Cassandra, Elasticsearch, JDBC, Kinesis, and (distributed) filesystems such as HDFS and S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T121502Z" creationid="xccui" creationdate="20190605T121502Z">
        <seg>用于最常见存储系统的连接器，如Apache Kafka、Apache Cassandra、Elasticsearch、JDBC、Kinesis以及（分布式）文件系统（HDFS和S3等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, all records with the same key access the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191837Z" creationid="xccui" creationdate="20190607T191804Z">
        <seg>因此所有键值一样的记录都能访问到相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, records of both inputs are processed based on the same event-time clock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T030644Z" creationid="xccui" creationdate="20190607T030436Z">
        <seg>这就导致所有输入的记录都必须基于同一个事件时间时钟来处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, the processing latencies and state size of time-based opera‐ tors can significantly increase if a task does not receive new watermarks from all input tasks at regular intervals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T032904Z" creationid="xccui" creationdate="20190607T032902Z">
        <seg>因此，如果一个任务没有从全部输入任务以常规间隔接收新的水位线，就会导致时间相关算子的处理延迟或状态大小激增。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conse‐ quently, an application can only be operated under exactly-once state consistency if all input streams are consumed by resettable data sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T053412Z" creationid="xccui" creationdate="20190609T050740Z">
        <seg>因此只有所有输入流都是来自于可重置的数据源，应用才支持精确一次的状态一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consid&lt;t0/&gt;‐&lt;t1/&gt; ering that streaming applications might run for several days, months, or even years, you need to make sure that state can be reliably recovered under failures and that your system can guarantee accurate results even if things break.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T205442Z" creationid="xccui" creationdate="20190409T205052Z">
        <seg>考虑到流式应用可能需要成日、甚至长年累月地运行，因此必须保证出错时状态能进行可靠的恢复，即使发生故障系统也能提供准确的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider Bob, another player of the online mobile game, who happens to be on the same train as Alice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T152139Z" creationid="xccui" creationdate="20190412T152139Z">
        <seg>考虑另一位在线手游玩家鲍勃，他恰好和爱丽丝在同一趟地铁上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider a program that analyzes events generated by users playing an online mobile game.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014905Z" creationid="xccui" creationdate="20190606T014733Z">
        <seg>假设有个程序会分析用户玩在线手游时产生的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider a program that analyzes events generated by users playing online mobile games.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T211520Z" creationid="xccui" creationdate="20190409T211346Z">
        <seg>考虑某程序会分析用户玩在线手游时产生的事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that ana&lt;t3/&gt;‐&lt;t4/&gt; lyzes online user behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025233Z" creationid="xccui" creationdate="20190407T025046Z">
        <seg>假设有一个应用要在线分析用户行为，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that analyzes online user behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013553Z" creationid="xccui" creationdate="20190606T013553Z">
        <seg>假设有一个应用要在线分析用户行为，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that provides real-time traffic information to drivers so that they can avoid congested routes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043400Z" creationid="xccui" creationdate="20190406T043152Z">
        <seg>假设有一个应用能向司机提供实时路况信息以帮助他们躲避拥堵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider for example a streaming join opera&lt;t2/&gt;‐&lt;t3/&gt; tion or a holistic aggregate, such as median.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041531Z" creationid="xccui" creationdate="20190406T041221Z">
        <seg>例如：流连接或是像求中位数的整体聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the case where Alice starts popping bubbles while her phone is connected to the network and sends events to the analysis application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151136Z" creationid="xccui" creationdate="20190411T150723Z">
        <seg>因此考虑如下情况：爱丽丝开始消泡泡的时候手机还能联网向分析应用发送事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the case where Alice starts pop‐ ping bubbles while her phone is connected to the network and sends events to the analysis application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T015023Z" creationid="xccui" creationdate="20190606T015023Z">
        <seg>因此考虑如下情况：爱丽丝开始消泡泡的时候手机还能联网向分析应用发送事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following example of keying a stream of Tuple3[Int, Int, Int] on the first field and computing a rolling sum on the second field:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054958Z" creationid="xccui" creationdate="20190614T054424Z">
        <seg>以下示例中，我们对一个Tuple3[Int, Int, Int]类型的数据流按照第1个字段进行键值分区，然后滚动计算第2个字段的总和：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider, for example, a streaming join opera‐ tion or a holistic aggregate, such as the median function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012013Z" creationid="xccui" creationdate="20190606T012013Z">
        <seg>例如：流连接或是像求中位数的整体聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considering that streaming applications might run for several days, months, or even years, you need to make sure that state can be reliably recovered under failures and that your system can guarantee accurate results even if things break.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014557Z" creationid="xccui" creationdate="20190606T014534Z">
        <seg>考虑到流式应用可能需要整日、甚至长年累月地运行，因此必须保证出错时状态能进行可靠的恢复，即使发生故障系统也能提供准确的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considering the color of the input event as the key, Figure 5-4 assigns black events to one partition and all other events to another partition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051108Z" creationid="xccui" creationdate="20190614T051108Z">
        <seg>我们假设以输入事件的颜色作为键值，在图5-4中会将所有黑色事件分到一个分区，而将其他事件分到另一个分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consistent Checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154728Z" creationid="xccui" creationdate="20190225T022145Z">
        <seg>一致性检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant width</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210802Z" creationid="esouser" creationdate="20190603T210802Z">
        <seg>Constant width</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant width italic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210807Z" creationid="esouser" creationdate="20190603T210807Z">
        <seg>Constant width italic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consumers of the log incorporate the updates into the affected data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T041345Z" creationid="xccui" creationdate="20190605T040435Z">
        <seg>日志的消费者会将这些更新整合到相关数据存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controlling Task Chaining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030013Z" creationid="xccui" creationdate="20190225T030013Z">
        <seg>控制任务链接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controlling Task Scheduling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025953Z" creationid="xccui" creationdate="20190225T025953Z">
        <seg>控制任务调度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions Used in This Book</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210758Z" creationid="esouser" creationdate="20190603T210758Z">
        <seg>Conventions Used in This Book</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright 2019 Fabian Hueske and Vasiliki Kalavri, 978-1-491-97429-2.”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210826Z" creationid="esouser" creationdate="20190603T210826Z">
        <seg>Copyright 2019 Fabian Hueske and Vasiliki Kalavri, 978-1-491-97429-2.”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright © 2019 Fabian Hueske, Vasiliki Kalavri.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210711Z" creationid="esouser" creationdate="20190603T210711Z">
        <seg>Copyright © 2019 Fabian Hueske, Vasiliki Kalavri.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-based tumbling window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013112Z" creationid="xccui" creationdate="20190606T013111Z">
        <seg>基于数量的滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-based tumbling window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023544Z" creationid="xccui" creationdate="20190407T023544Z">
        <seg>基于数量的滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-based tumbling windows define how many events are collected before triggering evaluation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023227Z" creationid="xccui" creationdate="20190406T051102Z">
        <seg>基于数量的（count-based）滚动窗口定义在触发计算前需要集齐多少条事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating Type Information for Data Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145213Z" creationid="esouser" creationdate="20190603T145213Z">
        <seg>为数据类型创建类型信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating TypeInformation for data types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022835Z" creationid="xccui" creationdate="20190225T022835Z">
        <seg>为数据类型创建TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-Based Flow Control</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202504Z" creationid="esouser" creationdate="20190603T144321Z">
        <seg>基于信用值的流量控制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-based Flow Control</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T143815Z" creationid="xccui" creationdate="20190225T021817Z">
        <seg>基于信用度的流量控制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-based flow control reduces latency because senders can ship data as soon as the receiver has enough resources to accept it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203111Z" creationid="xccui" creationdate="20190606T203100Z">
        <seg>由于发送端可以在接收端有足够资源时立即传输数据，因此基于信用值的流量控制可以有效降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-based flow control reduces the latency because senders can ship data as soon as the receiver has enough resources to accept it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T144033Z" creationid="esouser" creationdate="20190514T143810Z">
        <seg>由于发送端可以在接收端有足够资源时立即传输数据，因此基于信用度的流量控制可以降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Customizing Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023237Z" creationid="xccui" creationdate="20190225T023237Z">
        <seg>自定义窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051345Z" creationid="xccui" creationdate="20190612T051345Z">
        <seg>Data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data &lt;t0/&gt;ingestion&lt;t1/&gt; is the operation of fetching raw data from exter&lt;t2/&gt;‐&lt;t3/&gt; nal sources and converting it into a format that is suitable for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152000Z" creationid="xccui" creationdate="20190405T152000Z">
        <seg>数据接入操作从外部数据源获取原始数据并将其转换成适合后续处理的格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data &lt;t6/&gt;egress&lt;t7/&gt; is the operation of producing output in a form that is suitable for consumption by external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152354Z" creationid="xccui" creationdate="20190405T152354Z">
        <seg>数据输出操作将数据以适合外部系统使用的格式输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Exchange Strategies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143856Z" creationid="esouser" creationdate="20190603T143856Z">
        <seg>数据交换策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Parallelism and Task Parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143848Z" creationid="esouser" creationdate="20190603T143838Z">
        <seg>数据并发和任务并发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Pipelines</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142926Z" creationid="esouser" creationdate="20190603T142926Z">
        <seg>数据管道</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Pipelines and Real-time ETL</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014644Z" creationid="xccui" creationdate="20190225T014644Z">
        <seg>数据管道和实时ETL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Transfer between TaskManagers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T043826Z" creationid="xccui" creationdate="20190504T043826Z">
        <seg>TaskManager之间的数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Transfer in Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021809Z" creationid="xccui" creationdate="20190225T021809Z">
        <seg>Flink中的数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Transfer in Flink | 45</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032549Z" creationid="xccui" creationdate="20190610T032549Z">
        <seg>Flink中的数据传输 | 45</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data and data processing have been omnipresent in businesses for many decades.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T050834Z" creationid="esouser" creationdate="20190603T193512Z">
        <seg>几十年来，数据和数据处理在各类企业中都无处不在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data arriving to the Lambda architecture is ingested by the stream processor as well as written to a batch storage such as HDFS.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014858Z" creationid="xccui" creationdate="20190322T044236Z">
        <seg>该架构中到来的数据会同时发往流处理引擎和写入批量存储（如：HDFS）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data arriv‐ ing at the lambda architecture is ingested by the stream processor and also written to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051911Z" creationid="xccui" creationdate="20190605T051850Z">
        <seg>该架构中到来的数据会同时发往流处理引擎和写入批量存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data egress is the operation of producing output in a form suitable for consumption by external sys‐ tems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T010152Z" creationid="xccui" creationdate="20190606T010152Z">
        <seg>数据输出操作将数据以适合外部系统使用的格式输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015028Z" creationid="xccui" creationdate="20190225T015028Z">
        <seg>数据交换策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies can be automatically chosen by the execu&lt;t0/&gt;‐&lt;t1/&gt; tion engine depending on the semantics of the operators or explicitly imposed by the dataflow programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034641Z" creationid="xccui" creationdate="20190401T034618Z">
        <seg>这些策略可以由执行引擎根据算子的语义自动选择，也可以由dataflow编码人员显式指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies can be automatically chosen by the execu‐ tion engine depending on the semantics of the operators or explicitly imposed by the dataflow programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233342Z" creationid="xccui" creationdate="20190605T233342Z">
        <seg>这些策略可以由执行引擎根据算子的语义自动选择，也可以由Dataflow编程人员显式指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies define how data items are assigned to tasks in a physical dataflow graph.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233334Z" creationid="xccui" creationdate="20190401T034226Z">
        <seg>数据交换策略定义数据项如何分配给物理Dataflow图中的不同任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142204Z" creationid="xccui" creationdate="20190401T142204Z">
        <seg>数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data ingestion and data egress</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151752Z" creationid="xccui" creationdate="20190405T151752Z">
        <seg>数据接入和数据输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data ingestion and data egress operations allow the stream processor to communicate with external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151836Z" creationid="xccui" creationdate="20190405T151836Z">
        <seg>数据接入和数据输出操作允许流处理引擎和外部系统进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data ingestion is the operation of fetching raw data from exter‐ nal sources and converting it into a format suitable for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T005219Z" creationid="xccui" creationdate="20190606T005219Z">
        <seg>数据接入操作从外部数据源获取原始数据并将其转换成适合后续处理的格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data parallelism and task parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015011Z" creationid="xccui" creationdate="20190225T015011Z">
        <seg>数据并发度和任务并发度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data parallelism is use&lt;t2/&gt;‐&lt;t3/&gt; ful because it allows for processing large volumes of data and spreading the computa&lt;t4/&gt;‐&lt;t5/&gt; tion load across several computing nodes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T031923Z" creationid="xccui" creationdate="20190401T031116Z">
        <seg>数据并行非常有用，因为它支持处理大规模数据，能够将计算负载分配到多个节点上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data parallelism is use‐ ful because it allows for processing large volumes of data and spreading the computa‐ tion load across several computing nodes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233252Z" creationid="xccui" creationdate="20190605T233252Z">
        <seg>数据并行非常有用，因为它支持处理大规模数据，能够将计算负载分配到多个节点上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data pipelines must be able to process large amounts of data in a short time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T042639Z" creationid="xccui" creationdate="20190605T042639Z">
        <seg>它需要在短时间内处理大批量数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data stream processing is not a novel technology.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045907Z" creationid="xccui" creationdate="20190319T041222Z">
        <seg>数据流处理并非是一项新技术，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data that resides in such storage systems can be queried with and processed by a SQL-on-Hadoop engine, for example Apache Hive, Apache Drill, or Apache Impala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T204141Z" creationid="esouser" creationdate="20190603T203856Z">
        <seg>而它们中的数据也可以通过很多基于Hadoop的SQL引擎（如：Apache Hive、Apache Drill、Apache Impala）进行查询和处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data that resides in such storage systems is accessible to several SQL-on-Hadoop engines, as for example Apache Hive, Apache Drill, or Apache Impala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T032911Z" creationid="xccui" creationdate="20190301T032911Z">
        <seg>而它们中的数据也可以通过很多基于Hadoop的SQL引擎（如：Apache Hive、Apache Drill、Apache Impala）进行访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data transfer between TaskManagers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T200559Z" creationid="xccui" creationdate="20190606T200556Z">
        <seg>TaskManager之间的数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream but reorganize it by partitioning or grouping.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052753Z" creationid="xccui" creationdate="20190612T052753Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow Graphs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143808Z" creationid="esouser" creationdate="20190603T143808Z">
        <seg>Dataflow图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow graphs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015000Z" creationid="xccui" creationdate="20190225T015000Z">
        <seg>Dataflow图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow graphs like the one in Figure 2-1 are called logical because they convey a high-level view of the computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233042Z" creationid="xccui" creationdate="20190605T233042Z">
        <seg>像是图2-1之类的Dataflow图被称作逻辑图，因为它们描述了高层视角下的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow graphs like the one of &lt;t0/&gt;Figure 2-1&lt;t1/&gt; are called logical because they convey a high-level view of the computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T002544Z" creationid="xccui" creationdate="20190401T001357Z">
        <seg>诸如图2-1之类的dataflow图被称作逻辑图，因为它们描述了高层视角下的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow programs are commonly represented as directed graphs, where nodes are called operators and represent computations and edges represent data dependen&lt;t2/&gt;‐&lt;t3/&gt; cies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190331T214808Z" creationid="xccui" creationdate="20190331T060933Z">
        <seg>dataflow程序通常会表示为有向图。其中节点称为算子（operator），表示计算；而边表示数据间的依赖关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow programs are commonly represented as directed graphs, where nodes are called operators and represent computations and edges represent data dependen‐ cies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224821Z" creationid="xccui" creationdate="20190605T224809Z">
        <seg>Dataflow程序通常会表示为有向图。其中节点称为算子，表示计算；而边表示数据间的依赖关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug Flink Applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144924Z" creationid="esouser" creationdate="20190603T144924Z">
        <seg>在IDE中调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug Flink applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022345Z" creationid="xccui" creationdate="20190225T022345Z">
        <seg>在IDE中调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Keyed State at RuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150917Z" creationid="esouser" creationdate="20190603T150900Z">
        <seg>在RuntimeContext中声明Keyed State</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Keyed State at the RuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024537Z" creationid="xccui" creationdate="20190225T024537Z">
        <seg>在RuntimeContext中声明Keyed State</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Keys and Referencing Fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145323Z" creationid="esouser" creationdate="20190603T145323Z">
        <seg>定义键值及引用字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Slot Sharing Groups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030021Z" creationid="xccui" creationdate="20190225T030021Z">
        <seg>定义Slot共享组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Slot-Sharing Groups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152401Z" creationid="esouser" creationdate="20190603T152401Z">
        <seg>定义处理槽共享组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023144Z" creationid="xccui" creationdate="20190225T023144Z">
        <seg>定义窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining keys and referencing fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022905Z" creationid="xccui" creationdate="20190225T022905Z">
        <seg>定义key和引用字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining the Maximum Parallelism of Keyed State Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030725Z" creationid="xccui" creationdate="20190225T024714Z">
        <seg>为使用键值状态的算子定义最大并发度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depend&lt;t0/&gt;‐&lt;t1/&gt; ing on the application, you might care about &lt;t2/&gt;average&lt;t3/&gt; latency, &lt;t4/&gt;maximum&lt;t5/&gt; latency, or &lt;t6/&gt;percentile &lt;t7/&gt;latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T154750Z" creationid="xccui" creationdate="20190401T154546Z">
        <seg>根据应用的不同，你可能会关注平均延迟，最大延迟或延迟的百分位数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on    the environment (YARN, Mesos, Kubernetes, standalone cluster), some steps can be omitted or components might run in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143250Z" creationid="xccui" creationdate="20190606T143213Z">
        <seg>根据环境的不同（YARN、Mesos、Kubernetes、独立集群），有些步骤其实可以省略，也可能会有多个组件运行在同一个JVM进程中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on how an application is submitted for execution (discussed in the next section), a dispatcher might not be required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024404Z" creationid="xccui" creationdate="20190423T024404Z">
        <seg>根据应用提交执行的方式（会在下节讨论），dispatcher可能并非必需。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on how an application is submitted for execution (dis‐ cussed in “Application Deployment”), a dispatcher might not be required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143021Z" creationid="xccui" creationdate="20190606T142947Z">
        <seg>根据应用提交执行的方式（会在"应用部署"一节讨论），Dispatcher可能并非必需。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on how an operator is connected with its predecessor or successor operators, its tasks can receive records and water‐ marks from one or more input partitions and emit records and watermarks to one or more output partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T015225Z" creationid="xccui" creationdate="20190607T015151Z">
        <seg>根据算子和它上下游的连接情况，其任务可能同时从多个输入分区接收记录和水位线，也可能需要将它们发送到多个输出分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the application requirements, you might want to ignore such events, log them, or use them to correct previous results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T040224Z" creationid="xccui" creationdate="20190414T032650Z">
        <seg>根据应用需求的不同，你可能想直接忽略那些事件，将它们写入日志或利用它们去修正之前的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the business logic, an event-driven application can trigger actions such as sending an alert or an email or write events to an outgoing event stream that is possibly consumed by another event-driven application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T024745Z" creationid="xccui" creationdate="20190307T024745Z">
        <seg>根据业务逻辑的不同，此类应用可能触发告警或发送电子邮件之类的操作，也支持将事件写入输出流以供其他同类应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the business logic, an event-driven application can trigger actions such as sending an alert or an email or write events to an outgoing event stream to be consumed by another event-driven application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213520Z" creationid="esouser" creationdate="20190603T213520Z">
        <seg>根据业务逻辑的不同，此类应用可能触发告警或发送电子邮件之类的操作，也支持将事件写入输出流以供其他同类应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the scheduling intervals it may take hours or days until a data point is included in a report.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T031535Z" creationid="xccui" creationdate="20190317T031535Z">
        <seg>根据调度周期的不同，数据可能会在数小时或数天后才出现在报告中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the sink operators of an application, some result records might be emitted multiple times to downstream sys‐ tems, such as an event log, a filesystem, or a database, during the recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054005Z" creationid="xccui" creationdate="20190609T053722Z">
        <seg>根据应用所采用的数据汇算子，在恢复期间，某些结果记录可能会向下游系统（如事件日志系统、文件系统或数据库）发送多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the the environment (YARN, Mesos, Kubernetes, stand-alone cluster), some steps can be omitted or components might run in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024812Z" creationid="xccui" creationdate="20190423T024729Z">
        <seg>根据环境的不同（YARN、Mesos、Kubernetes、独立集群），有些步骤其实可以省略，同时可能会有多个组件运行在同一个JVM进程中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the type of execution environment, a JobManager is started as a local thread (local execution environment) or the JobGraph is sent to a remote JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T012430Z" creationid="xccui" creationdate="20190613T012430Z">
        <seg>根据执行环境类型的不同，可能会将JobManager作为本地线程启动（本地执行环境），也可能会将JobGraph发送到远程JobManager上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the use case and data store, the updates need to be processed before they can be incorporated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062601Z" creationid="xccui" creationdate="20190314T073211Z">
        <seg>根据用例和数据存储系统的不同，需要在更新的数据整合前对它们进行一些处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the use case, the transferred data may need to be normalized, enriched with external data, or aggregated before it is ingested by the target data store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T042555Z" creationid="xccui" creationdate="20190605T041712Z">
        <seg>根据用例的不同，转存的数据可能需要归一化，利用外部输入丰富数据或在写入目标存储之前进行聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depend‐ ing on the application, you might care about average latency, maximum latency, or percentile latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234017Z" creationid="xccui" creationdate="20190605T234017Z">
        <seg>根据应用的不同，你可能会关注平均延迟，最大延迟或延迟的百分位数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deployment Modes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025408Z" creationid="xccui" creationdate="20190225T025402Z">
        <seg>部署模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designed for the special case where the state of each task of an operator is identi‐ cal.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T185523Z" creationid="xccui" creationdate="20190607T184956Z">
        <seg>专门为一类特殊场景而设计——算子的每个任务都要保持相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Detailed and customizable collection of system and application metrics help to identify and react to problems ahead of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052524Z" creationid="xccui" creationdate="20190328T052451Z">
        <seg>详细、可自由定制的系统及应用指标集合有助于提前定位和响应问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Detailed and customizable collection of system and application metrics to iden‐ tify and react to problems ahead of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T121703Z" creationid="xccui" creationdate="20190605T121631Z">
        <seg>详细、可自由定制的系统及应用指标集合，用于提前定位和响应问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disk Storage</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025610Z" creationid="xccui" creationdate="20190225T025610Z">
        <seg>磁盘存储</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022750Z" creationid="xccui" creationdate="20190225T022750Z">
        <seg>分发转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution transformations reorganize stream events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024707Z" creationid="xccui" creationdate="20190613T024707Z">
        <seg>分发转换会将流中的事件重新组织。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Docker</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040308Z" creationid="xccui" creationdate="20190418T040308Z">
        <seg>Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does it include the time Alice was offline or not?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152409Z" creationid="xccui" creationdate="20190411T152118Z">
        <seg>需要把爱丽丝离线的时间考虑在内吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Download the JAR file that includes all example programs of this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035848Z" creationid="xccui" creationdate="20190329T035651Z">
        <seg>下载涵盖本书所有示例程序的JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Download the JAR file that includes examples in this book:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123515Z" creationid="xccui" creationdate="20190605T123435Z">
        <seg>下载涵盖本书所有示例的JAR文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dropping Late Events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150747Z" creationid="xccui" creationdate="20190225T023339Z">
        <seg>丢弃迟到事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the append-only property of the log, events are always published to all consumers in exactly the same order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T060020Z" creationid="xccui" creationdate="20190305T054916Z">
        <seg>得益于日志的追加特性，无论向消费者发布几次，事件的顺序都能保持一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the single JVM execution mode, it is also possible to debug Flink applications in an IDE almost like any other program in your IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T053500Z" creationid="xccui" creationdate="20190611T052843Z">
        <seg>由于单JVM执行模式的存在，你可以像调试其他程序那样在IDE中调试Flink应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to this replication of data, the data stores must be kept in sync.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T070309Z" creationid="xccui" creationdate="20190314T070309Z">
        <seg>由于数据存在多个副本，这些数据存储系统之间需要保持同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Duplicate processing might be acceptable if application correctness only depends on the completeness of information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T042104Z" creationid="xccui" creationdate="20190416T042059Z">
        <seg>如果正确性仅依赖信息的完整度，那重复处理或许可以接受。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dupli‐ cate processing might be acceptable if application correctness only depends on the completeness of information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034633Z" creationid="xccui" creationdate="20190606T034633Z">
        <seg>如果正确性仅依赖信息的完整度，那重复处理或许可以接受。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During exe&lt;t6/&gt;‐&lt;t7/&gt; cution, the JobManager is responsible for all actions that require a central coordi&lt;t8/&gt;‐&lt;t9/&gt; nation such as the coordination of checkpoints (see later section).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T050152Z" creationid="xccui" creationdate="20190418T035245Z">
        <seg>在执行过程中，JobManager负责所有需要集中协调的行为，例如：checkpoint协调（下节会提到）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, a TaskManager exchanges</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142706Z" creationid="xccui" creationdate="20190606T142706Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, a TaskManager exchanges data with other TaskManagers that run tasks of the same application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T052434Z" creationid="xccui" creationdate="20190418T052055Z">
        <seg>执行期间，运行同一应用不同任务的TaskManager之间会产生数据交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, the JobManager is responsible for all actions that require a central coordination such as the coordination of check‐ points (see “Checkpoints, Savepoints, and State Recovery”).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142051Z" creationid="xccui" creationdate="20190606T141827Z">
        <seg>在执行过程中，JobManager负责所有需要集中协调的行为，例如：创建检查点（见"检查点、保存点和状态恢复"）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the execution of a streaming application, Flink periodically takes consistent checkpoints of the application’s state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T033400Z" creationid="xccui" creationdate="20190609T031849Z">
        <seg>在流式应用执行过程中，Flink会周期性地为应用状态生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the execution of an application, the JobManager receives the state handles (storage locations) of the individual task checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T050216Z" creationid="xccui" creationdate="20190502T045939Z">
        <seg>在应用执行过程中，JobManager会接收每个任务进行checkpoint的状态句柄（存储位置）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL jobs periodically import data into a data store and the data is pro&lt;t0/&gt;‐&lt;t1/&gt; cessed by ad-hoc or scheduled queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T025952Z" creationid="xccui" creationdate="20190317T025429Z">
        <seg>ELT作业周期性地把数据导入数据存储系统，并通过即席或计划查询处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL jobs periodically import data into a datastore and the data is processed by ad-hoc or scheduled queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T042806Z" creationid="xccui" creationdate="20190605T042806Z">
        <seg>ELT作业周期性地把数据导入数据存储系统，并通过即席或计划查询处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL processes can be quite complex and often require technically sophisticated solutions to meet performance requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T025827Z" creationid="xccui" creationdate="20190228T191045Z">
        <seg>该流程可能会非常麻烦，需要复杂的技术方案来满足性能要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL processes need to run periodically to keep the data in the data warehouse synchronized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T025837Z" creationid="esouser" creationdate="20190603T202915Z">
        <seg>ETL过程需要周期性地执行以确保数据仓库中数据能够同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TaskManager has a pool of network buffers (by default 32 KB in size) to send and receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195742Z" creationid="xccui" creationdate="20190606T195742Z">
        <seg>每个TaskManager有一个用于收发数据的网络缓冲区池（默认32KB大小）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TaskManager has a pool of network buffers (by default 32KB in size) which are used to send and receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042430Z" creationid="xccui" creationdate="20190504T042430Z">
        <seg>每个TaskManager有一个用于收发数据的网络缓冲区池（默认32KB大小）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TaskManager provides a certain number of slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142532Z" creationid="xccui" creationdate="20190418T051523Z">
        <seg>每个TaskManager提供一定数量的处理槽，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each application can be stateful and can locally manage its own state without accessing external datastores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214101Z" creationid="esouser" creationdate="20190603T214101Z">
        <seg>每个应用都可以是状态化的，只需要管理自身状态而无须访问外部数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each application can be stateful, i.e., locally manage its own state without accessing external data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T073303Z" creationid="xccui" creationdate="20190308T073224Z">
        <seg>每个应用都可以是状态化的，只需要管理自身状态而无须访问外部数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each component has the follow‐ ing responsibilities:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141429Z" creationid="xccui" creationdate="20190606T141429Z">
        <seg>它们各自的职责如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each component provides its own guarantees and the end-to-end guarantee of the complete pipeline would be the weakest of each of its components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035338Z" creationid="xccui" creationdate="20190416T045936Z">
        <seg>在每个组件都提供自身的保障情况下，整个处理管道上端到端的保障会取决于保障最弱的那个组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator can define one or more keyed and operator states.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214508Z" creationid="xccui" creationdate="20190609T214500Z">
        <seg>每个算子可以定义一个或多个的键值或算子状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each partition is a stream of timestamped records and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T014920Z" creationid="xccui" creationdate="20190607T014705Z">
        <seg>每个分区作为一个数据流，都会包含带有时间戳的记录以及水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each partition is processed by a task that computes the sum  of all received numbers and forwards the updated sum to a sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062301Z" creationid="xccui" creationdate="20190609T062128Z">
        <seg>每一部分都会有一个任务负责对收到的全部数字求和，并将结果值更新至下游数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each sender task needs at least four network buffers to send data to each receiver task and each receiver task requires at least four buffers to receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044254Z" creationid="xccui" creationdate="20190504T044254Z">
        <seg>每个发送端任务至少需要4个网络缓冲区来向任一接收端任务发送数据；同理每个接收端任务也需要至少4个缓冲区来接收数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eager watermarks ensure low latency but provide lower confidence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025637Z" creationid="xccui" creationdate="20190606T025637Z">
        <seg>激进的水位线策略保证了低延迟，但随之而来的是低可信度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emitting to Side Outputs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023126Z" creationid="xccui" creationdate="20190225T023126Z">
        <seg>向副输出发送数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enabling Failure Recovery for Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024644Z" creationid="xccui" creationdate="20190225T024644Z">
        <seg>在状态化应用中开启故障恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End- to-end guarantees refer to result correctness across the whole data processing pipe‐ line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035307Z" creationid="xccui" creationdate="20190606T035307Z">
        <seg>端到端的保障指的是在整个数据处理管道上结果都是正确的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end Exactly-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045106Z" creationid="xccui" creationdate="20190416T045106Z">
        <seg>端到端的精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end exactly-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035007Z" creationid="xccui" creationdate="20190606T035007Z">
        <seg>端到端的精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end guarantees refer to result cor&lt;t0/&gt;‐&lt;t1/&gt; rectness across the data processing pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045541Z" creationid="xccui" creationdate="20190416T045541Z">
        <seg>端到端的保障指的是在整个数据处理管道上结果都是正确的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring low latency is critical for many streaming applications, such as fraud detec&lt;t0/&gt;‐&lt;t1/&gt; tion, raising alarms, network monitoring, and offering services with strict service level agreements (SLAs).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T191615Z" creationid="xccui" creationdate="20190401T191318Z">
        <seg>保证低延迟对很多流式应用而言至关重要，例如：诈骗识别、警报触发、网络监测以及遵循服务级别协议（SLA）的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring low latency is critical for many streaming applications, such as fraud detec‐ tion, system alarms, network monitoring, and offering services with strict service- level agreements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234228Z" creationid="xccui" creationdate="20190605T234208Z">
        <seg>保证低延迟对很多流式应用而言至关重要，例如：诈骗识别、系统告警、网络监测以及遵循服务级别协议（SLA）的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring the Maintainability of Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024655Z" creationid="xccui" creationdate="20190225T024655Z">
        <seg>确保状态化应用的可维护性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Essentially, it is the time interval between receiving an event and seeing the effect of processing this event in the output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T152024Z" creationid="xccui" creationdate="20190401T151641Z">
        <seg>本质上，它是从接收事件到在输出中观察到事件处理所带来的影响的时间间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluation functions can be aggregations like sum or minimum or custom operations applied on the buck&lt;t14/&gt;‐&lt;t15/&gt; et’s collected elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T050152Z" creationid="xccui" creationdate="20190406T045737Z">
        <seg>这些计算函数可以是某些聚合，例如：求和、求最小值或一些直接作用于桶内收集好元素的自定义聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluation functions can be aggregations like sum or minimum or custom operations applied on the bucket’s col‐ lected elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012907Z" creationid="xccui" creationdate="20190606T012907Z">
        <seg>这些计算函数可以是某些聚合，例如：求和、求最小值或一些直接作用于桶内收集好元素的自定义聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though Flink is a distributed data processing system, you will typically develop and run initial tests on your local machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T032142Z" creationid="xccui" creationdate="20190611T031040Z">
        <seg>虽然Flink是一个分布式的数据处理系统，但你通常可以在本地计算机上进行开发并运行一些初始测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though low latency is an attractive feature of stream processing, its true value is way beyond just fast analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014221Z" creationid="xccui" creationdate="20190606T014221Z">
        <seg>尽管低延迟是流处理中一个很吸引人的特性，但流处理的真正价值远不止提供快速分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though low latency is an attractive feature of stream processing, its true value is way beyond just offering fast analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T201052Z" creationid="xccui" creationdate="20190409T200416Z">
        <seg>尽管低延迟是流处理中一个很吸引人的特性，但流处理的真正价值远不止提供快速分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though when writing the book we intended for it to be read in chapter order, readers familiar with a chapter’s content might want to skip it and readers excited about writing Flink code right away might want to read the practical chapters first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191312Z" creationid="xccui" creationdate="20190225T162157Z">
        <seg>尽管我们在写书的时候是按照预期的阅读顺序进行章节编排，但如果你已经对某些章节的内容很熟悉，仍然可以选择跳过；或者如果你迫不及待想接触Flink代码也可以选择先阅读实践章节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144203Z" creationid="esouser" creationdate="20190603T144203Z">
        <seg>事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event Time Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021843Z" creationid="xccui" creationdate="20190225T021843Z">
        <seg>事件时间处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020346Z" creationid="xccui" creationdate="20190225T020346Z">
        <seg>事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time completely decouples the processing speed from the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024245Z" creationid="xccui" creationdate="20190606T024245Z">
        <seg>事件时间将处理速度和结果内容彻底解耦。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time correctly places events in a window, reflecting the reality of how things happened</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024225Z" creationid="xccui" creationdate="20190606T024225Z">
        <seg>事件时间准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time is based on a &lt;t0/&gt;timestamp&lt;t1/&gt; that is attached on the events of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150123Z" creationid="xccui" creationdate="20190412T145549Z">
        <seg>它源自附加在流中事件的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time is based on a timestamp that is attached to the events of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024136Z" creationid="xccui" creationdate="20190606T023937Z">
        <seg>它以附加在流中事件的时间戳为依据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time is the time when an event in the stream actually happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023932Z" creationid="xccui" creationdate="20190606T023925Z">
        <seg>事件时间是数据流中事件实际发生的时间，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-Driven Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142916Z" creationid="esouser" creationdate="20190603T142916Z">
        <seg>事件驱动型应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-Time Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144458Z" creationid="esouser" creationdate="20190603T144458Z">
        <seg>事件时间处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-Time Processing | 47</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032621Z" creationid="xccui" creationdate="20190610T032621Z">
        <seg>事件时间处理 | 47</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014553Z" creationid="xccui" creationdate="20190225T014553Z">
        <seg>事件驱动型应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are an evolution of microservices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213735Z" creationid="esouser" creationdate="20190603T213735Z">
        <seg>事件驱动型应用本质上是之前讨论的微服务的演变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are an evolution of the previously discussed microservices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T151857Z" creationid="xccui" creationdate="20190307T151857Z">
        <seg>事件驱动型应用本质上是之前讨论的微服务的演变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are an interesting design pattern because they offer several benefits compared to the traditional architecture of separate storage and compute tiers or the popular microservice architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190312T212111Z" creationid="xccui" creationdate="20190308T073918Z">
        <seg>事件驱动型应用的设计模式之所以引起大家关注，主要是因为它和计算存储相互独立的传统架构以及流行的微服务架构相比，有很多优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are stateful streaming applications that ingest event streams and apply business logic on the received events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T015819Z" creationid="xccui" creationdate="20190307T015819Z">
        <seg>事件驱动型应用是一类通过接收事件流触发业务逻辑的状态化流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are stateful streaming applications that ingest event streams and process the events with application-specific business logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213515Z" creationid="esouser" creationdate="20190603T213335Z">
        <seg>事件驱动型应用是一类通过接收事件流触发特定应用业务逻辑的状态化流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications have quite high requirements on the stream processor that runs them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014619Z" creationid="xccui" creationdate="20190313T010614Z">
        <seg>事件驱动型应用对作为载体的底层流处理引擎具有极高的要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications offer several benefits compared to transactional applica‐ tions or microservices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214201Z" creationid="esouser" creationdate="20190603T214152Z">
        <seg>和事务型应用和微服务架构相比，事件驱动型应用有很多优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time and processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054041Z" creationid="xccui" creationdate="20190605T054041Z">
        <seg>同时支持事件时间和处理时间语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time completely decouples the processing speed from the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150740Z" creationid="xccui" creationdate="20190412T150740Z">
        <seg>事件时间将处理速度和结果内容彻底解耦。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time correctly places events in a window, reflecting the reality of how things happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150649Z" creationid="xccui" creationdate="20190412T150619Z">
        <seg>事件时间准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time is the time when an event in the stream actually happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145554Z" creationid="xccui" creationdate="20190412T145346Z">
        <seg>事件时间是数据流中事件实际发生的时间，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time provides consistent and accurate results despite out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042352Z" creationid="xccui" creationdate="20190328T042125Z">
        <seg>事件时间能够针对无序事件提供一致、精确的结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time semantics provide consis‐ tent and accurate results despite out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054107Z" creationid="xccui" creationdate="20190605T054107Z">
        <seg>事件时间语义能够针对无序事件提供一致、精确的结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are buffered in the player’s phone and delivered to the application when the network connection is restored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T153031Z" creationid="xccui" creationdate="20190411T153031Z">
        <seg>事件会缓存在玩家的手机里，网络恢复后才会发给应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are usually assigned to buckets based on data properties or based on time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T044950Z" creationid="xccui" creationdate="20190406T044901Z">
        <seg>事件通常会根据其时间或其他数据属性分配到不同桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are written to a durable, append-only log which means that the order of written events cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T054925Z" creationid="xccui" creationdate="20190305T054304Z">
        <seg>由于事件只能以追加的形式写入持久化日志中，因此其顺序无法在后期改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are written to a durable, append-only log, which means that the order of written events cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210612Z" creationid="esouser" creationdate="20190603T210612Z">
        <seg>由于事件只能以追加的形式写入持久化日志中，因此其顺序无法在后期改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events in a data stream can represent monitoring data, sensor measurements, credit card transactions, weather station observations, online user interactions, web searches, etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T143258Z" creationid="xccui" creationdate="20190401T143030Z">
        <seg>数据流中的事件可以表示监控数据、传感器测量值、信用卡交易、气象站观测数据、在线用户交互、网络搜索等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events with different keys can be processed by the same task, but the keyed state of a task’s function is always accessed in the scope of the current event’s key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050816Z" creationid="xccui" creationdate="20190614T050816Z">
        <seg>虽然键值不同的事件也可能会在同一个任务上处理，但任务函数所能访问的键值状态始终会被约束在当前事件键值的范围内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eventually, the checkpoint barriers arrive at a sink task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193734Z" creationid="xccui" creationdate="20190609T193734Z">
        <seg>最终检查点分隔符到达数据汇任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every record contains an average temperature of a sensor over a period of 5 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054643Z" creationid="xccui" creationdate="20190612T054622Z">
        <seg>每条记录都会包含对应传感器在5秒内的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evolving Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024857Z" creationid="xccui" creationdate="20190225T024857Z">
        <seg>状态化应用的演变</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050839Z" creationid="xccui" creationdate="20190415T050839Z">
        <seg>精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034738Z" creationid="xccui" creationdate="20190606T034738Z">
        <seg>精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once is the strictest guarantee and hard to achieve.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034820Z" creationid="xccui" creationdate="20190606T034802Z">
        <seg>精确一次是最严格，也是最难实现的一类保障，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once means that not only will there be no event loss, but also updates on the internal state will be applied exactly once for each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034815Z" creationid="xccui" creationdate="20190606T034808Z">
        <seg>它意味着不但没有事件丢失，而且每个事件对于内部状态的更新都只有一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once result guarantees means that not only there will be no event loss, but also updates on the internal state will be applied exactly once for each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044034Z" creationid="xccui" creationdate="20190416T043928Z">
        <seg>精确一次结果保障意味着不但没有事件丢失，而且每个事件对于内部状态的更新都只有一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once state consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054402Z" creationid="xccui" creationdate="20190605T054206Z">
        <seg>提供精确一次的状态一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035805Z" creationid="xccui" creationdate="20190612T035805Z">
        <seg>示例5-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except from experiencing network delays, streams might be affected by many other factors resulting in events arriving &lt;t0/&gt;out-of-order&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T152014Z" creationid="xccui" creationdate="20190412T151943Z">
        <seg>除了遇到网络延迟外，数据流还可能受很多其他因素的影响，从而导致事件乱序到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035744Z" creationid="xccui" creationdate="20190418T035744Z">
        <seg>执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execute the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044410Z" creationid="xccui" creationdate="20190612T044410Z">
        <seg>运行程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly Providing Type Information</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145233Z" creationid="esouser" creationdate="20190603T145233Z">
        <seg>显式提供类型信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly providing TypeInformation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022853Z" creationid="xccui" creationdate="20190225T022853Z">
        <seg>显式提供TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exposing Queryable State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151726Z" creationid="xccui" creationdate="20190225T025031Z">
        <seg>对外暴露可查询式状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extract the archive file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024939Z" creationid="xccui" creationdate="20190329T024915Z">
        <seg>提取归档文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extract the archive file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123035Z" creationid="xccui" creationdate="20190605T123035Z">
        <seg>提取归档文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fabian Hueske and Vasiliki Kalavri</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T062527Z" creationid="esouser" creationdate="20190603T142832Z">
        <seg>费比安·霍斯克，瓦西里基·卡拉夫里</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Farnham</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210639Z" creationid="esouser" creationdate="20190603T210639Z">
        <seg>Farnham</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Expressions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145343Z" creationid="esouser" creationdate="20190603T145343Z">
        <seg>字段表达式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Positions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145330Z" creationid="esouser" creationdate="20190603T145330Z">
        <seg>字段位置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T051343Z" creationid="xccui" creationdate="20190226T155724Z">
        <seg>图1-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-2 depicts a microservices architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T201038Z" creationid="esouser" creationdate="20190603T201038Z">
        <seg>图1-2描绘了微服务的架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T201055Z" creationid="xccui" creationdate="20190228T172811Z">
        <seg>图1-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203636Z" creationid="xccui" creationdate="20190228T194722Z">
        <seg>图1-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210546Z" creationid="xccui" creationdate="20190305T033052Z">
        <seg>图1-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-5 shows a service architecture composed of event-driven streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213938Z" creationid="esouser" creationdate="20190603T213855Z">
        <seg>图1-5粗略展示了一个由事件驱动型应用组成的服务架构，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213901Z" creationid="xccui" creationdate="20190307T152532Z">
        <seg>图1-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044636Z" creationid="xccui" creationdate="20190317T061404Z">
        <seg>图1-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051830Z" creationid="xccui" creationdate="20190322T043259Z">
        <seg>图1-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123342Z" creationid="xccui" creationdate="20190329T035536Z">
        <seg>图1-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123747Z" creationid="xccui" creationdate="20190329T041504Z">
        <seg>图1-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-1 shows a dataflow program that extracts and counts hashtags from an input stream of tweets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224949Z" creationid="xccui" creationdate="20190605T224942Z">
        <seg>图2-1展示了一个从推文输入流中提取并计算主题标签数目的Dataflow程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000821Z" creationid="xccui" creationdate="20190401T000821Z">
        <seg>图2-1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-10 shows a parallel count- based tumbling window of length 2 that is partitioned by event color.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014052Z" creationid="xccui" creationdate="20190606T014052Z">
        <seg>图2-10展示了一个按事件颜色划分、基于数量2的并行滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195852Z" creationid="xccui" creationdate="20190409T195852Z">
        <seg>图2-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-11 illustrates this problem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T015254Z" creationid="xccui" creationdate="20190606T015143Z">
        <seg>图2-11解释了这一问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152133Z" creationid="xccui" creationdate="20190411T152133Z">
        <seg>图2-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145254Z" creationid="xccui" creationdate="20190412T145254Z">
        <seg>图2-12，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-13 shows that an event-time window would correctly place events in a window, reflecting the reality of how things happened, even though some events were delayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024207Z" creationid="xccui" creationdate="20190606T024207Z">
        <seg>如图2-13所示，即便事件有延迟，事件时间窗口也能准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150547Z" creationid="xccui" creationdate="20190412T150547Z">
        <seg>图2-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-2 shows a physical dataflow graph for the logical graph of Figure 2-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233137Z" creationid="xccui" creationdate="20190605T233123Z">
        <seg>图2-2展示了图2-1中逻辑图对应的物理Dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233204Z" creationid="xccui" creationdate="20190401T021435Z">
        <seg>图2-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233614Z" creationid="xccui" creationdate="20190401T142156Z">
        <seg>图2-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011531Z" creationid="xccui" creationdate="20190405T155233Z">
        <seg>图2-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-5 shows a rolling minimum aggregation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011908Z" creationid="xccui" creationdate="20190606T011908Z">
        <seg>图2-5展示了一个求最小值的滚动聚合，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011935Z" creationid="xccui" creationdate="20190406T035853Z">
        <seg>图2-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-6 shows a count-based tumbling window that discretizes the input stream into buckets of four elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013041Z" creationid="xccui" creationdate="20190606T013033Z">
        <seg>图2-6中基于数量的滚动窗口将输入流按每4个元素一组分配到不同的桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013105Z" creationid="xccui" creationdate="20190407T023535Z">
        <seg>图2-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-7 shows a time-based tumbling window that gathers events into buckets and triggers computation every 10 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013100Z" creationid="xccui" creationdate="20190606T013100Z">
        <seg>图2-7中基于时间的滚动窗口将事件汇集到桶中，每10分钟触发一次计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013116Z" creationid="xccui" creationdate="20190407T023601Z">
        <seg>图2-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013309Z" creationid="xccui" creationdate="20190407T024337Z">
        <seg>图2-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-9 shows a session win‐ dow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013816Z" creationid="xccui" creationdate="20190606T013816Z">
        <seg>图2-9展示了一个会话窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193600Z" creationid="xccui" creationdate="20190409T193600Z">
        <seg>图2-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1 &lt;t0/&gt;visualizes how Flink’s components interact with each other when an applica&lt;t1/&gt;‐&lt;t2/&gt; &lt;t3/&gt;tion is submitted for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024536Z" creationid="xccui" creationdate="20190423T024536Z">
        <seg>图3-1展示了应用提交执行过程中Flink各组件之间的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1 is a high-level sketch to visualize the responsibilities and interactions of the components of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143207Z" creationid="xccui" creationdate="20190606T143140Z">
        <seg>图3-1仅从一个较高层次上展示了各组件的职责与交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1 shows how Flink’s components interact with each other when an applica‐ tion is submitted for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143119Z" creationid="xccui" creationdate="20190606T143119Z">
        <seg>图3-1展示了应用提交执行过程中Flink各组件之间的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024559Z" creationid="xccui" creationdate="20190423T024553Z">
        <seg>图3-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-10 shows the typical interaction between a task and its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054157Z" creationid="xccui" creationdate="20190607T054157Z">
        <seg>图3-10展示了某个任务和它状态之间的典型交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054241Z" creationid="xccui" creationdate="20190607T054204Z">
        <seg>图3-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-11 shows how tasks access operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061822Z" creationid="xccui" creationdate="20190607T061818Z">
        <seg>图3-11展示了任务访问算子状态的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061850Z" creationid="xccui" creationdate="20190607T061850Z">
        <seg>图3-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-12 shows how tasks interact with keyed state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191856Z" creationid="xccui" creationdate="20190607T191856Z">
        <seg>图3-12展示了任务和键值状态的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191916Z" creationid="xccui" creationdate="20190607T191916Z">
        <seg>图3-12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-13 shows how keyed state is repartitioned in key groups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060134Z" creationid="xccui" creationdate="20190608T060134Z">
        <seg>图3-13展示了键值状态通过键值组进行重新分区的过程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060142Z" creationid="xccui" creationdate="20190608T060142Z">
        <seg>图3-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-14 shows the redistribution of operator list state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060932Z" creationid="xccui" creationdate="20190608T060915Z">
        <seg>图3-14展示了算子列表状态的重分配过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-14.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060955Z" creationid="xccui" creationdate="20190608T060955Z">
        <seg>图3-14，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-15 shows how operator union list state is redistributed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061440Z" creationid="xccui" creationdate="20190608T061440Z">
        <seg>图3-15展示了算子联合列表状态的重分配过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-15.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061453Z" creationid="xccui" creationdate="20190608T061444Z">
        <seg>图3-15，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-16 shows the redistribution of operator broadcast state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062216Z" creationid="xccui" creationdate="20190608T062216Z">
        <seg>图3-16展示了算子广播状态的重分配过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062225Z" creationid="xccui" creationdate="20190608T062224Z">
        <seg>图3-16，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-17 shows a consistent checkpoint of a simple application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224948Z" creationid="xccui" creationdate="20190608T224942Z">
        <seg>图3-17展示了一个简单应用的一致性检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-17.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224957Z" creationid="xccui" creationdate="20190608T224957Z">
        <seg>图3-17，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-18 shows the recovery process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035854Z" creationid="xccui" creationdate="20190609T035854Z">
        <seg>图3-18展示了整个恢复过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-18.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035859Z" creationid="xccui" creationdate="20190609T035859Z">
        <seg>图3-18，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062327Z" creationid="xccui" creationdate="20190609T062327Z">
        <seg>图3-19，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-2 shows the relationships between Task‐ Managers, slots, tasks, and operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144423Z" creationid="xccui" creationdate="20190606T144423Z">
        <seg>图3-2展示了TaskManager、处理槽、任务以及算子之间的关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042935Z" creationid="xccui" creationdate="20190423T042916Z">
        <seg>图3-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-20.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062435Z" creationid="xccui" creationdate="20190609T062435Z">
        <seg>图3-20，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-21 shows the streaming application after both source tasks checkpointed their local state and emit‐ ted checkpoint barriers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155312Z" creationid="xccui" creationdate="20190609T155242Z">
        <seg>图3-21展示了流式应用为数据源任务的本地状态生成检查点并发出检查点分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-21.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155332Z" creationid="xccui" creationdate="20190609T155332Z">
        <seg>图3-21，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T174943Z" creationid="xccui" creationdate="20190609T174943Z">
        <seg>图3-22，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-23.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T191821Z" creationid="xccui" creationdate="20190609T191821Z">
        <seg>图3-23，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-24 shows the application at this point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193413Z" creationid="xccui" creationdate="20190609T193413Z">
        <seg>图3-24展示了此时的应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-24.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193437Z" creationid="xccui" creationdate="20190609T193437Z">
        <seg>图3-24，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-25 shows the final step of the checkpointing algorithm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194328Z" creationid="xccui" creationdate="20190609T194328Z">
        <seg>图3-25展示了检查点算法的最后一步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-25.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194520Z" creationid="xccui" creationdate="20190609T194520Z">
        <seg>图3-25，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-26 shows an application with three operators, each running with two tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214838Z" creationid="xccui" creationdate="20190609T214829Z">
        <seg>图3-26所展示的应用包含了3个算子，每个算子各有两个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-26.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215058Z" creationid="xccui" creationdate="20190609T215058Z">
        <seg>图3-26，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-3 illustrates this design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T194307Z" creationid="xccui" creationdate="20190606T194307Z">
        <seg>图3-3阐明了这一设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051909Z" creationid="xccui" creationdate="20190502T051909Z">
        <seg>图3-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-4 shows this architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T200550Z" creationid="xccui" creationdate="20190606T200545Z">
        <seg>图3-4展示了这一架构.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T043815Z" creationid="xccui" creationdate="20190504T043815Z">
        <seg>图3-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152413Z" creationid="esouser" creationdate="20190514T152357Z">
        <seg>图3-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-6 &lt;t0/&gt;depicts how the pipeline is executed with task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152448Z" creationid="esouser" creationdate="20190514T152448Z">
        <seg>图3-6展示了流水线如何在任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-6 depicts how the pipeline is executed with task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203516Z" creationid="xccui" creationdate="20190606T203516Z">
        <seg>图3-6展示了流水线如何在任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153047Z" creationid="esouser" creationdate="20190514T153047Z">
        <seg>图3-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-7 shows the same pipeline executed without task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204010Z" creationid="xccui" creationdate="20190606T203922Z">
        <seg>图3-7展示了相同的流水线在非任务链接模式下执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T154741Z" creationid="esouser" creationdate="20190514T154741Z">
        <seg>图3-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042306Z" creationid="xccui" creationdate="20190523T042306Z">
        <seg>图3-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-9 shows how a task with four input partitions and three output partitions receives watermarks, updates its partition watermarks and event-time clock, and emits watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025533Z" creationid="xccui" creationdate="20190607T025519Z">
        <seg>图3-9展示了一个有4个输入分区和3个输出分区的任务在接收到水位线后是如何更新它的分区水位线和事件时间时钟，并将水位线发出的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025624Z" creationid="xccui" creationdate="20190607T025617Z">
        <seg>图3-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 4-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041603Z" creationid="xccui" creationdate="20190611T041603Z">
        <seg>图4-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 4-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041632Z" creationid="xccui" creationdate="20190611T041632Z">
        <seg>图4-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 4-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041648Z" creationid="xccui" creationdate="20190611T041648Z">
        <seg>图4-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-1 shows a map transformation that converts every square into a circle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045343Z" creationid="xccui" creationdate="20190613T045343Z">
        <seg>图5-1所示的map转换会将每个方形输入转换为圆形。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045347Z" creationid="xccui" creationdate="20190613T045347Z">
        <seg>图5-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-2 shows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052259Z" creationid="xccui" creationdate="20190613T052259Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052306Z" creationid="xccui" creationdate="20190613T052306Z">
        <seg>图5-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-3 shows a flatMap operation that differentiates its output based on the color of the incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054323Z" creationid="xccui" creationdate="20190613T054323Z">
        <seg>图5-3展示的flatMap操作会根据输入事件颜色的不同输出不同的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054545Z" creationid="xccui" creationdate="20190613T054545Z">
        <seg>图5-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051113Z" creationid="xccui" creationdate="20190614T051113Z">
        <seg>图5-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figures 4-1 to 4-3 illustrate the import process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041557Z" creationid="xccui" creationdate="20190611T041557Z">
        <seg>图4-1到图4-3展示了导入过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File System Configuration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025511Z" creationid="xccui" creationdate="20190225T025511Z">
        <seg>文件系统配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File System Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025157Z" creationid="xccui" creationdate="20190225T025157Z">
        <seg>文件系统汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File System Source Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025149Z" creationid="xccui" creationdate="20190225T025149Z">
        <seg>文件系统源连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem Configuration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152252Z" creationid="esouser" creationdate="20190603T152252Z">
        <seg>文件系统配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152052Z" creationid="esouser" creationdate="20190603T152052Z">
        <seg>文件系统汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem Source Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152039Z" creationid="esouser" creationdate="20190603T152039Z">
        <seg>文件系统源连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T051132Z" creationid="xccui" creationdate="20190613T051132Z">
        <seg>Filter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Chapter 11 contains resources you can use to ask questions, attend Flink- related events, and learn how Flink is currently being used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162637Z" creationid="esouser" creationdate="20190603T162637Z">
        <seg>最后在第11章，我们提供了一些资源，以方便你提问、参与Flink相关活动和了解Flink的现实应用场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Chapter 11 contains resources you can use to ask questions, attend Flink-related events, and learn what people use Flink for.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T190926Z" creationid="xccui" creationdate="20190225T190148Z">
        <seg>最后在第11章，我们提供了一些资源，以方便你提问、参与Flink相关活动和了解Flink的现实应用场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, by leveraging an event log as input source the complete input of an applica&lt;t0/&gt;‐&lt;t1/&gt; tion is reliably stored and can be deterministically replayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190312T212958Z" creationid="xccui" creationdate="20190312T212817Z">
        <seg>以事件日志作为应用的输入，不但完整可靠，而且还支持精准的数据重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, processing time windows offer a faithful rep&lt;t0/&gt;‐&lt;t1/&gt; resentation of the streams themselves, might also be a desirable property for some use-cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T044817Z" creationid="xccui" creationdate="20190414T044223Z">
        <seg>最后一点，处理时间窗口能够表示数据流自身的真实情况，这可能是某些用例的理想属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, processing-time windows offer a faithful rep‐ resentation of the streams themselves, which might be a desirable property for some use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031118Z" creationid="xccui" creationdate="20190606T031118Z">
        <seg>最后一点，处理时间窗口能够表示数据流自身的真实情况，这可能是某些用例的理想属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we apply a user-defined function that computes the average temperature on each window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053852Z" creationid="xccui" creationdate="20190612T053852Z">
        <seg>最后我们用了一个用户自定义函数来计算每个窗口的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we briefly discuss the evolution of open source stream processors and help you run a streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T050750Z" creationid="esouser" creationdate="20190603T163101Z">
        <seg>最后，我们会简要回顾开源流处理引擎的衍变，并帮助你在本地Flink实例上运行一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we briefly discuss the evolution of open source stream processors and help you to run a first streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014510Z" creationid="xccui" creationdate="20190225T223601Z">
        <seg>章节最后，我们会简要回顾开源流处理引擎的衍变，并帮助你在本地Flink实例上运行第一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we explain how Flink’s highly available mode works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141208Z" creationid="xccui" creationdate="20190606T141208Z">
        <seg>最后，我们会解释Flink高可用模式的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we explain how Flink’s highly-available mode works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033313Z" creationid="xccui" creationdate="20190418T033232Z">
        <seg>最后，我们会解释Flink高可用模式的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we learned why state is important in streaming applications and how to guard it against failures and guarantee correct results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041236Z" creationid="xccui" creationdate="20190606T040520Z">
        <seg>最后我们了解了状态对流式应用的重要性，以及如何应对故障并保证结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we say a big thank you to all the people at O’Reilly who accompanied us on our two and a half year long journey and helped us to push this project over the fin‐ ish line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T045126Z" creationid="xccui" creationdate="20190605T134105Z">
        <seg>最后，我们非常感谢O'Reilly的相关工作人员：Alicia Young、Colleen Lobner、Christine Edwards、Katherine Tozer、Marie Beaugureau以及Tim McGovern，感谢你们在这两年半旅途中的陪伴，共同协助我们将这个项目推至终点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we show how to bootstrap a Flink Maven project, the starting point for a new application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004304Z" creationid="xccui" creationdate="20190610T040552Z">
        <seg>最后我们会介绍如何创建Flink Maven项目，这通常是任何一个新应用的起点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we took a look at Apache Flink and the extensive features it offers and showed how to install a local Flink setup and run a first stream processing application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130025Z" creationid="xccui" creationdate="20190605T125759Z">
        <seg>最后我们简单了解了Apache Flink以及它提供的诸多特性，展示了如何在本地安装设置Flink并运行第一个流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you have seen why state is important in streaming applications and how you can guard it against failures and guarantee correct results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051729Z" creationid="xccui" creationdate="20190416T051720Z">
        <seg>最后你明白了状态对流式应用的重要性，以及如何在故障时保证结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you should stop the local Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045629Z" creationid="xccui" creationdate="20190329T045629Z">
        <seg>最后别忘了停止本地Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you should stop the local Flink cluster:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124426Z" creationid="xccui" creationdate="20190605T124426Z">
        <seg>最后别忘了停止本地Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Find us on Facebook: http://facebook.com/oreilly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210845Z" creationid="esouser" creationdate="20190603T210845Z">
        <seg>Find us on Facebook: http://facebook.com/oreilly</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First Edition</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210730Z" creationid="esouser" creationdate="20190603T210730Z">
        <seg>First Edition</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First of all, it requires two semantically equivalent implementations of the application logic for two separate processing sys&lt;t2/&gt;‐&lt;t3/&gt; tems with different APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T030941Z" creationid="xccui" creationdate="20190327T030811Z">
        <seg>首先，该架构需要在拥有不同API的两套独立处理系统之上实现两次语义相同的应用逻辑；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First of all, it requires two semantically equivalent implementations of the application logic for two separate processing systems with different APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052927Z" creationid="xccui" creationdate="20190605T052927Z">
        <seg>首先，该架构需要在拥有不同API的两套独立处理系统之上实现两次语义相同的应用逻辑；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First research prototypes and com&lt;t0/&gt;‐&lt;t1/&gt; mercial products date back to the late 1990s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T041319Z" creationid="xccui" creationdate="20190319T041302Z">
        <seg>它最初的原型和商业产品可以追溯到上世纪90年代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, a savepoint of a running application is taken and then it is used to restore the state in a starting application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214317Z" creationid="xccui" creationdate="20190609T214237Z">
        <seg>首先为正在运行的应用生成一个保存点，然后在应用启动时用它去初始化状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it needs to restart failed pro&lt;t2/&gt;‐&lt;t3/&gt; cesses and second, it needs to restart the application and recover its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205013Z" creationid="xccui" creationdate="20190428T204413Z">
        <seg>一是需要重启故障进程，二是需要重启应用并恢复其状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it should be clear that there is an optimal latency in the case of no load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T204244Z" creationid="xccui" creationdate="20190402T204244Z">
        <seg>首先需要明确的是，在空负载的情况下延迟会达到最优。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it should be clear that there is optimal latency when there is no load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235030Z" creationid="xccui" creationdate="20190605T235030Z">
        <seg>首先需要明确的是，在空负载的情况下延迟会达到最优。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, let’s discuss the software you need to develop Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T040837Z" creationid="xccui" creationdate="20190610T040837Z">
        <seg>首先我们来讨论一下开发Flink应用所需的软件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, let’s have a look at the data type we will be using to represent sensor readings:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035700Z" creationid="xccui" creationdate="20190612T035700Z">
        <seg>首先来看一下传感器读取数据的数据类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you can parti&lt;t0/&gt;‐&lt;t1/&gt; tion your input data and have tasks of the same operation execute on the data subsets in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032148Z" creationid="xccui" creationdate="20190401T030434Z">
        <seg>首先，你可以将输入数据分组，让同一操作的多个任务并发执行在不同数据子集上，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you can parti‐ tion your input data and have tasks of the same operation execute on the data subsets in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233238Z" creationid="xccui" creationdate="20190605T233227Z">
        <seg>首先，你可以将输入数据分组，让同一操作的多个任务并发执行在不同数据子集上，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlatMap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053224Z" creationid="xccui" creationdate="20190613T053224Z">
        <seg>FlatMap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142352Z" creationid="esouser" creationdate="20190603T142352Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink  provides different ways to deal with late records, which are discussed in “Handling Late Data” on page 148.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205759Z" creationid="xccui" creationdate="20190606T205759Z">
        <seg>为了处理迟到记录，Flink提供了不同的机制，我们将在148页"处理迟到记录"一节讨论它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink Web UI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030126Z" creationid="xccui" creationdate="20190225T030126Z">
        <seg>Flink Web UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink achieves millisecond latencies and is able to process millions of events per second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042644Z" creationid="xccui" creationdate="20190328T042616Z">
        <seg>Flink能够实现毫秒级延迟，同时每秒可处理数百万条事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink allows for updating the application code of jobs and migrating jobs to dif&lt;t0/&gt;‐&lt;t1/&gt; ferent Flink clusters without losing the state of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052335Z" creationid="xccui" creationdate="20190328T052036Z">
        <seg>Flink允许在不丢失应用状态的前提下更新作业的程序代码或进行跨Flink集群的作业迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink also</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211241Z" creationid="xccui" creationdate="20190609T211241Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink applications can be deployed in two different styles.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025403Z" creationid="xccui" creationdate="20190423T025315Z">
        <seg>Flink应用可以通过两种模式进行部署。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink applications can be scaled to run on thousands of cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042749Z" creationid="xccui" creationdate="20190328T042749Z">
        <seg>基于Flink的应用可以扩展到数千核心之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink appli‐ cations can be scaled to run on thousands of cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T055912Z" creationid="xccui" creationdate="20190605T055912Z">
        <seg>基于Flink的应用可以扩展到数千核心之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not automatically take a save‐ point, so a user (or external scheduler) has to explicitly trigger its creation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210829Z" creationid="xccui" creationdate="20190609T210829Z">
        <seg>保存点的生成不是由Flink自动完成，而是需要由用户（或外部调度器）显式触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not implement all this functionality by itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T031440Z" creationid="xccui" creationdate="20190418T031424Z">
        <seg>Flink并没有依靠自己实现所有上述功能，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not provide durable, distributed storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032116Z" creationid="xccui" creationdate="20190418T032114Z">
        <seg>Flink没有提供分布式持久化存储，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not provide tooling to restart failed processes when running in a stand-alone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T040150Z" creationid="xccui" creationdate="20190504T035856Z">
        <seg>Flink没有针对独立集群模式提供重启故障进程的工具，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not provide tooling to restart failed processes when running in a standalone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195157Z" creationid="xccui" creationdate="20190606T195157Z">
        <seg>Flink没有针对独立集群模式提供重启故障进程的工具，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink encodes timestamps as 16-byte Long values and attaches them as metadata to records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205013Z" creationid="xccui" creationdate="20190606T204939Z">
        <seg>Flink内部将时间戳编码为16字节的Long类型值并将它们以元数据的形式附加在记录之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink encodes timestamps as 16-byte long values and attaches them as metadata to records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040434Z" creationid="xccui" creationdate="20190523T040434Z">
        <seg>Flink内部将时间戳编码为16字节的long类型值并将它们以元数据的形式附加在记录之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features an optimization technique called task chaining that reduces the over‐ head of local communication under certain conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203233Z" creationid="xccui" creationdate="20190606T203214Z">
        <seg>Flink采用一种名为任务链接的优化技术来降低部分情况下本地通信的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features an optimization technique called task chaining which reduces the over&lt;t0/&gt;‐&lt;t1/&gt; head of local communication under certain conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151913Z" creationid="esouser" creationdate="20190514T151904Z">
        <seg>Flink利用一项名为任务链接（task chaining）的优化技术来降低部分情况下本地通信的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features different techniques to reduce the communication costs between tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T192536Z" creationid="esouser" creationdate="20190513T192536Z">
        <seg>Flink采用多种技术来降低任务之间的通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features layered APIs with varying tradeoffs for expressiveness and ease-of-use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T044046Z" creationid="xccui" creationdate="20190328T042847Z">
        <seg>Flink提供的层次化API，在表达能力和易用性方面各有权衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features multiple &lt;t0/&gt;ResourceManager&lt;t1/&gt;s for different environments and resource providers such as YARN, Mesos, Kubernetes, and stand-alone deploy&lt;t2/&gt;‐&lt;t3/&gt; ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T050208Z" creationid="xccui" creationdate="20190418T050003Z">
        <seg>针对不同的环境和资源提供者（例如：YARN、Mesos、Kubernetes或独立部署），Flink提供了不同的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features multiple ResourceManagers for different environments and resource providers such as YARN, Mesos, Kubernetes, and standalone deploy‐ ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142057Z" creationid="xccui" creationdate="20190606T142057Z">
        <seg>针对不同的环境和资源提供者（例如：YARN、Mesos、Kubernetes或独立部署），Flink提供了不同的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink guarantees this by periodically writing a consistent checkpoint of the application state to a remote and durable storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154922Z" creationid="xccui" creationdate="20190305T032707Z">
        <seg>为了实现该特性，Flink会定期将应用状态的一致性检查点写入远程持久化存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements a credit-based flow control mechanism that works as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202657Z" creationid="xccui" creationdate="20190606T202654Z">
        <seg>Flink实现了一个基于信用值的流量控制机制，它的工作原理如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements a credit-based flow control mechanism which works as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151603Z" creationid="esouser" creationdate="20190513T210738Z">
        <seg>Flink实现了一个基于信用度的流量控制机制，它的工作原理如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements tweaks that can alleviate the performance impact under certain conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195937Z" creationid="xccui" creationdate="20190609T195841Z">
        <seg>Flink实现了一些调整策略，从而可以减轻某些条件下对性能的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements watermarks as special records that are received and emitted by operator tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040759Z" creationid="xccui" creationdate="20190529T040724Z">
        <seg>Flink内部将水位线实现为特殊的记录，可以通过算子任务进行接收和发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is a distributed data processing system, and as such, has to deal with failures such as killed processes, failing machines, and interrupted network connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T151730Z" creationid="xccui" creationdate="20190608T062326Z">
        <seg>Flink是一个分布式的数据处理系统，因此必须能够处理一些故障，例如：进程被强制关闭、机器故障以及网络连接中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is a distributed system for stateful parallel data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190417T181954Z" creationid="xccui" creationdate="20190417T181954Z">
        <seg>Flink是一个用于状态化并行流处理的分布式系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is able to run streaming applications 24/7 with very little downtime due to its highly-available setup (no single point of failure), a tight integration with Kubernetes, YARN, and Apache Mesos, fast recovery from failures, and the abil&lt;t0/&gt;‐&lt;t1/&gt; ity to dynamically scale jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052002Z" creationid="xccui" creationdate="20190328T051545Z">
        <seg>Flink支持高可用性配置（无单点失效），和Kubernetes、YARN、Apache Mesos紧密集成，快速故障恢复，动态扩容作业等。基于上述特点，它可以7*24小时运行流式应用，几乎无须停机。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is well integrated with cluster resource managers, such as Apache Mesos, YARN, and Kubernetes, but can also be configured to run as a stand- alone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140736Z" creationid="xccui" creationdate="20190606T140736Z">
        <seg>Flink和很多集群管理器，例如：Apache Mesos、YARN、Kubernetes，都有很好地集成；同时它也可以通过配置以独立集群模式运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is well integrated with cluster resource managers, such as Apache Mesos, YARN, and Kubernetes, but can also be configured to run as a stand-alone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032041Z" creationid="xccui" creationdate="20190418T032041Z">
        <seg>Flink和很多集群管理器，例如：Apache Mesos、YARN、Kubernetes，都有很好地集成；同时它也可以通过配置以独立集群模式运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink joined the Apache Software Foun&lt;t2/&gt;‐&lt;t3/&gt; dation as an incubating project in April 2014 and became a top-level project in January 2015.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T192355Z" creationid="xccui" creationdate="20190225T192355Z">
        <seg>Flink于2014年4月以孵化项目的形式进入Apache软件基金会，并在次年1月就成为了顶级项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink joined the Apache Software Foun‐ dation as an incubating project in April 2014 and became a top-level project in January 2015.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T045323Z" creationid="esouser" creationdate="20190603T162828Z">
        <seg>Flink于2014年4月以孵化项目的形式进入Apache软件基金会，并在次年一月就成为了顶级项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink maintains one state instance per key value and parti‐ tions all records with the same key to the operator task that maintains the state for this key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191729Z" creationid="xccui" creationdate="20190607T190646Z">
        <seg>Flink为每个键值都维护了一个状态实例，该实例总是会位于那个处理对应键值记录的算子任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink offers good answers to all of these requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033243Z" creationid="xccui" creationdate="20190319T033237Z">
        <seg>Flink 能够完美满足上述需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink offers three primitives for operator state:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061941Z" creationid="xccui" creationdate="20190607T061925Z">
        <seg>Flink为算子状态提供了3类原语：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink powers large-scale business-critical applications in many companies and enterprises across different industries and around the globe.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T220902Z" creationid="xccui" creationdate="20190225T220902Z">
        <seg>全球各行各业很多公司和企业的大型核心业务应用都是基于Flink完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink powers large-scale, business-critical applications in many companies and enterprises across different industries and around the globe.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162927Z" creationid="esouser" creationdate="20190603T162927Z">
        <seg>全球各行各业很多公司和企业的大型核心业务应用都是基于Flink完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink programs are executed lazily.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011017Z" creationid="xccui" creationdate="20190613T010906Z">
        <seg>Flink程序都是通过延迟计算的方式执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides Maven archetypes to generate Maven projects for Java or Scala Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004621Z" creationid="xccui" creationdate="20190612T004239Z">
        <seg>Flink提供了Maven模板来为Java或Scala的Flink应用生成Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides a well-maintained collection of stream sinks that can be used to write data to different systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054203Z" creationid="xccui" creationdate="20190612T054203Z">
        <seg>Flink提供了一组维护良好的流式数据汇，可用来完成上述工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides connectors to the most commonly used storage systems such as Apache Kafka, Apache Cassandra, Elasticsearch, JDBC, Kinesis, and (distributed) file systems such as HDFS and S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T045210Z" creationid="xccui" creationdate="20190328T044823Z">
        <seg>Flink提供了一些用于最常见存储系统的连接器，如Apache Kafka、Apache Cassandra、Elasticsearch、JDBC、Kinesis以及（分布式）文件系统（HDFS和S3等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides different mechanisms to deal with late records which are dis&lt;t8/&gt;‐&lt;t9/&gt; cussed in &lt;t10/&gt;Chapter 6&lt;t11/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035634Z" creationid="xccui" creationdate="20190529T035619Z">
        <seg>为了处理迟到记录，Flink提供了不同的机制，我们将在第6章讨论它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides different primitives for keyed state that determine the type of the value stored for each key in this distributed key-value map.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T192522Z" creationid="xccui" creationdate="20190607T192242Z">
        <seg>Flink为键值状态提供了不同原语，它们的区别就在于分布式键值映射中每个键对应存储值的类型不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides intuitive and easy-to-use primitives for common event-time process&lt;t0/&gt;‐&lt;t1/&gt; ing operations but also exposes expressive APIs to implement more advanced event-time applications with custom operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T034459Z" creationid="xccui" creationdate="20190523T034002Z">
        <seg>Flink不仅针对常见的事件时间操作提供了直观且易用的原语，还支持一些表达能力很强API，允许使用者以自定义算子的方式实现更高级的事件时间处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides intuitive and easy-to-use primitives for common event-time process‐ ing operations but also exposes expressive APIs to implement more advanced event- time applications with custom operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204453Z" creationid="xccui" creationdate="20190606T204427Z">
        <seg>Flink不仅针对常见的事件时间操作提供了直观易用的原语，还支持一些表达能力很强API，允许使用者以自定义算子的方式实现更高级的事件时间处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides state backends that manage keyed state as objects stored in in-memory data structures on the JVM heap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T052639Z" creationid="xccui" creationdate="20190608T052050Z">
        <seg>Flink提供的一类状态后端会把键值状态作为对象，以内存数据结构的形式存在JVM堆里面；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink restricts access to timestamps or watermarks through the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T012539Z" creationid="xccui" creationdate="20190607T012506Z">
        <seg>Flink对通过DataStream API访问时间戳和水位线有一些限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink restricts the access to timestamps or watermarks through the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042520Z" creationid="xccui" creationdate="20190529T042453Z">
        <seg>Flink限制通过DataStream API访问时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports event-time and processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T041957Z" creationid="xccui" creationdate="20190328T041957Z">
        <seg>Flink同时支持事件时间和处理时间语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports exactly-once state consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042435Z" creationid="xccui" creationdate="20190328T042435Z">
        <seg>Flink提供精确一次的状态一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports four patterns for scaling different types of state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T054918Z" creationid="xccui" creationdate="20190608T054918Z">
        <seg>Flink对不同类型的状态提供了4种扩缩容模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports many data types, which we describe in the next section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051637Z" creationid="xccui" creationdate="20190612T051624Z">
        <seg>Flink支持很多数据类型，我们会在下一节介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink treats all states—regardless of built-in or user-defined operators—the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T053301Z" creationid="xccui" creationdate="20190607T053200Z">
        <seg>Flink对所有状态一视同仁，无论是内置的还是用户自定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink uses ZooKeeper for leader election and as a highly available and durable datastore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T150042Z" creationid="xccui" creationdate="20190606T150002Z">
        <seg>它在Flink中主要用于"领导"选举以及高可用性数据持久化存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink uses ZooKeeper for leader election and as a highly-available and durable data store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T045628Z" creationid="xccui" creationdate="20190502T045316Z">
        <seg>它在Flink中用于"领导"选举以及高可用性数据持久化存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink will exclude stream partitions produced by idle source functions from the watermark computation of subsequent operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034703Z" creationid="xccui" creationdate="20190607T034613Z">
        <seg>Flink会在后续算子计算水位线的时候把那些来自于空闲源函数的流分区排除在外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlinkCEP for Complex Event Processing and Pattern Matching</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152541Z" creationid="esouser" creationdate="20190603T152541Z">
        <seg>用于复杂事件处理和模式匹配的FlinkCEP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s Checkpointing Algorithm</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154858Z" creationid="xccui" creationdate="20190225T022209Z">
        <seg>Flink的检查点算法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s DataStream API is available for Java and Scala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T015102Z" creationid="xccui" creationdate="20190611T014730Z">
        <seg>Flink的DataStream API支持Java和Scala语言，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s batch processing API, the DataSet API, and the runtime are separate from their corresponding stream&lt;t0/&gt;‐&lt;t1/&gt; ing counterparts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060914Z" creationid="xccui" creationdate="20190328T060503Z">
        <seg>虽然Flink用于批处理的DataSet API以及它的运行时环境都独立于对应的流处理部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s checkpointing algorithm produces consistent distributed checkpoints from streaming applications without stopping the whole application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195749Z" creationid="xccui" creationdate="20190609T195709Z">
        <seg>虽然Flink的检查点算法能够在不停止整个应用的情况下为流式应用生成一致的分布式检查点，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s checkpointing algorithm uses a special type of record called a checkpoint bar‐ rier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060715Z" creationid="xccui" creationdate="20190609T060148Z">
        <seg>Flink的检查点算法中会用到一类名为检查点分隔符（checkpoint barrier）的特殊记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s default configuration for network buffers is sufficient for small to medium-sized setups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045743Z" creationid="xccui" creationdate="20190504T045713Z">
        <seg>Flink默认的网络缓冲区配置足以应对中小型设置场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s default configuration for network buffers is sufficient for small- to medium-sized set‐ ups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T201811Z" creationid="xccui" creationdate="20190606T201811Z">
        <seg>Flink默认的网络缓冲区配置足以应对中小型设置场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s high-availability mode is based on &lt;t0/&gt;Apache ZooKeeper&lt;t1/&gt;, a system for distributed services that require coordination and consensus.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T045126Z" creationid="xccui" creationdate="20190502T045126Z">
        <seg>Flink的高可用模式是基于能够提供分布式协调和共识服务的Apache ZooKeeper系统来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s high-availability mode is based on Apache ZooKeeper, a system for distributed services that require coordination and consensus.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T150018Z" creationid="xccui" creationdate="20190606T145941Z">
        <seg>Flink的高可用模式是基于能够提供分布式协调和共识服务的Apache ZooKeeper系统来完成，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s recovery algorithm is based on state checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T205400Z" creationid="xccui" creationdate="20190609T205357Z">
        <seg>Flink的故障恢复算法是基于状态的检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s recovery mechanism is based on consistent application checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054558Z" creationid="xccui" creationdate="20190609T054558Z">
        <seg>Flink的故障恢复机制是基于应用的一致性检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s recovery mechanism is based on consistent checkpoints of application state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155305Z" creationid="xccui" creationdate="20190608T154504Z">
        <seg>Flink的故障恢复机制是基于应用状态的一致性检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s relational APIs, SQL and the LINQ-style Table API, are not discussed in this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T064340Z" creationid="xccui" creationdate="20190328T044231Z">
        <seg>而Flink的关系型API：SQL及LINQ风格的Table API，并没有在书中过多涉及。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s watermark-handling and propagation algorithm ensures operator tasks emit properly aligned timestamped records and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T031249Z" creationid="xccui" creationdate="20190607T031249Z">
        <seg>Flink的水位线处理和传播算法保证了算子任务所发出的记录时间戳和水位线一定会对齐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Follow the authors on Twitter: @fhueske and @vkalavri</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210848Z" creationid="esouser" creationdate="20190603T210848Z">
        <seg>Follow the authors on Twitter: @fhueske and @vkalavri</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Follow us on Twitter: http://twitter.com/oreillymedia</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210846Z" creationid="esouser" creationdate="20190603T210846Z">
        <seg>Follow us on Twitter: http://twitter.com/oreillymedia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For almost 40 years, O’Reilly has provided technology and    business training, knowledge, and insight to help companies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210829Z" creationid="esouser" creationdate="20190603T210829Z">
        <seg>For almost 40 years, O’Reilly has provided technology and    business training, knowledge, and insight to help companies</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For applications that require very low latency and can tolerate at-least-once state guarantees, Flink can be configured to process all arriving records during buffer alignment instead of buffering those for which the barrier has already arrived.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T204845Z" creationid="xccui" creationdate="20190609T204517Z">
        <seg>对于那些需要极低延迟且能容忍至少一次状态保障的应用，可以通过配置让Flink在分隔符对齐的过程中不缓存那些已收到分隔符所对应分区的记录，而是直接处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For batch applications, we usually care about the total execution time of a job, or how long it takes for our processing engine to read the input, perform the computation, and write back the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150442Z" creationid="xccui" creationdate="20190401T150338Z">
        <seg>对批处理应用而言，我们通常会关心作业的总执行时间，或者说处理引擎读取输入、执行计算、写回结果分别用了多长时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each event in the input stream, a task is a processing step that performs the fol‐ lowing steps: (1) receives the event, storing it in a local buffer; (2) possibly updates internal state; and (3) produces an output record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033550Z" creationid="xccui" creationdate="20190606T033527Z">
        <seg>对于输入流中的每个事件，任务都需要执行以下步骤：（1）接收事件并将它们存在本地缓冲；（2）选择性地更新内部状态；（3）产生输出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each event in the input stream, a task performs the following steps: (1) receive the event, i.e. store it in a local buffer, (2) possibly update internal state, and (3) produce an output record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042612Z" creationid="xccui" creationdate="20190415T042352Z">
        <seg>对于输入流中的每个事件，任务都需要执行以下步骤：（1）接收事件（将它们存在本地缓冲）；（2）有可能更新内部状态；（3）产生输出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each expired timer, the task invokes a call-back function that can perform a computation and emit records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042230Z" creationid="xccui" creationdate="20190529T042140Z">
        <seg>对于每个到期的定时器，调用回调函数，利用它来执行计算和发出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each expired timer, the task invokes a callback function that can perform a computation and emit records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T212956Z" creationid="xccui" creationdate="20190606T212941Z">
        <seg>对于每个到期的定时器，调用回调函数，利用它来执行计算并发出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each incoming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052406Z" creationid="xccui" creationdate="20190614T052406Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For exam&lt;t0/&gt;‐&lt;t1/&gt; ple, the data of an order processing system can be analyzed to obtain sales growth over time, to identify reasons for delayed shipments, or to predict future sales in order to adjust the inventory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T182744Z" creationid="xccui" creationdate="20190228T182744Z">
        <seg>例如：通过分析订单处理系统中的数据来获知销售增长率、分析运输延迟原因、预测销售量以调整库存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example they need to be normalized, joined or enriched with additional data, or pre-aggregated, i.e., transformations that are also commonly performed by ETL processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T013802Z" creationid="xccui" creationdate="20190314T073857Z">
        <seg>例如：标准化，与其他数据连接或丰富数据，预聚合等一系列在ETL过程中的常见变换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a time-window operator assigns records to windows according to their associated timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040311Z" creationid="xccui" creationdate="20190523T040311Z">
        <seg>例如，时间窗口算子会根据记录关联的时间戳将其分配到窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a time-window task finalizes a window computa&lt;t0/&gt;‐&lt;t1/&gt; tion and emits the result when the task event-time passes the window’s end boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T041949Z" creationid="xccui" creationdate="20190523T041914Z">
        <seg>例如：基于时间窗口的任务会在其事件时间超过窗口结束边界时确定最终的窗口进行计算并发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a time-window task finalizes a window computa‐ tion and emits the result when the task event-time passes the window’s end boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205223Z" creationid="xccui" creationdate="20190606T205223Z">
        <seg>例如：基于时间窗口的任务会在其事件时间超过窗口结束边界时确定最终的窗口进行计算并发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a window operator registers a timer for every active window, which cleans up the window’s state when the event time passes the window’s ending time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T212901Z" creationid="xccui" creationdate="20190606T211126Z">
        <seg>例如：窗口算子会为每个活动窗口注册一个定时器，它们会在事件时间超过窗口的结束时间时清理窗口状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an average latency value of 10 ms means that events are processed within 10 ms on average.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234026Z" creationid="xccui" creationdate="20190605T234026Z">
        <seg>例如：平均延迟为10毫秒表示平均每条数据会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an average latency value of 10ms means that events&lt;t8/&gt; &lt;t9/&gt;are processed within 10ms on average.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T155133Z" creationid="xccui" creationdate="20190401T154841Z">
        <seg>例如：平均延迟10毫秒表示平均每条数据会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, determining whether a specific event occurs in the input stream can be correctly realized with at-least-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T042547Z" creationid="xccui" creationdate="20190416T042315Z">
        <seg>例如：确定某个事件是否在输入流中出现过可以在至少一次保障下正确地实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if all users in a team pop 500 bubbles within one minute, they get a level-up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014931Z" creationid="xccui" creationdate="20190411T145904Z">
        <seg>（例如：如果团队所有成员在一分钟内消除了500个泡泡，他们就会提升一级）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are processing a stream of measurements from a set of sensors, you can use a parti‐ tioned operator state to maintain state for each sensor independently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032927Z" creationid="xccui" creationdate="20190606T032927Z">
        <seg>举例而言，如果你要处理从一组传感器得到的测量值数据流，则可以用分组算子状态（partitioned operator state）来独立地维持每个传感器的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are processing a stream of measurements from a set of sensors, you can use partitioned operator state to maintain state for each sensor inde&lt;t3/&gt;‐&lt;t4/&gt; pendently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T034432Z" creationid="xccui" creationdate="20190415T033859Z">
        <seg>举例而言，如果你要处理从一组传感器得到的测量值数据流，则可以用分组算子状态（partitioned operator state）来独立地维持每个传感器的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are the first customer showing up at the coffee shop right after it opened its doors in the morning, you will be served immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234700Z" creationid="xccui" creationdate="20190605T234700Z">
        <seg>这就如同你是早晨咖啡店开门后第一个顾客，将立即享受服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, information for a product that is offered in a webshop can be stored in a transactional database, a web cache, and a search index.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T070514Z" creationid="xccui" creationdate="20190314T065839Z">
        <seg>例如：网店内某产品的信息可能会同时放到事务型型数据库、网站缓存以及搜索索引中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it can make sense to break a long pipeline of chained tasks or break a chain into two tasks to schedule an expensive function to different slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T154535Z" creationid="esouser" creationdate="20190514T154252Z">
        <seg>例如：需要对过长任务链接进行切分或者将两个计算量大的函数分配到不同的处理槽中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, once data has been emitted to a sink, it is hard to guarantee result correctness, since the sink might not provide transactions to revert results that have been previously written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050731Z" creationid="xccui" creationdate="20190415T050222Z">
        <seg>举例而言，一旦数据从数据汇中写出，结果正确性将难以保障。原因在于，数据汇可能不提供事务来恢复之前写入的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the FileSystem state backend and the RocksDB state backend support asynchronous checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202717Z" creationid="xccui" creationdate="20190609T202658Z">
        <seg>举例而言，文件系统状态后端和RocksDB状态后端支持异步生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the data of an order processing system can be analyzed to obtain sales growth over time, to identify reasons for delayed shipments, or to predict future sales in order to adjust the inventory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T201909Z" creationid="esouser" creationdate="20190603T201909Z">
        <seg>例如：通过分析订单处理系统中的数据来获知销售增长率、分析运输延迟原因、预测销售量以调整库存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to finalize windows when the event-time passes their end boundaries, a time-window task registers a timer for the ending time of each of its active windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041839Z" creationid="xccui" creationdate="20190529T041558Z">
        <seg>例如：为了在事件时间越过结束边界时最终确定窗口，时间窗口任务会根据当前活动窗口的结束时间注册定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, user interactions with a series of news articles one after the other could be considered a session.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025919Z" creationid="xccui" creationdate="20190407T025745Z">
        <seg>例如：用户浏览一连串新闻文章的交互过程可以看作一个会话。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, writing a program that uses several chunks of code from this book does not require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210818Z" creationid="esouser" creationdate="20190603T210818Z">
        <seg>For example, writing a program that uses several chunks of code from this book does not require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example: “Stream Processing with Apache Flink by Fabian Hueske and Vasiliki Kalavri (O’Reilly).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210824Z" creationid="esouser" creationdate="20190603T210824Z">
        <seg>For example: “Stream Processing with Apache Flink by Fabian Hueske and Vasiliki Kalavri (O’Reilly).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a time-window operator task attaches the end time of a window as the timestamp to all records emitted by the window computation before it emits the watermark with the timestamp that triggered the computation of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T013912Z" creationid="xccui" creationdate="20190607T013520Z">
        <seg>例如：时间窗口算子任务会在发送触发窗口计算的水位线时间戳之前，为所有经过窗口计算并发出的结果附加窗口的结束时间作为它们的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, event logs like Apache Kafka can provide records from a previous offset of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044504Z" creationid="xccui" creationdate="20190609T044407Z">
        <seg>例如，类似Apache Kafka的事件日志系统就允许从之前的某个偏移读取记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if we are using a dis&lt;t2/&gt;‐&lt;t3/&gt; tributed processing engine, each operator might have several parallel tasks running on different physical machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T003110Z" creationid="xccui" creationdate="20190401T002829Z">
        <seg>例如：当我们使用分布式处理引擎，每个算子可能会在不同物理机器上运行多个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if we are using a distributed processing engine, each operator might have several parallel tasks running on different physical machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233104Z" creationid="xccui" creationdate="20190605T233104Z">
        <seg>例如：当我们使用分布式处理引擎，每个算子可能会在不同物理机器上运行多个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you are receiving meas&lt;t4/&gt;‐&lt;t5/&gt; urements from different sensors, you probably want to group the stream by sensor id before applying a window computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195017Z" creationid="xccui" creationdate="20190409T194251Z">
        <seg>例如，如果你在收集来自不同传感器的测量值，那么可能会想在应用窗口计算前按照传感器id对数据流进行划分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you are receiving measurements from different sensors, you probably want to group the stream by sensor ID before applying a window computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013856Z" creationid="xccui" creationdate="20190606T013849Z">
        <seg>例如，如果你在收集来自不同传感器的测量值，那么可能会想在应用窗口计算前按照传感器ID对数据流进行划分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in a stand-alone setup, i.e., a setup without a resource provider, the ResourceManager can only distribute the slots of available TaskManagers and cannot start new TaskManagers on its own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062146Z" creationid="xccui" creationdate="20190423T025023Z">
        <seg>例如：独立集群设置中没有资源提供者，因此ResourceManager只能分配现有TaskManager中的处理槽而无法自己启动新的TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in a standalone setup—a setup without a resource provider—the ResourceManager can only distribute the slots of available TaskManagers and cannot start new TaskManag‐ ers on its own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143258Z" creationid="xccui" creationdate="20190606T143258Z">
        <seg>例如：独立集群设置中没有资源提供者，因此ResourceManager只能分配现有TaskManager中的处理槽而无法自己启动新的TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the RocksDB state backend supports incremental checkpoints, which can significantly reduce the checkpointing overhead for very large state sizes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155142Z" creationid="xccui" creationdate="20190608T053953Z">
        <seg>举例而言，RocksDB状态后端支持增量检查点，对于大规模的状态，这会显著降低生成检查点的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you might be interested in measuring how the stream is observed and count events per second in order to detect possible outages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052851Z" creationid="xccui" creationdate="20190414T045116Z">
        <seg>例如，你可能会有兴趣监测数据流的接入情况或通过计算每秒事件数来发现潜在的数据中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you might be interested in observing the stream and counting the number of events per second to detect outages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031301Z" creationid="xccui" creationdate="20190606T031132Z">
        <seg>例如，你可能会有兴趣观察数据流的接入情况，通过计算每秒事件数来检测数据中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you might want to know how many vehicles cross an intersection every 5 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T044551Z" creationid="xccui" creationdate="20190406T043731Z">
        <seg>例如，你可能想了解某路口每5分钟的车流量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For larger setups, you need to tune the configuration as described in &lt;t2/&gt;Chapter 9&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045859Z" creationid="xccui" creationdate="20190504T045853Z">
        <seg>而对于大型设置场景，需要根据第9章的介绍调节配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For larger setups, you need to tune the configuration as described in “Main Memory and Network Buffers” on page 240.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202005Z" creationid="xccui" creationdate="20190606T201833Z">
        <seg>而对于大型设置场景，需要根据第240页"内存和网络缓冲"一节所介绍的内容调节配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For leader election in highly available setups, Flink depends on Apache ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140840Z" creationid="xccui" creationdate="20190606T140816Z">
        <seg>Flink依赖Apache ZooKeeper来完成高可用设置中的领导选举。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For leader election in highly-available setups, Flink depends on Apache ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032403Z" creationid="xccui" creationdate="20190418T032403Z">
        <seg>Flink依赖Apache ZooKeeper来完成高可用设置中的领导选举过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For local state management, a state backend stores all keyed states and ensures that all accesses are correctly scoped to the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051829Z" creationid="xccui" creationdate="20190608T051526Z">
        <seg>对于本地状态管理，状态后端会存储所有键值状态并保证能将状态访问范围正确地限制在当前键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about our books, courses, conferences, and news, see our web‐ site at http://www.oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210844Z" creationid="esouser" creationdate="20190603T210844Z">
        <seg>For more information about our books, courses, conferences, and news, see our web‐ site at http://www.oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, contact our corporate/institutional sales department: 800-998-9938 or corporate@oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210718Z" creationid="esouser" creationdate="20190603T210718Z">
        <seg>For more information, contact our corporate/institutional sales department: 800-998-9938 or corporate@oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, please visit http://oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210834Z" creationid="esouser" creationdate="20190603T210834Z">
        <seg>For more information, please visit http://oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some storage systems, Flink provides sink functions that feature exactly-once output, for example, by committing emitted records on checkpoint completion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054217Z" creationid="xccui" creationdate="20190609T053939Z">
        <seg>对于某些存储系统，Flink提供的数据汇函数支持精确一次输出，例如，在检查点完成后才会把写出的记录正式提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For such advanced applications, a good understanding of Flink’s internal time handling is often helpful and sometimes required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204542Z" creationid="xccui" creationdate="20190523T034809Z">
        <seg>在面对这些高级应用时，充分理解Flink内部事件处理机制通常会有所帮助，有时也是必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this example, your system needs Java 8 installed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122651Z" creationid="xccui" creationdate="20190605T122651Z">
        <seg>为此你需要先安装Java 8。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this your system needs to have Java 8 installed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T055409Z" creationid="xccui" creationdate="20190328T055216Z">
        <seg>为此你需要先安装Java 8。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, in many cases, you can partition the state by a key and manage the state of each partition independently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T033736Z" creationid="xccui" creationdate="20190415T033542Z">
        <seg>幸运的是，在很多场景下可以把状态按照键值划分并独立管理每一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Framework style</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143403Z" creationid="xccui" creationdate="20190606T143403Z">
        <seg>框架模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Framework style&lt;t0/&gt;: In this mode, Flink applications are packaged into a JAR file and&lt;t1/&gt; &lt;t2/&gt;submitted by a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030257Z" creationid="xccui" creationdate="20190423T025356Z">
        <seg>框架模式：在本模式下，Flink应用会打包成一个JAR文件并通过客户端提交到运行的服务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022917Z" creationid="xccui" creationdate="20190225T022917Z">
        <seg>函数类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are not able to read or modify record timestamps and watermarks, except for the &lt;t0/&gt;ProcessFunc&lt;t1/&gt; &lt;t2/&gt;tion &lt;t3/&gt;which can read the timestamp of a currently processed&lt;t4/&gt; &lt;t5/&gt;record, request the current event-time of the operator, and register timers&lt;t6/&gt;4&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T140632Z" creationid="esouser" creationdate="20190603T140632Z">
        <seg>Flink中的普通函数无法读写记录的时间戳或水位线。但有一个例外——ProcessFunction，它可以读取当前正在处理记录的时间戳，请求获取当前算子的事件时间以及注册定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are written by the application programmer and implement custom computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011521Z" creationid="xccui" creationdate="20190606T011456Z">
        <seg>函数由应用开发人员编写，可以实现某些自定义的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions cannot read or modify record time‐ stamps and watermarks, except for the process functions, which  can read the timestamp of a currently processed record, request the current event time of the operator, and register timers.3 None of the functions exposes an API to set the timestamps of emitted records, manipulate the event-time clock of a task, or emit watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T012935Z" creationid="xccui" creationdate="20190607T012544Z">
        <seg>普通函数无法读写记录的时间戳或水位线，但一系列处理函数除外，它们可以读取当前正在处理记录的时间戳，请求获得当前算子的事件时间以及注册定时器。3所有函数都无法通过API来设置发出记录的时间戳，调整任务的事件时间时钟或发出水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions, such as</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020745Z" creationid="xccui" creationdate="20190613T020745Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fundamentals, Implementation, and Operation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041340Z" creationid="esouser" creationdate="20190603T142422Z">
        <seg>流式应用基础、实现及操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, Flink can reset the state of an application to a previous savepoint, making it possible to evolve or rescale an application without losing its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T053639Z" creationid="xccui" creationdate="20190604T052208Z">
        <seg>此外，Flink可以将应用状态重置到之前的某个检查点，从而允许应用在不丢失状态的前提下更新或扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gelly for Graph Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152554Z" creationid="esouser" creationdate="20190603T152554Z">
        <seg>用于图计算的Gelly</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Give your project a name and click Finish</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041704Z" creationid="xccui" creationdate="20190611T041704Z">
        <seg>为项目命名，然后单击Finish</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a Flink setup with four TaskManagers that provide two slots each, a streaming application can be executed with a maximum par&lt;t0/&gt;‐&lt;t1/&gt; allelism of eight.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205754Z" creationid="xccui" creationdate="20190428T205630Z">
        <seg>假设一个Flink设置包含4个TaskManager，每个TaskManager有2个处理槽，那么一个流式应用最多运行以并行度8来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a Flink setup with four TaskManagers that provide two slots each, a streaming application can be executed with a maximum par‐ allelism of eight.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145448Z" creationid="xccui" creationdate="20190606T145448Z">
        <seg>假设一个Flink设置包含4个TaskManager，每个TaskManager有2个处理槽，那么一个流式应用最多运行以并行度8来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an application and a compatible savepoint, you can start the application from the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211347Z" creationid="xccui" creationdate="20190609T211347Z">
        <seg>给定一个应用和一个兼容的保存点，可以从该保存点启动应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the unpredictable reality of distributed systems and arbitrary delays that might be caused by external components, there are no categorically cor‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025236Z" creationid="xccui" creationdate="20190606T025236Z">
        <seg>鉴于分布式系统现实的不确定性以及外部组件可能引发任意延迟，这些问题没有绝对正确的答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the unpredictable reality of distributed systems and arbitrary delays that might be caused by external components, there is no categorically correct answer to these questions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T204356Z" creationid="xccui" creationdate="20190412T203922Z">
        <seg>鉴于分布式系统现实的不确定性以及外部组件可能引发任意延迟，这些问题没有绝对正确的答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given two TaskManag&lt;t0/&gt;‐&lt;t1/&gt; ers with two processing slots each, this requirement is fulfilled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T163329Z" creationid="xccui" creationdate="20190423T043703Z">
        <seg>给定两个TaskManager，每个TaskManager内都有两个处理槽，即可满足该需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given two TaskManagers with two processing slots each, this requirement is fulfilled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144546Z" creationid="xccui" creationdate="20190606T144546Z">
        <seg>给定两个TaskManager，每个TaskManager内都有两个处理槽，即可满足该需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go to the Apache Flink webpage &lt;t0/&gt;flink.apache.org&lt;t1/&gt; &lt;t2/&gt;and download the Hadoop-free binary distribution of Apache Flink 1.7.1 for Scala 2.12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024852Z" creationid="xccui" creationdate="20190329T024852Z">
        <seg>从Apache Flink官网flink.apache.org下载支持Scala 2.12的Apache Flink 1.7.1无Hadoop二进制发行版。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go to the Apache Flink webpage and download the Hadoop-free binary distribu‐ tion of Apache Flink 1.7.1 for Scala 2.12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123020Z" creationid="xccui" creationdate="20190605T123020Z">
        <seg>从Apache Flink官网flink.apache.org下载支持Scala 2.12的Apache Flink 1.7.1无Hadoop二进制发行版。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gravenstein Highway North Sebastopol, CA 95472</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210839Z" creationid="esouser" creationdate="20190603T210839Z">
        <seg>Gravenstein Highway North Sebastopol, CA 95472</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HA Kubernetes Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152240Z" creationid="esouser" creationdate="20190603T152240Z">
        <seg>Kubernetes的HA设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HA Standalone Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152203Z" creationid="esouser" creationdate="20190603T152203Z">
        <seg>独立集群的HA设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HA YARN Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152218Z" creationid="esouser" creationdate="20190603T152218Z">
        <seg>YARN上的HA设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Late Data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150755Z" creationid="xccui" creationdate="20190225T023322Z">
        <seg>处理迟到数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling delayed events is only one of the challenges that you can overcome with event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T151803Z" creationid="xccui" creationdate="20190412T151554Z">
        <seg>使用事件时间唯一要克服的挑战是如何处理延迟事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having no guaran&lt;t0/&gt;‐&lt;t1/&gt; tees whatsoever sounds like a terrible idea, but it might be fine, if you can live with approximate results and all you care about is providing the lowest latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041743Z" creationid="xccui" creationdate="20190415T184946Z">
        <seg>无论如何，没有保障听上去都不是个好主意。但如果你能接受近似结果并且只关心提供尽可能低的延迟，这种保障可能没多大问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having no guarantees whatsoever sounds like a terrible idea, but it might be fine if you can live with approximate results and all you care about is providing the lowest latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034507Z" creationid="xccui" creationdate="20190606T034436Z">
        <seg>无论如何，没有保障听上去都不是个好主意。但如果你能接受近似结果并且只关心提供尽可能低的延迟，这种保障也什么问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hello, Flink!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035709Z" creationid="xccui" creationdate="20190418T035709Z">
        <seg>Hello, Flink!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a Java JDK is required to implement Flink DataStream applications—Java JDK 8 (or higher).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T015629Z" creationid="xccui" creationdate="20190611T014959Z">
        <seg>因此在写DataStream 应用之前需要安装Java JDK 8或更高版本，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a single misbehaving task can kill a whole TaskManager process and all tasks that run on it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144925Z" creationid="xccui" creationdate="20190606T144925Z">
        <seg>因此只要有一个任务运行异常，就会终止整个TaskManager进程，它上面运行的所有任务都会随之停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a single misbehaving task can kill a whole TaskManager process and all tasks which run on the TaskManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063433Z" creationid="xccui" creationdate="20190424T063420Z">
        <seg>因此只要有一个任务运行异常，就会终止整个TaskManager进程，它上面运行的所有任务都会随之停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a typical application consists of multiple states that are distributed across multiple operator tasks that can run on different TaskManager processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214735Z" creationid="xccui" creationdate="20190609T214705Z">
        <seg>因此一个典型的应用会包含多个状态，它们分布在不同TaskManager进程内的算子任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, all data that is required to recover from a Job&lt;t2/&gt;‐&lt;t3/&gt; Manager failure is stored in the remote storage and ZooKeeper holds pointers to the storage locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051205Z" creationid="xccui" creationdate="20190502T051143Z">
        <seg>因此所有用于JobManager故障恢复的数据都在远程存储上面，而ZooKeeper持有指向这些存储位置的指针。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, all data that is required to recover from a JobManager failure is stored in the remote storage and ZooKeeper holds pointers to the storage locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T194220Z" creationid="xccui" creationdate="20190606T194220Z">
        <seg>因此所有用于JobManager故障恢复的数据都在远程存储上面，而ZooKeeper持有指向这些存储位置的指针。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, credit-based flow control is an important building block for Flink to achieve high throughput and low latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203206Z" creationid="esouser" creationdate="20190514T151545Z">
        <seg>所以说基于信用值的流量控制是Flink实现高吞吐低延迟的重要一环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, data transfer between tasks that run on the same TaskManager does not cause network communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202134Z" creationid="xccui" creationdate="20190606T202123Z">
        <seg>这意味着在同一个TaskManager内不同的任务之间传输数据不需要经过网络传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it can be useful to run stand-by JobManagers and TaskManagers that can take over the work of failed processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T040555Z" creationid="xccui" creationdate="20190504T040147Z">
        <seg>因此运行一些后备JobManager及TaskManager来接管故障进程的工作会很有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it can be useful to run standby JobManagers and TaskManagers that can take over the work of failed processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195249Z" creationid="xccui" creationdate="20190606T195220Z">
        <seg>因此运行一些后备JobManager及TaskManager来接管故障进程的工作就很有必要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it is important that their execution does not stop even if an involved process fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T204156Z" creationid="xccui" creationdate="20190424T064522Z">
        <seg>因此能够做到在内部进程发生故障时也不终止运行就显得异常重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, its storage must be considered volatile.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053629Z" creationid="xccui" creationdate="20190608T053557Z">
        <seg>它们的存储只能看做是易失的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, no events are lost and the state is completely built up from scratch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034118Z" creationid="xccui" creationdate="20190606T034000Z">
        <seg>因此不会有事件丢失，状态也可以完全从最初开始构建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, no network communication is involved for a TaskManager-local connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T192436Z" creationid="esouser" creationdate="20190513T192419Z">
        <seg>因此对于TaskManager本地连接而言无须网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, simply relying on watermarks might not always be a good idea.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025830Z" creationid="xccui" creationdate="20190414T031243Z">
        <seg>因此简单地依赖水位线并不总是可以高枕无忧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the identifier of an operator changes when one of its predecessors changes, for example, when an operator is added or removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T025037Z" creationid="xccui" creationdate="20190610T023325Z">
        <seg>这意味着任意一个前置算子的改变（例如：添加或删除某个算子）都会导致该标识发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, there are basically no serialization and communication costs for pass&lt;t3/&gt;‐&lt;t4/&gt; ing records between functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153042Z" creationid="esouser" creationdate="20190514T153042Z">
        <seg>因此函数之间的记录传输基本上不存在序列化及通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, there are basically no serialization and communication costs for passing records between functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203739Z" creationid="xccui" creationdate="20190606T203739Z">
        <seg>因此函数之间的记录传输基本上不存在序列化及通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you can fix bugs in your application logic and reprocess as many events as your streaming source can provide in order to repair your results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212237Z" creationid="xccui" creationdate="20190609T212214Z">
        <seg>这意味着你可以修复应用的一些逻辑bug，然后在数据流来源的支持范围内下尽可能多地重新处理输入事件，以此来修复结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you should be aware that you might debug a multithreaded program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T054146Z" creationid="xccui" creationdate="20190611T054146Z">
        <seg>所以你应该有可能要调试多线程程序的觉悟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we briefly review some common data exchange strate&lt;t2/&gt;‐&lt;t3/&gt; gies, as shown in &lt;t4/&gt;Figure 2-3&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034906Z" creationid="xccui" creationdate="20190401T034747Z">
        <seg>下面我们结合图2-3来简单回顾一下常见的数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we briefly review some common data exchange strate‐ gies, as shown in Figure 2-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233351Z" creationid="xccui" creationdate="20190605T233351Z">
        <seg>下面我们结合图2-3来简单回顾一下常见的数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we use a Scala case class as the data type that we defined before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051901Z" creationid="xccui" creationdate="20190612T051901Z">
        <seg>在这里我们使用事先定义好的Scala样例类作为数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly Available Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144306Z" creationid="esouser" creationdate="20190603T144306Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly Available Setups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152146Z" creationid="esouser" creationdate="20190603T152146Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Kubernetes Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025452Z" creationid="xccui" creationdate="20190225T025452Z">
        <seg>基于Kubernetes 的高可用设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021800Z" creationid="xccui" creationdate="20190225T021800Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Setups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025425Z" creationid="xccui" creationdate="20190225T025425Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Stand-Alone Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025438Z" creationid="xccui" creationdate="20190225T025438Z">
        <seg>基于独立集群的高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available YARN Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025441Z" creationid="xccui" creationdate="20190225T025441Z">
        <seg>基于YARN的高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How can you ensure that such failures are handled transparently so that your streaming job can continue to run?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T041951Z" creationid="xccui" creationdate="20190415T041907Z">
        <seg>如何保证可以透明地处理这些故障，让流式作业可以继续运行？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How exactly the state is stored, accessed, and maintained is determined by a pluggable component</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051428Z" creationid="xccui" creationdate="20190608T051306Z">
        <seg>至于状态具体的存储、访问和维护，则是由一个名为状态后端的可插拔组件决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How exactly the state of a task is copied depends on the implementation of the state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202643Z" creationid="xccui" creationdate="20190609T202643Z">
        <seg>因此任务的状态具体是怎么拷贝的完全取决于状态后端的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to Contact Us</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210835Z" creationid="esouser" creationdate="20190603T210835Z">
        <seg>How to Contact Us</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How&lt;t6/&gt;‐&lt;t7/&gt; ever, too many co-located tasks can also overload a TaskManager and result in bad performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062808Z" creationid="xccui" creationdate="20190424T062808Z">
        <seg>然而，任务过于集中也会使TaskManager负载变高，继而导致性能下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, UNIX-based setups enjoy the richest tooling support because this environment is preferred by most Flink developers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T054143Z" creationid="xccui" creationdate="20190610T041004Z">
        <seg>但基于类UNIX系统的设置会享有最丰富的工具支持，因为大多数Flink开发人员都偏爱这类环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, also with storage systems and execution engines of the Hadoop ecosystem the overall mode of operation of the infrastructure remains basically the same as the traditional data warehouse architec&lt;t2/&gt;‐&lt;t3/&gt; ture, i.e., data is periodically extracted and loaded into to a data store and processed by periodic or ad-hoc queries in a batch fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T040639Z" creationid="xccui" creationdate="20190301T034022Z">
        <seg>虽说如此，但对Hadoop生态中的存储系统和执行引擎而言，其基础工作模式仍和传统数据仓库的架构保持一致，即周期性地将数据提取加载到数据存储系统，随后以批处理的方式执行定期或ad-hoc查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, applications can freely choose the meaning of the time&lt;t0/&gt;‐&lt;t1/&gt; stamps as long as the timestamps of the stream records are roughly ascending as the stream is advancing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035947Z" creationid="xccui" creationdate="20190523T035924Z">
        <seg>但实际上应用可以自由选择时间戳的含义，只要保证流记录的时间戳会随着数据流的前进大致递增即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, applications can freely choose the meaning of the timestamps as long as the timestamps of the stream records are roughly ascending as the stream is advancing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204846Z" creationid="xccui" creationdate="20190606T204846Z">
        <seg>但实际上应用可以自由选择时间戳的含义，只要保证流记录的时间戳会随着数据流的前进大致递增即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, counting how many times a specific event occurs in the input stream might return the wrong result under at-least-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T042923Z" creationid="xccui" creationdate="20190416T042900Z">
        <seg>但如果要计算某个事件在输入流中出现的次数，至少一次保障可能就会返回错误的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, custom operators can have their own interpretation and may, for example, adjust the preci‐ sion to microseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205054Z" creationid="xccui" creationdate="20190606T205029Z">
        <seg>但自定义算子可以有自己的解析机制，例如：将精度调整为微秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, custom operators can have their own interpretation and, for example, adjust the precision to microseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040846Z" creationid="xccui" creationdate="20190523T040820Z">
        <seg>但自定义算子可以有自己的解析机制，例如，将精度调整为微秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, during busy times, customers will have to wait in line and latency will increase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T205348Z" creationid="xccui" creationdate="20190402T205216Z">
        <seg>但在高峰时段，顾客必须要排队，此时延迟将增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, even with continuous ETL there will always be a certain delay until an event is processed by a query.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032305Z" creationid="xccui" creationdate="20190317T032305Z">
        <seg>但即便使用持续ETL，事件在被查询处理到之前总会有一定延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, even with continuous ETL there will always be a delay until an event is processed by a query.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T043619Z" creationid="xccui" creationdate="20190605T043619Z">
        <seg>但即便使用持续ETL，事件在被查询处理到之前总会有一定延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, event-time applications require additional configuration com‐ pared to applications with processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204315Z" creationid="xccui" creationdate="20190606T204315Z">
        <seg>但和基于处理时间语义的应用相比，基于事件时间的应用需要一些额外的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, event-time applications require some additional configuration compared to applications with processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T160953Z" creationid="esouser" creationdate="20190514T160953Z">
        <seg>但和基于处理时间语义的应用相比，基于事件时间的应用需要一些额外的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, guaranteeing exactly-once delivery of results to external systems is very challenging.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050212Z" creationid="xccui" creationdate="20190415T045640Z">
        <seg>至于保证将结果精确一次地传递到外部系统，则难度很大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it can</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195737Z" creationid="xccui" creationdate="20190609T195737Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it has a few notable drawbacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052922Z" creationid="xccui" creationdate="20190605T052900Z">
        <seg>但存在很多不足。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it relies on the fact that all partitions continuously provide increasing watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T031937Z" creationid="xccui" creationdate="20190607T031937Z">
        <seg>但这依赖于一个事实——所有分区都会持续提供自增的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, most real-world applications combine charac&lt;t0/&gt;‐&lt;t1/&gt; teristics of more than one class which again shows the flexibility of this application design pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T072733Z" creationid="xccui" creationdate="20190305T160041Z">
        <seg>而现实中绝大多数应用都同时兼有多种类别模式的特征，这也印证了状态化流处理的灵活性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, once we reach a rate of incoming events such that the system resources are fully used, we will have to start buffering events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T201505Z" creationid="xccui" creationdate="20190401T210044Z">
        <seg>但现实中，一旦事件到达速率过高致使系统没有空闲资源，我们将被迫开始缓冲事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, once we reach a rate of incoming events such that the sys‐ tem resources are fully used, we will have to start buffering events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234718Z" creationid="xccui" creationdate="20190605T234718Z">
        <seg>但现实中，一旦事件到达速率过高致使系统没有空闲资源，将被迫开始缓冲事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, some improvements such as higher throughput and better failure guarantees came at the cost of increasing processing latencies from milliseconds to seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T050215Z" creationid="xccui" creationdate="20190327T035003Z">
        <seg>但是它们诸如高吞吐和故障处理保障等改进是以增加处理延迟（从纳秒级到秒级）为代价。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, some operations must collect and buffer records to compute their result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041813Z" creationid="xccui" creationdate="20190406T040646Z">
        <seg>但有些操作必须收集并缓冲数据才能计算结果，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the approach had a few notable drawbacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T015901Z" creationid="xccui" creationdate="20190327T015901Z">
        <seg>但它有很多不足之处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the growing adoption of stream processing technology in the recent past has been driven to a large extent by the availability of mature open source stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050242Z" creationid="xccui" creationdate="20190605T050109Z">
        <seg>然而近期流处理技术的普及在很大程度上还要归功于开源界很多成熟的流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the growing adoption of stream processing technology in the recent past is driven to a large extent by the availability of mature open source stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014756Z" creationid="xccui" creationdate="20190319T041536Z">
        <seg>然而近期流处理技术的普及还要归功于开源界很多成熟的流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the identifier of an operator is deterministically generated based on the identifiers of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T023205Z" creationid="xccui" creationdate="20190610T021226Z">
        <seg>但该标识是根据前置算子的标识按照某种确定规则生成的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the infrastructure remains basically the same as a traditional data ware‐ house architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T204519Z" creationid="esouser" creationdate="20190603T204255Z">
        <seg>但这些基础设施和传统数据仓库的架构还是基本相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the vision of the Flink community is to treat batch processing as a special case of stream processing, i.e., the processing of bounded streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060757Z" creationid="xccui" creationdate="20190328T060625Z">
        <seg>但Flink社区的视角是把批处理看做流处理的一个特例，即处理有界的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the vision of the Flink community is to treat batch processing as a special case of stream processing—the processing of bounded streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122214Z" creationid="xccui" creationdate="20190605T122214Z">
        <seg>但Flink社区的视角是把批处理看做流处理的一个特例，即处理有界的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are a few things to consider when debugging a Flink application in an IDE:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T053805Z" creationid="xccui" creationdate="20190611T053805Z">
        <seg>但在调试时需要注意一下几点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is also a mode in which the call of the execute() method starts a Job‐ Manager and a TaskManager (by default with as many slots as available CPU threads) as separate threads within the same JVM. Consequently, the whole Flink application is multithreaded and executed within the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T052546Z" creationid="xccui" creationdate="20190611T052546Z">
        <seg>但除此之外还有一种执行模式：当execute()方法被调用时，会在同一个JVM中以独立线程的方式启动一个JobManager线程和一个TaskManager（默认的处理槽数等于???CPU可用线程数???）。这样，整个Flink应用会以多线程的方式在同一个JVM进程中执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they do not meet the latency requirements for many of today’s use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T062139Z" creationid="xccui" creationdate="20190604T055430Z">
        <seg>但这对于现如今很多用例场景而言无法满足延迟的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this has dramatically changed in the last decade.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T051715Z" creationid="xccui" creationdate="20190317T033023Z">
        <seg>然而，这在过去十年里发生了巨大的变化，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, to improve the efficiency of the necessary state transfer between tasks, Flink does not redistribute individual keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T055813Z" creationid="xccui" creationdate="20190608T055302Z">
        <seg>但为了降低状态在不同任务之间迁移的必要成本，Flink不会对单独的键值执行再分配，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, transactional data is often distributed across several disconnected database systems and becomes more valuable when it can be jointly analyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192024Z" creationid="xccui" creationdate="20190228T183532Z">
        <seg>虽然如此，但事务数据通常存储于互不相连的数据库系统之中，如能将它们联结分析必能创造更大价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, transactional data is often distributed across several discon‐ nected database systems and is more valuable when it can be jointly analyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T025730Z" creationid="esouser" creationdate="20190603T201929Z">
        <seg>虽说如此，但事务数据通常存储于互不相连的数据库系统之中，如能将它们联结分析必然会创造更大价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, we have not yet discussed where they originate from.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033616Z" creationid="xccui" creationdate="20190607T033558Z">
        <seg>但一直没涉及它们的来源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, with the growing popularity of Hadoop, companies realized that a lot of valuable data was excluded from their data analytics process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T205940Z" creationid="xccui" creationdate="20190228T203747Z">
        <seg>但随着Hadoop的流行，不少公司开始意识到他们现有的数据分析流程会遗漏很多有价值的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you should also know how to create a new Flink project from scratch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004140Z" creationid="xccui" creationdate="20190612T004101Z">
        <seg>但同时你也要掌握如何从头开始创建一个新的Flink项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How‐ ever, efficient and reliable management of state is more challenging.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055302Z" creationid="xccui" creationdate="20190607T055225Z">
        <seg>而难点在于如何高效、可靠地管理状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How‐ ever, too many colocated tasks can also overload a TaskManager and result in bad performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144821Z" creationid="xccui" creationdate="20190606T144803Z">
        <seg>然而，任务过于集中也会使TaskManager负载变高，继而可能导致性能下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ideally, you would like this latency to remain constant and independent of the rate of the incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T210053Z" creationid="xccui" creationdate="20190401T205449Z">
        <seg>理想情况下，你会希望延迟保持平稳，不受事件到来速率的影响；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idempotent Sink Connectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025308Z" creationid="xccui" creationdate="20190225T025308Z">
        <seg>幂等性汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idempotent Writes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152026Z" creationid="esouser" creationdate="20190603T151856Z">
        <seg>幂等性写</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a modified application is started from a savepoint, a state in the savepoint can only be mapped to the application if it contains an operator with a corresponding identi‐ fier and state name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T220244Z" creationid="xccui" creationdate="20190609T220228Z">
        <seg>如果应用在从保存点启动的时候发生过改动，那么保存点中的状态只有在应用还保留着那些含有对应标识符和状态名称的算子时才可以成功映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a source function (temporarily) does not emit anymore watermarks, it can declare itself idle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034450Z" creationid="xccui" creationdate="20190607T034439Z">
        <seg>如果源函数（临时性地）不会再发出水位线，可以把自己声明成空闲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210742Z" creationid="esouser" creationdate="20190603T210742Z">
        <seg>If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both tasks are located on the same physical machine (which is often ensured by task schedu&lt;t2/&gt;‐&lt;t3/&gt; lers), this exchange strategy avoids network communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T134825Z" creationid="xccui" creationdate="20190401T134633Z">
        <seg>如果两端任务运行在同一物理机器上（通常由任务调度器保障），该交换策略可以避免网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both tasks are located on the same physical machine (which is often ensured by task schedu‐ lers), this exchange strategy avoids network communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233415Z" creationid="xccui" creationdate="20190605T233415Z">
        <seg>如果两端任务运行在同一物理机器上（通常由任务调度器保障），该交换策略可以避免网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If events take a long time to travel in the data processing pipeline, we cannot easily ensure high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235008Z" creationid="xccui" creationdate="20190605T234945Z">
        <seg>如果事件在数据处理管道中的传输时间太久，将难以确保高吞吐；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If events take long to travel in the data processing pipeline, we cannot easily ensure high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T203457Z" creationid="xccui" creationdate="20190402T203213Z">
        <seg>如果事件在数据处理管道中的传输时间太久，我们将难以确保高吞吐；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it fails after it has updated its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033627Z" creationid="xccui" creationdate="20190606T033627Z">
        <seg>如果在更新内部状态后发生故障，系统恢复后是否会重复更新？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it fails after it has updated its internal state, will it update it again after it recovers?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043148Z" creationid="xccui" creationdate="20190415T043141Z">
        <seg>如果在更新内部状态后发生故障，系统恢复后是否会重复更新？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one of the TaskManagers fails, the number of available slots drops to six.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205758Z" creationid="xccui" creationdate="20190428T205742Z">
        <seg>如果有一个TaskManager出现故障，则可用处理槽的数量就降到了6个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If state gets lost during a failure, results will be incorrect after recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035834Z" creationid="xccui" creationdate="20190415T035644Z">
        <seg>如果故障时状态丢失，那恢复后的结果就会不正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the JobManager runs remotely, the JobGraph must be shipped together with a JAR file that contains all classes and required dependencies of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T012656Z" creationid="xccui" creationdate="20190613T012656Z">
        <seg>如果是远程JobManager的情况，除了JobGraph之外，还要同时提供包含应用所需全部类和依赖的JAR包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the ResourceManager does not have enough slots to fulfill the JobManager’s request, the ResourceManager can talk to a resource provider to provision containers in which TaskManager processes are started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062029Z" creationid="xccui" creationdate="20190418T050826Z">
        <seg>如果ResourceManager的处理槽数无法满足JobManager的请求，ResourceManager可以和资源提供者通信，让它们提供额外容器来启动TaskManager进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application was submitted to a Dispatcher or YARN Resource&lt;t5/&gt;‐&lt;t6/&gt; Manager, it will spin up a JobManager, hand over the application, and the Job&lt;t7/&gt;‐&lt;t8/&gt; Manager continues to execute the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030049Z" creationid="xccui" creationdate="20190423T030049Z">
        <seg>如果应用提交到Dispatcher或YARN ResourceManager，它们会启动一个JobManager并将应用转交给它，随后由JobManager负责继续执行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application was submitted to a Dispatcher or YARN ResourceManager, it will spin up a JobManager and hand over the application, and the JobManager will start to execute the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143514Z" creationid="xccui" creationdate="20190606T143514Z">
        <seg>如果应用提交到Dispatcher或YARN ResourceManager，它们会启动一个JobManager并将应用转交给它，随后由JobManager负责继续执行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application was submitted to a JobManager, it immediately starts to execute the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025910Z" creationid="xccui" creationdate="20190423T025902Z">
        <seg>如果应用提交到JobManager，会立即开始执行；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the barista runs out of milk right before preparing your cappuccino, you will have to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234059Z" creationid="xccui" creationdate="20190605T234059Z">
        <seg>如果咖啡师在给你准备卡布奇诺（译者注：一种需要牛奶和奶泡的咖啡）前刚好把牛奶用光了，则你必须等他从补给室再拿一些出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the barista runs out of milk right before preparing your cappuccino, you will have to wait until they bring some from the supply room.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T160202Z" creationid="xccui" creationdate="20190401T155651Z">
        <seg>如果咖啡师在给你准备卡布奇诺（译者注：一种需要牛奶和奶泡的咖啡）前刚好把牛奶用光了，则你必须等他从补给室再拿一些出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the command completed successfully, you will find a new target folder in your project folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010337Z" creationid="xccui" creationdate="20190612T010337Z">
        <seg>如果命令成功完成，你会在项目目录里看到一个新的target文件夹。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the event-time clock advances, the task processes all triggered timers and finally broadcasts its new event time to all downstream tasks by emitting a corresponding watermark to all con‐ nected output partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025139Z" creationid="xccui" creationdate="20190607T025043Z">
        <seg>如果事件时间时钟向前推动，任务会先处理因此而触发的所有定时器，最后才会把对应的水位线发往所有连接的输出分区，从而实现将事件时间广播到全部下游任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the input is a white square, it outputs the event unmodified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054414Z" creationid="xccui" creationdate="20190613T054359Z">
        <seg>如果输入是白色方块，则不加改动直接输出；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the key domain is continuously growing—for example, because the key is a unique transaction ID—you have to clean up state for keys that are no longer active to avoid memory problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T045513Z" creationid="xccui" creationdate="20190614T045513Z">
        <seg>如果键值域会持续增长（例如将唯一的事务ID作为键值），则必须对那些不再活跃的键值进行清理，以避免出现内存问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the method is invoked from a submission cli‐ ent with a connection to a remote cluster, a remote execution environment is returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045413Z" creationid="xccui" creationdate="20190612T045413Z">
        <seg>如果是一个连接远程集群的提交客户端调用了该方法，则会返回一个远程执行环境；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the sender and receiver tasks run in separate Task&lt;t0/&gt;‐&lt;t1/&gt; Manager processes, they communicate via the network stack of the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042532Z" creationid="xccui" creationdate="20190504T042532Z">
        <seg>如果发送端和接收端的任务运行在不同的TaskManager进程中，就需要利用操作系统的网络栈进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the sender and receiver tasks run in separate TaskManager pro‐ cesses, they communicate via the network stack of the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195843Z" creationid="xccui" creationdate="20190606T195843Z">
        <seg>如果发送端和接收端的任务运行在不同的TaskManager进程中，就需要利用操作系统的网络栈进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the system continues to receive data at a higher rate than it can handle, buffers might become unavailable and data might get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T202331Z" creationid="xccui" creationdate="20190402T201609Z">
        <seg>如果系统持续以难以应对的高速率接收数据，缓冲区可能会用尽，继而可能导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the system continues to receive data at a higher rate than it can handle, buf‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234746Z" creationid="xccui" creationdate="20190605T234746Z">
        <seg>如果系统持续以难以应对的高速率接收数据，缓冲区可能会用尽，继而可能导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the task fails during the first step, will the event get lost?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043111Z" creationid="xccui" creationdate="20190415T043111Z">
        <seg>如果故障发生在第一步，事件是否会丢失？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are fewer list entries than the new parallelism of an operator, some tasks will start with empty state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060844Z" creationid="xccui" creationdate="20190608T060655Z">
        <seg>如果列表项目的数量小于算子新设置的并发度，部分任务在启动时的状态就可能为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is not possible, for example because the application runs in a stand-alone cluster, the JobManager is not able to restart the application until enough slots become available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210324Z" creationid="xccui" creationdate="20190428T210135Z">
        <seg>若无法完成（例如应用运行在一个独立集群上），JobManager将无法重启应用，直至有足够数量的可用处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is not possible—for example, because the application runs in a standalone cluster—the JobManager can not restart the application until enough slots become available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145517Z" creationid="xccui" creationdate="20190606T145517Z">
        <seg>若无法完成（例如应用运行在一个独立集群上），JobManager将无法重启应用，直至有足够数量的可用处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we only consider how much data we receive within one minute, our results will vary and depend on the speed of the network connection or the speed of the processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143249Z" creationid="xccui" creationdate="20190412T142831Z">
        <seg>如果我们仅考虑现实时间一分钟内收到多少数据，那结果可能会随网络连接速度或处理速度而改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are familiar with batch data processing APIs, functional programming languages, or SQL you will find the API concepts very easy to grasp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024103Z" creationid="xccui" creationdate="20190613T024059Z">
        <seg>如果你熟悉批处理API、函数式编程语言或SQL，将会发现这里的API概念都很容易掌握。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are interested in learning more about real-world use cases and deployments, check out Apache Flink’s &lt;t0/&gt;Powered By&lt;t1/&gt; &lt;t2/&gt;page and the talk recordings and slide decks of &lt;t3/&gt;Flink For&lt;t4/&gt;‐&lt;t5/&gt; &lt;t6/&gt;ward &lt;t7/&gt;presentations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T155324Z" creationid="xccui" creationdate="20190305T154924Z">
        <seg>如果还想了解更多的用例和部署方案，请查看Apache Flink的Powered By页面或Flink Forward的演讲录像及幻灯片。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are interested in learning more about real-world use cases and deployments, check out Apache Flink’s Powered By page and the talk recordings and slide decks of Flink Forward presentations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T212615Z" creationid="esouser" creationdate="20190603T212449Z">
        <seg>如果想了解更多真实用例和部署方案，请查看Apache Flink的用户页面或Flink Forward的演讲录像及幻灯片。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are running Windows, we recom&lt;t2/&gt;‐&lt;t3/&gt; mend to set up a virtual machine with Linux, Cygwin (a Linux environment for Win&lt;t4/&gt;‐&lt;t5/&gt; dows), or the Windows Subsystem for Linux, which was introduced with Windows 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060249Z" creationid="xccui" creationdate="20190328T055732Z">
        <seg>如果你的系统是Windows，我们建议你配置一个Linux虚拟机，或安装Cygwin（一个Windows下的Linux环境），或设置Linux子系统（Win10中新加的功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are the first customer showing up at the coffee shop right after it opened its doors in the morning, you will be served immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T205517Z" creationid="xccui" creationdate="20190401T205243Z">
        <seg>如果你是早晨咖啡店开门后第一个顾客，将立即得到服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you click on that job you will see the data flow and live metrics about the opera&lt;t0/&gt;‐&lt;t1/&gt; tors of the running job similar to the screenshot in &lt;t2/&gt;Figure 1-9&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042154Z" creationid="xccui" creationdate="20190329T041245Z">
        <seg>点击那个作业，你会看到和图1-9中的截图类似的数据流程及运行作业中算子的实时指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210827Z" creationid="esouser" creationdate="20190603T210827Z">
        <seg>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine that during Christmas holiday season, baristas have to draw a Santa Claus on the cup of each coffee they serve.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T205829Z" creationid="xccui" creationdate="20190402T205727Z">
        <seg>假设正值圣诞假期，咖啡师要在他们端出的每一杯咖啡上面画一个圣诞老人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine that during the Christmas holiday season, baristas have to draw a Santa Claus on the cup of each coffee they serve.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235108Z" creationid="xccui" creationdate="20190605T235108Z">
        <seg>假设正值圣诞假期，咖啡师要在他们端出的每一杯咖啡上面画一个圣诞老人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022910Z" creationid="xccui" creationdate="20190225T022910Z">
        <seg>实现函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Operator List State with the ListCheckpointed Interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024556Z" creationid="xccui" creationdate="20190225T024556Z">
        <seg>通过ListCheckpointed接口实现Operator List State</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Stateful Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030643Z" creationid="xccui" creationdate="20190225T024522Z">
        <seg>实现状态化函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a Custom Sink Function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025258Z" creationid="xccui" creationdate="20190225T025258Z">
        <seg>实现自定义汇函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a Custom Source Function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025229Z" creationid="xccui" creationdate="20190225T025229Z">
        <seg>实现自定义源函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the Book’s Examples in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144859Z" creationid="esouser" creationdate="20190603T144859Z">
        <seg>将书中示例导入IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the book examples repository into IntelliJ</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041629Z" creationid="xccui" creationdate="20190611T041629Z">
        <seg>将书中示例仓库导入IntelliJ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the book’s examples in your IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022322Z" creationid="xccui" creationdate="20190225T022322Z">
        <seg>将书中示例导入你的IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Importing the examples-scala repository into your IDE to experiment with Flink is a good first step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004111Z" creationid="xccui" creationdate="20190612T004022Z">
        <seg>将examples-scala库导入IDE来体验Flink是一个良好的开端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improving on the first generation, the next generation of distributed open source stream processors (2013) provided better failure guarantees and ensured that in case of a failure each input record affects the result exactly once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053230Z" creationid="xccui" creationdate="20190605T053117Z">
        <seg>和第一代开源分布式流处理引擎相比，第二代引擎（2013年）提供了更加完善的故障处理机制，即便出现故障，也能保证每条记录仅参与一次结果运算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improving on the first generation, the next generation of distributed open source stream processors (2013) provided better failure guarantees and ensured that in case of a failure each record contributes exactly once to the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T034733Z" creationid="xccui" creationdate="20190327T034557Z">
        <seg>和第一代开源分布式流处理引擎相比，第二代引擎（2013年）提供了更加完善的故障处理机制，可以保证在出错的情况下每条记录也仅参与一次结果运算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t0/&gt;Chapter 10&lt;t1/&gt;, we show how to disable task chaining for an application and how to control the chaining behavior of individual opera&lt;t2/&gt;‐&lt;t3/&gt; tors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155735Z" creationid="esouser" creationdate="20190514T155247Z">
        <seg>在第10章中，我们会展示如何对某一应用内禁用任务链接以及如何单独控制每个算子的链接行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t0/&gt;Chapter 2&lt;t1/&gt;, we highlighted the importance of time semantics for stream processing applications and explained the differences between processing-time and event-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155850Z" creationid="esouser" creationdate="20190514T155850Z">
        <seg>在第二章里，我们强调了时间语义对于流处理应用的重要性并解释了处理时间和事件时间的不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t2/&gt;Chapter 9&lt;t3/&gt;, we will discuss how to setup and configure Flink for different environments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025244Z" creationid="xccui" creationdate="20190423T025119Z">
        <seg>在第9章里，我们会讨论如何针对不同环境搭建及配置Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t2/&gt;Figure 2-2&lt;t3/&gt;, the output of the “Extract hashtags” operator is partitioned by key (the hashtag), so that the count operator tasks can correctly compute the occurrences of each hashtag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135717Z" creationid="xccui" creationdate="20190401T135653Z">
        <seg>图2-2中，"Extract hashtags"算子的输出就是按照键值（主题标签）划分的，因此下游的计数算子可以正确计算出每个主题标签的出现次数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Alice’s game example, the streaming application could operate with two different notions of time, Processing time or Event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143526Z" creationid="xccui" creationdate="20190412T143355Z">
        <seg>在爱丽丝游戏的例子中，流式应用可以使用两个不同概念的时间，即处理时间和事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Alice’s game example, the streaming application could operate with two different notions of time: processing time or event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023542Z" creationid="xccui" creationdate="20190606T023542Z">
        <seg>在爱丽丝游戏的例子中，流式应用可以使用两个不同概念的时间，即处理时间和事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter 1, you learned that streaming applications have different operational requirements than traditional batch programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233723Z" creationid="xccui" creationdate="20190605T233716Z">
        <seg>在第一章，你已经了解了流式应用在操作需求方面和传统批处理程序有所不同，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter 2 we pointed out that most streaming applications are stateful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T042001Z" creationid="xccui" creationdate="20190607T041304Z">
        <seg>在第2章我们指出，大部分的流式应用都是有状态的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Figure 2-2, the output of the “Extract hashtags” operator is partitioned by the key (the hashtag), so that the count operator tasks can correctly compute the occurrences of each hashtag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233520Z" creationid="xccui" creationdate="20190605T233520Z">
        <seg>图2-2中，"Extract hashtags"算子的输出就是按照键值（主题标签）划分的，因此下游的计数算子可以正确计算出每个主题标签的出现次数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Figure 3-17, Flink took a checkpoint when the input offset was 5, and the sums were 6 and 9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T031758Z" creationid="xccui" creationdate="20190609T031739Z">
        <seg>在图3-17中，Flink会在输入偏移到达5的时候生成一个检查点，此时两个和值分别为6和9。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, state is always associated with a specific operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055854Z" creationid="xccui" creationdate="20190607T055833Z">
        <seg>在Flink中，状态都是和特定算子相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, watermarks are implemented as special records holding a timestamp as a Long value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205301Z" creationid="xccui" creationdate="20190606T205232Z">
        <seg>在Flink中，水位线是利用一些包含Long值时间戳的特殊记录来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, watermarks are implemented as special records holding a timestamp long value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042055Z" creationid="xccui" creationdate="20190523T042038Z">
        <seg>在Flink中，水位线是利用一些包含时间戳long值的特殊记录来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink’s design it is the responsibility of the state backend to perform a checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202614Z" creationid="xccui" creationdate="20190609T202559Z">
        <seg>按照Flink的设计，是由状态后端负责生成检查点，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a batch processing scenario, all these questions are answered because a batch job can be simply restarted from the beginning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033857Z" creationid="xccui" creationdate="20190606T033840Z">
        <seg>在批处理场景下，上面提的都不是问题，因为批处理任务可以轻易"从头再来"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a batch processing scenario, you can solve all these problems easily since all the input data is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044030Z" creationid="xccui" creationdate="20190415T044017Z">
        <seg>在批处理场景下，由于可以得到所有输入数据，上述问题都能轻松解决。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a real-word streaming architecture however, it is common to have several connected components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045315Z" creationid="xccui" creationdate="20190416T045214Z">
        <seg>但在现实世界的流处理架构中，有多个连接组件是很稀松平常的事儿。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a real-world streaming application however, there will be at least one source and one sink apart from the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035106Z" creationid="xccui" creationdate="20190606T035056Z">
        <seg>但在实际流处理应用中，除了流处理引擎也至少要有一个数据源和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a true streaming model, events can be processed as soon as they arrive in the system and latency more closely reflects the actual work that has to performed on each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195212Z" creationid="xccui" creationdate="20190401T194838Z">
        <seg>在该模型中，事件一到达系统就可以进行处理，延迟会更真实地反映出每个事件都要经历的实际执行工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a true stream‐ ing model, events can be processed as soon as they arrive in the system and latency more closely reflects the actual work that has to be performed on each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234331Z" creationid="xccui" creationdate="20190605T234331Z">
        <seg>在该模型中，事件一到达系统就可以进行处理，延迟会更真实地反映出每个事件都要经历的实际执行工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to record timestamps, a Flink event-time application must also provide watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040914Z" creationid="xccui" creationdate="20190523T040914Z">
        <seg>除了记录的时间戳，Flink基于事件时间的应用还必须提供水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the system properties discussed so far, such as failure tolerance, perfor&lt;t0/&gt;‐&lt;t1/&gt; mance, and result accuracy, stream processors also continuously added new opera&lt;t2/&gt;‐&lt;t3/&gt; tional features.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T140909Z" creationid="xccui" creationdate="20190327T135929Z">
        <seg>除了已经讨论过的如：容错、性能、结果精确性等系统属性，流处理引擎还在不断添加新的操作功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the system properties discussed so far, such as failure tolerance, perfor‐ mance, and result accuracy, stream processors have also continuously added new operational features such as highly available setups, tight integration with resource managers, such as YARN or Kubernetes, and the ability to dynamically scale stream‐ ing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053906Z" creationid="xccui" creationdate="20190605T053708Z">
        <seg>除了已经讨论过的如：容错、性能、结果精确性等系统属性，流处理引擎还在不断添加新的操作功能，例如：高可用设置，和资源管理器（如YARN、Kubernetes）的紧密整合以及支持流式应用动态扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to these features, Flink is a very developer-friendly framework due to its easy-to-use APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T053253Z" creationid="xccui" creationdate="20190328T052954Z">
        <seg>除了上述特性，Flink还有十分易用的API，因此作为框架而言对开发者非常友好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, program&lt;t0/&gt;‐&lt;t1/&gt; ming APIs evolved from rather low-level operator interfaces to high-level APIs with more built-in primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T035008Z" creationid="xccui" creationdate="20190327T034928Z">
        <seg>此外，编程API也从低层基于算子的接口进化为拥有更多内置操作原语的高层API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, program‐ ming APIs evolved from rather low-level operator interfaces to high-level APIs with more built-in primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053242Z" creationid="xccui" creationdate="20190605T053242Z">
        <seg>此外，编程API也从低层基于算子的接口进化为拥有更多内置操作原语的高层API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the JobManager writes a pointer to the storage location into ZooKeeper’s data store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051712Z" creationid="xccui" creationdate="20190502T045820Z">
        <seg>此外，它还会将存储位置的指针写入ZooKeeper的数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the JobManager writes a pointer to the storage location into ZooKeeper’s datastore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T194254Z" creationid="xccui" creationdate="20190606T150105Z">
        <seg>此外，JobManager还会将存储位置的指针（译者注：目录地址）写入ZooKeeper的数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the RocksDB state backend also features incremental checkpointing, which reduces the amount of data to transfer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203905Z" creationid="xccui" creationdate="20190609T203841Z">
        <seg>除此之外，RocksDB状态后端还支持增量生成检查点，这可以降低需要传输的数据量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, there is a service running that accepts the Flink application and ensures it is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143501Z" creationid="xccui" creationdate="20190606T143501Z">
        <seg>无论哪种情况，运行的服务都会接收Flink应用并确保其执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In batch processing you first need to gather the events in batches and only then you are able to process them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T193255Z" creationid="xccui" creationdate="20190401T193141Z">
        <seg>在批处理中，你先要批量收集事件，然后才能处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In batch processing, you first need to gather the events in batches and only then can you pro‐ cess them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234259Z" creationid="xccui" creationdate="20190605T234259Z">
        <seg>在批处理中，你先要批量收集事件，然后才能处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, Flink recovers a stateful streaming application by restoring its state from a previous checkpoint and resetting the read position on the event log.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155036Z" creationid="esouser" creationdate="20190603T211702Z">
        <seg>一旦出现故障，Flink会利用之前的检查点恢复状态并重置事件日志的读取指针，以此来使状态化流处理应用恢复正常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, Flink restores a stateful streaming application by recovering its state from a previously taken checkpoint and resets the read position on the event log.The application will replay (and fast forward) the input events from the event log until it reaches the tail of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T144620Z" creationid="xccui" creationdate="20190305T062150Z">
        <seg>一旦计算失败，Flink会利用之前的checkpoint恢复状态和重置事件日志的读取指针，以此来使状态化流处理应用恢复正常。随后应用会从事件日志中读取并（快速）重放输入事件，直到数据流末尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, Flink uses the latest check‐ point  to  consistently  restore  the  application’s   state   and   restarts   the   processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035819Z" creationid="xccui" creationdate="20190609T033338Z">
        <seg>一旦发生故障，Flink会利用最新的检查点为应用恢复一致性的状态并重启进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a fail‐ ure, these records will be processed again, which means the checkpoint provides at- least-once instead of exactly-once consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T205249Z" creationid="xccui" creationdate="20190609T205203Z">
        <seg>一旦出现故障，这些记录会被重复处理，而这意味着检查点只能提供至少一次而非精确一次的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a shuffle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045224Z" creationid="xccui" creationdate="20190504T044946Z">
        <seg>在shuffle或broadcast连接的情况下，每个发送任务都需要针对每个接收任务提供一个缓冲区，因此所需的缓冲区数量是相关算子并发度的平方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a shuffle connection pattern, each sender task needs to be able to send data to each receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T043112Z" creationid="xccui" creationdate="20190504T043112Z">
        <seg>在shuffle连接模式下，每个发送端的任务都需要能够向每个接受任务发送数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In combination with exactly-once failure semantics, systems of this generation are the first open source stream processors capable of computing consistent and accurate results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053340Z" creationid="xccui" creationdate="20190605T053340Z">
        <seg>结合精确一次故障恢复语义，这一代系统才称得上第一批能够计算精确、一致结果的开源流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In combination with exactly-once failure semantics, systems of this generation are the first open source stream processors that are capable of computing consistent and accurate results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T051821Z" creationid="xccui" creationdate="20190327T050854Z">
        <seg>结合精确一次故障恢复语义，这一代系统才称得上第一批能够计算精确、一致结果的开源流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to batch processors that guarantee accurate results, the first open source stream processors traded result accuracy for much better latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T044942Z" creationid="xccui" creationdate="20190322T043015Z">
        <seg>和提供精确结果的批处理引擎相比，第一代开源流处理引擎通过牺牲结果的准确度换取更低的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to executing a Flink program by sending it to a remote JobManager, the program is executed in a single JVM. Therefore, certain issues, such as class‐ loading issues, cannot be properly debugged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T054526Z" creationid="xccui" creationdate="20190611T054526Z">
        <seg>和将Flink程序发送到远程JobManager执行相比，将程序放在单个JVM进程中执行可能会导致某些问题（例如类加载）无法正确调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to the AssignerWithPeriodicWatermarks function, this function can—but does not need to—extract a watermark from each record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040244Z" creationid="xccui" creationdate="20190607T040224Z">
        <seg>和AssignerWithPeriodicWatermarks函数不同，这个函数不会强制你从每条记录中都提取一个时间戳（虽然这样也行）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, a stream consumed from a socket cannot be reset because sockets discard data once it has been consumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044947Z" creationid="xccui" creationdate="20190609T044943Z">
        <seg>相反，如果数据流来是从套接字消费而来则无法重置，因为套接字会在数据被取走后将它们丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, a stream processor that runs a stateful streaming application takes care of all processing steps, including event ingestion, continuous computation including state maintenance, and updating the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014657Z" creationid="xccui" creationdate="20190317T063132Z">
        <seg>相较之下，运行状态化流处理应用的流处理引擎会负责事件获取、维护状态的持续计算、更新结果等所有处理步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, a stream pro‐ cessor that runs a stateful streaming application takes care of all these processing steps, including event ingestion, continuous computation including state mainte‐ nance, and updating the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044852Z" creationid="xccui" creationdate="20190605T044848Z">
        <seg>相比之下，运行状态化流处理应用的流处理引擎会负责事件获取、维护状态的持续计算、更新结果等所有处理步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, event-time semantics yield reproducible and consis&lt;t2/&gt;‐&lt;t3/&gt; tent results which is a hard requirement for many stream processing use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T160831Z" creationid="esouser" creationdate="20190514T160831Z">
        <seg>而事件时间语义恰恰相反，它会生成可重现、一致性的结果，这也是很多流处理场景中的刚性需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, event-time semantics yield reprodu‐ cible and consistent results, which is a hard requirement for many stream processing use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204307Z" creationid="xccui" creationdate="20190606T204233Z">
        <seg>相反，事件时间语义会生成可重现且一致性的结果，这也是很多流处理场景中的刚性需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, in continuously running streaming jobs, state is durable across events and we can expose it as a first-class citi‐ zen in the programming model.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032132Z" creationid="xccui" creationdate="20190606T032132Z">
        <seg>反之，在持续运行的流式作业中，每次处理事件状态都是持久化的，我们完全可以将其作为编程模型中的一等公民。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, stateful operators may main‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235838Z" creationid="xccui" creationdate="20190605T235838Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, traditional batch processing latencies typically range from a few minutes to several hours.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T193105Z" creationid="xccui" creationdate="20190401T193105Z">
        <seg>相反，传统批处理的延迟可能从几分钟到几小时不等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In con‐ trast to batch processors, the first open source stream processors traded result accu‐ racy for better latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051716Z" creationid="xccui" creationdate="20190605T051623Z">
        <seg>和批处理引擎相比，第一代开源流处理引擎通过牺牲结果的准确度来换取低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In data streaming, latency is measured in units of time, such as milliseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T154533Z" creationid="xccui" creationdate="20190401T154502Z">
        <seg>在流处理中，延迟是以时间片（例如：毫秒）为单位计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, there is a ser&lt;t3/&gt;‐&lt;t4/&gt; vice running that accepts the Flink application and ensures it is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025733Z" creationid="xccui" creationdate="20190423T025658Z">
        <seg>无论哪种情况，运行的服务都会接收Flink应用并确保其执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, exactly-once guarantees mean that our application will provide the correct result, as if a failure never happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045641Z" creationid="xccui" creationdate="20190416T044057Z">
        <seg>本质上，精确一次保障意味着应用总会提供正确的结果，就如同故障从未发生过一般。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, exactly-once guarantees mean that our application will provide the correct result, as though a failure never happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034827Z" creationid="xccui" creationdate="20190606T034827Z">
        <seg>本质上，精确一次保障意味着应用总会提供正确的结果，就如同故障从未发生过一般。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, watermarks pro&lt;t0/&gt;‐&lt;t1/&gt; vide a logical clock which informs the system about the current event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205344Z" creationid="xccui" creationdate="20190412T205344Z">
        <seg>本质上，水位线提供了一个逻辑时钟，通知系统当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, watermarks provide a logical clock that informs the system about the current event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025413Z" creationid="xccui" creationdate="20190606T025413Z">
        <seg>本质上，水位线提供了一个逻辑时钟，通知系统当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, if you want to compute anything interesting in a streaming application, even a simple count, you need to maintain state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T204338Z" creationid="xccui" creationdate="20190409T204144Z">
        <seg>实际上，如果你想在流式应用中计算任何有点意思的结果（即便是简单的计数），都需要维护状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it is difficult to find</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T040711Z" creationid="xccui" creationdate="20190301T035808Z">
        <seg>事实上，很难从现实世界找到那种瞬间就生成完整数据集的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it is difficult to find examples of finite, complete datasets that are generated all at once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T204824Z" creationid="esouser" creationdate="20190603T204824Z">
        <seg>事实上，很难从现实世界找到那种瞬间就生成完整数据集的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, that is what you achieve by exploiting parallelism in a stream processing pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T212158Z" creationid="xccui" creationdate="20190402T212052Z">
        <seg>事实上这就是在流处理管道中利用并行性实现的效果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, that’s what happens when you exploit parallelism in a stream processing pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235716Z" creationid="xccui" creationdate="20190605T235716Z">
        <seg>事实上这就是在流处理管道中利用并行性实现的效果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, the flatMap transformation is a gener‐ alization of filter and map and can be used to implement both those operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053755Z" creationid="xccui" creationdate="20190613T053755Z">
        <seg>事实上，flatMap转换可以看做是filter和map的泛化，能够实现它们二者的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, this has been a common implementation choice before the rise of modern stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053346Z" creationid="xccui" creationdate="20190414T053223Z">
        <seg>事实上，在现代流处理引擎兴起之前，状态就是一个常见的实现选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, you would like your stream processor to not only continue processing in the case of task failures, but also provide correctness guarantees about the result and operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033501Z" creationid="xccui" creationdate="20190606T033501Z">
        <seg>事实上，你不仅需要流处理引擎在任务故障时可以继续运行，还需要它保证结果和算子状态的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, you would like your stream processor to not only continue the processing in the case of task failures, but also provide correctness guarantees about the result and operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042203Z" creationid="xccui" creationdate="20190415T042023Z">
        <seg>事实上，你不仅需要流处理引擎在任务故障时可以继续运行，还需要它保证结果和算子状态的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, all data maintained by a task and used to compute the results of a function belong to the state of the task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T053933Z" creationid="xccui" creationdate="20190607T053933Z">
        <seg>通常意义上，所函数里所有需要任务去维护和用来计算结果的数据都属于任务的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, if example code is offered with this book, you may use it in your programs and documentation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210816Z" creationid="esouser" creationdate="20190603T210816Z">
        <seg>In general, if example code is offered with this book, you may use it in your programs and documentation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In long-running, streaming jobs, each of these tasks can fail at any time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042040Z" creationid="xccui" creationdate="20190415T041755Z">
        <seg>对于长期运行的流式作业而言，每个任务都随时可能出现故障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many real-world applications, the system does not have enough knowledge to per&lt;t0/&gt;‐&lt;t1/&gt; fectly determine watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T211450Z" creationid="xccui" creationdate="20190412T211024Z">
        <seg>在很多现实应用中，系统必须知道足够多的信息才能完美地设置水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many real-world applications, the system does not have enough knowledge to per‐ fectly determine watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025733Z" creationid="xccui" creationdate="20190606T025733Z">
        <seg>在很多现实应用中，系统必须知道足够多的信息才能完美地设置水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most real-world applications, the expectation is that events should not get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034559Z" creationid="xccui" creationdate="20190606T034519Z">
        <seg>对大多数现实应用而言，用户期望是不丢事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most real-world applications, the minimum requirement is that events do not get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041926Z" creationid="xccui" creationdate="20190416T041813Z">
        <seg>对大多数现实应用而言，最低要求是不丢失事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to enable a smooth pipelined data exchange, a TaskManager must be able to provide enough buf&lt;t2/&gt;‐&lt;t3/&gt; fers to serve all outgoing and incoming connections concurrently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044648Z" creationid="xccui" creationdate="20190504T044648Z">
        <seg>为了使流水线式的数据交换平滑进行，TaskManager必须提供足够多的缓冲区来同时服务全部进出连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to enable a smooth pipe‐ lined data exchange, a TaskManager must be able to provide enough buffers to serve all outgoing and incoming connections concurrently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T201341Z" creationid="xccui" creationdate="20190606T201341Z">
        <seg>为了使流水线式的数据交换平滑进行，TaskManager必须提供足够多的缓冲区来同时服务全部进出连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to ensure at-least-once result correctness, you need to have a mechanism to replay events, either from the source or from some buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T043259Z" creationid="xccui" creationdate="20190416T042957Z">
        <seg>为了确保至少一次结果的正确，需要一些机制从源头或缓冲中重放事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to ensure at-least-once result correctness, you need to have a way to replay events—either from the source or from some buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034854Z" creationid="xccui" creationdate="20190606T034644Z">
        <seg>为了确保至少一次结果的正确，需要一些办法从源头或缓冲中重放事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to evaluate such operations effi&lt;t4/&gt;‐&lt;t5/&gt; ciently on unbounded streams, you need to limit the amount of data these operations maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041628Z" creationid="xccui" creationdate="20190406T041619Z">
        <seg>为了在无限数据流上高效地执行这些操作，必须限制操作所维持的数据量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to evaluate such operations efficiently on unbounded streams, you need to limit the amount of data these operations maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012044Z" creationid="xccui" creationdate="20190606T012044Z">
        <seg>为了在无限数据流上高效地执行这些操作，必须限制操作所维持的数据量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to execute a dataflow program, its logical graph is converted into a physical dataflow graph, which includes details about how the computation is going to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T003156Z" creationid="xccui" creationdate="20190401T002442Z">
        <seg>为了执行dataflow程序，需要将逻辑图转化为物理dataflow图，它们包含了计算执行的细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to execute a dataflow program, its logical graph is converted into a physical dataflow graph, which specifies in detail how the program is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233054Z" creationid="xccui" creationdate="20190605T233054Z">
        <seg>为了执行Dataflow程序，需要将逻辑图转化为物理Dataflow图，从而可以指定程序执行的执行细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to keep the data of the data warehouse up-to-date, ETL processes need to run periodically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192243Z" creationid="xccui" creationdate="20190228T191319Z">
        <seg>同时为了保证数据仓库中数据的实效，ETL流程需要定期重复执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to make Flink’s runtime aware of the state of an operator, the operator needs to register its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055945Z" creationid="xccui" creationdate="20190607T055945Z">
        <seg>为了让Flink的运行层知道算子有哪些状态，算子需要自己注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to populate a data ware&lt;t2/&gt;‐&lt;t3/&gt; house, the data managed by the transactional database systems needs to be copied to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T191750Z" creationid="xccui" creationdate="20190228T184446Z">
        <seg>为了填充它，需要将事务型数据库系统中的数据拷贝过去，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to populate a data warehouse, the data managed by the transac‐ tional database systems needs to be copied to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T202712Z" creationid="esouser" creationdate="20190603T202712Z">
        <seg>为了填充数据仓库，需要将事务型数据库系统中的数据拷贝过去，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to satisfy the requirements for task chaining, two or more operators must be configured with the same parallelism and be connected by local forward channels.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152052Z" creationid="esouser" creationdate="20190514T152010Z">
        <seg>为了满足任务链接的条件，多个算子必须有相同的并发度且通过本地转发通道连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to satisfy the requirements for task chaining, two or more operators must be configured with the same parallelism and connected by local forward channels.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203321Z" creationid="xccui" creationdate="20190606T203255Z">
        <seg>任务链接的前提条件是，多个算子必须有相同的并发度且通过本地转发通道连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, events can be simply dropped and nothing is done to ensure result correctness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034357Z" creationid="xccui" creationdate="20190606T034357Z">
        <seg>换句话说，事件可以随意丢弃，没有任何机制来保证结果的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, events can be simply dropped and there is no mechanism to ensure result correctness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T184510Z" creationid="xccui" creationdate="20190415T184441Z">
        <seg>换句话说，事件可以随意丢弃，没有任何机制来保证结果的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our discussion about event-time windows so far, we have overlooked one very important aspect: &lt;t0/&gt;how do we decide when to trigger an event-time window&lt;t1/&gt;?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T160625Z" creationid="xccui" creationdate="20190412T160108Z">
        <seg>在到目前为止有关事件时间窗口的讨论中，我们一直忽略了一个非常重要的方面：如何决定触发事件时间窗口的时间？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our discussion about event-time windows so far, we have overlooked one very important aspect: how do we decide when to trigger an event-time window?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025229Z" creationid="xccui" creationdate="20190606T025229Z">
        <seg>在到目前为止有关事件时间窗口的讨论中，我们一直忽略了一个非常重要的方面：如何决定触发事件时间窗口的时间？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, the result is a DataStream[SensorReading] record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054549Z" creationid="xccui" creationdate="20190612T054549Z">
        <seg>在所给示例中，结果是DataStream[SensorReading]中的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we define the AverageSensorReadings object and include most of the application logic inside main().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043342Z" creationid="xccui" creationdate="20190612T043342Z">
        <seg>在示例中，我们定义了AverageSensorReadings对象，并将大部分应用逻辑都放到了main()方法里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we first apply a map() transformation that converts the temperature of each sensor reading to Celsius.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053231Z" creationid="xccui" creationdate="20190612T053231Z">
        <seg>在示例中，我们首先利用map()转换将每个传感器读取的温度都转换为摄氏度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we retrieve the execution environment by calling the static getExecutionEnvironment() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045057Z" creationid="xccui" creationdate="20190612T045057Z">
        <seg>在示例中，我们通过调用静态的getExecutionEnvironment()方法来获取执行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we use:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051434Z" creationid="xccui" creationdate="20190612T051404Z">
        <seg>在示例中，我们通过：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In parallel windows, each partition applies the window policies independently of other partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195229Z" creationid="xccui" creationdate="20190409T194934Z">
        <seg>并行窗口中，每个数据分区都会都会各自应用独立于其他分区的窗口策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In parallel windows, each partition applies the win‐ dow policies independently of other partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014028Z" creationid="xccui" creationdate="20190606T013916Z">
        <seg>并行窗口中，每个数据分区所应用的窗口策略都相互独立。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular the following features let it stand out:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042143Z" creationid="xccui" creationdate="20190328T041315Z">
        <seg>尤其是以下功能使其在同类系统中脱颖而出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the following features make Flink stand out:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054030Z" creationid="xccui" creationdate="20190605T054030Z">
        <seg>尤其是以下功能使其在同类系统中脱颖而出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, we explain Flink’s distributed architecture, show how Flink handles time and state in streaming applications, and discuss its fault tolerance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T054253Z" creationid="xccui" creationdate="20190416T054235Z">
        <seg>我们将重点解释Flink的分布式架构，展示它如何在流式应用中处理时间和状态并讨论它的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, we explain Flink’s distributed architecture, show how it handles time and state in streaming applications, and discuss its fault- tolerance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140429Z" creationid="xccui" creationdate="20190606T140115Z">
        <seg>我们将重点解释Flink的分布式架构，展示它如何在流式应用中处理时间和状态，继而讨论它的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice though you might want to partition a stream into multiple logical streams and define &lt;t2/&gt;parallel&lt;t3/&gt; windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193928Z" creationid="xccui" creationdate="20190409T193840Z">
        <seg>但在实际应用中，你可能会想将数据流划分为多条逻辑流并定义一些并行窗口（parallel window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In principle, save‐ points are created using the same algorithm as checkpoints and hence are basically checkpoints with some additional metadata.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210719Z" creationid="xccui" creationdate="20190609T210541Z">
        <seg>原则上，保存点的生成算法和检查点完全一样，因此可以把保存点看做包含一些额外元数据的检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In principle, state can be stored and accessed in many different places including pro&lt;t0/&gt;‐&lt;t1/&gt; gram variables, local files, or embedded or external databases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T031704Z" creationid="xccui" creationdate="20190305T031345Z">
        <seg>原则上，可以在很多不同的位置存储并访问状态，例如：应用程序变量、本地文件、嵌入式或外部数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In principle, state can be stored and accessed in many different places including pro‐ gram variables, local files, or embedded or external databases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T205934Z" creationid="esouser" creationdate="20190603T205858Z">
        <seg>原则上，可以在很多不同的位置存储并访问状态，例如：程序变量、本地文件、嵌入式或外部数据库等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In streaming systems you usually want to ensure that your system can handle the maximum expected rate of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T205745Z" creationid="xccui" creationdate="20190401T203251Z">
        <seg>在流处理系统中，你通常希望系统有能力应对事件到来的最大期望速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a case, a job is executed repeatedly over batches of incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053531Z" creationid="xccui" creationdate="20190414T053446Z">
        <seg>在以往的场景中，作业会在批量传入的事件上重复执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such applications, we would like to group together events that origin from the same period of user activity or &lt;t5/&gt;session&lt;t6/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025410Z" creationid="xccui" creationdate="20190407T025207Z">
        <seg>在该应用中我们要把事件按照用户的同一活动或会话来源进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such applications, we would like to group together events that originate from the same period of user activity or session.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013602Z" creationid="xccui" creationdate="20190606T013602Z">
        <seg>在该应用中我们要把事件按照用户的同一活动或会话来源进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the DataStream API, the execution environment of an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044948Z" creationid="xccui" creationdate="20190612T044948Z">
        <seg>在DataStream API中，执行环境用StreamExecutionEnvironment表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the beginning of this chapter, you saw how you can model streaming programs as dataflow graphs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033203Z" creationid="xccui" creationdate="20190415T041033Z">
        <seg>在本章开头，你了解了如何将流处理程序建模为Dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of a mobile game, consequences can be as bad as Alice and her team getting disappointed and never playing again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T142610Z" creationid="xccui" creationdate="20190411T153935Z">
        <seg>在手游的例子中，后果可能非常糟糕，以至于爱丽丝和她团队的其他玩家失望透顶，再也不会碰这个游戏。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of downscaling, the surplus tasks are simply canceled since state is already replicated and will not be lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062154Z" creationid="xccui" creationdate="20190608T061946Z">
        <seg>在缩容的情况下，由于状态经过复制不会丢失，我们可以简单地停掉多出的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the coffee shop example, you will probably see this happening right after lunch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T211019Z" creationid="xccui" creationdate="20190401T210715Z">
        <seg>咖啡店的例子中，很有可能在午餐时间刚过看到这种情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of stream processing, one disadvantage of buffering is that it adds latency because records are collected in a buffer instead of being immediately shipped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202650Z" creationid="esouser" creationdate="20190513T210715Z">
        <seg>在流处理环境下，缓冲的一个明显缺点是会增加延迟，因为记录首先要在缓冲中收集而不会立即发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, we briefly discuss credit-based flow control and task chain&lt;t0/&gt;‐&lt;t1/&gt; ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T205548Z" creationid="esouser" creationdate="20190513T192619Z">
        <seg>在接下来的几节，我们简要讨论一下基于信任度的流量控制以及任务链接（task chaining）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, we briefly discuss credit-based flow control and task chain‐ ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202453Z" creationid="xccui" creationdate="20190606T202141Z">
        <seg>在接下来的几节，我们简要讨论一下基于信用值的流量控制以及任务链接（task chaining）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following we present three classes of applications that are commonly implemented using stateful stream processing, 1) event-driven applications, 2) data pipeline applications, and 3) data analytics applications and give examples of real-world applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T153749Z" creationid="xccui" creationdate="20190305T153717Z">
        <seg>接下来我们结合例子，介绍三类常见的状态化流处理应用：1）事件驱动型应用；2）数据管道应用；3）数据分析应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following we will describe how Flink internally implements and handles timestamps and water&lt;t4/&gt;‐&lt;t5/&gt; marks to support streaming applications with event-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035243Z" creationid="xccui" creationdate="20190523T035101Z">
        <seg>接下面我们会介绍Flink内部如何实现和处理时间戳及水位线以支持事件时间语义的流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we briefly describe the contents and style of each chapter, so you can directly jump to the part that interests you most.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T163452Z" creationid="xccui" creationdate="20190225T163433Z">
        <seg>接下来我们简要介绍一下每个章节的内容和特点，以便于你直接跳到最感兴趣的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we briefly describe the contents of each chapter, so you can directly jump to those chapters that interest you most.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041630Z" creationid="esouser" creationdate="20190603T153658Z">
        <seg>接下来我们会简要介绍一下每个章节的内容，便于你直接跳到最感兴趣的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we describe how Flink internally implements and handles timestamps and watermarks to support streaming applications with event-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204715Z" creationid="xccui" creationdate="20190606T204617Z">
        <seg>接下面我们会介绍Flink内部如何实现和处理时间戳及水位线以支持事件时间语义的流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we describe how to obtain the code examples we use here, how to import them into IntelliJ, how to run an example application, and how to debug it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T035134Z" creationid="xccui" creationdate="20190611T035122Z">
        <seg>下文我们会介绍如何获取书中用到的代码，如何将它们导入IntelliJ以及如何运行和调试它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we describe in detail how a task emits watermarks to multiple output tasks and how it advances its event-time clock from the watermarks it receives from its input tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T024024Z" creationid="xccui" creationdate="20190607T015241Z">
        <seg>下面我们将详细介绍一个任务如何将水位线发送至多个输出任务以及它从多个输入任务获取水位线后如何推动事件时间时钟前进。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we explain how this algorithm works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060033Z" creationid="xccui" creationdate="20190609T060033Z">
        <seg>接下来我们解释一下这个算法的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we explain this step in detail for IntelliJ.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041041Z" creationid="xccui" creationdate="20190611T040830Z">
        <seg>下文我们会以IntelliJ为例对该步骤进行详细解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we present three classes of applications that are commonly implemented using stateful stream processing: (1) event-driven applications, (2) data pipeline applications, and (3) data analytics applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T212222Z" creationid="esouser" creationdate="20190603T212154Z">
        <seg>接下来我们介绍三类常见的状态化流处理应用：1）事件驱动型应用；2）数据管道应用；3）数据分析应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we will guide you through the process of starting a local cluster and executing a streaming application to give you a first look at Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122617Z" creationid="xccui" creationdate="20190605T122436Z">
        <seg>接下来为了让你对Flink有一个初步印象，我们将一步步指导你启动本地集群并运行一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we will use a keyBy transformation to convert a DataStream into a KeyedStream and keyed transformations such as rolling aggrega‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050213Z" creationid="xccui" creationdate="20190614T050124Z">
        <seg>下面我们将使用keyBy转换将一个DataStream转化为KeyedStream，然后对它进行滚动聚合以及reduce。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the library mode, there is no Flink ser&lt;t0/&gt;‐&lt;t1/&gt; vice continuously running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041017Z" creationid="xccui" creationdate="20190423T040707Z">
        <seg>而在库模式中，Flink服务不是一直运行，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the library style, there is no Flink service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144231Z" creationid="xccui" creationdate="20190606T144151Z">
        <seg>而在库模式中，Flink不是作为服务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the mobile gaming case for example, it is practically impossible to know for how long a user might remain disconnected; they could be going through a tunnel, boarding a plane, or never playing again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T030410Z" creationid="xccui" creationdate="20190414T030248Z">
        <seg>以手游场景为例，现实中根本无法得知用户离线多久，他们可能正在过隧道，可能正在上飞机，也可能直接退坑不玩了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the mobile gaming example, it is practically impossi‐ ble to know how long a user might remain disconnected; they could be going through a tunnel, boarding a plane, or never playing again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025740Z" creationid="xccui" creationdate="20190606T025740Z">
        <seg>以手游场景为例，现实中根本无法得知用户离线多久，他们可能正在过隧道，可能正在上飞机，也可能直接退坑不玩了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the next section, we discuss task failures and result guarantees in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033049Z" creationid="xccui" creationdate="20190606T033021Z">
        <seg>在下一节，我们会讨论有关任务故障和结果保障的详情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the next section, you will learn about task failures and result guarantees in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035719Z" creationid="xccui" creationdate="20190415T035232Z">
        <seg>在下一节，你将了解任务故障和结果保障的详细信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the past, analyzing data with a few hours or even days delay was often</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032918Z" creationid="xccui" creationdate="20190317T032601Z">
        <seg>在过去，由于对最新结果或见解的快速反应并不会产生显著优势，因此人们完全可以接受分析数据存在几小时甚至几天的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the previous chapter, you saw how streaming applications have different opera&lt;t0/&gt;‐&lt;t1/&gt; tional requirements from traditional batch programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150245Z" creationid="xccui" creationdate="20190401T150006Z">
        <seg>在上一章，你已经了解了流式应用在操作需求方面和传统批处理程序有所不同，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this book, we are going to see how Flink actually implements these concepts and how you can use its DataStream API to write applications that use all of the features we have introduced so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041244Z" creationid="xccui" creationdate="20190606T041244Z">
        <seg>在本书的其余部分，我们会介绍Flink是如何实现这些概念的，以及怎样利用它的DataStream API来编写那些涵盖目前所介绍的所有特性的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this book, we are going to see how Flink actually implements these concepts and how you can use its DataStream APIs to write applications that use all of the features that we have introduced so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052330Z" creationid="xccui" creationdate="20190416T051935Z">
        <seg>在本书的其余部分，我们会介绍Flink是如何实现这些概念的，以及怎样利用它的DataStream API来编写那些涵盖目前所介绍的所有特性的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, we are going to look deeper into the concepts of time and state guarantees under failures in data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T205822Z" creationid="xccui" creationdate="20190409T205616Z">
        <seg>在本章剩余部分，我们将深入研究流处理发生故障时的时间和状态保障相关概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, we are going to look deeper into the concepts of time and state guarantees under failures in data stream process‐ ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014614Z" creationid="xccui" creationdate="20190606T014614Z">
        <seg>在本章剩余部分，我们将深入研究流处理发生故障时的时间和状态保障相关概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, when we talk about “result guarantees” we mean the consistency of the internal state of the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034209Z" creationid="xccui" creationdate="20190606T034209Z">
        <seg>在本章剩余部分，当提到"结果保障"，我们指的是流处理引擎内部状态的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, when we talk about “result guarantees” we refer to the consistency of the internal state of the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T045234Z" creationid="xccui" creationdate="20190415T044920Z">
        <seg>在本章剩余部分，当提到"结果保障"，我们指的是流处理引擎内部状态的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the streaming world, however, dealing with failures is not a trivial problem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044227Z" creationid="xccui" creationdate="20190415T044227Z">
        <seg>然而在流式场景中，处理故障就没那么容易了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the streaming world, however, dealing with fail‐ ures is not a trivial problem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034123Z" creationid="xccui" creationdate="20190606T034123Z">
        <seg>然而在流式场景中，处理故障就没那么容易了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the very simple case, there will be at least one source and one sink apart from the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045446Z" creationid="xccui" creationdate="20190416T045403Z">
        <seg>即便是最简单的情形，除了流处理引擎也至少要有一个数据源和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the worst case, you will locate the event more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T042801Z" creationid="xccui" creationdate="20190416T042615Z">
        <seg>即使在最坏情况下，也无非多几次定位到该事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this architecture the event log acts as a source of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T060836Z" creationid="xccui" creationdate="20190305T060746Z">
        <seg>在该架构下，事件日志扮演了真实数据源的角色，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this architecture the event log persists the input events and can replay them in deterministic order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T211549Z" creationid="esouser" creationdate="20190603T211452Z">
        <seg>在该架构下，事件日志系统可以持久化输入事件并以确定顺序将其重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, late events might arrive after the watermark, and we should provide some code to handle them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025649Z" creationid="xccui" creationdate="20190606T025649Z">
        <seg>该情况下，延迟事件可能会在水位线之后到来，我们必须额外加一些代码来处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, late&lt;t2/&gt; &lt;t3/&gt;events might arrive after the watermark and we should provide some code to handle them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210653Z" creationid="xccui" creationdate="20190412T210653Z">
        <seg>该情况下，延迟事件可能会在水位线之后到来，我们必须额外加一些代码来处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, you can ach&lt;t2/&gt;‐&lt;t3/&gt; ieve exactly-once semantics with at-least-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050315Z" creationid="xccui" creationdate="20190416T050315Z">
        <seg>该情况下，你可以利用至少一次保障去实现精确一次的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, you can achieve exactly-once semantics with at-least-once guar‐ antees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035403Z" creationid="xccui" creationdate="20190606T035403Z">
        <seg>该情况下，你可以利用至少一次保障去实现精确一次的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we discuss why stateful stream processing is becoming so popular and assess its potential.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T222743Z" creationid="xccui" creationdate="20190225T222138Z">
        <seg>本章我们将讨论为何状态化流处理会变得流行，并进一步评估它的发展潜力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we discussed Flink’s high-level architecture and the internals of its net‐ working stack, event-time processing mode, state management, and failure recovery mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T031909Z" creationid="xccui" creationdate="20190610T030858Z">
        <seg>本章我们主要讨论了Flink的高层次设计架构以及内部的网络栈、事件时间处理模式、状态管理以及故障恢复机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we give a high-level introduc&lt;t0/&gt;‐&lt;t1/&gt; tion to Flink’s architecture and describe how Flink addresses the aspects of stream processing that we discussed before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T054045Z" creationid="xccui" creationdate="20190416T053847Z">
        <seg>本章中我们将从一个较高的层次来讲解Flink的架构，并介绍Flink是如何解决之前讨论的流处理相关问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter you learned how to set up an environment to develop and debug Flink DataStream applications and how to generate a Maven project using Flink’s Maven archetype.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010845Z" creationid="xccui" creationdate="20190612T010845Z">
        <seg>本章你学到了如何设置一个用于开发和调试Flink DataStream应用的环境，以及如何使用Flink的Maven模板生成Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we discuss why stateful stream processing is becoming so popular and assess its poten‐ tial.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T024714Z" creationid="esouser" creationdate="20190603T163008Z">
        <seg>本章我们会讨论为何状态化流处理会变得流行，并进一步评估其发展潜力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we give a high-level introduction to Flink’s architecture and describe how Flink addresses the aspects of stream processing we discussed earlier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140110Z" creationid="xccui" creationdate="20190606T140002Z">
        <seg>本章中我们将从一个较高的层次来讲解Flink的架构，并介绍Flink是如何解决之前所讨论的流处理相关问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we introduced stateful stream processing, discussed its use cases, and had a first look at Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124639Z" creationid="xccui" creationdate="20190605T124639Z">
        <seg>本章我们介绍了状态化流处理，讨论了它的几个用例并对Apache Flink进行了初步介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you have learned the fundamental concepts and ideas of data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051435Z" creationid="xccui" creationdate="20190416T050432Z">
        <seg>本章中你主要学习了数据流处理的基本概念和思想。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you learned the fundamentals of data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T040503Z" creationid="xccui" creationdate="20190606T035408Z">
        <seg>本章主要教给你数据流处理的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you will enter the streaming world for good and you will get the necessary background for the rest of this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T053424Z" creationid="xccui" creationdate="20190329T053246Z">
        <seg>在本章中，你将踏入流处理的世界并从中获得本书其余部分所需的背景知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you will enter the streaming world for good.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224655Z" creationid="xccui" creationdate="20190605T224655Z">
        <seg>本章将引领你将正式踏入流处理的世界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you will learn how to set up an environment to develop, run, and debug Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012943Z" creationid="xccui" creationdate="20190610T040115Z">
        <seg>本章你将学到如何搭建一个用于开发、运行和调试Flink应用的环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example the tuple input stream is keyed by the first field and the rolling sum is computed on the second field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054950Z" creationid="xccui" creationdate="20190614T054950Z">
        <seg>该示例中，输入流的元组按照第1个字段进行分区，然后滚动计算第2个字段的总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this mode, Flink applications are packaged into a JAR file and submitted by a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143428Z" creationid="xccui" creationdate="20190606T143415Z">
        <seg>在该模式下，Flink应用会打包成一个JAR文件，通过客户端提交到运行的服务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this mode, the Flink application is bundled in an application-specific con‐ tainer image, such as a Docker image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143707Z" creationid="xccui" creationdate="20190606T143646Z">
        <seg>在该模式下，Flink应用会绑定到一个特定应用的容器映像（如Docker映像）中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this scenario, you want to know if there has been an accident in a certain location within the last few minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043257Z" creationid="xccui" creationdate="20190406T043238Z">
        <seg>在该场景下，你想知道在最近几分钟内某个特定位置有没有发生交通事故。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section we describe the different components that a Flink setup consists of and discuss their responsibilities and how they interact with each other to execute an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033253Z" creationid="xccui" creationdate="20190418T032751Z">
        <seg>在本节，我们将首先介绍Flink设置中的不同组件，讨论它们的职责以及在运行应用时如何交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section we give an overview of the basic transformations of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T012954Z" creationid="xccui" creationdate="20190613T012853Z">
        <seg>本节我们将对DataStream API中的基本转换做一个概览。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe how Flink initializes the state of an application started from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214403Z" creationid="xccui" creationdate="20190609T214356Z">
        <seg>本节我们会介绍Flink在从保存点启动时如何去初始化应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe the different components of a Flink setup and how they interact with each other to execute an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140928Z" creationid="xccui" creationdate="20190606T140844Z">
        <seg>本节我们首先介绍Flink设置中的不同组件，讨论它们的职责以及在运行应用时的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe the most common streaming operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235815Z" creationid="xccui" creationdate="20190402T213018Z">
        <seg>在本节中，我们来介绍最常见的流式操作，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe the semantics of common window types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T050438Z" creationid="xccui" creationdate="20190406T050413Z">
        <seg>本节我们会介绍常见窗口类型的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss both types and how they manage and process data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T051154Z" creationid="esouser" creationdate="20190603T194239Z">
        <seg>在本节中，我们将对它们自身以及二者如何管理和处理数据加以讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss how operators process watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040632Z" creationid="xccui" creationdate="20190529T040632Z">
        <seg>在本节中，我们讨论算子如何处理水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss the different types of states Flink supports.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T053356Z" creationid="xccui" creationdate="20190607T053343Z">
        <seg>本节我们会对Flink支持的不同类别的状态加以讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss window operations, which provide such a mech&lt;t6/&gt;‐&lt;t7/&gt; anism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041719Z" creationid="xccui" creationdate="20190406T041719Z">
        <seg>在本章中，我们以窗口操作为例讨论这个机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss window operations, which pro‐ vide this service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012126Z" creationid="xccui" creationdate="20190606T012050Z">
        <seg>在本章中，我们以窗口操作为例讨论这个服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we introduce time semantics and describe the different notions of time in streaming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T210054Z" creationid="xccui" creationdate="20190409T205917Z">
        <seg>本节我们将介绍时间语义并描述流式场景中不同的时间概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we present Flink’s checkpointing and recovery mechanism to guaran‐ tee exactly-once state consistency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154954Z" creationid="xccui" creationdate="20190608T153948Z">
        <seg>本节我们会介绍Flink的检查点以及故障恢复机制，看一下它们如何提供精确一次的状态一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we will see how to use watermarks to configure event-time window behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025332Z" creationid="xccui" creationdate="20190606T025254Z">
        <seg>在本节中，我们来看一下如何利用水位线来设定事件时间窗口的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we will see how we can use the concept of &lt;t2/&gt;watermarks &lt;t3/&gt;to configure event-time window behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T204619Z" creationid="xccui" creationdate="20190412T204508Z">
        <seg>在本节中，我们来看一下如何利用水位线概念来设定事件窗口的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, you are going to learn how to process infinite streams in parallel, using the dataflow programming paradigm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233704Z" creationid="xccui" creationdate="20190605T233704Z">
        <seg>本节你将学到如何利用Dataflow编程范式去并行处理无限数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, you are going to learn the concepts of processing infinite streams in parallel, using the dataflow programming paradigm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T145933Z" creationid="xccui" creationdate="20190401T143350Z">
        <seg>本节中你将学到用dataflow编程范式去并行处理无限数据流的相关概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, you will learn how Flink restarts failed processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145341Z" creationid="xccui" creationdate="20190428T205043Z">
        <seg>本节你会学到Flink是如何重启故障进程的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this situation, the JobManager will ask the ResourceManager to provide</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210310Z" creationid="xccui" creationdate="20190428T205838Z">
        <seg>这时候JobManager就会向ResourceManager申请更多的处理槽，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this situation, the JobManager will ask the ResourceManager to provide more processing slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145522Z" creationid="xccui" creationdate="20190606T145500Z">
        <seg>这时候JobManager就会向ResourceManager申请更多的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Controlling Task Chaining” on page 261, we show how to disable task chaining for an application and how to control the chaining behavior of individual operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204112Z" creationid="xccui" creationdate="20190606T204112Z">
        <seg>在第261页的"控制任务链接"一节，我们会展示如何对某一应用内禁用任务链接以及如何单独控制每个算子的链接行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Controlling Task Scheduling” on page 260 we discuss how to con‐ trol the scheduling of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144841Z" creationid="xccui" creationdate="20190606T144841Z">
        <seg>我们将在260页"控制任务调度"一节讨论如何控制任务调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Deployment Modes” on page 221, we will dis‐ cuss how to set up and configure Flink for different environments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143345Z" creationid="xccui" creationdate="20190606T143345Z">
        <seg>在第221页"部署模式"一节，我们会讨论如何针对不同环境搭建及配置Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Time Semantics” on page 27, we highlighted the importance of time semantics for stream processing applications and explained the differences between processing time and event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204156Z" creationid="xccui" creationdate="20190606T204144Z">
        <seg>在第27页的"时间语义"一节，我们强调了时间语义对于流处理应用的重要性并解释了处理时间和事件时间的不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Including External and Flink Dependencies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022940Z" creationid="xccui" creationdate="20190225T022940Z">
        <seg>导入外部和Flink依赖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incorporating a signifi‐ cant amount of example code from this book into your product’s documentation does require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210821Z" creationid="esouser" creationdate="20190603T210821Z">
        <seg>Incorporating a signifi‐ cant amount of example code from this book into your product’s documentation does require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Index.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031120Z" creationid="xccui" creationdate="20190418T040551Z">
        <seg>索引</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexer: Judith McConville</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210722Z" creationid="esouser" creationdate="20190603T210722Z">
        <seg>Indexer: Judith McConville</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indicates new terms, URLs, email addresses, filenames, and file extensions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210801Z" creationid="esouser" creationdate="20190603T210801Z">
        <seg>Indicates new terms, URLs, email addresses, filenames, and file extensions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ingesting, transforming, and inserting data with low latency is another common use case for stateful stream processing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T014213Z" creationid="xccui" creationdate="20190317T013857Z">
        <seg>状态化流处理应用的另一个日常用例就是以低延迟获取、转换并插入数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inspect the web dashboard.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042050Z" creationid="xccui" creationdate="20190329T040028Z">
        <seg>检查一下Web仪表盘，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead a common approach is to write all changes into an event log that serves as source of truth.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T072031Z" creationid="xccui" creationdate="20190314T071923Z">
        <seg>一种常见的替代方法是把所有改动写入事件日志系统中，并以它为事实来源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead it takes advantage of distributed file systems like HDFS or object stores such as S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032244Z" creationid="xccui" creationdate="20190418T032212Z">
        <seg>而是利用了现有的分布式文件系统（如：HDFS）或对象存储（如：S3）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of inserting all data into a relational database system, significant amounts of data, such as, log files, social media, or web click logs, are written into Hadoop’s distributed file system (HDFS) or other bulk data stores, like Apache HBase, which provide massive storage capacity at small cost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T032702Z" creationid="xccui" creationdate="20190301T030218Z">
        <seg>海量日志文件、社交媒体、网页点击日志等数据已不再使用关系数据库系统存储，而是会写入Hadoop分布式文件系统（HDFS）或其他诸如Apache HBase的批量数据存储系统。这些系统以低廉的成本提供庞大的存储容量，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of inserting all data into a relational data‐ base system, significant amounts of data, such as log files, social media, or web click logs, are written into Hadoop’s distributed filesystem (HDFS), S3, or other bulk data‐ stores, like Apache HBase, which provide massive storage capacity at a small cost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203758Z" creationid="esouser" creationdate="20190603T203758Z">
        <seg>海量日志文件、社交媒体、网页点击日志等数据已不再使用关系数据库系统存储，而是会写入Hadoop分布式文件系统（HDFS）或其他诸如Apache HBase的批量数据存储系统。这些系统以低廉的成本提供庞大的存储容量，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of running analytical queries directly on the transactional databases, a com&lt;t0/&gt;‐&lt;t1/&gt; mon component in IT systems is a data warehouse.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192036Z" creationid="xccui" creationdate="20190228T184103Z">
        <seg>IT系统中一般会选用的数据仓库，而非事务型数据库来执行分析类查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of running analytical queries directly on the transactional databases, the data is typically replicated to a data warehouse, a dedicated datastore for analytical query workloads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T202625Z" creationid="esouser" creationdate="20190603T202102Z">
        <seg>对于分析类查询，我们通常不会选用事务型数据库，而是会将数据复制到专门用来处理分析类查询负载的数据仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of waiting to be periodically trig&lt;t0/&gt;‐&lt;t1/&gt; gered, a streaming analytics application continuously ingests streams of events and maintains an updating result by incorporating the latest events with low latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062449Z" creationid="xccui" creationdate="20190317T055651Z">
        <seg>流式分析应用不再需要等待周期性地触发。相反，它们会一直获取事件流，以极低的延迟整合最新事件，从而可以维护不断更新的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of waiting to be periodically triggered, a streaming analytics application con‐ tinuously ingests streams of events and updates its result by incorporating the latest events with low latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T043902Z" creationid="xccui" creationdate="20190605T043757Z">
        <seg>流式分析应用不再需要等待周期性地触发。相反，它会一直获取事件流，以极低的延迟整合最新事件，从而可以不断更新结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink implements checkpointing based on the Chandy–Lamport algorithm for distributed snapshots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T055721Z" creationid="xccui" creationdate="20190609T055529Z">
        <seg>而Flink的检查点是基于Chandy-Lamport分布式快照算法来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink is bundled as a library together with the application in a container image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T040922Z" creationid="xccui" creationdate="20190423T040832Z">
        <seg>而是以库的形式绑定在应用所在的容器映像中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink organizes keys in so-called key groups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T055556Z" creationid="xccui" creationdate="20190608T055448Z">
        <seg>而是会把所有键值分为不同的键值组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink uses a lightweight snapshotting mechanism to achieve exactly-once result guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154934Z" creationid="xccui" creationdate="20190416T045008Z">
        <seg>而Flink用的是轻量级检查点机制来实现精确一次结果保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, a 95th-percentile latency value of 10ms means that 95% of events are processed within 10ms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T155314Z" creationid="xccui" creationdate="20190401T155221Z">
        <seg>而第95百分位延迟在10毫秒意味着95%的事件会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it focuses on its core function - distributed data stream processing - and leverages existing cluster infra&lt;t0/&gt;‐&lt;t1/&gt; structure and services.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T031834Z" creationid="xccui" creationdate="20190418T031709Z">
        <seg>而是在已有集群基础设施和服务之上专注于它的核心功能——分布式数据流处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it focuses on its core function—distributed data stream processing—and leverages existing cluster infra‐ structure and services.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140707Z" creationid="xccui" creationdate="20190606T140707Z">
        <seg>而是在已有集群基础设施和服务之上专注于它的核心功能——分布式数据流处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it is crucial that the stream processing system provides some mechanism to deal with events that might arrive after the watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T032537Z" creationid="xccui" creationdate="20190414T031709Z">
        <seg>而流处理系统至关重要的一点是能提供一些机制来处理那些可能晚于流水线的落后事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it is crucial that the stream pro‐ cessing system provide some mechanism to deal with events that might arrive after the watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T030441Z" creationid="xccui" creationdate="20190606T030316Z">
        <seg>而流处理系统至关重要的一点是能提供一些机制来处理那些可能晚于水位线的落后事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it takes advantage of distributed filesystems like HDFS or object stores such as S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140811Z" creationid="xccui" creationdate="20190606T140758Z">
        <seg>而是利用了现有的分布式文件系统（如HDFS）或对象存储（如S3）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, streaming applications must provide results for incoming data &lt;t0/&gt;as fast as possible&lt;t1/&gt; while being able to handle high &lt;t2/&gt;ingest rates&lt;t3/&gt; of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151236Z" creationid="xccui" creationdate="20190401T150934Z">
        <seg>取而代之的是，流式应用必须尽可能快地针对到来数据计算结果，且需要应对较高的事件接入速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, streaming applications must provide results for incoming data as fast as possible while being able to handle high ingest rates of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233757Z" creationid="xccui" creationdate="20190605T233757Z">
        <seg>取而代之的是，流式应用需要针对到来数据尽可能快地计算结果，同时还要应对很高的事件接入速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the API calls construct an execution plan in the execution environment, which consists of the stream sources created from the environment and all transformations that were tran‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011810Z" creationid="xccui" creationdate="20190613T011810Z">
        <seg>事实上，它们只会在执行环境中构建一个执行计划，其中包含了从环境创建的流式数据源以及应用于这些数据源之上的一系列转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, time-based DataStream operator tasks configure the time‐ stamps of emitted records to ensure they are properly aligned with the emitted watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T013338Z" creationid="xccui" creationdate="20190607T013124Z">
        <seg>为发出记录设置时间的工作是由基于时间的DataStream算子任务来完成，这样才能确保时间戳和发出的水位线对齐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, we need a window operation that assigns events belonging to the same session in the same bucket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013758Z" creationid="xccui" creationdate="20190409T192442Z">
        <seg>而我们需要一个窗口操作，能将属于同一会话的事件分配到相同桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, what really defines the amount of events in one minute is the time of the data itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143725Z" creationid="xccui" creationdate="20190412T143109Z">
        <seg>而事实上每分钟收到事件数目的是由数据本身的时间来定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integration with Hadoop Components</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025502Z" creationid="xccui" creationdate="20190225T025502Z">
        <seg>集成Hadoop组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Rebecca Demarest</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210725Z" creationid="esouser" creationdate="20190603T210725Z">
        <seg>Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Rebecca Demarest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interval Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150359Z" creationid="esouser" creationdate="20190603T150359Z">
        <seg>时间间隔连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Dataflow Programming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143756Z" creationid="esouser" creationdate="20190603T143543Z">
        <seg>Dataflow编程介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Dataflow Programming | 19</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041328Z" creationid="xccui" creationdate="20190606T041328Z">
        <seg>Dataflow编程介绍 | 19</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191716Z" creationid="xccui" creationdate="20190225T191716Z">
        <seg>状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Stateful Stream Processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014519Z" creationid="xccui" creationdate="20190225T014519Z">
        <seg>状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to dataflow programming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014938Z" creationid="xccui" creationdate="20190225T014938Z">
        <seg>dataflow模型介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inversely, very conservative water&lt;t0/&gt;‐&lt;t1/&gt; marks increase processing latency but improve result completeness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040618Z" creationid="xccui" creationdate="20190529T040556Z">
        <seg>相反，非常宽松的水位线会增加处理延迟，但同时结果的完整性也会有所提升。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inversely, very conservative water‐ marks increase processing latency but improve result completeness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T210205Z" creationid="xccui" creationdate="20190606T210205Z">
        <seg>相反，非常宽松的水位线会增加处理延迟，但同时结果的完整性也会有所提升。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also gives you a brief look at what it is like to run your first streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031427Z" creationid="esouser" creationdate="20190603T155806Z">
        <seg>此外还简要介绍了如何在本地Flink实例上运行你的第一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also gives you a brief taste of what it is like to run a your first streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T164237Z" creationid="xccui" creationdate="20190225T164237Z">
        <seg>此外还简要介绍了如何在本地Flink实例上运行你的第一个流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also shows how to use Flink’s queryable state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162155Z" creationid="esouser" creationdate="20190603T162155Z">
        <seg>同时本章还会展示如何使用Flink的可查询式状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It applies a ReduceFunction on a KeyedStream, which combines each incoming event with the current reduced value, and produces a DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061436Z" creationid="xccui" creationdate="20190614T061430Z">
        <seg>它将一个ReduceFunction作用在一条KeyedStream上，每个到来事件都会和reduce结果进行一次组合，从而产生一条新的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used to generate watermarks that are encoded in special input records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040000Z" creationid="xccui" creationdate="20190607T035846Z">
        <seg>它可用于需要根据特殊输入记录生成水位线的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of 11 chapters that hopefully tell a coherent story.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152645Z" creationid="esouser" creationdate="20190603T152631Z">
        <seg>它总共包含了11个章节，我们希望通过这些章节讲述一个完整的故事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of 11 chapters which hopefully tell a coherent story.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T042123Z" creationid="xccui" creationdate="20190225T042123Z">
        <seg>它包含了11个章节，我们希望通过这些章节讲述一个完整的故事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of three operators that are all configured for a task parallelism of two and are connected with local forward connec&lt;t2/&gt;‐&lt;t3/&gt; tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152332Z" creationid="esouser" creationdate="20190514T152332Z">
        <seg>它包含了3个算子，每个算子的任务并发度都为2且通过本地转发方式连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of three operators that are all configured for a task parallelism of two and connected with local forward connec‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203412Z" creationid="xccui" creationdate="20190606T203412Z">
        <seg>它包含了3个算子，每个算子的任务并发度都为2且通过本地转发方式连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It defines the map() method that trans‐ forms an input event into exactly one output event:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050318Z" creationid="xccui" creationdate="20190613T050318Z">
        <seg>它定义的map()方法将每个输入事件转换为一个输出事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It discusses Flink’s approach to end-to-end application consistency and how to implement custom connectors to ingest data from and emit data to external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162535Z" creationid="esouser" creationdate="20190603T162455Z">
        <seg>其中会讨论Flink中端到端应用一致性的方案以及如何实现自定义连接器来读写外部系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It discusses distributed architecture, time and state handling in streaming applications, and Flink’s fault toler&lt;t0/&gt;‐&lt;t1/&gt; ance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T165047Z" creationid="xccui" creationdate="20190225T165047Z">
        <seg>其中讨论了分布式架构、流式应用中的时间和状态处理问题、Flink的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It discusses dis‐ tributed architecture, time and state handling in streaming applications, and Flink’s fault-tolerance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031452Z" creationid="esouser" creationdate="20190603T160106Z">
        <seg>其中讨论了分布式架构、流式应用中的时间和状态处理问题以及Flink的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It efficiently runs such applica&lt;t0/&gt;‐&lt;t1/&gt; tions at large scale in a fault-tolerant manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T215719Z" creationid="xccui" creationdate="20190225T192215Z">
        <seg>且支持在容错的前提下高效运行大规模的此类应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It efficiently runs such applica‐ tions at large scale in a fault-tolerant manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162821Z" creationid="esouser" creationdate="20190603T162716Z">
        <seg>且支持在容错的前提下高效、大规模地运行此类应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054227Z" creationid="xccui" creationdate="20190612T054227Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to configure an application to retain its last checkpoint when it is canceled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211232Z" creationid="xccui" creationdate="20190609T211232Z">
        <seg>可以通过配置让应用在取消的时候保留最近一次检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to explicitly create local or remote execution environments as fol‐ lows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045513Z" creationid="xccui" creationdate="20190612T045513Z">
        <seg>同时也可以像下面那样显式地创建一个本地或远程执行环境：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is common that companies store the same data in multiple different systems to improve the performance of data accesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T053952Z" creationid="xccui" creationdate="20190604T053931Z">
        <seg>公司为了提高数据访问性能已然稀松平常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is crucial to understand how to deliver accu‐ rate and deterministic results under such conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014411Z" creationid="xccui" creationdate="20190606T014330Z">
        <seg>了解如何在这种情况下提供精准、确定的结果就变得至关重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is crucial to understand how you can deliver accurate and deterministic results under such conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T201950Z" creationid="xccui" creationdate="20190409T201839Z">
        <seg>了解如何在这种情况下提供精准、确定的结果就变得至关重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that sometimes you can</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050336Z" creationid="xccui" creationdate="20190416T050038Z">
        <seg>注意，有时候可以通过弱保障实现强语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that sometimes you can get stronger semantics with weaker guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035348Z" creationid="xccui" creationdate="20190606T035348Z">
        <seg>注意，有时候可以通过弱保障实现强语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that the rate of processing depends on the rate of arrival; low throughput does not necessarily indicate bad performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T203141Z" creationid="xccui" creationdate="20190401T200707Z">
        <seg>但要注意，处理速率取决于数据到来速率，因此低吞吐不一定意味着性能差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to combine multiple rolling aggregation methods—only a single roll‐ ing aggregate can be computed at a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054053Z" creationid="xccui" creationdate="20190614T054037Z">
        <seg>注意，无法将多个滚动聚合方法组合使用，每次只能计算一个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is required by any non-trivial computa&lt;t0/&gt;‐&lt;t1/&gt; tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T051626Z" creationid="xccui" creationdate="20190414T050639Z">
        <seg>任何稍麻烦点的计算都用得到它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is required by any nontrivial computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031430Z" creationid="xccui" creationdate="20190606T031411Z">
        <seg>任何稍复杂点的计算都要用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It passes each incoming event to a user-defined mapper</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050421Z" creationid="xccui" creationdate="20190613T042926Z">
        <seg>该转换将每个到来的事件传给一个用户自定义的映射器，后者针对每个输入只会返回一个（可能是不同类型的）输出事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides accurate stream processing with high throughput and low latency at scale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T041932Z" creationid="xccui" creationdate="20190328T041119Z">
        <seg>它支持精确的流处理，能同时满足各种规模下高吞吐和低延迟的需求，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It requests processing slots from the ResourceManager to continue executing the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190503T192045Z" creationid="xccui" creationdate="20190503T192045Z">
        <seg>向ResourceManager申请处理槽来继续执行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It requests the storage locations from ZooKeeper to fetch the JobGraph, the JAR file, and the state handles of the last checkpoint of the application from the remote storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T034954Z" creationid="xccui" creationdate="20190503T192017Z">
        <seg>从ZooKeeper请求存储位置，以获取JobGraph、JAR文件以及应用最新checkpoint在远程存储的状态句柄。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It restarts the application and resets the state of all its tasks to the last completed checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190503T192125Z" creationid="xccui" creationdate="20190503T192125Z">
        <seg>重启应用并利用最新checkpoint重置任务状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It starts the same application with the same configuration on the same cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211715Z" creationid="xccui" creationdate="20190609T211715Z">
        <seg>它会在完全相同的集群上以完全相同的配置运行完全相同的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then starts to consume and process all data that was processed between the checkpoint and the failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T053306Z" creationid="xccui" creationdate="20190609T051830Z">
        <seg>随后应用就会开始重新消费并处理那些从之前检查点完成开始到发生系统故障之间已经处理过的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will help you to understand Flink’s internals and to reason about the performance and behavior of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T054615Z" creationid="xccui" creationdate="20190416T054457Z">
        <seg>这将帮助你理解Flink的内部原理，评估流式应用的性能及行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will help you to understand Flink’s internals and to reason about the perfor‐ mance and behavior of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140523Z" creationid="xccui" creationdate="20190606T140523Z">
        <seg>这将帮助你理解Flink的内部原理，评估流式应用的性能及行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will show that a single Task Manager (Flink’s worker processes) is connected and that a single Task Slot (resource units provided by a Task Manager) is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035532Z" creationid="xccui" creationdate="20190329T035513Z">
        <seg>它表示已经连接上一个Task Manager（Flink的工作进程），且有一个可用的Task Slot（Task Manager所提供的资源单元）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will show that a single TaskManager (Flink’s worker processes) is connected and that a single task slot (resource units provided by a TaskManager) is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123338Z" creationid="xccui" creationdate="20190605T123258Z">
        <seg>它表示已经连接上一个TaskManager（Flink的工作进程），且有一个可用的任务槽（TaskManager所提供的资源单元）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Italic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210800Z" creationid="esouser" creationdate="20190603T210800Z">
        <seg>Italic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its built-in operators interpret the Long value as a Unix timestamp with millisecond pre‐ cision—the number of milliseconds since 1970-01-01-00:00:00.000.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205018Z" creationid="xccui" creationdate="20190606T204948Z">
        <seg>它的内置算子会将这个Long类型值解析为毫秒精度的Unix时间戳（自1970-01-01-00:00:00.000以来的毫秒数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its built-in operators interpret the long value as a Unix timestamp with millisecond precision, i.e., the number of milliseconds since 1970-01-01-00:00:00.000.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040728Z" creationid="xccui" creationdate="20190523T040511Z">
        <seg>它的内置算子会将这个long类型值解析为毫秒精度的Unix时间戳（自1970-01-01-00:00:00.000以来的毫秒数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its goal is to introduce the funda&lt;t0/&gt;‐&lt;t1/&gt; mental concepts of stream processing and discuss the requirements of stream pro&lt;t2/&gt;‐&lt;t3/&gt; cessing frameworks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T053802Z" creationid="xccui" creationdate="20190329T053732Z">
        <seg>其目的在于介绍流处理的基础概念，讨论流处理框架的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Java and Classloading</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025533Z" creationid="xccui" creationdate="20190225T025533Z">
        <seg>Java和类加载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Job has been submitted with JobID cfde9dbe315ce162444c475a08cf93d9</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040020Z" creationid="xccui" creationdate="20190329T040020Z">
        <seg>Job has been submitted with JobID cfde9dbe315ce162444c475a08cf93d9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JobManager failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T222247Z" creationid="xccui" creationdate="20190428T222247Z">
        <seg>JobManager故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JobManager initiates a checkpoint by sending a message to all sources</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T063013Z" creationid="xccui" creationdate="20190608T063329Z">
        <seg>JobManager通过向所有数据源发送消息来启动检查点生成流程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joining Streams on Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150353Z" creationid="xccui" creationdate="20190225T023252Z">
        <seg>基于时间的数据流连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like many DataStream applications, the source, sink, and opera‐ tors of the program are assembled in the main() method of the AverageSensorRead ings class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042849Z" creationid="xccui" creationdate="20190611T042751Z">
        <seg>和大多数DataStream应用一样，该程序的数据源、数据汇以及其他算子都是在（AverageSensorReadings类的）main()方法中组装的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Selectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145630Z" creationid="esouser" creationdate="20190603T145630Z">
        <seg>键值选择器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keyed State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030457Z" creationid="xccui" creationdate="20190418T035556Z">
        <seg>键值状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keyed state is maintained and accessed with respect to a key defined in the records of an operator’s input stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191614Z" creationid="xccui" creationdate="20190607T185829Z">
        <seg>键值状态是按照算子输入记录所定义的键值来进行维护或访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStream Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022735Z" creationid="xccui" creationdate="20190225T022735Z">
        <seg>基于KeyedStream的转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStream transformations are transformations that are applied to events in the context of a key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024555Z" creationid="xccui" creationdate="20190613T024408Z">
        <seg>KeyedStream转换是作用于同一键值上下文内事件的转换；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStream, which is a DataStream that has been logically partitioned into disjoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044002Z" creationid="xccui" creationdate="20190614T044002Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kubernetes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040325Z" creationid="xccui" creationdate="20190418T040325Z">
        <seg>Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lambda Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022924Z" creationid="xccui" creationdate="20190225T022924Z">
        <seg>Lambda函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last but not least, Flink is also a full-fledged batch processor.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T121820Z" creationid="xccui" creationdate="20190605T121712Z">
        <seg>最后要强调的一点，Flink同时也是一个成熟的批处理引擎。1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last but not least, Flink is also a full-fledged batch processor&lt;t0/&gt;1&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052128Z" creationid="xccui" creationdate="20190328T052128Z">
        <seg>最后要强调的一点，Flink同时也是一个成熟的批处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151529Z" creationid="xccui" creationdate="20190401T151529Z">
        <seg>延迟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency Versus Throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234912Z" creationid="xccui" creationdate="20190605T234912Z">
        <seg>延迟 vs. 吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency and Throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143930Z" creationid="esouser" creationdate="20190603T143930Z">
        <seg>延迟和吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency and throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015312Z" creationid="xccui" creationdate="20190225T015312Z">
        <seg>延迟和吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency indicates how long it takes for an event to be processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151602Z" creationid="xccui" creationdate="20190401T151602Z">
        <seg>延迟表示处理一个事件所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency vs. throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T202243Z" creationid="xccui" creationdate="20190402T202238Z">
        <seg>延迟 vs. 吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Layered APIs with varying tradeoffs for expressiveness and ease of use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T055945Z" creationid="xccui" creationdate="20190605T055937Z">
        <seg>层次化API在表达能力和易用性方面各有权衡</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let us revisit the coffee shop example to clarify how latency and throughput affect each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210220Z" creationid="xccui" creationdate="20190402T204057Z">
        <seg>我们再通过咖啡店的示例来解释一下延迟和吞吐如何相互影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s assume you want to compute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014646Z" creationid="xccui" creationdate="20190606T014646Z">
        <seg>假设你想持续计算结果，比如每分钟计算一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s assume you want to compute results continuously, for example every one minute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T144504Z" creationid="xccui" creationdate="20190409T211020Z">
        <seg>假设你想持续计算结果，比如每分钟计算一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s now explain in more detail how a task emits watermarks and updates its event- time clock when receiving a new watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T014349Z" creationid="xccui" creationdate="20190607T014310Z">
        <seg>接下来我们详细解释一下当任务接收到一个新的水位线之后，将如何发送水位线以及更新其内部事件时间时钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s revisit the coffee shop example to clarify how latency and throughput affect each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235018Z" creationid="xccui" creationdate="20190605T235018Z">
        <seg>我们再通过咖啡店的示例来解释一下延迟和吞吐如何相互影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s start with a simple example to get a first impression of what it is like to write streaming applications with the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035305Z" creationid="xccui" creationdate="20190612T035028Z">
        <seg>让我们从一个简单的示例开始，来感受使用DataStream API编写流式应用的第一印象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Library style</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143638Z" creationid="xccui" creationdate="20190606T143638Z">
        <seg>库模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Library style&lt;t0/&gt;: In this mode, the Flink application is bundled in an application-specific container image, such as a Docker image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030252Z" creationid="xccui" creationdate="20190423T030236Z">
        <seg>库模式：在该模式下，Flink应用会绑定到一个应用相关的容器映像中（如Docker映像）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184138Z" creationid="xccui" creationdate="20190607T184048Z">
        <seg>列表状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local state access provides very good performance compared to reading and writing queries against remote datastores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T052249Z" creationid="xccui" creationdate="20190604T023347Z">
        <seg>本地状态访问会提供比读写远程数据存储系统更好的性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local state accesses, i.e., reading from or writing to memory or local disk, provide very good performance compared to read and write queries against remote data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190312T212225Z" creationid="xccui" creationdate="20190308T074008Z">
        <seg>只需要访问本地状态。和查询远程数据存储系统相比，读写本地内存或磁盘性能会更好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Low latency is a key characteristic of stream processing and it enables what we call &lt;t2/&gt;real-time&lt;t3/&gt; applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T192514Z" creationid="xccui" creationdate="20190401T191707Z">
        <seg>低延迟是流处理的一个关键特性，它滋生了所谓的实时应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Low latency is a key characteristic of stream processing and it enables what we call real-time applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234240Z" creationid="xccui" creationdate="20190605T234240Z">
        <seg>低延迟是流处理的一个关键特性，它滋生了所谓的实时应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Main Memory and Network Buffers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025555Z" creationid="xccui" creationdate="20190225T025555Z">
        <seg>内存和网络缓冲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure that “Import project from external model” and “Maven” are selected and click Next.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041318Z" creationid="xccui" creationdate="20190611T041318Z">
        <seg>确保勾上"Import project from external model"以及"Maven"两个选项，然后点击Next。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Managing Applications with the Command-Line Client</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025929Z" creationid="xccui" creationdate="20190225T025929Z">
        <seg>通过命令行客户端管理应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Managing Applications with the REST API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025932Z" creationid="xccui" creationdate="20190225T025932Z">
        <seg>通过REST API管理应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators continuously read and update some kind of state such as records collected in a window, reading positions of an input source, or custom, application-specific operator states like machine learning models.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T053106Z" creationid="xccui" creationdate="20190607T052753Z">
        <seg>很多算子会持续读取并更新某些状态，例如：窗口内收集的记录，输入源的读取位置或是一些定制的，诸如机器学习模型之类的特定应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many people show up at the same time and have to wait in line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234727Z" creationid="xccui" creationdate="20190605T234727Z">
        <seg>突然间涌入大量顾客，点单的人排起了长队。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many people show up at the same time and you have to wait in line to place your order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T211059Z" creationid="xccui" creationdate="20190401T211059Z">
        <seg>突然间涌入大量顾客，你必须排队点单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T044721Z" creationid="xccui" creationdate="20190613T044721Z">
        <seg>Map</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T220307Z" creationid="xccui" creationdate="20190607T220057Z">
        <seg>映射状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MapFunction in  the  following,  are  defined  as  classes  that  implement  a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020939Z" creationid="xccui" creationdate="20190613T020742Z">
        <seg>函数可以被定义为实现了某个特定转换接口的类，例如下面的MapFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metric System</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030134Z" creationid="xccui" creationdate="20190225T030134Z">
        <seg>指标系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metzger, Sebastian Schelter, Shaoxuan Wang, Shuyi Chen, Stefan Richter, Stephan Ewen, Theodore Vasiloudis, Thomas Weise, Till Rohrmann, Timo Walther, Tzu-Li (Gordon) Tai, Ufuk Celebi, Xiaogang Shi, Xiaowei Jiang, Xingcan Cui.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T044536Z" creationid="xccui" creationdate="20190605T132801Z">
        <seg>Metzger、Sebastian Schelter、Shaoxuan Wang（王绍翾）、Shuyi Chen（陈XX）、Stefan Richter、Stephan Ewen、Theodore Vasiloudis、Thomas Weise、 Till Rohrmann、Timo Walther、Tzu-Li (Gordon) Tai（戴资力）、Ufuk Celebi、Xiaogang Shi（施晓罡）、Xiaowei Jiang（蒋晓伟）、Xingcan Cui（崔星灿）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Microservices and all required software and services are typically bundled and deployed in independent containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172622Z" creationid="xccui" creationdate="20190228T172041Z">
        <seg>通常，微服务连同必须的软件及服务会打包部署到独立的容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Microservices are designed as small, self-contained, and independent applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172159Z" creationid="xccui" creationdate="20190227T042155Z">
        <seg>微服务由很多微型、完备、独立的应用组成，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Microser‐ vices and all the required software and services are typically bundled and deployed in independent containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T025508Z" creationid="esouser" creationdate="20190603T201022Z">
        <seg>通常情况下，微服务连同必须的软件及服务会打包部署到独立的容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Millisecond latencies while processing millions of events per second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T055845Z" creationid="xccui" creationdate="20190605T055840Z">
        <seg>每秒处理数百万条事件的同时保持毫秒级延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modern stream processors, like Apache Flink, can offer latencies as low as a few milliseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T193037Z" creationid="xccui" creationdate="20190401T192945Z">
        <seg>像Apache Flink这样的现代流处理引擎可以提供低至几毫秒的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modified applica‐ tions can also be used to run A/B tests or what-if scenarios with different busi‐ ness logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212424Z" creationid="xccui" creationdate="20190609T212336Z">
        <seg>应用修改还可用于A/B测试或需要不同业务逻辑的假想场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying the State of an Operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024933Z" creationid="xccui" creationdate="20190225T024924Z">
        <seg>改变算子的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring Flink Clusters and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030117Z" creationid="xccui" creationdate="20190225T030117Z">
        <seg>监控Flink集群及应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring Latency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030141Z" creationid="xccui" creationdate="20190225T030141Z">
        <seg>延迟监控</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring the quality of cellphone networks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045418Z" creationid="xccui" creationdate="20190605T045418Z">
        <seg>手机网络质量监控</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring the quality of cellphone networks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033619Z" creationid="xccui" creationdate="20190319T033357Z">
        <seg>手机网络质量监控，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More complex applications are built by connecting several microservices with each other that only communicate over stand&lt;t2/&gt;‐&lt;t3/&gt; ardized interfaces such as RESTful HTTP connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190227T233910Z" creationid="xccui" creationdate="20190227T233910Z">
        <seg>通过将多个微服务相互连接可以构建出更加复杂的应用，而微服务之间只通过标准化接口（如RESTful HTTP连接）进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More complex applica‐ tions are built by connecting several microservices with each other that only commu‐ nicate over standardized interfaces such as RESTful HTTP connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200705Z" creationid="esouser" creationdate="20190603T200705Z">
        <seg>通过将多个微服务相互连接可以构建出更加复杂的应用，而微服务之间只通过标准化接口（如RESTful HTTP连接）进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, Flink provides Maven archetypes to bootstrap new Flink Maven projects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004357Z" creationid="xccui" creationdate="20190611T020723Z">
        <seg>此外，Flink还提供了Maven模板（Maven archetypes）来创建新的Flink Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, even though events were not lost, they could be processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051608Z" creationid="xccui" creationdate="20190605T051608Z">
        <seg>此外，虽然数据在出错时不会丢失，但可能会被处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, even though events would not be lost in case of a failure, they could be processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T042844Z" creationid="xccui" creationdate="20190322T042844Z">
        <seg>此外，虽然数据在出错时不会丢失，但可能会被处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, exactly-once state consistency and the ability to scale an application are fundamental requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T064049Z" creationid="xccui" creationdate="20190314T062307Z">
        <seg>此外，作为基本需求，系统要提供精确一次的状态一致性保障和应用扩容能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, in the case of a failure, a stateless operator can be simply restarted and continue processing from where it left off.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T040129Z" creationid="xccui" creationdate="20190405T040033Z">
        <seg>此外，如果发生故障，无状态的算子可以很容易重启，从中断处继续工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it is an effective mecha&lt;t0/&gt;‐&lt;t1/&gt; nism to distribute network resources in case of skewed data distributions because credit is granted depending on the size of the senders’ backlog.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151301Z" creationid="esouser" creationdate="20190514T151123Z">
        <seg>此外，授予信用度是依据发送端的积压量来完成，因此该机制还会在出现数据倾斜时有效地分配网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it is an effective mechanism to distribute network resources in the case of skewed data distributions because credit is granted based on the size of the senders’ backlog.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203157Z" creationid="xccui" creationdate="20190606T203116Z">
        <seg>此外，信用值的授予是根据发送端的数据积压量来完成，因此该机制还会在出现数据倾斜时有效地分配网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it is often required to transform the data into a common format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T183803Z" creationid="xccui" creationdate="20190228T183803Z">
        <seg>此外，我们经常需要将数据转换为某种通用格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, results were still dependent on timing and order of arriving events, i.e., the results did not depend solely on the data but also on exter&lt;t2/&gt;‐&lt;t3/&gt; nal conditions such as the hardware utilization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T050519Z" creationid="xccui" creationdate="20190327T050502Z">
        <seg>此外，结果仍然依赖于到来事件的时间和顺序，换言之，结果的生成不仅依赖于数据本身，还和外部条件（如：硬件使用率）有关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, results were still dependent on timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053311Z" creationid="xccui" creationdate="20190605T053311Z">
        <seg>此外，结果仍然依赖于到来事件的时间和顺序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the stream processor can recover from failures with exactly-once state consistency guarantees and can adjust the compute resources of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045057Z" creationid="xccui" creationdate="20190605T044916Z">
        <seg>此外，它还能以精确一次的状态一致性保障进行故障恢复，调节应用计算资源等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the stream processor is respon&lt;t0/&gt;‐&lt;t1/&gt; sible to recover from failures with exactly-once state consistency guarantees and should be capable of adjusting the parallelism of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033138Z" creationid="xccui" creationdate="20190317T063754Z">
        <seg>此外，它还要负责以精确一次的状态一致性保障进行故障恢复，调节应用并发度等工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, users of open source software request or contribute new features that are missing to support their use</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T041404Z" creationid="xccui" creationdate="20190319T054608Z">
        <seg>此外，开源软件用户如果发现某些功能无法满足用例需求，都会向开源社区汇报或亲自操刀上阵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More‐ over, exactly-once state consistency and the ability to scale an application are funda‐ mental requirements for event-driven applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T053625Z" creationid="xccui" creationdate="20190604T053625Z">
        <seg>此外，作为基本需求，系统要提供精确一次的状态一致性保障和应用扩容能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More‐ over, the data often needs to be transformed into a common format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T202748Z" creationid="esouser" creationdate="20190603T202046Z">
        <seg>此外，数据经常需要转换为某种一般格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most commonly, this is done in a static</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043215Z" creationid="xccui" creationdate="20190612T043110Z">
        <seg>大多数情况下，这些工作都会在静态的main方法中完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most function interfaces are designed as SAM (single abstract method) interfaces and they can be implemented as Java 8 lambda functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T022250Z" creationid="xccui" creationdate="20190613T022250Z">
        <seg>大多数函数接口都被设计为SAM（单一抽象方法）形式的，因此可以通过Java 8的labmda函数实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most stream transformations are based on user-defined functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T014153Z" creationid="xccui" creationdate="20190613T014153Z">
        <seg>大多数流式转换都是基于用户自定义函数来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-Stream Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022743Z" creationid="xccui" creationdate="20190225T022743Z">
        <seg>基于多流的转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple companies have built streaming analytics services based on Flink’s SQL support both for internal use or to publicly offer them to paying customers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T041142Z" creationid="xccui" creationdate="20190319T040751Z">
        <seg>很多公司基于此构建了流式分析服务，供内部或外界付费用户使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multistream Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024730Z" creationid="esouser" creationdate="20190603T145126Z">
        <seg>多流转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multistream transformations merge multiple streams into one stream or split one stream into multiple streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024606Z" creationid="xccui" creationdate="20190613T024521Z">
        <seg>多流转换会将多条数据流合并为一条或将一条数据流拆分成多条；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nat&lt;t4/&gt;‐&lt;t5/&gt; urally, if a system can perform operations faster, it can perform more operations at the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211939Z" creationid="xccui" creationdate="20190402T211902Z">
        <seg>显然，系统执行操作越快，相同时间内执行的操作数量就会越多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naturally, if a system can perform operations faster, it can perform more operations in the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235710Z" creationid="xccui" creationdate="20190605T235634Z">
        <seg>显然，系统执行操作越快，相同时间内执行的操作数目就会越多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Navigate to File -&gt; New -&gt; Project from Existing Sources, select the book examples folder examples-scala, and click OK.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041215Z" creationid="xccui" creationdate="20190611T041215Z">
        <seg>依次找到File -&gt; New -&gt; Project from Existing Sources，选择书中示例文件夹examples-scala，点击OK。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New distributed stream processing projects are continuously entering the open source stage and are challenging the state-of-the-art with new features and capabilities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T054015Z" creationid="xccui" creationdate="20190319T054015Z">
        <seg>新的分布式流处理项目不断涌入开源领域，依靠其新特性和新功能向旧有的领先技术发起挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New distributed stream processing projects are continu‐ ously entering the open source stage and are challenging the state of the art with new features and capabilities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050557Z" creationid="xccui" creationdate="20190605T050557Z">
        <seg>新的分布式流处理项目不断涌入开源领域，依靠其新特性和新功能向旧有的领先技术发起挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next,  we  use env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045810Z" creationid="xccui" creationdate="20190612T045706Z">
        <seg>接下来我们通过env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, let’s run one of the book example applications in your IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042102Z" creationid="xccui" creationdate="20190611T042102Z">
        <seg>下一步让我们尝试在IDE里运行书中的一个示例程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we define a timeWindow() transfor‐ mation, which groups the sensor readings of each sensor ID partition into tumbling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053740Z" creationid="xccui" creationdate="20190612T053715Z">
        <seg>接下来我们通过timeWindow()转换，在每个传感器ID分区都将读数划分为5秒一次的滚动窗口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we describe the semantics of common window types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012953Z" creationid="xccui" creationdate="20190606T012936Z">
        <seg>接下来我们将介绍常见窗口类型的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we introduce application designs based on stateful stream processing that exhibit many interesting characteristics and benefits over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T223624Z" creationid="xccui" creationdate="20190225T222612Z">
        <seg>接下来，我们会介绍基于状态化流处理的应用方法。和传统方法相比，它有很多有趣的特性和优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we introduce application designs based on stateful stream pro‐ cessing that exhibit many interesting characteristics and benefits over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T050720Z" creationid="esouser" creationdate="20190603T163031Z">
        <seg>接下来，我们会介绍基于状态化流处理的应用设计。和传统设计相比，它有很多有趣的特性和优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we review the types of guarantees offered by modern stream processors and some mechanisms that systems implement to achieve those guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044532Z" creationid="xccui" creationdate="20190415T044532Z">
        <seg>接下来我们回顾一下现代流处理引擎所提供的不同种类的结果保障以及它们相应的实现机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we review the types of guarantees offered by modern stream processors and some of the mechanisms systems imple‐ ment to achieve those guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034141Z" creationid="xccui" creationdate="20190606T034141Z">
        <seg>接下来我们回顾一下现代流处理引擎所提供的不同种类的结果保障以及它们相应的实现机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we will guide you through the process of starting a local cluster and executing a first streaming application in order to give you a first impression of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T054710Z" creationid="xccui" creationdate="20190328T054710Z">
        <seg>接下来为了帮你获得Flink的第一印象，我们将一步步指导你启动本地集群并运行第一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, you have looked into the requirements of processing infinite streams in parallel and you have realized the importance of latency and throughput for stream applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051449Z" creationid="xccui" creationdate="20190416T050633Z">
        <seg>接下来你了解了并行处理无限流的需求并意识到了延迟和吞吐对于流式应用的重要性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, you learned the requirements of pro‐ cessing infinite streams in parallel and saw the importance of latency and throughput for stream applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T040339Z" creationid="xccui" creationdate="20190606T040339Z">
        <seg>紧接着你学习了的并行处理无限流的需求，了解了延迟和吞吐对于流式应用的重要性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No matter if water&lt;t2/&gt;‐&lt;t3/&gt; marks are user-defined or automatically generated, tracking global progress in a dis&lt;t4/&gt;‐&lt;t5/&gt; tributed system might be problematic in the presence of straggler tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T031322Z" creationid="xccui" creationdate="20190414T030615Z">
        <seg>无论水位线是由用户定义还是自动生成，只要存在落后的任务，追踪分布式系统中的全局进度就可能出现问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No matter if watermarks are user defined or automatically generated, tracking global progress in a distributed system might be problematic in the presence of straggler tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025748Z" creationid="xccui" creationdate="20190606T025748Z">
        <seg>无论水位线是由用户定义还是自动生成，只要存在落后的任务，追踪分布式系统中的全局进度就可能出现问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nodes represent operators and edges denote data dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T001302Z" creationid="xccui" creationdate="20190401T001240Z">
        <seg>其中节点表示算子，边表示数据依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nodes represent tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021810Z" creationid="xccui" creationdate="20190401T021708Z">
        <seg>每个节点表示一个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-chained task execution with dedicated threads and data transport via buffer channels and serialization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155047Z" creationid="esouser" creationdate="20190514T155047Z">
        <seg>使用特定线程执行非链接任务，利用缓冲通道及序列化进行数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonchained task execution with dedicated threads and data transport via</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204040Z" creationid="xccui" creationdate="20190606T204033Z">
        <seg>使用特定线程执行非链接任务，利用缓冲通道及序列化进行数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>None of the functions exposes an API to set the time&lt;t8/&gt;‐&lt;t9/&gt; stamps of emitted records, manipulate the event-time clock of a task, or emit watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T140736Z" creationid="esouser" creationdate="20190603T140736Z">
        <seg>但函数没有暴露相应的API来设置发出记录的时间戳，调整任务的事件时间时钟或发出水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all stream processors are equally well-suited to run event-driven applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T052727Z" creationid="xccui" creationdate="20190604T052517Z">
        <seg>并不是所有的流处理引擎都同等适合去运行事件驱动型应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note shipping records in buffers does imply that Flink’s processing model is based on micro-batches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042016Z" creationid="xccui" creationdate="20190504T042016Z">
        <seg>但注意，从缓冲区中传输记录并不意味着Flink的处理模型是基于微批次的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink does not implement this naive mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224835Z" creationid="xccui" creationdate="20190608T224543Z">
        <seg>但值得一提的是Flink没有实现这种朴素策略，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink uses TCP connec&lt;t0/&gt;‐&lt;t1/&gt; tions, thus these requirements are guaranteed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043546Z" creationid="xccui" creationdate="20190415T043439Z">
        <seg>由于Flink使用的是TCP连接，这些需求都能得以保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink uses TCP connec‐ tions, and thus these requirements are guaranteed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033713Z" creationid="xccui" creationdate="20190606T033713Z">
        <seg>由于Flink使用的是TCP连接，这些需求都能得以保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that guaranteeing the consistency of an application’s state is not the same a guarantee‐ ing consistency of its output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034253Z" creationid="xccui" creationdate="20190606T034216Z">
        <seg>但注意，保证应用状态的一致性和保证输出的一致性二者无法划等号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that shipping records in buffers does imply that Flink’s pro‐ cessing model is based on microbatches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195737Z" creationid="xccui" creationdate="20190606T195722Z">
        <seg>但注意，将记录放入缓冲区并不意味着Flink的处理模型就是基于微批次的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that stateful transformations and keyed aggregates have to be used with care.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044921Z" creationid="xccui" creationdate="20190614T044921Z">
        <seg>请注意，在使用状态化转换和基于键值的聚合时要格外小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that stream pro&lt;t0/&gt;‐&lt;t1/&gt; cessors can normally only guarantee result correctness for state that lives inside the stream processor itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T045425Z" creationid="xccui" creationdate="20190415T045308Z">
        <seg>注意，流处理引擎通常只能保障其自身内部状态结果的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the application and the savepoint must be compatible—the application must be able to load the state of the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212525Z" creationid="xccui" creationdate="20190609T212448Z">
        <seg>需要注意的是，应用和保存点必须相互兼容，只有这样应用才能加载保存点内的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the choice of a streaming sink affects the end-to-end con‐ sistency of an application, whether the result of the application is provided with at-least once or exactly-once semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005523Z" creationid="xccui" creationdate="20190613T005523Z">
        <seg>注意，无论应用结果是至少一次语义还是精确一次语义，流式数据汇的选择都将影响应用端到端的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the savepoint does not contain information about opera‐ tor tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215650Z" creationid="xccui" creationdate="20190609T215650Z">
        <seg>注意，保存点没有包含算子任务的相关信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that to be able to efficiently combine the current state with an event and produce a single value, the aggregation function must be associative and commuta&lt;t0/&gt;‐&lt;t1/&gt; tive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035418Z" creationid="xccui" creationdate="20190406T035032Z">
        <seg>注意，为了更有效地合并事件和当前状态、生成单个结果，聚合函数必须是可结合（associative）及可交换（commutative）的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that to be able to efficiently combine the current state with an event and produce a single value, the aggregation function must be associative and commuta‐ tive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011859Z" creationid="xccui" creationdate="20190606T011827Z">
        <seg>注意，为了更有效地合并事件和当前状态、生成单个结果，聚合函数必须是可结合（associative）及可交换（commutative）的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: you can also build the JAR file yourself by following the steps on the repo&lt;t0/&gt;‐&lt;t1/&gt; sitory’s README file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035840Z" creationid="xccui" creationdate="20190329T035802Z">
        <seg>注意：你也可以根据代码库中README文件的指示自行构建JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now let’s quickly discuss what is happening under the hood.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043738Z" creationid="xccui" creationdate="20190611T043738Z">
        <seg>接下来我们快速讨论一下内部发生的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now open your IDE and import the Maven project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040711Z" creationid="xccui" creationdate="20190611T040711Z">
        <seg>现在就可以打开你的IDE，把Maven项目导进去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that we have all that knowledge, it’s time to get our hands dirty and start devel‐ oping Flink applications!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T034012Z" creationid="xccui" creationdate="20190610T033449Z">
        <seg>既然我们已经掌握了这么多理论知识，是时候撸起袖子着手开发Flink应用了！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that you are familiar with the basics of dataflow programming, it’s time to see how these concepts apply to processing data streams in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233635Z" creationid="xccui" creationdate="20190605T233630Z">
        <seg>现在你已经对Dataflow编程的基础有所了解，接下来我们看一下这些概念如何应用于并行数据流处理中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that you have become familiar with the basics of dataflow programming, it’s time to see how these concepts apply to processing data streams in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142729Z" creationid="xccui" creationdate="20190401T142257Z">
        <seg>现在你已经对dataflow编程的基础有所了解，接下来我们看一下这些概念如何应用于并行数据流处理中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Obviously, the periodic nature of the ETL jobs and reporting queries induce a consid&lt;t0/&gt;‐&lt;t1/&gt; erable latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T031411Z" creationid="xccui" creationdate="20190317T031021Z">
        <seg>就是ETL作业和报告查询的周期性会导致相当高的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course there is much more to learn about stream pro&lt;t0/&gt;‐&lt;t1/&gt; cessing with Apache Flink and that’s what this book is about.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041854Z" creationid="xccui" creationdate="20190328T062511Z">
        <seg>当然，关于用Apache Flink进行流处理要学习的知识还有很多，这也正是本书要介绍的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, none of this matters if your system cannot guard state against failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T203538Z" creationid="xccui" creationdate="20190409T203538Z">
        <seg>当然，如果你的系统无法在故障时保护状态，那一切都是空谈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, there is much more to learn about stream processing with Apache Flink and that’s what this book is about.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124522Z" creationid="xccui" creationdate="20190605T124522Z">
        <seg>当然，关于用Apache Flink进行流处理要学习的知识还有很多，这也正是本书要介绍的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often are features of these newcomers being adop&lt;t0/&gt;‐&lt;t1/&gt; ted by more stream processors of earlier generations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014815Z" creationid="xccui" creationdate="20190319T055501Z">
        <seg>而这些新特性往往会被更多上一代的流处理引擎所采用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, a database system serves multiple applications that sometimes access the same databases or tables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T195827Z" creationid="esouser" creationdate="20190603T195556Z">
        <seg>很多时候，多个应用会共享同一个数据库系统，有时候还会访问相同的数据库或表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, this data was either unstruc&lt;t0/&gt;‐&lt;t1/&gt; tured, i.e., not strictly following a relational schema, or too voluminous to be cost-effectively stored in a relational database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T210826Z" creationid="xccui" creationdate="20190228T210612Z">
        <seg>这些数据通常是非结构化（即无法严格匹配关系模式）的，或因数量庞大无法经济高效地存放于关系型数据库系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the contrary, in continuously running stream&lt;t4/&gt;‐&lt;t5/&gt; ing jobs, state is durable across events and we can expose it as a first-class citizen in the programming model.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053122Z" creationid="xccui" creationdate="20190414T054354Z">
        <seg>反之，在持续运行的流式作业中，每次处理事件状态都是持久化的，我们完全可以将其作为编程模型中的一等公民。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the contrary, stateful operators may maintain information about the events they have received before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T040228Z" creationid="xccui" creationdate="20190405T040212Z">
        <seg>相反，状态化算子可能会维护之前接收的事件信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the left hand side you see a JobGraph - the non-parallel representation of an application - consisting of five operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043357Z" creationid="xccui" creationdate="20190423T043236Z">
        <seg>左侧的JobGraph（非并行化的应用表示）包含了5个算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the left-hand side of Figure 3-2 you see a JobGraph—the nonparallel representa‐ tion of an application—consisting of five operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144523Z" creationid="xccui" creationdate="20190606T144451Z">
        <seg>左侧的JobGraph（应用的非并行化表示）包含了5个算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, event time guarantees deterministic results and allows you to deal with events that are late or even out of order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031344Z" creationid="xccui" creationdate="20190606T031309Z">
        <seg>事件时间则与之相反，能保证结果的准确性，并允许你处理延迟甚至无序的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, event time guarantees deterministic results and allows you to deal with events that are late or even out-of-order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050333Z" creationid="xccui" creationdate="20190414T045924Z">
        <seg>与之相对的事件时间能保证确定的结果，并允许你处理延迟甚至无序的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if watermarks are too relaxed, you have high confidence but you might unnecessarily increase processing latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025714Z" creationid="xccui" creationdate="20190606T025703Z">
        <seg>反之，如果水位线过于宽松，虽然可信度得到了保证，但可能会无谓地增加处理延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if watermarks are too slow to arrive, you have high confi&lt;t4/&gt;‐&lt;t5/&gt; dence but you might unnecessarily increase processing latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210859Z" creationid="xccui" creationdate="20190412T210722Z">
        <seg>反之，如果水位线到来的太晚，虽然可信度得到了保证，但可能会无谓地增加处理延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, knowing about all accidents that have ever happened might not be so interesting in this case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043532Z" creationid="xccui" creationdate="20190406T043454Z">
        <seg>此时，我们可能对该位置发生过的所有事故并不感兴趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a job is scheduled for execution on the next batch, it cannot access the state of the pre&lt;t2/&gt;‐&lt;t3/&gt; vious job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053824Z" creationid="xccui" creationdate="20190414T053811Z">
        <seg>一旦作业调度到下个批次上执行，它将无法访问之前的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a job is scheduled for execution on the next batch, it cannot access the state of the previous job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032116Z" creationid="xccui" creationdate="20190606T032116Z">
        <seg>一旦作业调度到下个批次上执行，它将无法访问之前的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a sender receives a credit notification, it ships as many buffers as it was granted and the size of its backlog, i.e., the number of network buffers that are filled and ready to be shipped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151649Z" creationid="esouser" creationdate="20190513T211245Z">
        <seg>一旦发送端收到信用通知，就会在信用度范围内传输尽可能多的缓冲，并附带积压量（已经填满准备传输的缓冲数目）大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a sender receives a credit notification, it ships as many buffers as it was granted and the size of its backlog—the number of network buffers that are filled and ready to be shipped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203029Z" creationid="xccui" creationdate="20190606T202839Z">
        <seg>一旦发送端收到信用通知，就会在信用值所限定的范围内尽可能多地传输缓冲数据，并会附带上积压量（已经填满准备传输的缓冲数目）大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a watermark has been received, operators are signaled that all timestamps for a certain time interval have been observed and either trigger computation or order received events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210017Z" creationid="xccui" creationdate="20190412T205922Z">
        <seg>一旦收到某个水位线，就相当于算子接到信号：某个特定时间区间的的时间戳已经到齐，可以触发窗口计算或对接收的数据进行排序了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once all barriers for a checkpoint have arrived, the operator checkpoints the state, which might now also include modifications caused by records that would usually belong to the next checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T205131Z" creationid="xccui" creationdate="20190609T204938Z">
        <seg>待所有的检查点分隔符都到达以后，算子才将状态存入检查点，这时候状态可能会包含一些由本应出现在下一次检查点的记录所导致的改动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once all checkpoint barriers have been emitted, the task starts to process the buffered records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193035Z" creationid="xccui" creationdate="20190609T193035Z">
        <seg>任务在发出所有的检查点分隔符后就会开始处理缓冲的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once all tasks are up and running, the pro‐ gram starts to produce its results, which should look similar to the following lines:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043424Z" creationid="xccui" creationdate="20190611T043424Z">
        <seg>一旦所有任务启动起来并开始运行，程序就会开始生成类似下面这样的结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once an application is submitted for execution, it starts a JobManager and hands the application over.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142904Z" creationid="xccui" creationdate="20190606T142857Z">
        <seg>一旦某个应用提交执行，Dispatcher会启动一个JobManager并将应用交付给它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once data has been emitted to a sink, it is difficult to guarantee result correctness, unless the sink system supports transactions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034308Z" creationid="xccui" creationdate="20190606T034308Z">
        <seg>一旦数据从数据汇中写出，结果正确性将很难保障。原因在于，数据汇可能不提供事务来恢复之前写入的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it received enough TaskManager slots, it distributes the tasks of the ExecutionGraph to the TaskManagers that execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T061952Z" creationid="xccui" creationdate="20190418T035042Z">
        <seg>一旦它收到了足够的TaskManager处理槽，就会将ExecutionGraph中的任务分发给TaskManager来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it receives an application, it starts a JobMan&lt;t4/&gt;‐&lt;t5/&gt; ager and hands the application over.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T053136Z" creationid="xccui" creationdate="20190418T053058Z">
        <seg>一旦接收了某个应用，Dispatcher会启动一个JobManager并将应用交付给它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it receives enough Task‐ Manager slots, it distributes the tasks of the ExecutionGraph to the TaskManag‐ ers that execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141810Z" creationid="xccui" creationdate="20190606T141755Z">
        <seg>一旦它收到了足够数量的TaskManager处理槽，就会将ExecutionGraph中的任务分发给TaskManager来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the data has been imported into the data warehouse it can be queried and ana&lt;t0/&gt;‐&lt;t1/&gt; lyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192252Z" creationid="xccui" creationdate="20190228T191418Z">
        <seg>一旦数据导入数据仓库，就能对它们做查询分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the data has been imported into the data warehouse it can be queried and ana‐ lyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203005Z" creationid="esouser" creationdate="20190603T203005Z">
        <seg>一旦数据导入数据仓库，就能对它们做查询分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the execution environment has been configured, it is time to do some actual work and start processing streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T050957Z" creationid="xccui" creationdate="20190612T050957Z">
        <seg>在执行环境配置完后，就可以进行一些实质性的工作，正式开始处理数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the sender task completes, the data is sent as a batch over a temporary TCP connection to the receiver</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045623Z" creationid="xccui" creationdate="20190504T045549Z">
        <seg>一旦发送端任务完成，所有数据会经由一个到接收端的临时TCP连接，以批量形式发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the sender task completes, the data is sent as a batch over a temporary TCP connection to the receiver.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T200648Z" creationid="xccui" creationdate="20190606T200629Z">
        <seg>一旦发送端任务完成，所有数据会经由一个到接收端的临时TCP连接，批量发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once we have a DataStream, we can apply a transformation on it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052239Z" creationid="xccui" creationdate="20190612T052239Z">
        <seg>一旦得到了DataStream，我们就可以对它进行转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once your coffee is ready, the barista calls your name and you can pick up your coffee from the bench.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T153941Z" creationid="xccui" creationdate="20190401T152947Z">
        <seg>咖啡制作完成后，店员会叫你的名字，你来从吧台取走咖啡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once your coffee is ready, the barista calls your name and you can pick up your coffee from the counter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233910Z" creationid="xccui" creationdate="20190605T233910Z">
        <seg>咖啡制作完成后，店员会叫你的名字，你来从吧台取走咖啡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One appli&lt;t0/&gt;‐&lt;t1/&gt; cation emits its output to an event log and another application consumes the events that the other application emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152727Z" creationid="xccui" creationdate="20190307T152727Z">
        <seg>即上游应用将结果写入事件日志供下游应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One application emits its output to an event log and another application consumes the events the other appli‐ cation emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214038Z" creationid="esouser" creationdate="20190603T214015Z">
        <seg>上游应用将结果写入事件日志供下游应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of Flink’s most valued and unique features are savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210433Z" creationid="xccui" creationdate="20190609T210433Z">
        <seg>Flink最具价值和最独特的功能之一是保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the most interesting applications of save‐ points we have seen in the wild is continuously migrating a streaming application to the datacenter that provides the lowest instance prices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214038Z" creationid="xccui" creationdate="20190609T213849Z">
        <seg>我们在生态中见到保存点最有意思的应用之一是不断将流式应用迁移到实例价格最低的数据中心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One operator (OP-1) has a single operator state (OS-1) and another operator (OP-2) has two keyed states (KS-1 and KS-2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214916Z" creationid="xccui" creationdate="20190609T214916Z">
        <seg>其中一个算子（OP-1）有一个算子状态（OS-1），另一个算子（OP-2）有两个键值状态（KS-1和KS-2）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way you can lower latency is by hiring a more skilled barista, i.e. one that prepares coffees faster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210823Z" creationid="xccui" creationdate="20190402T210744Z">
        <seg>一种降低延迟的方法是雇佣更娴熟的咖啡师，他们制作咖啡会更快一些。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Online editions are also available for most titles (http://oreilly.com).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210717Z" creationid="esouser" creationdate="20190603T210717Z">
        <seg>Online editions are also available for most titles (http://oreilly.com).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Online gaming is a simple scenario showing how operator semantics should depend on the time when events actually happen and not the time when the application receives the events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T154124Z" creationid="xccui" creationdate="20190411T153601Z">
        <seg>在线游戏这个简单场景展示了当事件实际发生时间和应用收到事件的时间存在差异时，算子语义该如何依赖时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only Use Rolling Aggregations on Bounded Key Domains</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T060935Z" creationid="xccui" creationdate="20190614T060917Z">
        <seg>只对有限键值域使用滚动聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only when execute() is called does the system trig‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011948Z" creationid="xccui" creationdate="20190613T011858Z">
        <seg>只有在调用execute()方法时，系统才会触发程序执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open Flink’s Web UI by entering the URL http://localhost:8081 in your browser.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123232Z" creationid="xccui" creationdate="20190605T123228Z">
        <seg>在浏览器中输入URL http://localhost:8081，打开Flink Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open Flink’s Web UI on by entering the URL &lt;t0/&gt;http://localhost:8081&lt;t1/&gt; &lt;t2/&gt;in your browser.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035037Z" creationid="xccui" creationdate="20190329T025509Z">
        <seg>在你浏览器中输入URL http://localhost:8081，打开Flink Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open a terminal and run the following Git command to clone the examples-scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040102Z" creationid="xccui" creationdate="20190611T035954Z">
        <seg>打开终端运行以下Git命令将examples-scala库克隆到你的机器上1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open a terminal and run the following command to create a Flink Maven Quickstart Scala project as a starting point for your Flink application:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004808Z" creationid="xccui" creationdate="20190612T004808Z">
        <seg>打开终端运行以下命令来创建Flink Maven Quickstart Scala项目，并以它为基础开发Flink应用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source communities are constantly improving the capabilities of their projects and are pushing the technical boundaries of stream pro‐ cessing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050637Z" creationid="xccui" creationdate="20190605T050637Z">
        <seg>开源社区不断增强它们项目的功能并在流处理领域开疆拓土。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source software is a major driver of this trend, mainly due to two reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T052426Z" creationid="xccui" creationdate="20190319T051721Z">
        <seg>开源软件之所以能够主导这一趋势，主要有两方面原因：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source software is a major driver of this trend, mainly due to two reasons:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050320Z" creationid="xccui" creationdate="20190605T050320Z">
        <seg>开源软件之所以能够主导这一趋势，主要有两方面原因：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source stream processing software is a commodity that everybody can eval&lt;t0/&gt;‐&lt;t1/&gt; uate and use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T052828Z" creationid="xccui" creationdate="20190319T052828Z">
        <seg>开源流处理软件作为一件商品，所有人都可以评估和使用它；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source stream processing software is a commodity that everybody can eval‐ uate and use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T062555Z" creationid="xccui" creationdate="20190605T050444Z">
        <seg>开源流处理软件作为一类商品，允许任何人评估和使用；</seg>
      </tuv>
    </tu>
    <tu>
      <note>TODO</note>
      <tuv lang="EN-US">
        <seg>Operating Flink and Streaming Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031045Z" creationid="xccui" creationdate="20190225T025708Z">
        <seg>控制Flink和流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations based on event time are predictable and their results are deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024302Z" creationid="xccui" creationdate="20190606T024302Z">
        <seg>基于事件时间的操作是可预测的，它们的结果非常确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations based on event-time are predictable and their results deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150811Z" creationid="xccui" creationdate="20190412T150811Z">
        <seg>基于事件时间的操作是可预测的，它们的结果非常确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations can be either &lt;t0/&gt;stateless&lt;t1/&gt; or &lt;t2/&gt;stateful&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T213151Z" creationid="xccui" creationdate="20190402T213141Z">
        <seg>这些操作既可以是无状态（stateless）的，也可以是有状态（stateful）的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations can be either stateless or stateful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235803Z" creationid="xccui" creationdate="20190605T235803Z">
        <seg>这些操作既可以是无状态（stateless）的，也可以是有状态（stateful）的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations on Data Streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143937Z" creationid="esouser" creationdate="20190603T143937Z">
        <seg>数据流上的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations on data streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015445Z" creationid="xccui" creationdate="20190225T015445Z">
        <seg>数据流上的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022048Z" creationid="xccui" creationdate="20190225T022048Z">
        <seg>算子状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state cannot be accessed by another task of the same or a different operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061752Z" creationid="xccui" creationdate="20190607T061413Z">
        <seg>算子状态不能通过其他任务访问，无论该任务是否来自相同算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state in streaming jobs is very valuable and should be guarded against fail&lt;t0/&gt;‐&lt;t1/&gt; ures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035634Z" creationid="xccui" creationdate="20190415T035334Z">
        <seg>流式作业中的算子状态十分宝贵，因此需要在故障时予以保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state in streaming jobs is very valuable and should be guarded against fail‐ ures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033120Z" creationid="xccui" creationdate="20190606T033054Z">
        <seg>流式作业中的算子状态十分重要，因此需要在故障时加以保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state is scoped to an operator task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T060735Z" creationid="xccui" creationdate="20190607T060228Z">
        <seg>算子状态的作用域是某个算子任务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators A and C are sources and operator E is a sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043400Z" creationid="xccui" creationdate="20190423T043347Z">
        <seg>其中算子A和C是数据源，算子E是数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators C and E have a parallelism of two.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043448Z" creationid="xccui" creationdate="20190423T043412Z">
        <seg>算子C和E的并行度为2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators are executed in parallel by one or more operator tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214539Z" creationid="xccui" creationdate="20190609T214539Z">
        <seg>算子会在一个或多个任务上并行执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators are the basic functional units of a dataflow application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224831Z" creationid="xccui" creationdate="20190331T214759Z">
        <seg>算子是Dataflow程序的基本功能单元，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators can accept multiple inputs and produce multiple output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011643Z" creationid="xccui" creationdate="20190405T155812Z">
        <seg>算子可以同时接收多个输入流或产生多条输出流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that implement data ingestion logic are called &lt;t4/&gt;data sources&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152036Z" creationid="xccui" creationdate="20190405T152036Z">
        <seg>实现数据接入操作逻辑的算子称为数据源（data source）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that implement data ingestion logic are called data sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T005820Z" creationid="xccui" creationdate="20190606T005820Z">
        <seg>实现数据接入操作逻辑的算子称为数据源（data source）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that perform data egress are called &lt;t8/&gt;data sinks&lt;t9/&gt; and exam&lt;t10/&gt;‐&lt;t11/&gt; ples include files, databases, message queues, and monitoring interfaces.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152733Z" creationid="xccui" creationdate="20190405T152512Z">
        <seg>负责数据输出的算子称为数据汇（data sink），其写入的目标包括文件、数据库、消息队列、监控接口等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that perform data egress are called data sinks and examples include files, databases, message queues, and monitoring interfaces.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T010159Z" creationid="xccui" creationdate="20190606T010159Z">
        <seg>负责数据输出的算子称为数据汇（data sink），其写入的目标包括文件、数据库、消息队列、监控接口等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with keyed state are scaled by repartitioning keys to fewer or more tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T055204Z" creationid="xccui" creationdate="20190608T055151Z">
        <seg>带有键值状态的算子在扩缩容时会根据新的任务数量对键值重新分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with operator broadcast state are scaled up by copying the state to new tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061609Z" creationid="xccui" creationdate="20190608T061609Z">
        <seg>带有算子广播状态的算子在扩缩容时会把状态拷贝到全部新任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with operator list state are scaled by redistributing the list entries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060331Z" creationid="xccui" creationdate="20190608T060308Z">
        <seg>带有算子列表状态的算子在扩缩容时会重新分配列表中的项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with operator union list state are scaled by broadcasting the full list of state entries to each task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061235Z" creationid="xccui" creationdate="20190608T061211Z">
        <seg>带有算子联合列表状态的算子会在扩缩容时把状态列表的全部条目广播到全部任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators without input ports are called data sources and opera&lt;t4/&gt;‐&lt;t5/&gt; tors without output ports are called data sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190331T223800Z" creationid="xccui" creationdate="20190331T223724Z">
        <seg>没有输入口的算子称为数据源，没有输出口的算子称为数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators without input ports are called data sources and opera‐ tors without output ports are called data sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224919Z" creationid="xccui" creationdate="20190605T224919Z">
        <seg>没有输入口的算子称为数据源，没有输出口的算子称为数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators, Tasks, and Processing Slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042938Z" creationid="xccui" creationdate="20190423T042938Z">
        <seg>算子、任务以及处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators, tasks, and processing slots</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144442Z" creationid="xccui" creationdate="20190606T144442Z">
        <seg>算子、任务以及处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionally output the result to one or more data sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044352Z" creationid="xccui" creationdate="20190612T044352Z">
        <seg>选择性地将结果输出到一个或多个数据汇中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other features include support to upgrade application code or migrate a job to a different cluster or a new version of the stream processor without losing the current state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053924Z" creationid="xccui" creationdate="20190605T053913Z">
        <seg>还有一些特性包括：支持应用代码升级，在不丢失当前状态的前提下将作业迁移至一个新的集群或新版本的流处理引擎等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other features include support to upgrade application code or migrating a job to a different cluster or a new version of the stream processor without losing the current state of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T140840Z" creationid="xccui" creationdate="20190327T140804Z">
        <seg>还有一些特性包括支持应用代码升级，在不丢失当前状态的前提下将作业迁移至一个新的集群或新版本的流处理引擎等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Others more interested in writing Flink code right away might want to read the practical chapters first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041613Z" creationid="esouser" creationdate="20190603T153223Z">
        <seg>或者如果你迫不及待地想开始编写Flink代码，也可以先阅读实践章节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, it returns a local environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045422Z" creationid="xccui" creationdate="20190612T045422Z">
        <seg>否则会返回一个本地环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the operator would have to store the complete stream history.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035454Z" creationid="xccui" creationdate="20190406T035454Z">
        <seg>否则算子就需要存储整个历史流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our code exam‐ ples use Scala for conciseness, but the Java API is mostly analogous (exceptions or special cases will be pointed out).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T034526Z" creationid="xccui" creationdate="20190612T034526Z">
        <seg>出于简洁考虑，我们的示例代码还会选用Scala版本，但绝大多数的Java API都是类似的（如果有异常或特殊情况会指出）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our example application ingests a stream of temperature meas‐ urements from multiple sensors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035537Z" creationid="xccui" creationdate="20190612T035520Z">
        <seg>我们的示例应用会从多个传感器中获取温度测量数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our unique network of experts and innovators share their knowledge and expertise through books, articles, conferences, and our online learning platform.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210831Z" creationid="esouser" creationdate="20190603T210831Z">
        <seg>Our unique network of experts and innovators share their knowledge and expertise through books, articles, conferences, and our online learning platform.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Output the Result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145109Z" creationid="esouser" creationdate="20190603T145109Z">
        <seg>输出结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Output the result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022624Z" creationid="xccui" creationdate="20190225T022624Z">
        <seg>输出结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Over the years the collection and usage of data has grown consistently, and compa‐ nies have designed and built infrastructures to manage that data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T051012Z" creationid="esouser" creationdate="20190603T193927Z">
        <seg>随着数据收集和使用量的不断增长，很多公司都设计并构建了各种基础架构来管理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly Media, Inc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210837Z" creationid="esouser" creationdate="20190603T210837Z">
        <seg>O’Reilly Media, Inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly Online Learning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210828Z" creationid="esouser" creationdate="20190603T210828Z">
        <seg>O’Reilly Online Learning</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly books may be purchased for educational, business, or sales promotional use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210716Z" creationid="esouser" creationdate="20190603T210716Z">
        <seg>O’Reilly books may be purchased for educational, business, or sales promotional use.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly’s online learning platform gives you on-demand access to live training courses, in- depth learning paths, interactive coding environments, and a vast collection of text</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210832Z" creationid="esouser" creationdate="20190603T210832Z">
        <seg>O’Reilly’s online learning platform gives you on-demand access to live training courses, in- depth learning paths, interactive coding environments, and a vast collection of text</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parallelization gets complicated, since results depend on both the state and incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032919Z" creationid="xccui" creationdate="20190606T032919Z">
        <seg>由于结果需要同时依赖状态和到来的事件，状态并行化变得异常复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pattern detection or complex event processing (CEP), e.g., for fraud detection in credit card transactions, and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190315T012134Z" creationid="xccui" creationdate="20190307T151505Z">
        <seg>模式识别或复杂事件处理（CEP）（例如：根据信用卡交易记录进行反欺诈），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pattern detection or complex event processing (e.g., for fraud detection in credit card transactions)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213728Z" creationid="esouser" creationdate="20190603T213624Z">
        <seg>模式识别或复杂事件处理（例如：根据信用卡交易记录进行欺诈识别），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pause the ingestion of all input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223558Z" creationid="xccui" creationdate="20190608T223429Z">
        <seg>暂停接收所有输入流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performace Implications of Checkpointing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155008Z" creationid="esouser" creationdate="20190603T144627Z">
        <seg>检查点对性能的影响</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performance and Robustness of Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024730Z" creationid="xccui" creationdate="20190225T024730Z">
        <seg>状态化应用的性能及鲁棒性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Periodic assigner: The DataStream API provides a user-defined function called AssignerWithPeriodicWatermarks that extracts a timestamp from each record and is periodically queried for the current watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T035640Z" creationid="xccui" creationdate="20190607T034945Z">
        <seg>周期分配器：DataStream API提供了一个名为AssignerWithPeriodicWatermarks的用户自定义函数，它可以用来从每条记录提取时间戳并周期性地响应获取当前水位线的查询请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persistent event logs write all events to durable storage, so that they can be replayed if a task fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T043348Z" creationid="xccui" creationdate="20190416T043348Z">
        <seg>持久化事件日志会将所有事件写入永久存储，因此在任务故障时可以重放它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Playing online mobile games in the subway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152158Z" creationid="xccui" creationdate="20190411T152153Z">
        <seg>地铁上玩在线手游。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please address comments and questions concerning this book to the publisher:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210836Z" creationid="esouser" creationdate="20190603T210836Z">
        <seg>Please address comments and questions concerning this book to the publisher:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note that &lt;t0/&gt;Figure 3-1&lt;t1/&gt; is a high-level sketch to visualize the responsibilities and interactions of the components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024651Z" creationid="xccui" creationdate="20190423T024651Z">
        <seg>注意，图3-1仅仅从一个较高层次上展示了各组件的职责与交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Policies can be based on time (e.g. events received in the last 5 seconds), on count (e.g. the last 100 events), or on a data property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T050402Z" creationid="xccui" creationdate="20190406T050241Z">
        <seg>决策可以基于时间（例如：最近5秒钟接收的事件）、数量（例如：最新100个事件）或其他数据属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Policies can be based on time (e.g., events received in the last five seconds), on count (e.g., the last one hundred events), or on a data property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012927Z" creationid="xccui" creationdate="20190606T012927Z">
        <seg>决策可以基于时间（例如：最近5秒钟接收的事件）、数量（例如：最新100个事件）或其他数据属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T040256Z" creationid="xccui" creationdate="20190225T040256Z">
        <seg>序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface | xi</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130342Z" creationid="xccui" creationdate="20190605T130342Z">
        <seg>序言 | xi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface | xiii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130355Z" creationid="xccui" creationdate="20190605T130355Z">
        <seg>序言 | xiii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T013841Z" creationid="xccui" creationdate="20190225T013841Z">
        <seg>序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preventing Leaking State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024832Z" creationid="xccui" creationdate="20190225T024832Z">
        <seg>防止状态泄露</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously in this chapter, we described the common architecture for data analytics pipelines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T025235Z" creationid="xccui" creationdate="20190317T025021Z">
        <seg>本章前面已经介绍了数据分析管道的通用架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printed in the United States of America.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210713Z" creationid="esouser" creationdate="20190603T210713Z">
        <seg>Printed in the United States of America.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145830Z" creationid="xccui" creationdate="20190418T035908Z">
        <seg>处理函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process functions are discussed in more detail in Chapter 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025612Z" creationid="xccui" creationdate="20190607T025612Z">
        <seg>我们会在第6章详细讨论处理函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Streams in Parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143915Z" creationid="esouser" creationdate="20190603T143915Z">
        <seg>并行数据流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Streams in Parallel | 21</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041420Z" creationid="xccui" creationdate="20190606T041420Z">
        <seg>并行数据流处理 | 21</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144150Z" creationid="esouser" creationdate="20190603T144150Z">
        <seg>处理时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Time Versus Event Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144227Z" creationid="esouser" creationdate="20190603T144227Z">
        <seg>处理时间 vs. 事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing streams in parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015430Z" creationid="xccui" creationdate="20190225T015047Z">
        <seg>并行数据流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020340Z" creationid="xccui" creationdate="20190225T020340Z">
        <seg>处理时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time is the time of the local clock on the machine where the operator pro&lt;t0/&gt;‐&lt;t1/&gt; cessing the stream is being executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T144610Z" creationid="xccui" creationdate="20190412T143933Z">
        <seg>处理时间是当前流处理算子所在机器上的本地时钟时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time is the time of the local clock on the machine where the operator pro‐ cessing the stream is being executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023826Z" creationid="xccui" creationdate="20190606T023826Z">
        <seg>处理时间是当前流处理算子所在机器上的本地时钟时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time vs. event time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020419Z" creationid="xccui" creationdate="20190225T020419Z">
        <seg>处理时间 vs. 事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time can be applicable for applications with very low latency requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042414Z" creationid="xccui" creationdate="20190328T042346Z">
        <seg>处理时间能够用在具有极低延迟需求的应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time semantics can be used for applications with very low latency requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054156Z" creationid="xccui" creationdate="20190605T054156Z">
        <seg>处理时间语义能够用在具有极低延迟需求的应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time windows introduce the lowest latency possi&lt;t6/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043855Z" creationid="xccui" creationdate="20190414T041008Z">
        <seg>它能够将延迟降至最低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time windows introduce the lowest latency possi‐ ble.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T030804Z" creationid="xccui" creationdate="20190606T030730Z">
        <seg>例如：处理时间窗口能够将延迟降至最低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provided Connectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030757Z" creationid="xccui" creationdate="20190225T025117Z">
        <seg>内置连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing exactly-once guarantees requires at-least-once guarantees, and thus a data replay mechanism is again necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034836Z" creationid="xccui" creationdate="20190606T034836Z">
        <seg>提供精确一次保障是以至少一次保障为前提，因此同样需要数据重放机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing exactly-once guarantees requires at-least-once guarantees, thus a data replay mechanism is again necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044408Z" creationid="xccui" creationdate="20190416T044337Z">
        <seg>提供精确一次保障是以至少一次保障为前提，因此同样需要数据重放机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210715Z" creationid="esouser" creationdate="20190603T210715Z">
        <seg>Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Punctuated assigner: AssignerWithPunctuatedWatermarks is another user- defined function that extracts a timestamp from each record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T035811Z" creationid="xccui" creationdate="20190607T035758Z">
        <seg>定点分配器：另一个支持从记录中提取时间戳的用户自定义函数叫做AssignerWithPunctuatedWatermarks。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queryable State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151202Z" creationid="xccui" creationdate="20190225T024940Z">
        <seg>可查询式状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Querying State from External Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025041Z" creationid="xccui" creationdate="20190225T025041Z">
        <seg>从外部系统查询状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read an Input Stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145047Z" creationid="esouser" creationdate="20190603T145047Z">
        <seg>读取输入流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read an input stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022556Z" creationid="xccui" creationdate="20190225T022556Z">
        <seg>读取输入流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read one or more streams from data sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043536Z" creationid="xccui" creationdate="20190612T043536Z">
        <seg>从数据源中读取一条或多条流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading from and Writing to External Systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025053Z" creationid="xccui" creationdate="20190225T025053Z">
        <seg>读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-World Streaming Use-Cases and Deployments</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T212518Z" creationid="esouser" creationdate="20190603T212425Z">
        <seg>真实的流处理用例及部署方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-time recommendations (e.g., for recommending products while customers browse a retailer’s website)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213611Z" creationid="esouser" creationdate="20190603T213611Z">
        <seg>实时推荐（例如：在客户浏览商家页面的同时进行产品推荐），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-time recommendations, e.g., for recommending products while customers browse on a retailer’s website,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T151655Z" creationid="xccui" creationdate="20190307T025808Z">
        <seg>实时推荐（例如：在客户浏览商家页面的同时进行产品推荐），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-world sys&lt;t2/&gt;‐&lt;t3/&gt; tems, networks, and communication channels are far from perfect, thus streaming data can often be delayed or arrive out-of-order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T201230Z" creationid="xccui" creationdate="20190409T201230Z">
        <seg>真实世界的系统、网络、通信信道充斥缺陷，因此流数据通常都会有所延迟或以乱序到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-world systems, net‐ works, and communication channels are far from perfect, and streaming data can often be delayed or arrive out of order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014307Z" creationid="xccui" creationdate="20190606T014251Z">
        <seg>真实世界的系统、网络、通信信道往往充斥缺陷，因此流数据通常都会有所延迟或以乱序到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receiving Notifications About Completed Checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155015Z" creationid="esouser" creationdate="20190603T151120Z">
        <seg>接收检查点完成通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receiving Notifications about Completed Checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024630Z" creationid="xccui" creationdate="20190225T024630Z">
        <seg>接收Checkpoint完成通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records can be emitted together with an associated timestamp, and watermarks can be emitted at any point in time as special records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034317Z" creationid="xccui" creationdate="20190607T034317Z">
        <seg>每个发出的记录都可以附加一个时间戳，水位线可以作为一个车特殊记录在任何时间点发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records that are produced by a function are separately handed over to the next function with  a simple method call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203657Z" creationid="xccui" creationdate="20190606T203657Z">
        <seg>函数生成的记录只需通过简单的方法调用就可以分别发往各自的下游函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records that are produced by a function are separately handed over to the next function with a simple method call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152951Z" creationid="esouser" creationdate="20190514T152951Z">
        <seg>函数生成的记录只需通过简单的方法调用就可以分别发往各自的下游函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records that arrive on partitions that forwarded a barrier already cannot be processed and are buf‐ fered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162650Z" creationid="xccui" creationdate="20190609T162559Z">
        <seg>对于已经提供分隔符的分区，它们新到来的记录会被缓冲起来，不能处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recovering an application from a checkpoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035923Z" creationid="xccui" creationdate="20190609T035923Z">
        <seg>从检查点恢复应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recovery from a Consistent Checkpoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154850Z" creationid="xccui" creationdate="20190225T022157Z">
        <seg>从一致性检查点中恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redirecting Late Events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150750Z" creationid="xccui" creationdate="20190225T023448Z">
        <seg>重定向迟到事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reduce</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061233Z" creationid="xccui" creationdate="20190614T061233Z">
        <seg>Reduce</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refer to “Implementing Stateful Functions” on page 154, which discusses stateful functions in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T045701Z" creationid="xccui" creationdate="20190614T045650Z">
        <seg>有关状态化函数的详细信息请参阅第154页"实现状态化函数"一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removing State from an Application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024915Z" creationid="xccui" creationdate="20190225T024915Z">
        <seg>从应用中删除状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Represents state as a list of entries as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184420Z" creationid="xccui" creationdate="20190607T184334Z">
        <seg>同样是将状态看做一个条目列表，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Represents state as a list of entries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184410Z" creationid="xccui" creationdate="20190607T184245Z">
        <seg>将状态表看做一个条目列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reprocessing all input to reproduce lost state in the case of failures would be both very expensive and time-consuming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T040947Z" creationid="xccui" creationdate="20190415T040923Z">
        <seg>通过重新处理所有输入来重建故障时丢失的状态，不仅代价高，而且非常耗时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reprocessing all input to reproduce lost state in the case of fail‐ ures would be both very expensive and time-consuming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033139Z" creationid="xccui" creationdate="20190606T033139Z">
        <seg>通过重新处理所有输入来重建故障时丢失的状态，不仅代价高，而且非常耗时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required Software</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022254Z" creationid="xccui" creationdate="20190225T022254Z">
        <seg>所需软件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requirements also differ when it comes to evaluating performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150306Z" creationid="xccui" creationdate="20190401T150306Z">
        <seg>而这些不同还体现在性能评测方面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reset the states of all stateful tasks to the latest checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040226Z" creationid="xccui" creationdate="20190609T040149Z">
        <seg>利用最新的检查点重置任务状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resettable Source Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025236Z" creationid="xccui" creationdate="20190225T025236Z">
        <seg>可重置的源函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restart strategies are discussed in more detail in Chapter 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T150158Z" creationid="xccui" creationdate="20190606T150158Z">
        <seg>重启策略会在第10章详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restart strategies will be discussed in more detail in Chapter 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051610Z" creationid="xccui" creationdate="20190502T051440Z">
        <seg>重启策略会在第10章详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restart the whole application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040129Z" creationid="xccui" creationdate="20190609T040129Z">
        <seg>重启整个应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restoring the state of an application is described in a later section of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205243Z" creationid="xccui" creationdate="20190428T205226Z">
        <seg>恢复应用状态将会在本章的稍后一节进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restoring the state of an application is described in “Recovery from a Con‐ sistent Checkpoint” on page 60.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145415Z" creationid="xccui" creationdate="20190606T145348Z">
        <seg>恢复应用状态将会在60页"从一致性检查点恢复"一节进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Result Guarantees</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144259Z" creationid="esouser" creationdate="20190603T144259Z">
        <seg>结果保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Result guarantees</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021628Z" creationid="xccui" creationdate="20190225T021628Z">
        <seg>结果保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resume the ingestion of all streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224318Z" creationid="xccui" creationdate="20190608T224238Z">
        <seg>恢复所有数据流的接收。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resume the processing of all tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040646Z" creationid="xccui" creationdate="20190609T040646Z">
        <seg>恢复所有任务的处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revision History for the First Edition</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210732Z" creationid="esouser" creationdate="20190603T210732Z">
        <seg>Revision History for the First Edition</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revisiting the coffee shop example, if the shop is open from 7 a.m. to 7 p.m. and it serves 600 customers in one day, then its average throughput would be 50 customers per hour.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234402Z" creationid="xccui" creationdate="20190605T234402Z">
        <seg>回到刚刚咖啡店的例子，如果它的营业时间是早7点到晚7点，并且一天服务了600名顾客，那么它的平均吞吐是每小时50人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revisiting the coffee shop example, if the shop is open from 7am to 7pm and it serves 600 customers in one day, then its average throughput would be 50 customers per hour.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195720Z" creationid="xccui" creationdate="20190401T195656Z">
        <seg>回到刚刚咖啡店的例子，如果它的营业时间是早7点到晚7点，并且一天服务了600名顾客，那么它的平均吞吐是每小时50人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rich Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022929Z" creationid="xccui" creationdate="20190225T022929Z">
        <seg>富函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rolling aggregation transformations are applied on a KeyedStream and produce a DataStream of aggregates, such as sum, minimum, and maximum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052018Z" creationid="xccui" creationdate="20190614T052018Z">
        <seg>滚动聚合转换作用于KeyedStream上，生成包含聚合结果（例如求和、最小值、最大值等）的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rolling aggregations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T160158Z" creationid="xccui" creationdate="20190405T160158Z">
        <seg>滚动聚合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run Flink Applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144911Z" creationid="esouser" creationdate="20190603T144911Z">
        <seg>在IDE中运行Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run Flink applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022339Z" creationid="xccui" creationdate="20190225T022339Z">
        <seg>在IDE中运行Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run and Debug Flink Applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144840Z" creationid="esouser" creationdate="20190603T144840Z">
        <seg>在IDE中运行和调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run and Debug Flink Applications in an IDE | 73</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012826Z" creationid="xccui" creationdate="20190612T012826Z">
        <seg>在IDE中执行和调试Flink程序 | 73</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run and debug Flink applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022308Z" creationid="xccui" creationdate="20190225T022308Z">
        <seg>在IDE中执行和调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the example on your local cluster by specifying the applications entry class and the JAR file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035936Z" creationid="xccui" creationdate="20190329T035919Z">
        <seg>通过指定应用的入口类和JAR文件，在你的本地集群上运行示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the example on your local cluster by specifying the application’s entry class and JAR file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123600Z" creationid="xccui" creationdate="20190605T123600Z">
        <seg>通过指定应用的入口类和JAR文件，在你的本地集群上运行示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running Your First Flink Application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030140Z" creationid="esouser" creationdate="20190603T143056Z">
        <seg>首次运行Flink应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running and Managing Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025908Z" creationid="xccui" creationdate="20190225T025908Z">
        <seg>运行并管理流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144644Z" creationid="xccui" creationdate="20190418T035333Z">
        <seg>保存点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalable stream processing technology is rapidly maturing and evolving due to the efforts of many open source communities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T054139Z" creationid="xccui" creationdate="20190319T053253Z">
        <seg>得益于诸多开源社区的努力，可伸缩的流处理技术能够迅速发展和成熟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling Stateful Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T032530Z" creationid="xccui" creationdate="20190225T022106Z">
        <seg>状态化算子扩缩容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with keyed state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060226Z" creationid="xccui" creationdate="20190608T060217Z">
        <seg>算子扩缩容时键值状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with operator broadcast state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062304Z" creationid="xccui" creationdate="20190607T060257Z">
        <seg>算子扩缩容时算子广播状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with operator list state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061028Z" creationid="xccui" creationdate="20190608T061028Z">
        <seg>算子扩缩容时算子列表状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with operator union list state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061516Z" creationid="xccui" creationdate="20190608T061516Z">
        <seg>算子扩缩容时算子联合列表状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling and fault tolerance are handled by the stream processor, and by leveraging an event log as the input source the complete input of an application is reliably stored and can be deterministi‐ cally replayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T043949Z" creationid="xccui" creationdate="20190604T043856Z">
        <seg>伸缩和容错交由流处理引擎完成，以事件日志作为应用的输入，不但完整可靠，而且还支持精准的数据重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling and fault-tolerance do not need special consideration because these aspects are handled by the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014605Z" creationid="xccui" creationdate="20190312T212356Z">
        <seg>无须考虑伸缩性和容错性。这些都交给流处理引擎处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scheduling tasks as slices to slots has the advantage that many tasks are co-located on the TaskManager which means that they can efficiently exchange data within the the same process and without accessing the network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062846Z" creationid="xccui" creationdate="20190424T061942Z">
        <seg>将任务以切片的形式调度至处理槽中有一个好处：TaskManager中的多个任务可以在同一进程内高效地执行数据交换而无须访问网络。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scheduling tasks as slices to slots has the advantage that many tasks are colocated on the TaskManager, which means they can efficiently exchange data within the the same process and without accessing the network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144717Z" creationid="xccui" creationdate="20190606T144717Z">
        <seg>将任务以切片的形式调度至处理槽中有一个好处：TaskManager中的多个任务可以在同一进程内高效地执行数据交换而无须访问网络。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing a running job</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123752Z" creationid="xccui" creationdate="20190605T123752Z">
        <seg>展示运行作业的Apache Flink Web仪表盘截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing a running job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041702Z" creationid="xccui" creationdate="20190329T041546Z">
        <seg>展示运行作业的Apache Flink Web仪表盘截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing the overview</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123350Z" creationid="xccui" creationdate="20190605T123350Z">
        <seg>展示概览的Apache Flink Web仪表盘截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing the overview.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041649Z" creationid="xccui" creationdate="20190329T035553Z">
        <seg>展示概览的Apache Flink Web仪表盘截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Search for the AverageSensorReadings class and open it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042128Z" creationid="xccui" creationdate="20190611T042128Z">
        <seg>找到AverageSensorReadings类，打开它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sebastopol</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210641Z" creationid="esouser" creationdate="20190603T210641Z">
        <seg>Sebastopol</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, the latest results computed by the stream processor are not accurate but only approximated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T030945Z" creationid="xccui" creationdate="20190327T030820Z">
        <seg>其次，流处理引擎计算的最新结果仅仅是不精确的近似结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, the results compu‐ ted by the stream processor are only approximate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053042Z" creationid="xccui" creationdate="20190605T052957Z">
        <seg>其次，流处理引擎计算的结果只是近似的；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, you can have tasks from different operators performing computations on the same or different data in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034118Z" creationid="xccui" creationdate="20190401T031957Z">
        <seg>再者，你可以让不同算子的任务（基于相同或不同的数据）并行计算，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025635Z" creationid="xccui" creationdate="20190225T025635Z">
        <seg>安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See http://oreilly.com/catalog/errata.csp?isbn=9781491974292 for release details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210735Z" creationid="esouser" creationdate="20190603T210735Z">
        <seg>See http://oreilly.com/catalog/errata.csp?isbn=9781491974292 for release details.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Select the Maven project to import</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041645Z" creationid="xccui" creationdate="20190611T041645Z">
        <seg>选择要导入的Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Selling or distributing a CD-ROM of examples from O’Reilly books does require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210819Z" creationid="esouser" creationdate="20190603T210819Z">
        <seg>Selling or distributing a CD-ROM of examples from O’Reilly books does require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sending individual records over a network connection is inefficient and causes signif&lt;t0/&gt;‐&lt;t1/&gt; icant overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T210046Z" creationid="esouser" creationdate="20190513T210046Z">
        <seg>通过网络连接逐条发送记录不但低效，还会导致很多额外开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sending individual records over a network connection is inefficient and causes signif‐ icant overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202509Z" creationid="xccui" creationdate="20190606T202509Z">
        <seg>通过网络连接逐条发送记录不但低效，还会导致很多额外开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading contains the sensor ID, a timestamp denoting when the measurement was taken, and the measured temperature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052008Z" creationid="xccui" creationdate="20190612T052008Z">
        <seg>每一条SensorReading数据都包括传感器ID，表示测试时间的时间戳以及测量的温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(r.id, r.timestamp, celsius)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042303Z" creationid="xccui" creationdate="20190612T042303Z">
        <seg>SensorReading(r.id, r.timestamp, celsius)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041720Z" creationid="xccui" creationdate="20190329T041720Z">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259) SensorReading(sensor_6,1547718199000,15.402984393403084) SensorReading(sensor_7,1547718199000,6.720945201171228) SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123937Z" creationid="xccui" creationdate="20190605T123937Z">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259) SensorReading(sensor_6,1547718199000,15.402984393403084) SensorReading(sensor_7,1547718199000,6.720945201171228) SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041735Z" creationid="xccui" creationdate="20190329T041735Z">
        <seg>SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_6,1547718199000,15.402984393403084)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041723Z" creationid="xccui" creationdate="20190329T041723Z">
        <seg>SensorReading(sensor_6,1547718199000,15.402984393403084)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_7,1547718199000,6.720945201171228)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041731Z" creationid="xccui" creationdate="20190329T041731Z">
        <seg>SensorReading(sensor_7,1547718199000,6.720945201171228)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session &lt;t0/&gt;windows are useful in a common real-world scenario where neither&lt;t1/&gt; &lt;t2/&gt;tumbling nor sliding windows can be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024942Z" creationid="xccui" creationdate="20190407T024730Z">
        <seg>会话窗口在一类常见的真实场景下非常有用，该场景中既不适合用滚动窗口也不适合用滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013824Z" creationid="xccui" creationdate="20190606T013824Z">
        <seg>会话窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193607Z" creationid="xccui" creationdate="20190409T193607Z">
        <seg>会话窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows are useful in common real-world scenarios where neither tum‐ bling nor sliding windows can be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013529Z" creationid="xccui" creationdate="20190606T013410Z">
        <seg>会话窗口在一些既不适合用滚动窗口也不适合用滑动窗口的现实场景中非常有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows group events in session based on a &lt;t11/&gt;session gap&lt;t12/&gt; value that defines the time of inactivity to consider a session closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193417Z" creationid="xccui" creationdate="20190409T192834Z">
        <seg>会话窗口根据会话间隔（session gap）将事件分为不同的会话，该间隔值定义了会话在关闭前的非活动时间长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows group events in sessions based on a session gap value that defines the time of inactivity to consider a session closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013807Z" creationid="xccui" creationdate="20190606T013807Z">
        <seg>会话窗口根据会话间隔（session gap）将事件分为不同的会话，该间隔值定义了会话在关闭前的非活动时间长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sessions are com‐ prised of a series of events happening in adjacent times followed by a period of inactivity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013650Z" creationid="xccui" creationdate="20190606T013650Z">
        <seg>会话由发生在相邻时间内的一系列事件外加一段非活动时间组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sessions com&lt;t7/&gt;‐&lt;t8/&gt; prise of a series of events happening in adjacent times followed by a period of inactivity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025627Z" creationid="xccui" creationdate="20190407T025430Z">
        <seg>会话由发生在相邻时间内的一系列事件外加一段非活动时间组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set Up the Execution Environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044650Z" creationid="esouser" creationdate="20190603T145031Z">
        <seg>设置执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set up the Execution Environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022537Z" creationid="xccui" creationdate="20190225T022537Z">
        <seg>设置运行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set up the execution environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044657Z" creationid="xccui" creationdate="20190612T043506Z">
        <seg>设置执行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Flink Up for Streaming Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025346Z" creationid="xccui" creationdate="20190225T025346Z">
        <seg>配置Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up Flink for Streaming Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152129Z" creationid="esouser" creationdate="20190603T152129Z">
        <seg>配置Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up a Development Environment for</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T042846Z" creationid="xccui" creationdate="20190606T042846Z">
        <seg>设置Apaceh Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up a Development Environment for Apache Flink | 71</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012812Z" creationid="xccui" creationdate="20190612T012812Z">
        <seg>设置Apache Flink开发环境 | 71</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up a Development Environment for Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144822Z" creationid="esouser" creationdate="20190603T144822Z">
        <seg>设置Apaceh Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the Parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145135Z" creationid="esouser" creationdate="20190603T145135Z">
        <seg>设置并发度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022755Z" creationid="xccui" creationdate="20190225T022755Z">
        <seg>设置并发度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting up a development environment for Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022243Z" creationid="xccui" creationdate="20190225T022243Z">
        <seg>设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shows text that should be replaced with user-supplied values or by values deter‐ mined by context.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210808Z" creationid="esouser" creationdate="20190603T210808Z">
        <seg>Shows text that should be replaced with user-supplied values or by values deter‐ mined by context.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to watermarks, checkpoint barriers are broadcasted to all connected parallel tasks to ensure that each task receives a barrier from each of its input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T160224Z" creationid="xccui" creationdate="20190609T160142Z">
        <seg>和水位线类似，检查点分隔符总是以广播形式发送，从而可以确保每个任务能从它们的每个输入都收到一个分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to watermarks, checkpoint barriers are injected by source operators into the regular stream of records and cannot overtake or be passed by other records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060724Z" creationid="xccui" creationdate="20190609T060328Z">
        <seg>和水位线类似，这些检查点分隔符会通过数据源算子注入到普通的记录流中，它们在流中的位置无法提前或延后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, consider an operator that raises an alert when it detects a “high temperature” event followed by a “smoke” event within 10 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T052817Z" creationid="xccui" creationdate="20190414T052537Z">
        <seg>类似地，假设有一个算子，每次检测到"高温"事件且在随后10分钟内有"烟雾"事件都会报警。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if a system’s capacity is small, events will be buffered and have to wait before they get processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T203907Z" creationid="xccui" creationdate="20190402T203453Z">
        <seg>同样，如果系统性能不足，事件很容易堆积缓冲，必须等待一段时间才能处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple value conversions, splitting of records, or filtering of records are examples of common basic functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T025233Z" creationid="xccui" creationdate="20190613T025145Z">
        <seg>常见的基本函数示例有：简单的值转换，记录拆分或过滤等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is a distributed system, the JobManager and TaskManagers typically run as separate JVM processes on different machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T051402Z" creationid="xccui" creationdate="20190611T051402Z">
        <seg>由于Flink是一个分布式系统，JobManager和TaskManager通常会在不同机器上作为独立的JVM进程运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is a distributed system, the local state needs to be protected against failures to avoid data loss in case of application or machine failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210018Z" creationid="esouser" creationdate="20190603T210018Z">
        <seg>而由于是分布式的，Flink需要保护本地状态，以防因应用或机器故障导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is a distributed system, the local state needs to be protected against failures to avoid data loss in case of application or machine failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T032404Z" creationid="xccui" creationdate="20190305T032238Z">
        <seg>而由于是分布式的，Flink需要保护本地状态，以防因应用或机器故障导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is implemented in Java and Scala, all components run on Java Virtual Machines (JVMs).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141455Z" creationid="xccui" creationdate="20190606T141316Z">
        <seg>由于Flink本身是用Java和Scala实现的，因此所有组件都基于Java虚拟机（JVM）运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is implemented in Java and Scala, all components run on a Java Virtual Machine (JVM).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033634Z" creationid="xccui" creationdate="20190418T033634Z">
        <seg>由于Flink本身是用Java和Scala实现的，因此所有组件都运行在Java虚拟机（JVM）之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since its beginning, Flink has a very active and continuously growing community of users and contributors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T220449Z" creationid="xccui" creationdate="20190225T220008Z">
        <seg>Flink自创建伊始就拥有一个活跃、不断发展的用户及贡献者群体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since its beginning, Flink has had a very active and continuously grow‐ ing community of users and contributors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162841Z" creationid="esouser" creationdate="20190603T162841Z">
        <seg>Flink自创建伊始就拥有一个活跃、不断发展的用户及贡献者群体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since multiple applications might work on the same data representation or share the same infrastructure, changing the schema of a table or scaling a database system requires careful planning and a lot of effort.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200046Z" creationid="esouser" creationdate="20190603T200017Z">
        <seg>一旦多个应用基于相同的数据表示或共享架构，那么更改表模式或对数据库系统扩容必将劳心费力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since savepoints are such a powerful feature, many users periodically create save‐ points to be able to go back in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213645Z" creationid="xccui" creationdate="20190609T213645Z">
        <seg>保存点的功能如此强大，很多用户都会周期性地创建保存点，以便能即时"回到过去"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since state can become quite large and checkpointing requires writing the data over the network to a remote storage system, taking a checkpoint can easily take several seconds to minutes—much too long for latency-sensitive applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202510Z" creationid="xccui" creationdate="20190609T200126Z">
        <seg>由于状态可能会很大，而且生成检查点需要把这些数据通过网络写入远程存储系统，该过程可能持续数秒，甚至数分钟，这对于一些延迟敏感的应用而言时间过久。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming appli&lt;t2/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150756Z" creationid="xccui" creationdate="20190401T150551Z">
        <seg>但由于流式应用会一直执行且输入可能是无限的，因此在数据流处理中没有总执行时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming applications are often required to run 24/7 with minimum downtime, many stream processors added features such as highly-available setups, tight integration with resource managers, such as YARN or Mesos, and the ability to dynamically scale streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T140537Z" creationid="xccui" creationdate="20190327T140011Z">
        <seg>由于流式应用经常需要近7*24小时不间断运行，很多流处理引擎会添加像高可用设置、与资源管理器（YARN、Mesos等）紧密集成、动态扩展流式应用等特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming appli‐ cations run continuously and the input is potentially unbounded, there is no notion of total execution time in data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233740Z" creationid="xccui" creationdate="20190605T233740Z">
        <seg>但由于流式应用会一直执行且输入可能是无限的，因此在数据流处理中没有总执行时间的说法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming operators process potentially unbounded data, caution should be taken to not allow internal state to grow indefinitely.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T054811Z" creationid="xccui" creationdate="20190414T054737Z">
        <seg>由于流式算子处理的都是潜在无限的数据，因此必须小心避免内部状态无限增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since tasks maintain their state locally, Flink has to ensure that this state is not lost and remains consistent in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T152710Z" creationid="xccui" creationdate="20190608T152636Z">
        <seg>由于每个任务会把状态维护在本地，Flink要保证发生故障时状态不丢不错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the length of a session is not defined beforehand but depends on the actual data, tumbling and sliding win&lt;t9/&gt;‐&lt;t10/&gt; dows cannot be applied in this scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T192212Z" creationid="xccui" creationdate="20190407T030004Z">
        <seg>由于会话长度并非预先定义好，而是和实际数据有关，因此无论是滚动还是滑动窗口都无法用于该场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the length of a session is not defined beforehand but depends on the actual data, tumbling and sliding win‐ dows cannot be applied in this scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013707Z" creationid="xccui" creationdate="20190606T013707Z">
        <seg>由于会话长度并非预先定义好，而是和实际数据有关，因此无论是滚动还是滑动窗口都无法用于该场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the maximum operator parallelism is four, the application requires at least four available processing slots to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043551Z" creationid="xccui" creationdate="20190423T043528Z">
        <seg>由于算子最大并行度是4，因此应用若要执行则至少需要4个处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the pur‐ pose of checkpoints is to ensure an application can be restarted in case of a failure, they are deleted when an application is explicitly canceled.4 However, consistent snap‐ shots of the state of an application can be used for many more things than just failure recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210342Z" creationid="xccui" creationdate="20190609T205625Z">
        <seg>检查点的目的是保证应用可以在出现故障的时候顺利重启，因此当应用被显式取消后，检查点也会随之删除4。但应用状态的一致性快照除了故障恢复外，还有很多其他用途。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since this state is never cleaned up, you should only apply a rolling aggregations operator on a stream with a bounded key domain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061231Z" creationid="xccui" creationdate="20190614T061231Z">
        <seg>由于这些状态不会被自动清理，所以只能在键值域有限的流上使用滚动聚合算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you are running a streaming application, it will continue to run until you cancel it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045509Z" creationid="xccui" creationdate="20190329T045426Z">
        <seg>由于运行的是流式应用，因此它会一直运行下去，直到你手动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you are running a streaming application, the application will continue to run until you cancel it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124357Z" creationid="xccui" creationdate="20190605T124127Z">
        <seg>由于应用是流式的，它会一直运行下去，直到你手动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you do not take into consideration late events and out-of-order events, a window simply needs to buffer up events and immediately trigger computation once the specified time length is reached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T030906Z" creationid="xccui" creationdate="20190414T041209Z">
        <seg>由于无需考虑延迟或乱序事件，窗口只需简单地缓冲事件，然后在达到特定时间后立即触发窗口计算即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since, multiple applications might work on the same data representation or share the same infrastructure, changing the schema of a table or scaling a database system requires careful planning and a lot of effort.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T185223Z" creationid="xccui" creationdate="20190226T164028Z">
        <seg>一旦多个应用基于相同的数据表示或共享架构，那么更改表模式或对数据库系统扩容必将费心费力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sinks acknowledge the reception of a checkpoint barrier to the JobManager and a checkpoint is complete when all tasks have acknowledged the successful check‐ pointing of their state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195511Z" creationid="xccui" creationdate="20190609T194625Z">
        <seg>数据汇任务向JobManager确认收到检查点分隔符，在所有任务成功将自身状态存入检查点后整个应用的检查点才算完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding &lt;t0/&gt;windows assign events into overlapping buckets of fixed size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024655Z" creationid="xccui" creationdate="20190407T023648Z">
        <seg>滑动窗口（sliding window）将事件分配到大小固定且相互重叠的桶中，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding count-based window with a length of 4 events and a slide of 3 events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024429Z" creationid="xccui" creationdate="20190407T024415Z">
        <seg>长度为4个事件滑动间隔为3个事件的基于数量的滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding count-based window with a length of four events and a slide of three events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013350Z" creationid="xccui" creationdate="20190606T013314Z">
        <seg>长度为4个事件滑动间隔为3个事件的基于数量的滑动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding windows assign events into overlapping buckets of fixed size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013132Z" creationid="xccui" creationdate="20190606T013132Z">
        <seg>滑动窗口（sliding window）将事件分配到大小固定且相互重叠的桶中，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far we have explained what timestamps and watermarks are and how they are internally handled by Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034622Z" creationid="xccui" creationdate="20190607T033537Z">
        <seg>至今为止，我们已经解释了时间戳和水位线的含义以及它们在Flink内部的处理逻辑，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, you have seen how stream processing addresses limitations of traditional batch processing and how it enables new applications and architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T052148Z" creationid="xccui" creationdate="20190329T050348Z">
        <seg>至此，你已经了解过流式应用如何突破传统批处理的局限以及它如何支持新的应用和架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, you have seen how stream processing addresses some of the limitations of tra‐ ditional batch processing and how it enables new applications and architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224637Z" creationid="xccui" creationdate="20190605T224637Z">
        <seg>至此，你已经看到流式应用如何突破传统批处理的局限以及它如何支持新的应用和架构，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, can you get both low latency and high throughput or is this a hopeless endeavor?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235232Z" creationid="xccui" creationdate="20190605T235232Z">
        <seg>既然这样，可以通过某种方式同时获得低延迟和高吞吐吗？还是说根本不切实际？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the first research proto‐ types and commercial products date back to the late 1990s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045924Z" creationid="xccui" creationdate="20190605T045832Z">
        <seg>一些最初的研究原型和商业产品可以追溯到上世纪90年代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some transformations can produce a new DataStream, pos‐ sibly of a different type, while other transformations do not modify the records of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052746Z" creationid="xccui" creationdate="20190612T052453Z">
        <seg>有些会生成一个新的DataStream（类型可能不同）；而另外的一些不会修改DataStream中的记录，仅会通过分区或分组的方式将其重新组织。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Source Functions, Timestamps, and Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152108Z" creationid="xccui" creationdate="20190225T025249Z">
        <seg>源函数、时间戳及水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Source functions are discussed in more detail in “Implementing a Custom Source Function” on page 202.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034915Z" creationid="xccui" creationdate="20190607T034915Z">
        <seg>我们会在第202页"实现自定义源函数"一节详细讨论源函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sources checkpoint their state and emit a checkpoint barrier</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155352Z" creationid="xccui" creationdate="20190609T155352Z">
        <seg>数据源为状态生成检查点并发出检查点分隔符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special thanks go to our fellow Flink committers: Alan Gates, Aljoscha Krettek, Andra Lungu, ChengXiang Li, Chesnay Schepler, Chiwan Park, Daniel Warneke, Dawid Wysakowicz, Gary Yao, Greg Hogan, Gyula Fóra, Henry Saputra, Jamie Grier, Jark Wu, Jincheng Sun, Konstantinos Kloudas, Kostas Tzoumas, Kurt Young, Márton Balassi, Matthias J. Sax, Maximilian Michels, Nico Kruber, Paris Carbone, Robert</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T044619Z" creationid="xccui" creationdate="20190605T132711Z">
        <seg>特别感谢Flink社区的committer们：Alan Gates、Aljoscha Krettek、Andra Lungu、ChengXiang Li（李呈祥）、Chesnay Schepler、Chiwan Park、 Daniel Warneke、Dawid Wysakowicz、Gary Yao、Greg Hogan、Gyula Fóra、Henry Saputra、Jamie Grier、Jark Wu（伍翀）、Jincheng Sun（孙金城）、 Konstantinos Kloudas、Kostas Tzoumas、Kurt Young（杨克特）、Márton Balassi、Matthias J. Sax、Maximilian Michels、Nico Kruber、Paris Carbone、Robert</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying Unique Operator Identifiers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024703Z" creationid="xccui" creationdate="20190225T024703Z">
        <seg>指定算子唯一标识</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stand-Alone Cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025413Z" creationid="xccui" creationdate="20190225T025413Z">
        <seg>独立集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standalone Cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152136Z" creationid="esouser" creationdate="20190603T152136Z">
        <seg>独立集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Start a local Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025029Z" creationid="xccui" creationdate="20190329T025015Z">
        <seg>启动本地Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Start a local Flink cluster:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123053Z" creationid="xccui" creationdate="20190605T123051Z">
        <seg>启动本地Flink集群：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting an application from a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213449Z" creationid="xccui" creationdate="20190609T213449Z">
        <seg>从保存点启动应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting an application from a savepoint allows you to do much more.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211859Z" creationid="xccui" creationdate="20190609T211810Z">
        <seg>而将应用从某个保存点启动还能让你做更多事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025408Z" creationid="xccui" creationdate="20190329T025102Z">
        <seg>Starting cluster.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting execution of program</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040009Z" creationid="xccui" creationdate="20190329T040009Z">
        <seg>Starting execution of program</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting standalonesession daemon on host xxx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025401Z" creationid="xccui" creationdate="20190329T025401Z">
        <seg>Starting standalonesession daemon on host xxx.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting taskexecutor daemon on host xxx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025415Z" creationid="xccui" creationdate="20190329T025415Z">
        <seg>Starting taskexecutor daemon on host xxx.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State Backends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022056Z" creationid="xccui" creationdate="20190225T022056Z">
        <seg>状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State Management</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022008Z" creationid="xccui" creationdate="20190225T022008Z">
        <seg>状态管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State Management | 53</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032642Z" creationid="xccui" creationdate="20190610T032642Z">
        <seg>状态管理 | 53</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State and Consistency Models</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144240Z" creationid="esouser" creationdate="20190603T144240Z">
        <seg>状态和一致性模型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State and Consistency Models | 33</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041500Z" creationid="xccui" creationdate="20190606T041500Z">
        <seg>状态和一致性模型 | 33</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State and consistency models</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020429Z" creationid="xccui" creationdate="20190225T020429Z">
        <seg>状态和一致性模型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State backends differ in how state is checkpointed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155129Z" creationid="xccui" creationdate="20190608T053842Z">
        <seg>不同的状态后端生成状态检查点的方式也有所差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State checkpointing is important because Flink is a distributed system and state is only locally maintained.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162333Z" creationid="xccui" creationdate="20190608T053330Z">
        <seg>因为Flink是一个分布式系统但只在本地维护状态，因此状态检查点就显得极其重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State is ubiquitous in data processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050647Z" creationid="xccui" creationdate="20190414T050539Z">
        <seg>状态在数据处理中无处不在，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State management</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032900Z" creationid="xccui" creationdate="20190606T032900Z">
        <seg>状态管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State management&lt;t0/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055905Z" creationid="xccui" creationdate="20190414T055905Z">
        <seg>状态管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State partitioning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032915Z" creationid="xccui" creationdate="20190606T032915Z">
        <seg>状态划分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State partitioning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T033332Z" creationid="xccui" creationdate="20190415T033332Z">
        <seg>状态划分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State primitives expose the structure of the state to Flink and enable more efficient state accesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T223623Z" creationid="xccui" creationdate="20190607T222211Z">
        <seg>通过这些状态原语可以为Flink状态指定不同的结构，从而实现更加高效的状态访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032954Z" creationid="xccui" creationdate="20190606T032954Z">
        <seg>状态恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T034727Z" creationid="xccui" creationdate="20190415T034727Z">
        <seg>状态恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State, state consistency, and Flink’s checkpointing mechanism will be discussed in more detail in the following chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T033014Z" creationid="xccui" creationdate="20190305T033014Z">
        <seg>我们会在接下来的章节详细讨论状态、状态一致性以及Flink的checkpointing机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State, state consistency, and Flink’s checkpointing mech‐ anism will be discussed in more detail in the following chapters, but, for now, Figure 1-4 shows a stateful streaming Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155028Z" creationid="esouser" creationdate="20190603T210107Z">
        <seg>图1-4简单展示了Flink的状态化流式应用，而有关状态、状态一致性以及Flink的检查点机制会在接下来的章节详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Operators and Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023527Z" creationid="xccui" creationdate="20190225T023519Z">
        <seg>状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014544Z" creationid="xccui" creationdate="20190225T014544Z">
        <seg>状态化流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Stream Processing | 5</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130813Z" creationid="xccui" creationdate="20190605T130813Z">
        <seg>状态化流处理 | 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful operators use both incom&lt;t2/&gt;‐&lt;t3/&gt; ing events and internal state to compute their output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T051928Z" creationid="xccui" creationdate="20190414T051928Z">
        <seg>状态化算子同时利用到来的事件和内部状态来计算输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful operators use both incoming events and internal state to compute their output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031507Z" creationid="xccui" creationdate="20190606T031507Z">
        <seg>状态化算子同时利用到来的事件和内部状态来计算输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing applications are more challenging to parallelize and oper&lt;t4/&gt;‐&lt;t5/&gt; ate in a fault tolerant manner because state needs to be efficiently partitioned and reli&lt;t6/&gt;‐&lt;t7/&gt; ably recovered in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151433Z" creationid="xccui" creationdate="20190405T040600Z">
        <seg>状态化流处理应用在并行化和容错方面会麻烦很多，因为需要对状态进行高效划分并且在出错时需进行可靠的故障恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing applications are more challenging to parallelize and oper‐ ate in a fault-tolerant manner because state needs to be efficiently partitioned and reliably recovered in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T005138Z" creationid="xccui" creationdate="20190606T005043Z">
        <seg>状态化流处理应用在并行化和容错方面会更具挑战性，因为需要对状态进行高效划分并且在出错时需进行可靠的故障恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing applications often ingest their incoming events from an event log.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T034141Z" creationid="xccui" creationdate="20190305T034141Z">
        <seg>状态化流处理应用通常会从事件日志中读取事件记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing is an application design pattern for processing unbounded streams of events and is applicable to many different use cases in the IT infrastructure of a com&lt;t0/&gt;‐&lt;t1/&gt; pany.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T034013Z" creationid="xccui" creationdate="20190301T202026Z">
        <seg>作为一类面向无限事件流的应用设计模式，状态化流处理可用于公司IT基础设施中的很多用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing is an application design pattern for processing unbounded streams of events and is applicable to many different use cases in the IT infrastructure of a company.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T204846Z" creationid="esouser" creationdate="20190603T204846Z">
        <seg>作为一类面向无限事件流的应用设计模式，状态化流处理可用于公司IT基础设施中的很多用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful transformations that are applied on a KeyedStream read from and write to state in the context of the currently processed event’s key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044300Z" creationid="xccui" creationdate="20190614T044151Z">
        <seg>作用于KeyedStream的状态化转换可以对当前处理事件键值所对应上下文中的状态进行读写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateless operations are easy to parallelize, since events can be processed independently of each other and of their arriving order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T035959Z" creationid="xccui" creationdate="20190405T035840Z">
        <seg>由于事件处理互不影响且与它们的到来时间无关，无状态的操作很容易并行化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateless operations do not maintain any internal state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T035709Z" creationid="xccui" creationdate="20190405T035709Z">
        <seg>无状态的操作不会维持内部状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stores a key-value map per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T221802Z" creationid="xccui" creationdate="20190607T220156Z">
        <seg>每个键对应存储一个键值映射，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stores a list of values per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T220018Z" creationid="xccui" creationdate="20190607T215922Z">
        <seg>每个键对应存储一个值的列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stores a single value of arbitrary type per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T215753Z" creationid="xccui" creationdate="20190607T215707Z">
        <seg>每个键对应存储一个任意类型的值，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream API program essentially boils down to combining such transformations to create a dataflow graph that implements the application logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T013754Z" creationid="xccui" creationdate="20190613T013744Z">
        <seg>完成一个DataStream API程序在本质上可以归结为：通过组合不同的转换来创建一个满足应用逻辑的dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T050207Z" creationid="xccui" creationdate="20190329T050207Z">
        <seg>流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing Fundamentals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014755Z" creationid="xccui" creationdate="20190225T014755Z">
        <seg>流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing with Apache</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T163334Z" creationid="esouser" creationdate="20190603T142341Z">
        <seg>基于Apache Flink的流式处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing with Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210705Z" creationid="esouser" creationdate="20190603T210656Z">
        <seg>Stream Processing with Apache Flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing with Apache Flink, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210737Z" creationid="esouser" creationdate="20190603T210737Z">
        <seg>Stream Processing with Apache Flink, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing engines usually provide a set of built-in operations to ingest, trans&lt;t0/&gt;‐&lt;t1/&gt; form, and output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T212650Z" creationid="xccui" creationdate="20190402T212535Z">
        <seg>流处理引擎通常会提供一系列内置操作来实现数据流的获取、转换以及输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing engines usually provide a set of built-in operations to ingest, trans‐ form, and output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235741Z" creationid="xccui" creationdate="20190605T235741Z">
        <seg>流处理引擎通常会提供一系列内置操作来实现数据流的获取、转换以及输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing technology is becoming more and more popular with companies big and small because it provides superior solutions for many established use cases such as data analytics, ETL, and transactional applications, but also facilitates novel applications, software architectures, and business opportunities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T045628Z" creationid="esouser" creationdate="20190603T162936Z">
        <seg>流处理技术正受到越来越多大小公司的青睐，这是因为它不仅可以为很多现有场景提供更优的解决方案，而且可催生很多新颖的应用、软件架构以及商业机会。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing technology is being rapidly adopted by companies and enterprises of any size because it provides superior solutions for many established use cases but also facilitates novel applications, software architectures, and business opportunities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T222030Z" creationid="xccui" creationdate="20190225T221738Z">
        <seg>而流处理技术本身也迅速在各种规模的公司和企业中普及，这是因为它不仅可以为现有用例提供更优的解决方案，更可催生很多新颖的应用、软件架构以及商业机会。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processors like Flink also support event-time pro‐ cessing to produce correct and deterministic results and the ability to process large amounts of data in little time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045357Z" creationid="xccui" creationdate="20190605T045138Z">
        <seg>诸如Flink之类的流处理引擎还需要支持事件时间处理从而可以生成精准、确定的结果，具备在短时间内处理大量数据的能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processors of this generation made the lambda archi&lt;t2/&gt;‐&lt;t3/&gt; tecture obsolete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T135152Z" creationid="xccui" creationdate="20190327T135031Z">
        <seg>这使得Lambda架构彻底沦为历史。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processors of this generation made the lambda architecture obsolete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053621Z" creationid="xccui" creationdate="20190605T053616Z">
        <seg>这使得Lambda架构彻底沦为历史。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream&lt;t2/&gt;‐&lt;t3/&gt; ing jobs run for long periods of time, thus state might be collected over several days or even months.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T040818Z" creationid="xccui" creationdate="20190415T040248Z">
        <seg>流式作业会运行较长时间，因此状态可能是数天甚至数月才收集而来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming Analytics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014658Z" creationid="xccui" creationdate="20190225T014658Z">
        <seg>流式分析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming analytics applications are commonly used for:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045410Z" creationid="xccui" creationdate="20190605T045410Z">
        <seg>流式分析应用常用于：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming application with two stateful sources, two stateful tasks, and two stateless sinks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062410Z" creationid="xccui" creationdate="20190609T062410Z">
        <seg>拥有两个状态化数据源、两个状态化任务以及两个无状态数据汇的流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications are typically designed to run 24/7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T204049Z" creationid="xccui" creationdate="20190424T064357Z">
        <seg>由于流式应用通常都会设计成7*24小时运行，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications need to exchange data in a pipelined fashion, i.e., each pair of TaskManagers maintains a permanent TCP connection to exchange data&lt;t2/&gt;3&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042859Z" creationid="xccui" creationdate="20190504T042843Z">
        <seg>流式应用需要以流水线方式交换数据，即每对TaskManager之间都维护一个永久的TCP连接来交换数据3。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications need to exchange data in a pipelined fashion—each pair of TaskManag‐ ers maintains a permanent TCP connection to exchange data.2 With a shuffle connec‐ tion pattern, each sender task needs to be able to send data to each receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T200054Z" creationid="xccui" creationdate="20190606T195847Z">
        <seg>流式应用需要以流水线方式交换数据，每对TaskManager之间都维护一个永久的TCP连接来执行数据交换2。在shuffle连接模式下，每个发送端的任务都需要向每个接受任务发送数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications usually emit their results to some external system, such as Apache Kafka, a filesystem, or a database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054057Z" creationid="xccui" creationdate="20190612T054057Z">
        <seg>流式应用通常都会把结果发送到某些外部系统，例如Apache Kafka，文件系统或数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming systems define their behavior in the pres&lt;t0/&gt;‐&lt;t1/&gt; ence of failures by offering result guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044432Z" creationid="xccui" creationdate="20190415T044326Z">
        <seg>流处理系统通过不同的结果保障来定义故障时的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming systems define their behavior in the presence of failures by offering result guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034128Z" creationid="xccui" creationdate="20190606T034128Z">
        <seg>流处理系统通过不同的结果保障来定义故障时的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream‐ ing jobs run for long periods of time, and thus state might be collected over several days or even months.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033133Z" creationid="xccui" creationdate="20190606T033124Z">
        <seg>流式作业会运行较长时间，因此状态可能是数天甚至数月才收集得到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sub&lt;t0/&gt;‐&lt;t1/&gt; sets of an organization’s data are stored in multiple of these systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T040827Z" creationid="xccui" creationdate="20190314T065729Z">
        <seg>一些机构的数据可能会同时存储在多个系统里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently, the task updates its event-time clock to be the minimum of all partition watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T024721Z" creationid="xccui" creationdate="20190607T024706Z">
        <seg>随后，任务会把事件时间时钟调整为所有分区水位线中最小的那个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055728Z" creationid="xccui" creationdate="20190414T055139Z">
        <seg>摘要可能是一个计数值，一个累加和，至今所见事件的抽样，一个窗口缓冲，或是只保留了那些运行应用感兴趣属性的某种自定义数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a summary can be a count, a sum, a sample of the events seen so far, a window buffer, or a custom data structure that preserves some property of interest to the running application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032837Z" creationid="xccui" creationdate="20190606T032633Z">
        <seg>摘要可能是一个数量值，一个累加值，一个到至今为止全部事件的抽样，一个窗口缓冲或者是一个保留了运行应用某些有价值属性的自定义数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such records are called late records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035418Z" creationid="xccui" creationdate="20190529T035345Z">
        <seg>我们称此类记录为迟到记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021634Z" creationid="xccui" creationdate="20190225T021634Z">
        <seg>总结</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary | 15</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130843Z" creationid="xccui" creationdate="20190605T130843Z">
        <seg>总结 | 15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary | 69</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032814Z" creationid="xccui" creationdate="20190610T032814Z">
        <seg>总结 | 69</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary | 77</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012750Z" creationid="xccui" creationdate="20190612T012750Z">
        <seg>总结 | 77</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supplemental material (code examples in Java and Scala) is available for download at</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210813Z" creationid="esouser" creationdate="20190603T210813Z">
        <seg>Supplemental material (code examples in Java and Scala) is available for download at</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supported Data Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022807Z" creationid="xccui" creationdate="20190225T022807Z">
        <seg>支持的数据类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021655Z" creationid="xccui" creationdate="20190225T021655Z">
        <seg>系统架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Architecture | 39</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032542Z" creationid="xccui" creationdate="20190610T032542Z">
        <seg>系统架构 | 39</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Configuration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025523Z" creationid="xccui" creationdate="20190225T025523Z">
        <seg>系统配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table API and SQL for Relational Analysis</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152519Z" creationid="esouser" creationdate="20190603T152515Z">
        <seg>用于关系型分析的Table API及SQL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table of Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T013833Z" creationid="xccui" creationdate="20190225T013833Z">
        <seg>目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take a checkpoint by copying the state of each task to a remote, persistent stor‐ age.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224051Z" creationid="xccui" creationdate="20190608T224031Z">
        <seg>将所有任务的状态拷贝到远程持久化存储，生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take for example a rolling aggregation operator that outputs the current sum of all the events it has seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T052032Z" creationid="xccui" creationdate="20190414T052003Z">
        <seg>以某个滚动聚合算子为例，它会输出至今所有看到的事件之和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take, for example, a rolling aggregation operator that outputs the current sum of all the events it has seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031517Z" creationid="xccui" creationdate="20190606T031517Z">
        <seg>以某个滚动聚合算子为例，它会输出至今所有看到的事件之和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taking a savepoint from an application and restoring an application from a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215136Z" creationid="xccui" creationdate="20190609T215136Z">
        <seg>为应用生成保存点和从保存点恢复应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task Chaining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021822Z" creationid="xccui" creationdate="20190225T021822Z">
        <seg>任务链接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task Execution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021752Z" creationid="xccui" creationdate="20190225T021752Z">
        <seg>任务执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task Failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144251Z" creationid="esouser" creationdate="20190603T144251Z">
        <seg>任务故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task chaining can significantly reduce the communication costs between local tasks, but there are also cases when it makes sense to execute a pipeline without chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203900Z" creationid="xccui" creationdate="20190606T203900Z">
        <seg>虽然任务链接可以有效地降低本地任务之间的通信开销，但并不意味着所有的流水线执行都要启用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task chaining can significantly reduce the communication costs between local tasks, however there are also cases when it makes sense to execute a pipeline without chain&lt;t0/&gt;‐&lt;t1/&gt; ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T154339Z" creationid="esouser" creationdate="20190514T154032Z">
        <seg>虽然任务链接可以有效地降低本地任务之间的通信开销，但并不意味着所有的流水线执行都要启用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task chaining is enabled by default in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155143Z" creationid="esouser" creationdate="20190514T155137Z">
        <seg>Flink在默认情况下会开启任务链接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T204829Z" creationid="xccui" creationdate="20190225T020501Z">
        <seg>任务故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManager failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205310Z" creationid="xccui" creationdate="20190428T205310Z">
        <seg>TaskManager故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManagers &lt;t0/&gt;are the worker processes of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T051341Z" creationid="xccui" creationdate="20190418T051341Z">
        <seg>TaskManager是Flink的工作进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManagers are the worker processes of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142307Z" creationid="xccui" creationdate="20190606T142307Z">
        <seg>TaskManager是Flink的工作进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks can register timers at the timer service to perform a computa&lt;t2/&gt;‐&lt;t3/&gt; tion at a specific point in time in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041504Z" creationid="xccui" creationdate="20190529T041236Z">
        <seg>这些定时器可由任务在时间服务内注册，并在将来的某个时间点执行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks can register timers at the timer service to perform a computa‐ tion at a specific point in time in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T210249Z" creationid="xccui" creationdate="20190606T210249Z">
        <seg>这些定时器可由任务在时间服务内注册，并在将来的某个时间点执行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks checkpoint their state once all barriers have been received, then they forward the checkpoint barrier</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T192452Z" creationid="xccui" creationdate="20190609T191948Z">
        <seg>任务在收到全部分隔符后将状态存入检查点，然后向下游转发检查点分隔符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks continue regular processing after the checkpoint barrier is forwarded</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193707Z" creationid="xccui" creationdate="20190609T193606Z">
        <seg>任务在转发检查点分隔符后继续进行常规处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks have an internal time service that maintains timers and is activated when a water&lt;t0/&gt;‐&lt;t1/&gt; mark is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041324Z" creationid="xccui" creationdate="20190529T040840Z">
        <seg>任务的内部时间服务（time service）会维护定时器（timer），并在接收到水位线时激活。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks have an internal time service that maintains timers and is activated when a water‐ mark is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T210238Z" creationid="xccui" creationdate="20190606T210238Z">
        <seg>任务的内部时间服务（time service）会维护定时器（timer），并在接收到水位线时激活。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks of time-based opera&lt;t2/&gt;‐&lt;t3/&gt; tors collect and process records with possibly unordered timestamps and finalize a computation when their event-time clock, which is advanced by received watermarks, indicates that no more records with relevant timestamps have to be expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035025Z" creationid="xccui" creationdate="20190529T034137Z">
        <seg>对基于时间算子的任务而言，其收集和处理的记录可能会包含乱序的时间戳。只有当它们的事件时间时钟（由接收的水位线驱动）指示不必再等那些包含相关时间戳的记录时，才会最终触发计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks of time-based opera‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205539Z" creationid="xccui" creationdate="20190606T205539Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks wait to receive a barrier on each input partition; records from input streams for which a barrier already arrived are buffered; all other records are regularly processed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193637Z" creationid="xccui" creationdate="20190609T175039Z">
        <seg>任务等待接收所有输入分区的分隔符，来自已接收分隔符输入分区的记录会被缓存，其他记录则按常规处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks with keyed state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191928Z" creationid="xccui" creationdate="20190607T191928Z">
        <seg>带有键值状态的任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks with operator state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061908Z" creationid="xccui" creationdate="20190607T061908Z">
        <seg>带有算子状态的任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thank you, Adam Kawa, Aljoscha Krettek, Kenneth Knowles, Lea Giordano, Matthias J. Sax, Stephan Ewen, Ted Malaska, and Tyler Akidau.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T161943Z" creationid="xccui" creationdate="20190608T161943Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thank you, Alicia Young, Colleen Lobner, Christine Edwards, Katherine Tozer, Marie Beaugureau, and Tim McGovern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T162030Z" creationid="xccui" creationdate="20190605T134127Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is because the number of tasks might change when an application is started with different parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215733Z" creationid="xccui" creationdate="20190609T215724Z">
        <seg>这是因为任务数目可能会随着应用启动时所指定的并发数而改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, after recovery, it should know whether an event update has already been reflected on the state or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045657Z" creationid="xccui" creationdate="20190416T044436Z">
        <seg>即在故障恢复后，引擎需要知道某个事件对应的更新是否已经反映到状态上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, how long do we have to wait before we can be certain that we have received all events that happened before a certain point of time?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T161705Z" creationid="xccui" creationdate="20190412T161649Z">
        <seg>即我们需要等多久才能确定已经收到了所有发生在某个特定时间点之前的事件？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the API calls that create stream sources and transformations do not immediately trigger any data processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011133Z" creationid="xccui" creationdate="20190613T011133Z">
        <seg>也就是说，那些创建数据源和转换操作的API调用不会立即触发任何数据处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the processing of an event does not depend on any events seen in the past and no history is kept.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T035827Z" creationid="xccui" creationdate="20190405T035802Z">
        <seg>即处理每一个事件都无需依赖先前看到的事件，不保存历史数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, throughput tells us how many events the system can process per time unit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195507Z" creationid="xccui" creationdate="20190401T195445Z">
        <seg>它告诉我们系统每单位时间可以处理多少事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, we are concerned with what the application code sees as state value after recovering from a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T045230Z" creationid="xccui" creationdate="20190415T045129Z">
        <seg>换言之，我们关注故障恢复后应用代码能够看到的状态值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you are primarily concerned with determining the &lt;t0/&gt;peak&lt;t1/&gt; throughput, i.e. the perfor&lt;t2/&gt;‐&lt;t3/&gt; mance limit when your system is at its maximum load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T205829Z" creationid="xccui" creationdate="20190401T203852Z">
        <seg>换言之，首要关注点是确定峰值吞吐，即系统满负载时的性能上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you are primarily concerned with determining the peak throughput—the perfor‐ mance limit when your system is at its maximum load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234550Z" creationid="xccui" creationdate="20190605T234550Z">
        <seg>换言之，首要关注点是确定峰值吞吐，即系统满负载时的性能上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you can re-play a stream and analyze historic data as if events are happening in real-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T154822Z" creationid="xccui" creationdate="20190412T154656Z">
        <seg>这意味着你可以通过重放数据流来分析历史数据，就如同它们是实时产生的一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you can replay a stream and analyze historic data as if events are happening in real time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025105Z" creationid="xccui" creationdate="20190606T025105Z">
        <seg>这意味着你可以通过重放数据流来分析历史数据，就如同它们是实时产生的一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you will get the fastest service if you are the only customer in the coffee shop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210230Z" creationid="xccui" creationdate="20190402T204424Z">
        <seg>确切地说，如果咖啡店只有你一名顾客，你将得到最快的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That’s it!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041710Z" creationid="xccui" creationdate="20190611T041710Z">
        <seg>就这么简单！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That’s it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T022452Z" creationid="xccui" creationdate="20190328T061659Z">
        <seg>就这么简单，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203027Z" creationid="esouser" creationdate="20190603T203027Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;Dispatcher&lt;t1/&gt; runs across job executions and provides a REST interface to sub&lt;t2/&gt;‐&lt;t3/&gt; mit applications for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T053228Z" creationid="xccui" creationdate="20190418T052650Z">
        <seg>Dispatcher会跨多个作业运行，它提供了一个REST接口来提交要执行的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;JobManager&lt;t1/&gt; is the master process that controls the execution of a single application, i.e., each application is controlled by a different JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033838Z" creationid="xccui" creationdate="20190418T033838Z">
        <seg>JobManager作为主进程，控制着单个应用的执行。换句话说，每个应用都由一个不同的JobManager掌控。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;broadcast&lt;t1/&gt; strategy sends every data item to all parallel tasks of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135817Z" creationid="xccui" creationdate="20190401T134909Z">
        <seg> 广播策略（broadcast strategy）会把数据项发往下游算子的全部并发任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;forward&lt;t1/&gt; strategy sends data from a task to a receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135823Z" creationid="xccui" creationdate="20190401T134033Z">
        <seg>转发策略（forward strategy）在发送端任务和接收端任务之间进行一对一的数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;key-based&lt;t1/&gt; strategy partitions data by a key attribute and guarantees that data items having the same key will be processed by the same task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135841Z" creationid="xccui" creationdate="20190401T135059Z">
        <seg>基于键值的策略（key-based strategy）根据某一键值属性将数据分成多份并保证键值相同的数据项一定会交由同一个任务处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;random&lt;t1/&gt; strategy uniformly distributes data items to operator tasks in order to evenly distribute the load across computing tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T140101Z" creationid="xccui" creationdate="20190401T135738Z">
        <seg>随机策略（random strategy）为了实现计算任务的负载均衡，会将数据均匀分配至算子的所有任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Apache Software Foundation alone is the home of more than a dozen projects related to stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050546Z" creationid="xccui" creationdate="20190605T050546Z">
        <seg>仅Apache软件基金会一家就有十多个和流处理相关的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Apache Software Foundation alone is the home of more than a dozen projects that are related to stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T053503Z" creationid="xccui" creationdate="20190319T053503Z">
        <seg>仅Apache软件基金会一家就有十多个和流处理相关的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053550Z" creationid="xccui" creationdate="20190416T053550Z">
        <seg>Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Architecture of Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021648Z" creationid="xccui" creationdate="20190225T021648Z">
        <seg>Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CoProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023132Z" creationid="xccui" creationdate="20190225T023132Z">
        <seg>CoProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataSet API for Batch Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152457Z" creationid="esouser" creationdate="20190603T152457Z">
        <seg>用于批处理的DataSet API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014854Z" creationid="xccui" creationdate="20190612T014854Z">
        <seg>DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API (v1.7).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022444Z" creationid="xccui" creationdate="20190225T022435Z">
        <seg>DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API features the abstraction of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044525Z" creationid="xccui" creationdate="20190614T043951Z">
        <seg>作为一种特殊的DataStream，DataStream API中的KeyedStream抽象可以从逻辑上将事件按照键值分配到多条独立的子流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides the following rolling aggregation methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052557Z" creationid="xccui" creationdate="20190614T052557Z">
        <seg>DataStream API提供了以下滚动聚合方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides transformations for the most common data transfor‐ mation operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T023051Z" creationid="xccui" creationdate="20190613T023051Z">
        <seg>DataStream API为一些最常见的数据转换操作都提供了对应的转换抽象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Dispatcher runs across job executions and provides a REST interface to sub‐ mit applications for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142824Z" creationid="xccui" creationdate="20190606T142757Z">
        <seg>Dispatcher会跨多个作业运行，它提供了一个REST接口用以提交需要执行的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Evolution of Open Source Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014710Z" creationid="xccui" creationdate="20190225T014710Z">
        <seg>开源流处理的衍变</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Evolution of Open Source Stream Processing | 11</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130824Z" creationid="xccui" creationdate="20190605T130824Z">
        <seg>开源流处理的衍变 | 11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The FilterFunction interface is typed to the type of the input stream and defines the filter() method that is called with an input event and returns a boolean:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052914Z" creationid="xccui" creationdate="20190613T052914Z">
        <seg>FilterFunction接口的类型为输入流的类型，它的filter()方法会接收一个输入事件，返回一个布尔值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Interval Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023305Z" creationid="xccui" creationdate="20190225T023305Z">
        <seg>The Interval Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager can then assign tasks to the slots to execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142633Z" creationid="xccui" creationdate="20190606T142633Z">
        <seg>随后，JobManager就可以向处理槽中分配任务来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager can then assigns tasks to the slots to execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062133Z" creationid="xccui" creationdate="20190418T051927Z">
        <seg>随后，JobManager就可以向处理槽中分配任务来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager con&lt;t4/&gt;‐&lt;t5/&gt; verts the JobGraph into a physical dataflow graph called the ExecutionGraph, which consists of tasks that can be executed in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T034733Z" creationid="xccui" creationdate="20190418T034656Z">
        <seg>JobManager将JobGraph转化成名为ExecutionGraph的物理dataflow图，该图包含了那些可以并行执行的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager controls the execution of a streaming application and keeps metadata  about its execution, such as pointers to completed checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145804Z" creationid="xccui" creationdate="20190606T145722Z">
        <seg>它用于控制流式应用执行以及保存该过程中的元数据（例如用于已完成检查点的指针）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager controls the execution of a streaming application and keeps metadata about its execution, such as pointers to completed checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T043258Z" creationid="xccui" creationdate="20190502T042809Z">
        <seg>它用于控制流式应用执行以及保存该过程中的元数据（例如用于完成checkpoint的指针）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager converts the JobGraph into a physical dataflow graph called the ExecutionGraph, which consists of tasks that can be executed in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141728Z" creationid="xccui" creationdate="20190606T141717Z">
        <seg>JobManager将JobGraph转化成名为ExecutionGraph的物理Dataflow图，该图包含了那些可以并行执行的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager is the master process that controls the execution of a single application—each application is controlled by a different JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141515Z" creationid="xccui" creationdate="20190606T141505Z">
        <seg>作为主进程，JobManager控制着单个应用的执行。换句话说，每个应用都由一个不同的JobManager掌控。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager receives an application for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T034042Z" creationid="xccui" creationdate="20190418T033907Z">
        <seg>JobManager可以接收用于执行的应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager records the check‐ point of an application as completed once it has received a checkpoint acknowledge‐ ment from all tasks of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194311Z" creationid="xccui" creationdate="20190609T194259Z">
        <seg>JobManager在接收到所有应用任务返回的检查点确认消息后，就会将此次检查点标记为完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager requests the necessary resources (TaskManager slots) to execute the tasks from the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T061959Z" creationid="xccui" creationdate="20190418T034828Z">
        <seg>JobManager从ResourceManager申请执行任务的必要资源（TaskManager处理槽）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager spans the JobGraph into an ExecutionGraph and assigns the tasks to the four avail&lt;t2/&gt;‐&lt;t3/&gt; able slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T163951Z" creationid="xccui" creationdate="20190423T163315Z">
        <seg>JobManager将JobGraph转成ExecutionGraph并将任务分配到4个空闲槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Job‐ Manager receives an application for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141542Z" creationid="xccui" creationdate="20190606T141542Z">
        <seg>JobManager可以接收用于执行的应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Job‐ Manager spans the JobGraph into an ExecutionGraph and assigns the tasks to the four available slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144640Z" creationid="xccui" creationdate="20190606T144553Z">
        <seg>JobManager将JobGraph展开成ExecutionGraph并把任务分配到4个空闲槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lambda architecture aimed to improve the high result latency of the original batch analytics architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T015919Z" creationid="xccui" creationdate="20190322T054026Z">
        <seg>Lambda架构旨在改善原始批量分析架构中结果的高延迟问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lambda architecture augments the traditional periodic batch processing archi&lt;t0/&gt;‐&lt;t1/&gt; tecture with a Speed Layer that is powered by a low-latency stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032853Z" creationid="xccui" creationdate="20190322T043932Z">
        <seg>Lambda架构在传统周期性批处理架构的基础上添加了一个由低延迟流处理引擎所驱动的"提速层"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lambda architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T043711Z" creationid="xccui" creationdate="20190322T043711Z">
        <seg>Lambda架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The MapFunction is typed to the types of the input and output events and can be specified using the MapFunction interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052743Z" creationid="xccui" creationdate="20190613T050021Z">
        <seg>MapFunction的两个类型分别为输入和输出事件类型，可以通过MapFunction接口来指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The O’Reilly logo is a registered trademark of O’Reilly Media, Inc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210736Z" creationid="esouser" creationdate="20190603T210736Z">
        <seg>The O’Reilly logo is a registered trademark of O’Reilly Media, Inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST interface enables the dispatcher to serve as an HTTP entry point to clusters that are behind a firewall.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T053416Z" creationid="xccui" creationdate="20190418T053359Z">
        <seg>REST接口允许Dispatcher作为防火墙后集群的一个HTTP入口点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST interface enables the dispatcher to serve as an HTTP entry point to clusters that are behind a fire‐ wall.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142920Z" creationid="xccui" creationdate="20190606T142920Z">
        <seg>REST接口允许Dispatcher作为防火墙后集群的一个HTTP入口点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Resour&lt;t4/&gt;‐&lt;t5/&gt; ceManager also takes care of terminating idle TaskManagers to free compute resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T051307Z" creationid="xccui" creationdate="20190418T051307Z">
        <seg>同时，ResourceManager还负责终止空闲的TaskManager以释放计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ResourceManager also takes care of terminating idle TaskManagers to free com‐ pute resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142256Z" creationid="xccui" creationdate="20190606T142256Z">
        <seg>同时，ResourceManager还负责终止空闲的TaskManager以释放计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ResourceManager is responsible for managing TaskManager slots, Flink’s unit of processing resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062008Z" creationid="xccui" creationdate="20190418T050109Z">
        <seg>ResourceManager负责管理Flink的处理资源单元——TaskManager处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Rest of the Flink Ecosystem</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152428Z" creationid="esouser" creationdate="20190603T152428Z">
        <seg>Flink生态的其他组成部分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Scala DataStream API also has built-in support for lambda functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T022408Z" creationid="xccui" creationdate="20190613T022402Z">
        <seg>Scala DataStream API同样内置了对lambda函数的支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The StreamExecutionEnvironment provides methods to create stream sources that ingest data streams into the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051229Z" creationid="xccui" creationdate="20190612T051229Z">
        <seg>StreamExecutionEnvironment提供了一些创建流式数据源的方法，可以将数据流读取到应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TaskMan&lt;t0/&gt;‐&lt;t1/&gt; agers take care of shipping data from sending tasks to receiving tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041011Z" creationid="xccui" creationdate="20190504T040910Z">
        <seg>TaskManager负载将数据从发送任务传输至接收任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TaskMan‐ agers take care of shipping data from sending tasks to receiving tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195332Z" creationid="xccui" creationdate="20190606T195324Z">
        <seg>TaskManager负责将数据从发送任务传输至接收任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TimerService and Timers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023114Z" creationid="xccui" creationdate="20190225T023114Z">
        <seg>TimerService和定时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Window Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023309Z" creationid="xccui" creationdate="20190225T023309Z">
        <seg>The Window Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The algorithm does not pause the complete application but decouples checkpointing from processing, so that some tasks continue processing while others persist their state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060010Z" creationid="xccui" creationdate="20190609T055752Z">
        <seg>该算法不会暂停整个应用，而是把生成检查点的过程和处理过程分离，这样在部分任务持久化状态的过程中，其他任务还可以继续执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The appli&lt;t0/&gt;‐&lt;t1/&gt; cation we are going to run converts and aggregates randomly generated temperature sensor readings by time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T055143Z" creationid="xccui" creationdate="20190328T054951Z">
        <seg>该应用会读取随机生成的温度传感器数值，并按时间对它们执行转换和聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application consists of a so- called JobGraph, a logical dataflow graph (see “Introduction to Dataflow Programming”), and a JAR file that bundles all the required classes, libraries, and other resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141712Z" creationid="xccui" creationdate="20190606T141549Z">
        <seg>该应用会包含一个所谓的JobGraph，一个逻辑Dataflow图（见"Dataflow编程介绍"），还有一个打包了全部所需类、库以及其他资源的JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application consists of a so-called JobGraph, a logical dataflow graph (see &lt;t2/&gt;Chapter 2&lt;t3/&gt;), and a JAR file that bundles all required classes, libraries, and other resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T034834Z" creationid="xccui" creationdate="20190418T034254Z">
        <seg>该应用会包含一个所谓的JobGraph，一个逻辑dataflow图（见第2章），还有一个打包了全部所需类、库以及其他资源的JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application consists of two source tasks that each consume a stream of increasing numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061931Z" creationid="xccui" creationdate="20190609T061931Z">
        <seg>应用包含了两个数据源任务，每个任务都会各自消费一条自增数字流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application has a single source task that consumes a stream of increasing num‐ bers—1, 2, 3, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T030703Z" creationid="xccui" creationdate="20190609T030545Z">
        <seg>该应用有一个数据源任务，负责从一个递增数字（1、2、3……）流中读取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application is depicted in Figure 3-19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062323Z" creationid="xccui" creationdate="20190609T062323Z">
        <seg>图3-19描绘了该应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application logic to read from and write to state is often straightforward.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055248Z" creationid="xccui" creationdate="20190607T055148Z">
        <seg>应用读写状态的逻辑通常都很简单，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application we are going to run converts and aggregates randomly generated temperature sensor readings by time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122633Z" creationid="xccui" creationdate="20190605T122633Z">
        <seg>该应用会读取随机生成的温度传感器数值，并按时间对它们执行转换和聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application will replay (and fast for‐ ward) the input events from the event log until it reaches the tail of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T211749Z" creationid="esouser" creationdate="20190603T211749Z">
        <seg>随后应用会从事件日志中读取并（快速）重放输入事件，直到数据流末尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The applications are usually connected to external services or face human users and continuously process incoming events such as orders, or mails, or clicks on a website.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T162118Z" creationid="xccui" creationdate="20190226T162118Z">
        <seg>此类应用通常会连接外部服务或真人用户，并持续处理诸如订单、邮件、网站点击等传入的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The applications in Figure 1-5 are connected by event logs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214008Z" creationid="esouser" creationdate="20190603T213929Z">
        <seg>其中的应用通过事件日志进行连接，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The applications in our example architecture are connected by event logs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T073244Z" creationid="xccui" creationdate="20190307T152633Z">
        <seg>示例架构中的应用通过事件日志进行连接，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application’s restart strategy determines how often the JobManager restarts the application and how long it waits between restart attempts.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145716Z" creationid="xccui" creationdate="20190606T145556Z">
        <seg>应用的重启策略决定了JobManager以何种频率重启应用以及重启尝试之间的等待间隔。1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application’s restart strategy&lt;t0/&gt;2&lt;t1/&gt; determines how often the JobManager tries to restart the application and how long it waits between restart attempts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210615Z" creationid="xccui" creationdate="20190428T210355Z">
        <seg>应用的重启策略决定了JobManager以何种频率尝试重启应用以及重启尝试之间的等待间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The architecture is depicted in &lt;t0/&gt;Figure 1-3&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194650Z" creationid="xccui" creationdate="20190228T194528Z">
        <seg>图1-3详细描绘了其架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignTimestampsAndWater marks(new SensorTimeAssigner) method assigns the timestamps and watermarks that are required for event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052108Z" creationid="xccui" creationdate="20190612T052108Z">
        <seg>assignTimestampsAndWatermarks(new SensorTimeAssigner)方法负责分配事件时间所需的时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The batch processor periodically processes the data in batch storage, writes the exact results into a batch table, and drops the corre‐ sponding inaccurate results from the speed table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052357Z" creationid="xccui" creationdate="20190605T052246Z">
        <seg>批处理引擎周期性地处理批量存储的数据，将精确结果写入批处理表，随后将"提速表"中对应的非精确结果删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012714Z" creationid="xccui" creationdate="20190606T012714Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The book examples are provided as a Maven project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040502Z" creationid="xccui" creationdate="20190611T040502Z">
        <seg>书中的示例都是以Maven项目的形式提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The boolean condition is implemented as a function either using the FilterFunction interface or a lambda function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052627Z" creationid="xccui" creationdate="20190613T052627Z">
        <seg>可以利用FilterFunction接口或lambda函数来实现定义布尔条件的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The broadcast strategy sends every data item to all parallel tasks of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233431Z" creationid="xccui" creationdate="20190605T233431Z">
        <seg>广播策略（broadcast strategy）会把数据项发往下游算子的全部并发任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The business logic is constrained by how much it can control state and time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T061822Z" creationid="xccui" creationdate="20190313T051256Z">
        <seg>其业务逻辑受制于系统对状态和时间的把控能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The cashier receives your payment and passes your order to the barista who prepares your beverage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T152916Z" creationid="xccui" creationdate="20190401T152703Z">
        <seg>收银员收到你的付款后会把订单交给帮你准备饮品的咖啡师。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The challenges of end-to-end exactly-once applications and approaches to address them are dis‐ cussed in detail in “Application Consistency Guarantees” on page 184.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054457Z" creationid="xccui" creationdate="20190609T054457Z">
        <seg>有关端到端精确一次应用所面临的挑战和解决方案会在184页"应用一致性保障"一节详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkpoint barriers emitted by the source tasks are shipped to the connected tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155503Z" creationid="xccui" creationdate="20190609T155503Z">
        <seg>数据源任务发出的检查点分隔符会传输到与之相连的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkpoint is complete when all tasks have finished their copies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224148Z" creationid="xccui" creationdate="20190608T224148Z">
        <seg>在所有任务完成自己的拷贝工作后，检查点生成完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code examples of the book use Maven build manage‐ ment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T030150Z" creationid="xccui" creationdate="20190611T020420Z">
        <seg>书中示例代码都是使用Maven来构建管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code examples of this book are hosted on GitHub.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T035214Z" creationid="xccui" creationdate="20190611T035214Z">
        <seg>本书的示例代码托管在GitHub上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The completed checkpoint can be used to recover the appli‐ cation from a failure as described before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194512Z" creationid="xccui" creationdate="20190609T194447Z">
        <seg>如前所述，应用在发生故障时就可以利用这个生成好的检查点进行恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constructed plan is translated into a JobGraph and submitted to a JobManager for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T012200Z" creationid="xccui" creationdate="20190613T012055Z">
        <seg>构建完的计划会被转成JobGraph并提交至JobManager执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corre‐ sponding FlatMapFunction defines the flatMap() method, which may return zero, one, or more events as results by passing them to the Collector object:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T061011Z" creationid="xccui" creationdate="20190613T055004Z">
        <seg>对应的FlatMapFunction定义了flatMap()方法，可以通过向Collector对象中传递数据的方式返回零个、一个或多个事件作为结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data that is stored in the various transactional database systems of a company can provide valuable insights about a company’s business operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T025652Z" creationid="esouser" creationdate="20190603T201131Z">
        <seg>存储于公司多个事务型数据库系统中的数据，可以提供和公司业务运营相关的宝贵见解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data that is stored in the various transactional database systems of a company can provide valuable insights about various aspects of the company’s business.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T191929Z" creationid="xccui" creationdate="20190228T173220Z">
        <seg>存储于公司多个事务型数据库系统中的数据，可以为公司业务提供各个方面的宝贵见解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data written to the batch storage is periodically processed by a batch processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T045024Z" creationid="xccui" creationdate="20190322T045655Z">
        <seg>而批处理引擎会定期处理数据并将结果写入批量存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dis&lt;t6/&gt;‐&lt;t7/&gt; patcher also runs a web dashboard to provide information about job executions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024218Z" creationid="xccui" creationdate="20190423T024218Z">
        <seg>Dispatcher同时还会启动一个web仪表盘，用来提供有关作业执行的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dispatcher also runs a web dashboard to provide information about job executions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142935Z" creationid="xccui" creationdate="20190606T142935Z">
        <seg>Dispatcher同时还会启动一个web仪表盘，用来提供有关作业执行的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The embedded execution mode starts an application and the whole Flink system in a single JVM process, which can be used to run and debug Flink jobs within an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122100Z" creationid="xccui" creationdate="20190605T121832Z">
        <seg>嵌入式执行模式可将应用自身连同整个Flink系统在单个JVM进程内启动，方便从IDE里运行和调试Flink作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end-to- end consistency of the application depends on the integration of the chosen stream sinks with Flink’s checkpointing algorithm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005721Z" creationid="xccui" creationdate="20190613T005721Z">
        <seg>该一致性取决于所选数据汇和Flink检查点算法的集成情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event log decouples senders and receivers and provides asynchronous, non-blocking event transfer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T072837Z" creationid="xccui" creationdate="20190308T072837Z">
        <seg>事件日志将发送端和接收端解耦，并提供异步非阻塞的事件传输机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event log decouples senders and receivers and provides asynchro‐ nous, nonblocking event transfer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214042Z" creationid="esouser" creationdate="20190603T214042Z">
        <seg>事件日志将发送端和接收端解耦，并提供异步非阻塞的事件传输机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event log pub&lt;t0/&gt;‐&lt;t1/&gt; lishes the changes to consumers that incorporate the updates into the affected data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062519Z" creationid="xccui" creationdate="20190314T072026Z">
        <seg>事件日志系统将改动发布给消费者，再由消费者将更新整合到相关数据存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event-time clocks of a task with two input streams will corre‐ spond to the watermarks of the slower stream and usually the records or intermediate results of the faster stream are buffered in state until the event-time clock allows pro‐ cessing them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033418Z" creationid="xccui" creationdate="20190607T033418Z">
        <seg>对于一个有两个输入流的任务而言，其事件时间时钟会受制于那个相对较慢的流，而较快流的记录或中间结果会缓存在状态中，直到事件时间时钟到达允许处理它们的那个点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact results are written into a batch table and the corresponding inaccurate results from the speed table are dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032903Z" creationid="xccui" creationdate="20190322T051608Z">
        <seg>在精确结果写入批处理表后，"提速表"中对应的非精确结果就可以删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execu&lt;t5/&gt;‐&lt;t6/&gt; tion of tasks and the concept of slots is discussed in more detail in a later section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062139Z" creationid="xccui" creationdate="20190418T052505Z">
        <seg>我们将在随后一节更详细讨论任务执行和处理槽的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051339Z" creationid="xccui" creationdate="20190612T051339Z">
        <seg>The execution</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execution environment determines whether the program is running on a local machine or on a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044916Z" creationid="xccui" creationdate="20190612T044916Z">
        <seg>执行环境决定了应用是在本地机器上还是集群上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execu‐ tion of tasks and the concept of slots is discussed in “Task Execution”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142745Z" creationid="xccui" creationdate="20190606T142726Z">
        <seg>我们将在"任务执行"一节进一步讨论任务执行和处理槽的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expressiveness of the API and the quality of state handling and event-time support determine the business logic that can be implemented and exe‐ cuted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T053602Z" creationid="xccui" creationdate="20190604T052839Z">
        <seg>API的表达能力以及对状态处理和事件时间的支持水平等诸多因素决定了可以实现和执行的业务逻辑类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The extracted timestamps are assigned to the respective record and the queried watermarks are ingested into the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T035457Z" creationid="xccui" creationdate="20190607T035446Z">
        <seg>提取出来的时间戳会附加到各自的记录上，查询得到的水位线会注入到数据流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure shows four sender and four receiver tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044155Z" creationid="xccui" creationdate="20190504T044155Z">
        <seg>其中包含了4个发送端和4个接收端任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filter transformation drops or forwards events of a stream by evaluating a boolean condition on each input event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T051901Z" creationid="xccui" creationdate="20190613T051252Z">
        <seg>Filter转换利用一个作用在每条输入事件上的布尔条件来决定流中事件的去存，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first field of the SensorReading is a sensorId, the second field is the time‐ stamp in milliseconds since 1970-01-01-00:00:00.000, and the third field is an average temperature computed over 5 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124114Z" creationid="xccui" creationdate="20190605T123948Z">
        <seg>SensorReading的第一个字段是sensorId，第二个字段是用自1970-01-01-00:00:00.000以来的毫秒数所表示的时间戳，第三个字段是每隔5秒计算出的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first generation of distributed open source stream processors (2011) focused on event processing with millisecond latencies and provided guarantees against loss of events in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050830Z" creationid="xccui" creationdate="20190605T050830Z">
        <seg>第一代开源分布式流处理引擎（2011年）专注于以毫秒级延迟处理数据并保证系统出错时事件不会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first generation of distributed open source stream processors (2011) that got sub&lt;t0/&gt;‐&lt;t1/&gt; stantial adoption focused on event processing with millisecond latencies and pro&lt;t2/&gt;‐&lt;t3/&gt; vided guarantees that events would never be lost in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T050636Z" creationid="xccui" creationdate="20190322T040934Z">
        <seg>第一代开源分布式流处理引擎（2011年）专注于以毫秒级延迟处理数据并保证系统出错时事件不会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first thing a Flink application needs to do is set up its execution environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044646Z" creationid="xccui" creationdate="20190612T044646Z">
        <seg>Flink应用要做的第一件事就是设置执行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first type are periodic report queries that compute business relevant statistics such as revenue, user growth, or production output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T193927Z" creationid="xccui" creationdate="20190228T193139Z">
        <seg>第一类是定期报告查询，用于计算业务相关的统计信息，如收入、用户增长、产出等，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flatMap transformation applies a function on each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T055027Z" creationid="xccui" creationdate="20190613T054855Z">
        <seg>flatMap转换会针对每个到来事件应用一个函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flatMap transformation is similar to map, but it can produce zero, one, or more output events for each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053414Z" creationid="xccui" creationdate="20190613T053414Z">
        <seg>flatMap转换类似于map，但它可以对每个到来事件产生零个、一个或多个输出事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The folder contains a file flink-scala-project-0.1.jar, which is the JAR file of your Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010603Z" creationid="xccui" creationdate="20190612T010603Z">
        <seg>该文件夹里会有一个flink-scala-project-0.1.jar文件，也就是你Flink应用的JAR包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code declares the id field as the key of a stream of SensorReading records:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051701Z" creationid="xccui" creationdate="20190614T051701Z">
        <seg>以下代码针对SensorReading记录流将其中的id字段声明为键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows a filter that drops all sensor measurements with tem‐ perature below 25°F:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053205Z" creationid="xccui" creationdate="20190613T053205Z">
        <seg>下方示例所展示的filter会丢弃所有温度低于25°F的传感器测量值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following is a simple mapper that extracts the first field (id) of each SensorRead ing in the input stream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050710Z" creationid="xccui" creationdate="20190613T050710Z">
        <seg>下面是一个简单的映射器，它会提取输入流中的每个SensorReading记录的第一个字段（id）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following typographical conventions are used in this book:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210759Z" creationid="esouser" creationdate="20190603T210759Z">
        <seg>The following typographical conventions are used in this book:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fol‐ lowing steps show you how to start a local Flink cluster and submit an application for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123110Z" creationid="xccui" creationdate="20190605T123013Z">
        <seg>以下步骤会教你如何启动本地Flink集群并提交应用到上面执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forward and random strategies as key-based</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T140502Z" creationid="xccui" creationdate="20190401T140430Z">
        <seg>转发和随机策略同样基于键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forward strategy and the random strategy can also be viewed as variations of the key-based strategy, where the first preserves the key of the upstream tuple while the latter performs a random re-assignment of keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142138Z" creationid="xccui" creationdate="20190401T140443Z">
        <seg>转发策略和随机策略也可以看做基于键值策略的变种，前者保留了上游元组的键值，后者会随机分配键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forward strategy sends data from a task to a receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233408Z" creationid="xccui" creationdate="20190605T233408Z">
        <seg>转发策略（forward strategy）在发送端任务和接收端任务之间进行一对一的数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The framework style follows the traditional approach of submitting an application (or query) via a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144133Z" creationid="xccui" creationdate="20190606T144133Z">
        <seg>基于框架的模式遵循传统方式，即通过客户端提交应用（或查询）到正在运行的服务上；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The framework style is follows the traditional approach of submitting an application (or query) via a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T040741Z" creationid="xccui" creationdate="20190423T040646Z">
        <seg>基于框架的模式遵循传统方式，即通过客户端提交应用（或查询）到正在运行的服务上；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function interface defines the transformation method that needs to be imple‐ mented by the user, such as the map() method in the example above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T021057Z" creationid="xccui" creationdate="20190613T020932Z">
        <seg>函数接口规定了用户需要实现的转换方法，例如上面例子中的map()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function is applied on a stream of sentences, splits each sentence by the space character, and emits each resulting word as an individual record:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T062259Z" creationid="xccui" creationdate="20190613T061921Z">
        <seg>这个函数会作用于一个语句流上，将每个句子按照空格字符分割，然后把分割得到的每个单词作为一条独立的记录发出去：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions encapsulate the user application logic and define how the elements of the input stream are transformed into the elements of the output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T014237Z" creationid="xccui" creationdate="20190613T014237Z">
        <seg>这些函数封装了用户应用逻辑，定义了输入流的元素如何转换为输出流的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions of the operators are fused into a single task that is executed by a single thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203638Z" creationid="xccui" creationdate="20190606T203546Z">
        <seg>多个算子的函数被揉到同一个任务中，在一个线程里执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions of the&lt;t1/&gt; &lt;t2/&gt;operators are fused into a single task which is executed by a single thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153708Z" creationid="esouser" creationdate="20190514T152833Z">
        <seg>算子里的函数被揉到同一个任务中，在一个线程里执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fundamental mode of operation - batch processing - is the same regardless whether the architecture is based on a data ware&lt;t2/&gt;‐&lt;t3/&gt; house or components of the Hadoop ecosystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T030601Z" creationid="xccui" creationdate="20190317T030601Z">
        <seg>基本操作模式（批处理）对基于数据仓库或Hadoop生态组件的架构，都是都是完全相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generated pom.xml file also contains instructions on how to add new dependencies to your project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010743Z" creationid="xccui" creationdate="20190612T010743Z">
        <seg>生成的pom.xml文件里还包含一些如何往项目中添加其他依赖的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The gen‐ erated folder contains a src/ folder and a pom.xml file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005659Z" creationid="xccui" creationdate="20190612T005652Z">
        <seg>生成的文件夹内包含了一个src/目录和一个pom.xml文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The goal of this chapter is to introduce the fundamental concepts of stream process‐ ing and the requirements of its frameworks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224728Z" creationid="xccui" creationdate="20190605T224706Z">
        <seg>我们旨在通过本章介绍流处理的基础概念以及处理框架的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The idle mechanism of sources can be used to address the problem of not advancing watermarks as discussed earlier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034838Z" creationid="xccui" creationdate="20190607T034838Z">
        <seg>数据源空闲声明机制可以用来解决上面提到的水位线不向前推进的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The image also includes the code to run a JobManager and ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030328Z" creationid="xccui" creationdate="20190423T030328Z">
        <seg>映像中还包含着运行JobManager以及ResourceManager的代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation details of SensorTimeAssigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052836Z" creationid="xccui" creationdate="20190612T052147Z">
        <seg>现在无须关心SensorTimeAssigner的实现细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The import steps are similar for most IDEs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040757Z" creationid="xccui" creationdate="20190611T040757Z">
        <seg>大多数IDE的导入步骤都很类似，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The importance of state becomes even more evident if we consider the case of using a batch processing system to analyze an unbounded data set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053157Z" creationid="xccui" creationdate="20190414T053157Z">
        <seg>如果考虑使用批处理系统分析有限数据集的情况，那么状态的重要性就越发明显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The importance of state becomes even more evident if we consider the case of using a batch processing system to analyze an unbounded dataset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031746Z" creationid="xccui" creationdate="20190606T031623Z">
        <seg>在使用批处理系统分析有限数据集的情况下，状态的重要性会越发凸显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key and value of the map can be of arbitrary type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T221809Z" creationid="xccui" creationdate="20190607T221757Z">
        <seg>该映射的键和值可以是任意类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key-based strategy partitions data by a key attribute and guarantees that data items having the same key will be processed by the same task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233508Z" creationid="xccui" creationdate="20190605T233508Z">
        <seg>基于键值的策略（key-based strategy）根据某一键值属性将数据分成多份，并保证键值相同的数据项会交由同一任务处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyBy transformation converts a DataStream into a KeyedStream by specifying a key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050208Z" creationid="xccui" creationdate="20190614T050208Z">
        <seg>keyBy转换通过指定键值的方式将一个DataStream转化为KeyedStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyBy() method receives an argument that specifies the key (or keys) to group by and returns a KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051446Z" creationid="xccui" creationdate="20190614T051446Z">
        <seg>keyBy()方法接收一个用来指定分区键值（可以是多个）的参数，返回一个KeyedStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051834Z" creationid="xccui" creationdate="20190605T051834Z">
        <seg>Lambda架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda architecture augments the traditional periodic batch processing architec‐ ture with a speed layer that is powered by a low-latency stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051842Z" creationid="xccui" creationdate="20190605T051842Z">
        <seg>Lambda架构在传统周期性批处理架构的基础上添加了一个由低延迟流处理引擎所驱动的"提速层"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda architecture is no longer state of the art, but is still used in many places.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052742Z" creationid="xccui" creationdate="20190605T052742Z">
        <seg>虽然Lambda架构已经算不上最先进，但仍在许多地方使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda function r =&gt; r.id extracts the id field of a sensor reading r.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051842Z" creationid="xccui" creationdate="20190614T051803Z">
        <seg>lambda函数r =&gt; r.id表示从传感器读数r中提取id字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latter decision is based on a trigger condition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022846Z" creationid="xccui" creationdate="20190406T045549Z">
        <seg>其中参与计算的决策会根据触发条件判定，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list entries can be of arbitrary type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T220045Z" creationid="xccui" creationdate="20190607T220045Z">
        <seg>列表中的条目可以是任意类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The live updated results of a streaming analytics application can be used to power dashboard applications as shown in Figure 1-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044552Z" creationid="xccui" creationdate="20190605T044552Z">
        <seg>如图1-6所示，流式分析应用的实时更新结果可以支撑表盘应用的展示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The live updated results of a streaming analytics applications can be used to power dashboard applications as shown in &lt;t8/&gt;Figure 1-6&lt;t9/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062117Z" creationid="xccui" creationdate="20190317T061352Z">
        <seg>如图1-6所示，流式分析应用的实时更新结果可以支撑表盘应用的展示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The logic of an application is defined by chaining transformations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053100Z" creationid="xccui" creationdate="20190612T052904Z">
        <seg>应用的逻辑是通过一系列转换来定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main take-away here is that lowering latency actually increases throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211801Z" creationid="xccui" creationdate="20190402T211645Z">
        <seg>这里的要点就是降低延迟实际上可以提高吞吐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main takeaway here is that lowering latency increases throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235620Z" creationid="xccui" creationdate="20190605T235620Z">
        <seg>这里的要点就是降低延迟实际上可以提高吞吐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The map transformation is specified by calling the DataStream.map() method and produces a new DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T044734Z" creationid="xccui" creationdate="20190613T042736Z">
        <seg>通过调用DataStream.map()方法可以指定map转换产生一个新的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mechanism is similar to buffering techniques used in networking or disk IO pro&lt;t2/&gt;‐&lt;t3/&gt; tocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041925Z" creationid="xccui" creationdate="20190504T041925Z">
        <seg>其机制和网络以及磁盘IO协议中的缓冲技术很像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mechanism is similar to the buffering techniques used in networking or disk I/O protocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195625Z" creationid="xccui" creationdate="20190606T195538Z">
        <seg>它的机制和网络以及磁盘I/O协议中的缓冲技术很像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most trivial way would be to simply restart the job, but then we would have to replay all data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044142Z" creationid="xccui" creationdate="20190415T044114Z">
        <seg>最傻的办法就是简单地重启作业，但这样的话我们必须重放全部数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The naive approach to taking a checkpoint from a streaming application—to pause, checkpoint, and resume the application—is not practical for applications that have even moderate latency requirements due to its “stop-the-world” behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T055438Z" creationid="xccui" creationdate="20190609T054707Z">
        <seg>针对流式应用，生成检查点的朴素方法就是暂停执行，生成检查点，然后恢复应用。但这种"停止一切"的行为，即便对于那些具有中等延迟要求的应用也很不切实际。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The network</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041626Z" creationid="xccui" creationdate="20190504T041203Z">
        <seg>TaskManager的网络模块在传输记录前会将它们在缓冲区中收集起来，因此，记录并非逐个发送的，而是在缓冲区中以批次形式发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The network component of a TaskManager collects records in buffers before they are shipped, i.e., records are not shipped one by one but batched into buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195616Z" creationid="xccui" creationdate="20190606T195414Z">
        <seg>它的网络模块在传输记录前会将它们在缓冲区中收集起来，因此，记录并非逐个发送的，而是在缓冲区中以批次形式发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of slots limits the number of tasks a TaskManager can execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142537Z" creationid="xccui" creationdate="20190606T142537Z">
        <seg>处理槽的数目限制了一个TaskManager可执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of slots limits the number of tasks that a TaskMan&lt;t3/&gt;‐&lt;t4/&gt; ager can execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062053Z" creationid="xccui" creationdate="20190418T051544Z">
        <seg>处理槽的数目限制了一个TaskManager可执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The observation that data processing systems (at this point in time) could either provide fast or accurate results led to the design of the so-called Lambda architecture which is depicted in &lt;t6/&gt;Figure 1-7&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T043705Z" creationid="xccui" creationdate="20190322T043255Z">
        <seg>以当时的眼光看待流处理系统，快速计算和准确结果二者不可兼得，因此才有了所谓的Lambda架构，详见图1-7。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The observation that data processing systems (at this point in time) could either provide fast or accurate results led to the design of the so-called lambda architecture, which is depicted in Figure 1-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051812Z" creationid="xccui" creationdate="20190605T051725Z">
        <seg>以当时的眼光看待流处理系统，计算快速和结果准确二者不可兼得，因此才有了所谓的Lambda架构，详见图1-7。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The obvious next step is to learn how to actually implement a DataStream program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T011435Z" creationid="xccui" creationdate="20190612T011435Z">
        <seg>而接下来将要学的自然就是如何实现DataStream程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator identifier and state name are required to be able to map the state data of a savepoint to the states of the operators of a starting application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215509Z" creationid="xccui" creationdate="20190609T215456Z">
        <seg>该算子标识符和状态名需要能将保存点的状态数据映射到应用启动后的算子状态上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator keeps the current minimum value and accordingly updates it for each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011920Z" creationid="xccui" creationdate="20190606T011920Z">
        <seg>其算子会维护当前的最小值，并根据每个到来的事件同步更新这个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator keeps the current value of the sum as its internal state and updates it every time it receives a new event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T052510Z" creationid="xccui" creationdate="20190414T052338Z">
        <seg>该算子将当前的累加值存为内部状态，并在每次收到新事件时更新它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator keeps the current&lt;t4/&gt; &lt;t5/&gt;minimum value and accordingly updates it for each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035839Z" creationid="xccui" creationdate="20190406T035703Z">
        <seg>其算子会维护当前的最小值，并根据每个到来的事件同步更新这个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator needs to store the “high temperature” event in its internal state until it sees the “smoke” event or the until 10-minute time period expires.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031605Z" creationid="xccui" creationdate="20190606T031527Z">
        <seg>这个算子需要将"高温"事件存为内部状态，直到接下来发现"烟雾"事件或超过10分钟的有效时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator needs to store the “high temperature” event in its internal state, until it sees the “smoke” event or the until 10-minute time period expires.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T052942Z" creationid="xccui" creationdate="20190414T052942Z">
        <seg>这个算子需要将"高温"事件存为内部状态，直到发现"烟雾"事件或超过10分钟的过期时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator pipeline</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152223Z" creationid="esouser" creationdate="20190514T152223Z">
        <seg>图3-5中的算子所组成的流水线就满足上述需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator pipeline shown in Figure 3-5 fulfills these requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203507Z" creationid="xccui" creationdate="20190606T203341Z">
        <seg>图3-5中算子所组成的流水线就满足上述需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original goals of this architecture were to improve the high result latency of the original batch analytics architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052848Z" creationid="xccui" creationdate="20190605T052749Z">
        <seg>它最初的目标是改善原始批量分析架构中结果的高延迟问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other operators have a parallelism of four.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043456Z" creationid="xccui" creationdate="20190423T043437Z">
        <seg>其余算子的并行度为4。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other oper‐ ators have a parallelism of four.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144533Z" creationid="xccui" creationdate="20190606T144533Z">
        <seg>其余算子的并行度为4。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output can be read as follows: the first field of the SensorReading is a sen&lt;t0/&gt;‐&lt;t1/&gt; sorId, the second field is the timestamp as milliseconds since &lt;t2/&gt;1970-01-01-00:00:00.000&lt;t3/&gt;, and the third field is an average temperature compu&lt;t4/&gt;‐&lt;t5/&gt; &lt;t6/&gt;ted over five seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045333Z" creationid="xccui" creationdate="20190329T043115Z">
        <seg>输出说明如下：SensorReading的第一个字段是sensorId，第二个字段是以距1970-01-01-00:00:00.000的毫秒数表示的时间戳，第三个字段是每隔5秒计算出的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the example is (1,2,2) followed by (1,7,2) for the key “1” and (2,3,1) followed by (2,5,1) for the key “2.” The first</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T055333Z" creationid="xccui" creationdate="20190614T055254Z">
        <seg>示例对于键值"1"首先输出(1,2,2)，然后是(1,7,2)；对于键值"2"首先输出(2,3,1)然后是(2,5,1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the job is written to the standard out of Flink’s worker process which is by default redirected into a file in the &lt;t0/&gt;./log&lt;t1/&gt; folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042518Z" creationid="xccui" creationdate="20190329T042238Z">
        <seg>作业的输出会写入Flink工作进程的标准输出，默认情况下它会重定向到./log目录下的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the job is written to the standard out of Flink’s worker process, which is redirected into a file in the ./log folder by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123802Z" creationid="xccui" creationdate="20190605T123802Z">
        <seg>作业的输出会写入Flink工作进程的标准输出，默认情况下它会重定向到./log目录下的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the program is written to the standard out (or console) window of your IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042955Z" creationid="xccui" creationdate="20190611T042955Z">
        <seg>程序的输出会写到你IDE的标准输出（或控制台）窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the source tasks is partitioned into streams of  even and odd numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062132Z" creationid="xccui" creationdate="20190609T062059Z">
        <seg>数据源任务的输出会被分成奇数流和偶数流两个部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output starts with a few log statements about the states that parallel operator tasks go through, such as SCHED‐ ULING, DEPLOYING, and RUNNING.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043236Z" creationid="xccui" creationdate="20190611T043225Z">
        <seg>输出以几行日志语句开始，它们记录了并行算子所经过的一些状态，例如：SCHEDULING、DEPLOYING和RUNNING。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous chapter discussed important concepts of distributed stream processing, such as parallelization, time, and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053758Z" creationid="xccui" creationdate="20190416T053731Z">
        <seg>上一章主要讨论了分布式流处理中的一些重要概念，例如：并行、时间、状态等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous chapter introduced two concepts Flink leverages to provide event-time semantics: record timestamps and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204559Z" creationid="xccui" creationdate="20190606T204552Z">
        <seg>前一章介绍了Flink在提供处理时间语义时所采用的两个概念：记录时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous chapter introduced two concepts that Flink leverages to pro&lt;t2/&gt;‐&lt;t3/&gt; vide event-time semantics: record timestamps and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T034944Z" creationid="xccui" creationdate="20190523T034944Z">
        <seg>上一章介绍了Flink在提供处理时间语义时所采用的两个概念：记录时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that Alice lives in Berlin and she takes the subway to work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152542Z" creationid="xccui" creationdate="20190411T150344Z">
        <seg>但问题在于，爱丽丝住在柏林，每天乘地铁上班，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that Alice lives in Berlin and takes the subway to work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014945Z" creationid="xccui" creationdate="20190606T014945Z">
        <seg>但问题在于，爱丽丝住在柏林，每天乘地铁上班，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of copying data to the data warehouse is called extract-transform-load (ETL).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192128Z" creationid="xccui" creationdate="20190228T190335Z">
        <seg>这个向数据仓库拷贝数据的过程被称为提取-转换-加载（Extract-Transform-Load，ETL）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of copying data to the data warehouse is called extract–transform–load (ETL).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T202730Z" creationid="esouser" creationdate="20190603T202730Z">
        <seg>这个向数据仓库拷贝数据的过程被称为提取-转换-加载（Extract-Transform-Load，ETL）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of waiting for all barriers to arrive is called barrier alignment, and it is depicted in Figure 3-22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T174938Z" creationid="xccui" creationdate="20190609T162722Z">
        <seg>这个等待所有分隔符到达的过程称为分隔符对齐，我们在图3-22中对它进行了阐述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program in Example 5-1 converts the temperatures from Fahrenheit to Celsius and computes the average temperature every 5 seconds for each sensor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053332Z" creationid="xccui" creationdate="20190612T035758Z">
        <seg>示例5-1中的程序将温度从华氏度转为摄氏度并计算每个传感器每5秒钟的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program will continue to generate new events, process them, and emit new results every second until you terminate it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043558Z" creationid="xccui" creationdate="20190611T043547Z">
        <seg>如果不手动终止，这个程序会一直生成新的事件、处理它们并每秒产生新的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The project contains two skeleton files, BatchJob.scala and StreamingJob.scala, as a starting point for your own programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010104Z" creationid="xccui" creationdate="20190612T010104Z">
        <seg>项目所包含的两个骨架文件，BatchJob.scala和StreamingJob.scala，可以作为你程序的起点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The random strategy uniformly distributes data items to operator tasks in order to evenly distribute the load across computing tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233607Z" creationid="xccui" creationdate="20190605T233549Z">
        <seg>随机策略（random strategy）会将数据均匀分配至算子的所有任务，以实现计算任务的负载均衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rapid digitalization and emergence of connected systems made it possible to collect much more data in real-time and immediately act on this data for example by adjusting to changing conditions or by personalizing user experiences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T052548Z" creationid="xccui" creationdate="20190317T051706Z">
        <seg>数字化的迅猛发展和互联系统的出现使得我们可以实时获取更多数据并立即根据它们采取行动，例如：适应状况的变化或个性化用户体验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receiver processes the shipped data with the reserved buffers and uses the sender’s backlog size to prioritize the next credit grants for all its connected senders.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203049Z" creationid="esouser" creationdate="20190514T143015Z">
        <seg>接收端使用保留的缓冲来处理接收到的数据，同时依据发送端的积压量数据来计算相连的发送端在下一轮的信用优先级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receiving task takes the buffer from the queue and deserializes the incoming records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T192333Z" creationid="esouser" creationdate="20190513T192253Z">
        <seg>接收任务会从这个队列里获取缓冲并反序列化其中的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reduce transformation is a generalization of the rolling aggregation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061250Z" creationid="xccui" creationdate="20190614T061250Z">
        <seg>reduce转换是滚动聚合转换的泛化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remote storage for checkpointing could be a distributed filesystem or a database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053803Z" creationid="xccui" creationdate="20190608T053742Z">
        <seg>该远程存储可能是一个分布式文件系统，也可能是某个数据库系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the Flink ecosystem</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030241Z" creationid="xccui" creationdate="20190225T030241Z">
        <seg>Flink生态的其他组成部分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result stream is written to the standard output by calling print():</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T022726Z" creationid="xccui" creationdate="20190612T054705Z">
        <seg>通过调用print()将写过写到标准输出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results of the program are emitted to standard output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042541Z" creationid="xccui" creationdate="20190611T042541Z">
        <seg>程序的结果会写入标准输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rolling aggregate operator keeps a state for every key that is processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061006Z" creationid="xccui" creationdate="20190614T061006Z">
        <seg>滚动聚合算子会为每个处理过的键值维持一个状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second property is used to handle streams with out-of-order record timestamps, such as the records with timestamps 3 and 5 in &lt;t0/&gt;Figure 3-8&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T034143Z" creationid="xccui" creationdate="20190523T042812Z">
        <seg>第二个属性是用来应对那些记录时间戳乱序的数据流，例如图3-8中所示的时间戳3和5。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second property is used to handle streams with out-of-order record timestamps, such as the records with timestamps 3 and 5 in Figure 3-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205526Z" creationid="xccui" creationdate="20190606T205450Z">
        <seg>第二个属性是用来应对那些记录时间戳乱序的数据流，例如图3-8中的时间戳3和5。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second type are ad-hoc queries that aim to provide answers to specific questions and support business-critical deci&lt;t2/&gt;‐&lt;t3/&gt; sions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T030047Z" creationid="xccui" creationdate="20190228T193848Z">
        <seg>第二类是即席查询，其主要目的是通过解答特定问题来辅助商业决策。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second type are ad-hoc queries that aim to provide answers to specific questions and support business-critical decisions, for example a query to collect revenue numbers and spending on radio commercials to evaluate the effectiveness of a marketing cam‐ paign.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203542Z" creationid="esouser" creationdate="20190603T203150Z">
        <seg>第二类是即席查询，其主要目的是通过解答特定问题来辅助商业决策，例如：通过查询收集广播广告的投入和营收数字，以评估市场营销的有效性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service can be a Flink Dispatcher, a Flink JobManager, or YARN’s ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025600Z" creationid="xccui" creationdate="20190423T025547Z">
        <seg>此处的服务可以是Flink Dispatcher，Flink JobManager或是YARN的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service can be a Flink Dispatcher, a Flink Job‐ Manager, or YARN’s ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143452Z" creationid="xccui" creationdate="20190606T143434Z">
        <seg>这里的服务可以是Flink Dispatcher，Flink JobManager或是YARN的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service latency is the time you spend in the coffee shop, from the moment you enter until you have your first sip of coffee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233937Z" creationid="xccui" creationdate="20190605T233933Z">
        <seg>所谓服务延迟就是在店内买咖啡的时间，即从你进门的一刻到抿到第一口咖啡的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest thing to do when a task fails is to do nothing to recover lost state and replay lost events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034336Z" creationid="xccui" creationdate="20190415T051105Z">
        <seg>任务发生故障时最简单的措施就是既不恢复丢失的状态，也不重放丢失的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The slide value defines the interval at which a new bucket is created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024245Z" creationid="xccui" creationdate="20190407T024134Z">
        <seg>滑动间隔决定每隔多久生成一个新的桶。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sliding count-based window of &lt;t5/&gt;Figure 2-8&lt;t6/&gt; has a length of 4 events and slide of 3 events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024330Z" creationid="xccui" creationdate="20190407T024330Z">
        <seg>在图2-8中，基于数量的滑动窗口的长度为4个事件，滑动间隔为3个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sliding count-based window of Figure 2-8 has a length of four events and slide of three events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013302Z" creationid="xccui" creationdate="20190606T013302Z">
        <seg>在图2-8中，基于数量的滑动窗口的长度为4个事件，滑动间隔为3个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The source task stores the current offset of its input stream as  state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T031659Z" creationid="xccui" creationdate="20190609T030952Z">
        <seg>数据源算子的任务会把输入流的当前偏移量存为状态；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The src/ folder has the follow‐ ing structure:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005710Z" creationid="xccui" creationdate="20190612T005710Z">
        <seg>src/目录的结构如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state backend notifies the task once its state checkpoint is complete and the task acknowledges the check‐ point at the JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T154433Z" creationid="xccui" creationdate="20190609T154111Z">
        <seg>状态后端会在状态存为检查点完成后通知任务，然后任务会给JobManager发送确认消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state copies in the savepoint are organized by an operator identifier and a state name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215327Z" creationid="xccui" creationdate="20190609T215249Z">
        <seg>保存点中拷贝的状态会按照一个算子标识符和一个状态名称进行组织。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The steps of this naive algorithm would be:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223351Z" creationid="xccui" creationdate="20190608T223351Z">
        <seg>朴素算法的步骤包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream of numbers is partitioned into a stream of even and odd numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T030857Z" creationid="xccui" creationdate="20190609T030659Z">
        <seg>数字流会被分成奇数流和偶数流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream processor computes approximated results in near real time and writes them into a speed table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052213Z" creationid="xccui" creationdate="20190605T052213Z">
        <seg>流处理引擎会近实时地计算出近似结果，随后将其写入"提速表"中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream processor computes possibly inaccurate results in near real-time and writes the results into a speed table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032857Z" creationid="xccui" creationdate="20190322T045515Z">
        <seg>流处理引擎会近实时地计算出一个可能并不精确的结果，随后将其写入"提速表"中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sum tasks persist the current sum value as state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T031626Z" creationid="xccui" creationdate="20190609T031626Z">
        <seg>求和算子的任务会把当前和值存为状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The system needs to efficiently manage the state and make sure it is protected from concurrent updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032909Z" creationid="xccui" creationdate="20190606T032909Z">
        <seg>系统需要高效地管理状态并保证它们在面对并发更新时不会出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The system needs to efficiently manage the state and make&lt;t1/&gt; &lt;t2/&gt;sure it is protected from concurrent updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T033323Z" creationid="xccui" creationdate="20190415T033225Z">
        <seg>系统需要高效地管理状态并保证它们在面对并发更新时不会出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task can then choose which entries to use and which to dis‐ card.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061346Z" creationid="xccui" creationdate="20190608T061317Z">
        <seg>随后由任务自己决定哪些条目该保留，哪些该丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task emits a watermark with the updated event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T012501Z" creationid="xccui" creationdate="20190606T213002Z">
        <seg>任务根据更新后的事件时间发出水位线记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task emits a watermark with the updated event-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042340Z" creationid="xccui" creationdate="20190529T042213Z">
        <seg>根据更新后的事件时间发出水位线记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task updates its internal event-time clock based on the watermark’s time&lt;t0/&gt;‐&lt;t1/&gt; stamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041933Z" creationid="xccui" creationdate="20190529T041933Z">
        <seg>基于水位线记录的时间戳更新内部事件时间时钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task updates its internal event-time clock based on the watermark’s time‐ stamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T212920Z" creationid="xccui" creationdate="20190606T212920Z">
        <seg>基于水位线记录的时间戳更新内部事件时间时钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tasks of a running application are continuously exchanging data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T040830Z" creationid="xccui" creationdate="20190504T040830Z">
        <seg>运行状态下应用的任务会持续交换数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tasks of operators with two or more input streams such as Union or CoFlatMap (see “Multistream Transformations”) also compute their event-time clock as the mini‐ mum of all partition watermarks—they do not distinguish between partition water‐ marks of different input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024744Z" creationid="xccui" creationdate="20190607T025821Z">
        <seg>对于那些有着两条或多条输入数据流的算子，如Union或CoFlatMap（详见"多流转换"），它们的任务同样是利用全部分区水位线中的最小值来计算事件时间时钟而没有考虑分区是否来自不同的流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tasks of the operators with a parallelism of four are assigned to each slot.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062201Z" creationid="xccui" creationdate="20190423T164129Z">
        <seg>对于并行度为4的算子，其任务会每个处理槽分配一个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task’s time service identifies all timers with a time smaller than the updated event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T212936Z" creationid="xccui" creationdate="20190606T212936Z">
        <seg>任务的时间服务会找出所有触发时间小于更新后事件时间的定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task’s time service identifies all timers with a time smaller than the updated event-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042031Z" creationid="xccui" creationdate="20190529T042031Z">
        <seg>任务的时间服务会找出所有触发时间小于更新后事件时间的定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third and biggest challenge that comes with stateful operators is ensuring that state can be recovered and results will be correct even in the presence of fail‐ ures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032958Z" creationid="xccui" creationdate="20190606T032958Z">
        <seg>最后一个也是最大的挑战在于，状态化算子需要保证状态可以恢复，即便出现故障也要确保结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third generation of distributed open source stream processors (2015) addressed the dependency of results on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053334Z" creationid="xccui" creationdate="20190605T053320Z">
        <seg>第三代分布式流处理引擎（2015年）解决了结果对事件到来时间及顺序的依赖问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third generation of distributed open source stream processors (2015) fixed the dependency of results on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T050910Z" creationid="xccui" creationdate="20190327T050627Z">
        <seg>第三代分布式流处理引擎（2015年）修复了结果对事件到来时间及顺序的依赖问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timestamp associates a record with a specific point</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204839Z" creationid="xccui" creationdate="20190606T204839Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timestamp associates an record with a specific point in time, usually the point in time at which the event that is represented by the record happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035521Z" creationid="xccui" creationdate="20190523T035521Z">
        <seg>时间戳将记录和特定时间点进行关联，这些时间点通常是记录所表示事件的发生时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The traditional approach of a periodic ETL job to move data between storage systems is typically not able to propagate updates fast enough.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T070853Z" creationid="xccui" creationdate="20190314T070853Z">
        <seg>传统方式是通过定期执行ETL作业来转移数据，但这种更新传播方式往往不够迅速。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The traditional architecture that most businesses implement distinguishes two types of data process‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T051121Z" creationid="esouser" creationdate="20190603T194352Z">
        <seg>绝大多数企业实现的传统架构都会将数据处理分为两类：事务型处理和分析型处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transformation logic can be either integrated in the operator or provided by a user-defined function (UDF), as shown in &lt;t4/&gt;Figure 2-4&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T155218Z" creationid="xccui" creationdate="20190405T153643Z">
        <seg>如图2-4所示，具体转换逻辑可以是算子内置的，也可以由用户自定义函数（UDF）提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transformation logic can be either integrated in the operator or provided by a user-defined function, as shown in Figure 2-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011507Z" creationid="xccui" creationdate="20190606T011328Z">
        <seg>如图2-4所示，具体转换逻辑可以是算子内置的，也可以由用户自定义函数提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The truth is, processing time can indeed be useful in some cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T030725Z" creationid="xccui" creationdate="20190606T030701Z">
        <seg>事实上，处理时间有其特定的适用场景，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two tasks of operators C and E are assigned to slots 1.1 and 2.1 and slots 1.2 and 2.2, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144657Z" creationid="xccui" creationdate="20190606T144651Z">
        <seg>其余两个算子C和E的任务会分别放到处理槽1.1、2.1和处理槽1.2、2.2中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two tasks of operators C and E are assigned to slots 1.1 and 2.1 and slots 1.2 and 2.2, respectively&lt;t4/&gt;1&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062232Z" creationid="xccui" creationdate="20190423T164232Z">
        <seg>其余两个算子C和E的任务会分别放到处理槽1.1、2.1和处理槽1.2、2.2中1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the output stream is the same as the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061617Z" creationid="xccui" creationdate="20190614T061549Z">
        <seg>因此输出流的类型永远和输入流保持一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The types of guarantees you have seen so far refer to the state of an application that is managed by the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035037Z" creationid="xccui" creationdate="20190606T035014Z">
        <seg>至今为止你看到的保障类型都仅限于流处理引擎自身的应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The types of guarantees you have seen so far refer to the stream processor component only.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045141Z" creationid="xccui" creationdate="20190416T045141Z">
        <seg>至今为止你看到的保障类型都仅限于流处理引擎组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ubiquitous problem of out-of-order data can also be solved with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024431Z" creationid="xccui" creationdate="20190606T024422Z">
        <seg>普遍存在无序问题也可以借此解决。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The updates are written to and distributed by the event log.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T040443Z" creationid="xccui" creationdate="20190605T040204Z">
        <seg>具体而言就是将更新写入事件日志系统，并由它进行分发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The views expressed in this work are those of the authors, and do not represent the publisher’s views.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210738Z" creationid="esouser" creationdate="20190603T210738Z">
        <seg>The views expressed in this work are those of the authors, and do not represent the publisher’s views.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The “Extract hashtags" and “Count" operators have two parallel operator tasks, each performing a computation on a subset of the input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021422Z" creationid="xccui" creationdate="20190401T003521Z">
        <seg>"Extract hashtags"和"Count"算子都包含两个并行算子任务，每个任务负责计算一部分输入数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The&lt;t8/&gt; &lt;t9/&gt;behavior of windows is defined by a set of policies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T045355Z" creationid="xccui" creationdate="20190406T045224Z">
        <seg>窗口的行为是由一组策略定义的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then suddenly the train enters a tunnel and her phone gets dis‐ connected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T015033Z" creationid="xccui" creationdate="20190606T015033Z">
        <seg>突然，地铁开进隧道，手机断网了，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then suddenly, the train enters a tunnel and her phone gets dis&lt;t2/&gt;‐&lt;t3/&gt; connected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151228Z" creationid="xccui" creationdate="20190411T150738Z">
        <seg>突然，地铁开进隧道，手机断网了，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then we introduced the idea of stateful stream processing and explained how it addresses a wide spectrum of use cases, rang‐ ing from business applications and microservices to ETL and data analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T125220Z" creationid="xccui" creationdate="20190605T125200Z">
        <seg>随后我们介绍了状态化流处理的基本思想，解释了它如何处理从业务应用和微服务到ETL和数据分析的多种用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, can you somehow get both low latency and high throughput or is this a hope&lt;t0/&gt;‐&lt;t1/&gt; less endeavour?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210637Z" creationid="xccui" creationdate="20190402T210637Z">
        <seg>既然这样，可以通过某种方式同时获得低延迟和高吞吐吗？还是说根本不切实际？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, we use the keyBy() transformation to parti‐ tion the sensor readings by their sensor ID.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053453Z" creationid="xccui" creationdate="20190612T053453Z">
        <seg>然后我们使用keyBy()转换，将传感器读数按照传感器ID进行分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also applications that do not emit results but keep them internally to serve them via Flink’s queryable state feature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054456Z" creationid="xccui" creationdate="20190612T054456Z">
        <seg>还有一些应用不会发出结果，而是将它们保存在内部，利用Flink的可查询状态功能对外提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are different types of transformations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052719Z" creationid="xccui" creationdate="20190612T052303Z">
        <seg>转换的类型多种多样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are different ways to specify keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051541Z" creationid="xccui" creationdate="20190614T051506Z">
        <seg>指定键值的方式多种多样，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several event log sys&lt;t0/&gt;‐&lt;t1/&gt; tems available as open source software, Apache Kafka being the most popular, or as integrated services offered by cloud computing providers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T060116Z" creationid="xccui" creationdate="20190305T055922Z">
        <seg>有不少事件日志系统会以开源软件或云计算集成服务的形式出现，其中最流行的当属Apache Kafka。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several event log sys‐ tems available as open source software, Apache Kafka being the most popular, or as integrated services offered by cloud computing providers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T211354Z" creationid="esouser" creationdate="20190603T211119Z">
        <seg>有不少事件日志系统都是开源软件，其中最流行的当属Apache Kafka；也有一些会作为云计算提供商的集成服务出现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two types of state, operator state and keyed state, that are accessible from different scopes and discussed in the following sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T060205Z" creationid="xccui" creationdate="20190607T023422Z">
        <seg>根据作用域的不同，状态可以分为两类：算子状态和键值状态，我们会在接下来的几节介绍它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, we strongly recommend manually assign‐ ing unique identifiers to operators and not relying on Flink’s default assignment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T030745Z" creationid="xccui" creationdate="20190610T030737Z">
        <seg>所以我们强烈建议手工指定算子标识，而不要依赖Flink的默认分配机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These chapters guide you through setting up a development environment, cover the basics of the DataStream API, and go into the details of Flink’s time seman&lt;t2/&gt;‐&lt;t3/&gt; tics and window operators, its connectors to external systems, and the details of Flink’s fault-tolerant operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191557Z" creationid="xccui" creationdate="20190225T165712Z">
        <seg>这些章节将指导你完成开发环境设置，学习DataStream API的基础知识，深入了解Flink的时间语义、窗口算子、外部系统连接器以及Flink容错性operator state的细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These components are a JobManager, a ResourceManager, a TaskManager, and a Dispatcher.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033541Z" creationid="xccui" creationdate="20190418T033541Z">
        <seg>这些组件是：JobManager、ResourceManager、TaskManager及Dispatcher。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These components need to be carefully orchestrated and especially error handling and failure recovery can become challenging.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T063117Z" creationid="xccui" creationdate="20190317T063117Z">
        <seg>这些组件需要仔细地协调，尤其是错误处理和故障恢复可能颇具挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These metrics are assembled into reports that help the management to assess the business’s overall health.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203141Z" creationid="esouser" creationdate="20190603T203141Z">
        <seg>在报告中汇总这些指标，可以帮助管理层评估企业整体健康状况；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These metrics are assembled into reports that help to assess the situation of the business.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T193934Z" creationid="xccui" creationdate="20190228T193457Z">
        <seg>在报告中汇总这些指标，有助于评估业务状况；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operations consume one event after the other and apply some trans&lt;t2/&gt;‐&lt;t3/&gt; formation to the event data, producing a new output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T034637Z" creationid="xccui" creationdate="20190405T153227Z">
        <seg>这些操作挨个读取事件，对其应用某些转换并产生一条新的输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operations consume one event after the other and apply some trans‐ formation to the event data, producing a new output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011319Z" creationid="xccui" creationdate="20190606T011303Z">
        <seg>这些操作逐个读取事件，对其应用某些转换并产生一条新的输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators can be combined into dataflow processing graphs to implement the logic of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235756Z" creationid="xccui" creationdate="20190402T212738Z">
        <seg>这些算子可以组合生成Dataflow处理图，从而实现流式应用的基本逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These systems are typically designed with separate tiers for data processing (the application itself) and data storage (a transactional database system) as shown in Figure 1-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T025346Z" creationid="esouser" creationdate="20190603T195128Z">
        <seg>如图1-1所示，这些应用系统通常都会设置独立的数据处理层（应用程序自身）和数据存储层（事务性数据库系统）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These systems had rather low-level APIs and did not provide built-in support for accurate and con&lt;t4/&gt;‐&lt;t5/&gt; sistent results of streaming applications because the results depended on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T042817Z" creationid="xccui" creationdate="20190322T042044Z">
        <seg>它们的API非常底层，而且并未针对流式应用结果的准确性和一致性提供内置保障。其结果完全取决于事件到达的时间和顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These systems had rather low-level APIs and did not provide built-in support for accurate and consistent results of streaming applications because the results depended on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051546Z" creationid="xccui" creationdate="20190605T051546Z">
        <seg>它们的API非常底层，而且并未针对流式应用结果的准确性和一致性提供内置保障。其结果完全取决于事件到达的时间和顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These tasks can be of the same operator (data parallelism), a different operator (task parallelism), or even from a different application (job parallelism).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041312Z" creationid="xccui" creationdate="20190423T041251Z">
        <seg>这些任务可以属于同一个算子（数据并行），也可以是不同算子（任务并行），甚至还可以来自不同的应用（作业并行）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These tasks can be sub‐ tasks of the same operator (data parallelism), a different operator (task parallelism), or even from a different application (job parallelism).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144322Z" creationid="xccui" creationdate="20190606T144322Z">
        <seg>这些任务可以属于同一个算子（数据并行），也可以是不同算子（任务并行），甚至还可以来自不同的应用（作业并行）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are discussed further in “Declaring Keyed State at RuntimeCon‐ text” on page 154.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T223752Z" creationid="xccui" creationdate="20190607T223752Z">
        <seg>更多相关内容请见154页"在RuntimeContext中声明键值状态"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are related to record timestamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205429Z" creationid="xccui" creationdate="20190606T205410Z">
        <seg>和记录的时间戳相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can also modify the structure of the dataflow graph by either splitting a stream into multi&lt;t0/&gt;‐&lt;t1/&gt; ple streams or merging streams into a single flow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T160048Z" creationid="xccui" creationdate="20190405T160023Z">
        <seg>也可以通过单流分割或合并多条流来改变dataflow图的结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can also modify the structure of the dataflow graph by either splitting a stream into multi‐ ple streams or merging streams into a single flow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011745Z" creationid="xccui" creationdate="20190606T011745Z">
        <seg>也可以通过单流分割或合并多条流来改变dataflow图的结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They communicate via event logs instead of REST calls and hold application data as local state instead of writing it to and reading it from an external data store, such as a transactional database or key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152406Z" creationid="xccui" creationdate="20190307T152335Z">
        <seg>微服务通过REST调用进行通信，利用关系型数据库或键值存储等外部系统存储数据；而事件驱动型应用利用事件日志进行通信，而其数据会以本地状态形式存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They communicate via event logs instead of REST calls and hold application data as local state instead of writing it to and reading it from an external datastore, such as a relational database or key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213828Z" creationid="esouser" creationdate="20190603T213740Z">
        <seg>微服务通过REST调用进行通信，利用事务型数据库或键值存储等外部系统存储数据；而事件驱动型应用利用事件日志进行通信，而其数据会以本地状态形式存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They consume data from inputs, perform a computation on them, and produce data to outputs for further processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190331T223630Z" creationid="xccui" creationdate="20190331T215135Z">
        <seg>它们从输入消费数据，进行计算，然后产生数据到输出以进行下一步处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They follow the UNIX philoso&lt;t0/&gt;‐&lt;t1/&gt; phy of doing a single thing and doing it well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T171125Z" creationid="xccui" creationdate="20190227T233311Z">
        <seg>每个应用都遵循UNIX设计哲学：专注做好一件事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They follow the UNIX philosophy of doing a single thing and doing it well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200630Z" creationid="esouser" creationdate="20190603T200630Z">
        <seg>每个应用都遵循UNIX设计哲学：专注做好一件事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They must be monotonically increasing to ensure the event-time clocks of tasks are progressing and not going backward.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205400Z" creationid="xccui" creationdate="20190606T205354Z">
        <seg>必须单调递增，这是为了确保任务中的事件时间时钟正确前进，不会倒退。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of user interac&lt;t0/&gt;‐&lt;t1/&gt; tions on websites or in mobile apps, placements of orders, server logs, or sensor measurements; all of these data are streams of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T035558Z" creationid="xccui" creationdate="20190301T035451Z">
        <seg>考虑一下，无论是网站或移动应用中的用户交互还是订单下达，无论是服务器日志还是传感器测量结果，这些数据本质上都是事件流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of user interac‐ tions on websites or in mobile apps, placements of orders, server logs, or sensor measurements; all of these are streams of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T204811Z" creationid="esouser" creationdate="20190603T204811Z">
        <seg>考虑一下，无论是网站或移动应用中的用户交互还是订单下达，无论是服务器日志还是传感器测量结果，这些数据本质上都是事件流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Third, the Lambda architecture is hard to setup and maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T031328Z" creationid="xccui" creationdate="20190327T030936Z">
        <seg>最后，Lambda架构很难配置和维护，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Third, the lambda architecture is hard to set up and maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053103Z" creationid="xccui" creationdate="20190605T053047Z">
        <seg>最后，Lambda架构很难配置和维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032416Z" creationid="xccui" creationdate="20190401T032416Z">
        <seg>这类并行性称作任务并行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to migrate an application to a newer Flink version or to a different cluster or data- center.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212841Z" creationid="xccui" creationdate="20190609T212841Z">
        <seg>这允许你把应用迁移到一个新的Flink版本，或是一个不同的集群或数据中心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This application design can cause problems when applications need to evolve or scale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200010Z" creationid="esouser" creationdate="20190603T195919Z">
        <seg>该设计在应用需要升级或扩容时，容易导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect depends on the APIs of the stream processor, what kinds of state primitives it provides, and on the quality of its support for event-time processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014629Z" creationid="xccui" creationdate="20190314T062102Z">
        <seg>具体一些，这种能力依赖于流处理引擎的API、提供的状态原语以及对事件时间处理的支持程度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect depends on the APIs of the stream processor, what kinds of state primitives it provides, and the quality of its support for event-time processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T053612Z" creationid="xccui" creationdate="20190604T053132Z">
        <seg>这方面会具体依赖于流处理引擎的API、提供的状态原语以及对事件时间处理的支持程度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior can cause problems if the event times of the individual input streams of an application are not aligned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T031114Z" creationid="xccui" creationdate="20190607T031013Z">
        <seg>如果应用不同输入流的事件时间没有对齐，那么该行为会导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book couldn’t have been possible without the help and support of several amaz‐ ing people.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T160100Z" creationid="xccui" creationdate="20190605T131119Z">
        <seg>本书的付梓离不开众多能人志士的帮助和支持，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book covers the DataStream API and ProcessFunctions which provide primitives for common stream processing operations, such as windowing and asynchronous operations, and interfaces to precisely control state and time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T044508Z" creationid="xccui" creationdate="20190328T043432Z">
        <seg>本书涵盖了DataStream API和ProcessFunction的相关内容，它们提供了通用的流处理操作原语（如：窗口划分、异步操作）以及精确控制时间和状态的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book covers the DataStream API and process functions, which provide primitives for common stream processing operations, such as windowing and asynchronous operations, and interfaces to precisely control state and time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T064118Z" creationid="xccui" creationdate="20190605T060812Z">
        <seg>本书涵盖了DataStream API和处理函数的相关内容，它们提供了通用的流处理操作原语（如：窗口划分、异步操作）以及精确控制时间和状态的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book is here to help you get your job done.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210815Z" creationid="esouser" creationdate="20190603T210815Z">
        <seg>This book is here to help you get your job done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book summarizes knowledge obtained through years of design, development, and testing performed by the Apache Flink community at large.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T042941Z" creationid="xccui" creationdate="20190605T131400Z">
        <seg>本书总结了Apache Flink社区多年来在设计、开发、测试等方面整体积累的知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book will teach you everything to know about stream processing with Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T042801Z" creationid="xccui" creationdate="20190225T042801Z">
        <seg>本书将教给你用Apache Flink进行流处理的一切知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book will teach you everything you need to know about stream processing with Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031208Z" creationid="esouser" creationdate="20190603T152621Z">
        <seg>本书将教给你基于Apache Flink进行流处理的一切知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be explained by looking at the steps of a naive algorithm that takes a consistent checkpoint of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223326Z" creationid="xccui" creationdate="20190608T223205Z">
        <seg>它可以通过用朴素算法对应用建立一致性检查点的步骤加以解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter introduces the basics of Flink’s DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014914Z" creationid="xccui" creationdate="20190612T014914Z">
        <seg>本章主要介绍Flink DataStream API的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter is still rather independent of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T053557Z" creationid="xccui" creationdate="20190329T053557Z">
        <seg>本章节内容仍然独立于Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter provides relevant background information to successfully implement and operate advanced streaming applications with Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140516Z" creationid="xccui" creationdate="20190416T054356Z">
        <seg>本章会涉及使用Apache Flink成功实现并控制高级流式应用的相关背景，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This checkpointing and recovery mechanism can provide exactly-once consistency for application state, given that all operators checkpoint and restore all of their states</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T043911Z" creationid="xccui" creationdate="20190609T040709Z">
        <seg>如果所有算子都将它们全部的状态写入检查点并从中恢复，并且所有输入流的消费位置都能重置到检查点生成那一刻，那么该检查点和恢复机制就能为整个应用的状态提供精确一次的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This deployment mode is common for microservice architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041101Z" creationid="xccui" creationdate="20190423T041101Z">
        <seg>该部署模式常用于微服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This deployment mode is common for microservices architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144242Z" creationid="xccui" creationdate="20190606T144242Z">
        <seg>该部署模式常用于微服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This design can cause problems when applications need to evolve or scale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T163248Z" creationid="xccui" creationdate="20190226T163132Z">
        <seg>该设计模式在应用需要升级或扩容时，容易导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This element signifies a general note.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210810Z" creationid="esouser" creationdate="20190603T210810Z">
        <seg>This element signifies a general note.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This element signifies a tip or suggestion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210809Z" creationid="esouser" creationdate="20190603T210809Z">
        <seg>This element signifies a tip or suggestion.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This element signifies a warning or caution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210811Z" creationid="esouser" creationdate="20190603T210811Z">
        <seg>This element signifies a warning or caution.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example shows a flatMap transformation commonly found in data processing tutorials.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T061551Z" creationid="xccui" creationdate="20190613T061551Z">
        <seg>以下示例展示了数据处理教程中一个常见的flagMap转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This fea&lt;t0/&gt;‐&lt;t1/&gt; ture comes in handy when developing and testing Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T053736Z" creationid="xccui" creationdate="20190328T053645Z">
        <seg>这在开发和调试Flink应用的时候非常好用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature comes in handy when developing and testing Flink appli‐ cations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122111Z" creationid="xccui" creationdate="20190605T122111Z">
        <seg>这在开发和调试Flink应用的时候非常好用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function will be discussed in “Assigning Timestamps and Generating Watermarks” on page 111.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T035555Z" creationid="xccui" creationdate="20190607T035526Z">
        <seg>这个函数会在111页"分配时间戳和生成水位线"介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives the possibility to release cluster resources for higher-priority applications or when input data is not continuously produced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213217Z" creationid="xccui" creationdate="20190609T213202Z">
        <seg>这样可以为更高优先级的应用腾出集群资源，或者在输入数据不连续的情况下及时释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes handling of very large states, possibly exceeding memory, and ensuring that no state is lost in case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055510Z" creationid="xccui" creationdate="20190607T055446Z">
        <seg>这其中包括如何处理数量庞大、可能超出内存的状态，如何保证发生故障时状态不会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes window operators and time-based joins as well as process functions that provide the most flexibility when dealing with time in streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T042311Z" creationid="esouser" creationdate="20190603T161606Z">
        <seg>其中包含窗口算子以及一系列基于时间的连接。此外还会涉及一系列处理函数，它们为流式应用中的时间处理提供了诸多便利。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This information will come in handy when designing advanced stream‐ ing applications, setting up and configuring clusters, and operating streaming appli‐ cations as well as reasoning about their performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032507Z" creationid="xccui" creationdate="20190610T031959Z">
        <seg>在设计高级流式应用，设置并配置集群，控制流式应用并推断其性能时，这些内容都将派上用场。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also the reason it is not a good idea to override existing timestamps and watermarks in the middle of a streaming application, although this is possible with user-defined functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T041209Z" creationid="xccui" creationdate="20190607T041148Z">
        <seg>这也是为什么不建议在流式应用中途覆盖已有的时间戳和水位线（虽然这可以通过用户自定义函数实现）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is batch processing regardless of whether the architecture is based on a data warehouse or components of the Hadoop ecosystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T043423Z" creationid="xccui" creationdate="20190605T043413Z">
        <seg>无论架构是基于数据仓库还是Hadoop生态系统组件，都属于批处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is fine for some applications, but what if you are only interested in the most recent data?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043032Z" creationid="xccui" creationdate="20190406T042859Z">
        <seg>该操作对某些应用而言是可行的，但如果你只对最新的那部分数据感兴趣该怎么办？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to the maintenance techniques database sys‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044538Z" creationid="xccui" creationdate="20190605T044509Z">
        <seg>这有点类似于数据库系统为了更新物化视图而采用的维护技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to view maintenance techniques that database systems use to update materi&lt;t2/&gt;‐&lt;t3/&gt; alized views.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T060100Z" creationid="xccui" creationdate="20190317T060100Z">
        <seg>这有点类似于数据库系统为了更新物化视图而使用的视图维护技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the last call in our example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005918Z" creationid="xccui" creationdate="20190613T005918Z">
        <seg>这是我们示例中最后一个方法调用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the strictest and most challenging to achieve type of guarantee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T043916Z" creationid="xccui" creationdate="20190416T043916Z">
        <seg>这是最严格也是最难实现的一类保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very attractive especially in combination with Flink’s savepoint feature which can reset the state of an application to a previous consistent savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190313T005726Z" creationid="xccui" creationdate="20190312T214059Z">
        <seg>这在Flink保存点（savepoint）功能的加持下，尤为引人注目。所谓保存点功能是指在保证一致性的前提下，允许将应用状态重置到先前某个保存的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes development easier and sim‐ plifies cluster deployment, as you can run the exact same code in a cluster environ‐ ment without making any changes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T034912Z" creationid="xccui" creationdate="20190611T032127Z">
        <seg>这让开发过程变得更容易，也让集群部署变得更简单，因为你可以在不对代码进行任何修改的情况下直接切换到集群环境中运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes the JobManager a single point of failure for applications in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145839Z" creationid="xccui" creationdate="20190606T145818Z">
        <seg>这就导致JobManager成为Flink应用中的一个单点失效组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes the JobManager a single-point-of-failure for applications in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T044559Z" creationid="xccui" creationdate="20190502T043400Z">
        <seg>这就导致JobManager成为Flink应用中一个单点失效组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that all events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044724Z" creationid="xccui" creationdate="20190614T044724Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that all records processed by the same parallel task have access to the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T060848Z" creationid="xccui" creationdate="20190607T060836Z">
        <seg>这意味着所有在同一个并发任务之内的记录都能访问到相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means the time needed to prepare a single beverage will increase, causing each person to spend more time in the coffees hop, thus lowering the overall throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235158Z" creationid="xccui" creationdate="20190605T235136Z">
        <seg>这意味着准备单杯咖啡的时间会延长，继而导致每位顾客在店里花费的时间增加，整体吞吐量下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method returns a local or remote environment, depending on the con‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045221Z" creationid="xccui" creationdate="20190612T045221Z">
        <seg>根据调用时所处上下文的不同，这个方法可能会返回一个本地或远程环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method stores every event in a buffer until its processing has been acknowledged by all tasks in the pipeline, at which point the event can be discarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045558Z" creationid="xccui" creationdate="20190416T043634Z">
        <seg>该方法会将所有事件存在缓冲中，直到处理管道中所有任务都确认某个事件已经处理完毕才会将它丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mode is used to execute a Flink program within an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T052637Z" creationid="xccui" creationdate="20190611T052637Z">
        <seg>该模式可用于在IDE中执行Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This problem is commonly solved by delegating state management to an external system, such as a database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T054012Z" creationid="xccui" creationdate="20190414T053952Z">
        <seg>该问题通常的解决方案是将状态管理交由某个外部系统（如：数据库）完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This problem is commonly solved by delegating state manage‐ ment to an external system, such as a database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032125Z" creationid="xccui" creationdate="20190606T032125Z">
        <seg>该问题通常的解决方案是将状态管理交由某个外部系统（如：数据库）完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property can be leveraged during checkpoints and when rescaling an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T185718Z" creationid="xccui" creationdate="20190607T185319Z">
        <seg>该特性可用于检查点保存或算子扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This situation can be problematic for time-based operators that rely on an advancing clock to perform computations and clean up   their state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T032609Z" creationid="xccui" creationdate="20190607T032609Z">
        <seg>这种情形会给那些靠时钟前进来执行计算或清除状态的时间相关算子带来麻烦。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This situation is commonly known as &lt;t6/&gt;backpressure&lt;t7/&gt; and there exist different strategies to deal with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T202658Z" creationid="xccui" creationdate="20190402T202106Z">
        <seg>这种情形通常被称为背压（backpressure），可以通过多种策略来处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This situation is commonly known as backpressure and there are different strategies to deal with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234857Z" creationid="xccui" creationdate="20190605T234829Z">
        <seg>这种情形通常被称为背压（backpressure），它可以通过多种策略来处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This state can be updated by incoming events and can be used in the processing logic of future events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T040548Z" creationid="xccui" creationdate="20190405T040313Z">
        <seg>它们的状态会根据传入的事件更新，并用于未来事件的处理逻辑中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This state can be upda‐ ted by incoming events and can be used in the processing logic of future events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235848Z" creationid="xccui" creationdate="20190605T235848Z">
        <seg>它们的状态会根据传入的事件更新，并用于未来事件的处理逻辑中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is fun&lt;t0/&gt;‐&lt;t1/&gt; damental to effectively utilize the networking resource and achieve high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041748Z" creationid="xccui" creationdate="20190504T041748Z">
        <seg>该技术是有效利用网络资源、实现高吞吐的基础。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is funda‐ mental to effectively using the networking resource and achieving high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195459Z" creationid="xccui" creationdate="20190606T195459Z">
        <seg>该技术是有效利用网络资源、实现高吞吐的基础。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is used to recover from failures but can also be leveraged to update an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T211855Z" creationid="esouser" creationdate="20190603T211855Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is used to recover from failures but can also be leveraged to update an application, fix bugs and repair previously emitted results, migrate an application to a different cluster, or perform A/B tests with different application versions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T145302Z" creationid="xccui" creationdate="20190305T145014Z">
        <seg>该技术不但可用于失败恢复，还可用于应用更新、bug修复、结果修正、集群迁移或针对不同版本应用执行A/B测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of application is called a data pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T042644Z" creationid="xccui" creationdate="20190605T042611Z">
        <seg>我们将此类应用称为数据管道，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is also known as “no guar‐ antee” since even a system that drops every event can provide this guarantee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034419Z" creationid="xccui" creationdate="20190606T034419Z">
        <seg>这类保障也被称作"没有保障"，因为即便系统丢掉所有事件也能满足。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is also known as “no-guarantee” since even a system that drops every event can fulfil it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T184916Z" creationid="xccui" creationdate="20190415T184739Z">
        <seg>这类保障也被称作"没有保障"，因为即便系统丢掉所有事件也能满足。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is called at-least-once and it means that all events will def&lt;t0/&gt;‐&lt;t1/&gt; initely be processed, even though some of them might be processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041957Z" creationid="xccui" creationdate="20190416T041845Z">
        <seg>这类保障称为至少一次。它意味着所有事件最终都会处理，即便有些可能会处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is called at-least-once, and it means that all events will be pro‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034604Z" creationid="xccui" creationdate="20190606T034604Z">
        <seg>这类保障称为至少一次。它意味着所有事件最终都会处理，即便有些可能会处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of parallelism is called data parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233240Z" creationid="xccui" creationdate="20190401T030647Z">
        <seg>这种并行称作数据并行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of parallelism is called task parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233311Z" creationid="xccui" creationdate="20190605T233305Z">
        <seg>这种并行称为数据并行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, open source communities are constantly improving the capabilities of their projects and are pushing the technical boundaries of stream processing further.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T041353Z" creationid="xccui" creationdate="20190322T035856Z">
        <seg>这样，开源社区不断增强它们项目的功能并在流处理领域开疆拓土。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, the time to prepare a sin&lt;t0/&gt;‐&lt;t1/&gt; gle beverage will increase, causing each person to spend more time in the coffee shop, thus lowering the overall throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210136Z" creationid="xccui" creationdate="20190402T205924Z">
        <seg>这样的话，准备单杯咖啡的时间就会延长，继而导致每名顾客在店里花费的时间增加，整体吞吐量下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will generate a Maven project for Flink 1.7.1 in a folder called flink-scala-project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005158Z" creationid="xccui" creationdate="20190612T005158Z">
        <seg>上述命令会为Flink 1.7.1版本生成一个Maven项目，放在flink-scala-project文件夹内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will initialize the state of the application to the state of the save‐ point and run the application from the point at which the savepoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211521Z" creationid="xccui" creationdate="20190609T211509Z">
        <seg>这样可以用保存点内的数据初始化状态并从生成保存点的那一刻继续运行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This works because broadcasting state ensures that all tasks have the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061853Z" creationid="xccui" creationdate="20190608T061836Z">
        <seg>这样做的原因是广播状态能确保所有任务的状态相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Threads are more lightweight than separate processes and have lower communication costs but do not strictly isolate tasks from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063219Z" creationid="xccui" creationdate="20190424T063109Z">
        <seg>和独立进程相比，线程更加轻量并且通信开销更低，但无法严格地将任务彼此隔离。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195249Z" creationid="xccui" creationdate="20190401T195249Z">
        <seg>吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput is a measure of the system’s processing capacity, i.e. its &lt;t0/&gt;rate&lt;t1/&gt; of processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195449Z" creationid="xccui" creationdate="20190401T195333Z">
        <seg>吞吐是用来衡量系统处理能力（处理速率）的指标，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput is a measure of the system’s processing capacity—its rate of processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234345Z" creationid="xccui" creationdate="20190605T234345Z">
        <seg>吞吐是用来衡量系统处理能力（处理速率）的指标，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput is measured in events or operations per time unit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T200345Z" creationid="xccui" creationdate="20190401T200345Z">
        <seg>吞吐以每个单位时间的事件或操作数来衡量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, an event might belong to multiple buckets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013221Z" creationid="xccui" creationdate="20190606T013145Z">
        <seg>这意味着每个事件可能会同时属于多个桶。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, an&lt;t1/&gt; &lt;t2/&gt;event might belong to multiple buckets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024049Z" creationid="xccui" creationdate="20190407T023736Z">
        <seg>这意味着每个事件可能会属于多个桶。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, for applications where speed is more important than accuracy, processing time comes handy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043219Z" creationid="xccui" creationdate="20190414T041302Z">
        <seg>因此对于那些更重视处理速度而非准确度的应用而言，处理时间用起来很方便。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, for applications where speed is more important than accuracy, processing time comes in handy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T030938Z" creationid="xccui" creationdate="20190606T030938Z">
        <seg>因此对于那些更重视处理速度而非准确度的应用而言，处理时间用起来很方便。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the latency is bounded by the arrival time of the last event in each batch and naturally depends on the batch size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T200248Z" creationid="xccui" creationdate="20190401T193810Z">
        <seg>因此处理延迟受制于每个批次最迟事件的时间，且天然依赖批次大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, you wait in line and when it is your turn you make an order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T152842Z" creationid="xccui" creationdate="20190401T152507Z">
        <seg>这时候你就需要排队，等轮到你的时候再开始点单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, you wait in line and when it is your turn you place an order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233857Z" creationid="xccui" creationdate="20190605T233857Z">
        <seg>这时候你就需要排队，等轮到你的时候再开始点单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time Semantics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144012Z" creationid="esouser" creationdate="20190603T144012Z">
        <seg>时间语义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time Semantics | 27</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041436Z" creationid="xccui" creationdate="20190606T041436Z">
        <seg>时间语义 | 27</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time is perhaps the most important aspect of stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T200209Z" creationid="xccui" creationdate="20190409T200209Z">
        <seg>时间可能是流处理中最重要的方面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time semantics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015458Z" creationid="xccui" creationdate="20190225T015458Z">
        <seg>时间语义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time to get our hands dirty and start developing Flink applications!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190224T174724Z" creationid="xccui" creationdate="20190224T174724Z">
        <seg>是时候撸起袖子着手开发Flink应用了！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time- based tumbling windows define a time interval during which events are buffered in the bucket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013049Z" creationid="xccui" creationdate="20190606T013049Z">
        <seg>基于时间的（time-based）滚动窗口定义在桶中缓冲数据的时间间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-Based and Window Operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145657Z" creationid="esouser" creationdate="20190603T145657Z">
        <seg>基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based and Window Operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022953Z" creationid="xccui" creationdate="20190225T022953Z">
        <seg>基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based operators use this time to trigger computations and make progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T041707Z" creationid="xccui" creationdate="20190523T041707Z">
        <seg>基于时间的算子会使用这个时间来触发计算并向前推进。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based tumbling window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013123Z" creationid="xccui" creationdate="20190606T013122Z">
        <seg>基于时间的滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based tumbling window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023609Z" creationid="xccui" creationdate="20190407T023609Z">
        <seg>基于时间的滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based tumbling windows define a time interval during which events are buffered in the bucket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023258Z" creationid="xccui" creationdate="20190407T023053Z">
        <seg>基于时间的（time-based）滚动窗口定义在桶中缓冲数据的时间间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-related operators such as window operators and other specialized trans‐ formations are described in later chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T013239Z" creationid="xccui" creationdate="20190613T013033Z">
        <seg>基于时间的算子（例如窗口算子）以及其他一些特殊转换会在后面章节介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TimerService and Timers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145847Z" creationid="esouser" creationdate="20190603T145847Z">
        <seg>时间服务和定时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamp Assignment and Watermark Generation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144538Z" creationid="xccui" creationdate="20190225T021938Z">
        <seg>时间戳分配和水位线生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155747Z" creationid="xccui" creationdate="20190225T021851Z">
        <seg>时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and watermarks are usually assigned and generated when a stream is ingested by a streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033706Z" creationid="xccui" creationdate="20190607T033653Z">
        <seg>时间戳和水位线通常都是在数据流刚刚进入流处理应用的时候分配和生成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and watermarks for event-time applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023039Z" creationid="xccui" creationdate="20190225T023039Z">
        <seg>事件时间应用中的时间戳和watermark</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps usually exist inside the event data before they enter the processing pipeline (e.g. event cre&lt;t2/&gt;‐&lt;t3/&gt; ation time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150102Z" creationid="xccui" creationdate="20190412T150102Z">
        <seg>这些时间戳通常在事件数据进入流处理管道之前就存在（例如：事件生成时间）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps usually exist inside the event data before they enter the processing pipeline (e.g., the event creation time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024140Z" creationid="xccui" creationdate="20190606T024140Z">
        <seg>这些时间戳通常在事件数据进入流处理管道之前就存在（例如：事件生成时间）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To assess end-to-end guarantees, one has to consider all the components of an application pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045840Z" creationid="xccui" creationdate="20190416T045830Z">
        <seg>为了评估它，需要考虑应用处理管道上的所有组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To better understand the con&lt;t4/&gt;‐&lt;t5/&gt; cept of peak throughput, let us consider that system resources are completely unused.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T204336Z" creationid="xccui" creationdate="20190401T204219Z">
        <seg>为了更好地理解峰值吞吐的概念，我们假设系统资源完全空闲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To better understand the con‐ cept of peak throughput, let’s consider a stream processing application that does not receive any incoming data and thus does not consume any system resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234637Z" creationid="xccui" creationdate="20190605T234611Z">
        <seg>为了更好地理解峰值吞吐的概念，我们先假设某个流处理应用没有在接收到来的数据，无需占用任何系统资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To comment or ask technical questions about this book, send email to bookques‐ tions@oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210844Z" creationid="esouser" creationdate="20190603T210844Z">
        <seg>To comment or ask technical questions about this book, send email to bookques‐ tions@oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To date, more than five hundred individu‐ als have contributed to Flink, and it has evolved into one of the most sophisticated open source stream processing engines as proven by its widespread adoption.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T045427Z" creationid="esouser" creationdate="20190603T162900Z">
        <seg>截至目前，项目已经有超过470名贡献者，并在不断普及的过程中逐渐演变为开源界最为复杂的流处理引擎之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To limit the state size, operators usually maintain some kind of summary or &lt;t0/&gt;synopsis&lt;t1/&gt; of the events seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055014Z" creationid="xccui" creationdate="20190414T054943Z">
        <seg>为了限制状态大小，算子通常都会只保留到目前为止所见事件的摘要或概览。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To limit the state size, operators usually maintain some kind of summary or synopsis of the events seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032413Z" creationid="xccui" creationdate="20190606T032413Z">
        <seg>为了限制状态大小，算子通常都会只保留到目前为止所见事件的摘要或概览。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To overcome this problem, Flink supports a high-availability mode that migrates the responsibility and metadata for a job to another JobManager in case that the original JobManager disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T044628Z" creationid="xccui" creationdate="20190502T044050Z">
        <seg>为了解决该问题，Flink提供了高可用模式，支持在原JobManager消失的情况下将作业的管理职责及元数据迁移到另一个JobManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To over‐ come this problem, Flink supports a high-availability mode that migrates the respon‐ sibility and metadata for a job to another JobManager in case the original JobManager disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145905Z" creationid="xccui" creationdate="20190606T145905Z">
        <seg>为了解决该问题，Flink提供了高可用模式，支持在原JobManager消失的情况下将作业的管理职责及元数据迁移到另一个JobManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To produce a result, a UDF accumulates state over a period or number of events, e.g. to compute an aggregation or detect a pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T051900Z" creationid="xccui" creationdate="20190414T051733Z">
        <seg>为了生成结果，UDF会在一段时间或基于一定个数的事件来累积状态，如：计算聚合或检测某个模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To produce a result, a function accumulates state over a period of time or number of events (e.g., to compute an aggregation or detect a pattern).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031502Z" creationid="xccui" creationdate="20190606T031435Z">
        <seg>为了生成结果，函数会在一段时间或基于一定个数的事件来累积状态（例如：计算聚合或检测某个模式）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prop&lt;t0/&gt;‐&lt;t1/&gt; erly define window operator semantics, we need to answer two main questions: “&lt;t2/&gt;how&lt;t3/&gt; &lt;t4/&gt;are events assigned to buckets?&lt;t5/&gt;” and “&lt;t6/&gt;how often does the window produce a result?&lt;t7/&gt;”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022727Z" creationid="xccui" creationdate="20190406T045045Z">
        <seg>为了准确定义窗口算子语义，我们需要回答两个核心问题："事件如何分配到桶中"以及"窗口以什么频率产生结果"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prop‐ erly define window operator semantics we need to determine both how events are assigned to buckets and how often the window produces a result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012636Z" creationid="xccui" creationdate="20190606T012334Z">
        <seg>为了准确定义窗口算子语义，我们需要决定事件如何分配到桶中以及窗口以怎样的频率产生结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recap, processing time offers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031242Z" creationid="xccui" creationdate="20190606T031242Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recap, processing time offers low latency but results depend on the speed of processing and are not deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050354Z" creationid="xccui" creationdate="20190414T045432Z">
        <seg>总之，虽然处理时间提供了很低的延迟，但它的结果依赖处理速度，具有不确定性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recover from fail&lt;t0/&gt;‐&lt;t1/&gt; ures, the system needs to deal with two aspects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205059Z" creationid="xccui" creationdate="20190428T204311Z">
        <seg>为了从故障中恢复，系统需要做两手处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recover from fail‐ ures, the system first needs to restart failed processes, and second, restart the applica‐ tion and recover its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145331Z" creationid="xccui" creationdate="20190606T145331Z">
        <seg>为了从故障中恢复，系统首先需要重启故障进程，随后需要重启应用并恢复其状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To some extent, the latency can be reduced by importing data into the data store with data pipeline applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032021Z" creationid="xccui" creationdate="20190317T032021Z">
        <seg>在某种程度上，使用数据管道应用来导入数据可以降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To some extent, the latency can be reduced by importing data into the datastore with a data pipeline application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T043556Z" creationid="xccui" creationdate="20190605T043556Z">
        <seg>在某种程度上，使用数据管道应用来导入数据可以降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To start the application, run the main() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042857Z" creationid="xccui" creationdate="20190611T042842Z">
        <seg>直接运行它就能启动应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To structure a typical Flink streaming application:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043456Z" creationid="xccui" creationdate="20190612T043456Z">
        <seg>构建一个典型的Flink流式应用需要以下步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To understand latency intuitively, consider your daily visit to your favorite coffee shop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233829Z" creationid="xccui" creationdate="20190401T152125Z">
        <seg>为了直观地理解延迟，想一下你每天都会光顾自己喜欢的咖啡店。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, components of the Apache Hadoop ecosystem are integral parts in the IT infrastructures of many enterprises and companies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T032150Z" creationid="xccui" creationdate="20190228T210817Z">
        <seg>时至今日，Apache Hadoop生态组件已经成为很多公司和企业IT基础架构中举足轻重的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, components of the Apache Hadoop ecosystem are integral parts in the IT infrastructures of many enterprises.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T204436Z" creationid="esouser" creationdate="20190603T203736Z">
        <seg>时至今日，Apache Hadoop生态组件已经成为很多公司和企业IT基础设施中举足轻重的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, distributed open source stream processors power business-critical applications in many enterprises across dif&lt;t2/&gt;‐&lt;t3/&gt; ferent industries such as (online) retail, social media, telecommunication, gaming, and banking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014807Z" creationid="xccui" creationdate="20190319T041711Z">
        <seg>如今，开源分布式流处理引擎已经支撑起包括（在线）零售、社交媒体、移动通信、游戏、银行等很多不同行业的核心业务应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, dis‐ tributed open source stream processors power business-critical applications in many</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050251Z" creationid="xccui" creationdate="20190605T050251Z">
        <seg>如今，开源分布式流处理引擎已经支撑起包括（在线）零售、社交媒体、移动通信、游戏、银行等很多不同行业的核心业务应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today’s IT architectures include many different data stores, such as relational and special-purpose database systems, event logs, distributed file systems, in-memory caches, and search indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T013908Z" creationid="xccui" creationdate="20190314T064734Z">
        <seg>今日的IT架构通常会涵盖多种不同的数据存储，例如：关系型或专用数据库系统、事件日志系统、分布式文件系统、内存缓存、搜索索引等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today’s IT architectures include many different datastores, such as relational and special-purpose database systems, event logs, distributed filesystems, in-memory caches, and search indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T053748Z" creationid="xccui" creationdate="20190604T053748Z">
        <seg>今日的IT架构通常会涵盖多种不同的数据存储，例如：关系型或专用数据库系统、事件日志系统、分布式文件系统、内存缓存、搜索索引等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tokyo</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210643Z" creationid="esouser" creationdate="20190603T210643Z">
        <seg>Tokyo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional Data Infrastructures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014533Z" creationid="xccui" creationdate="20190225T014533Z">
        <seg>传统数据处理架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional Data Infrastructures   | 3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203023Z" creationid="esouser" creationdate="20190603T203023Z">
        <seg>传统数据处理架构 | 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional analytics pipelines consist of several individual components such as an ETL process, a storage system, and in case of a Hadoop-based environment also a data processor and scheduler to trigger jobs or queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062950Z" creationid="xccui" creationdate="20190317T062820Z">
        <seg>传统分析流水线包含了很多独立组件，例如：ETL进程、存储系统等。即便是基于Hadoop的环境，也需要有数据处理器和用来触发作业或查询的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional analytics pipelines consist of several individual components such as an ETL process, a storage system, and in the case of a Hadoop-based environment, a data processor and scheduler to trigger jobs or queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044756Z" creationid="xccui" creationdate="20190605T044756Z">
        <seg>传统分析流水线包含了很多独立组件，例如：ETL进程、存储系统等。即便是基于Hadoop的环境，也需要有数据处理器和用来触发作业或查询的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional batch oriented architectures are not able to address such use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T054141Z" creationid="xccui" creationdate="20190317T054141Z">
        <seg>面向批次的传统架构根本无力应对它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional design of transactional applications that store data in a remote database system</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T195357Z" creationid="esouser" creationdate="20190603T195332Z">
        <seg>将数据存储在远程数据库系统内的传统事务型应用设计</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142849Z" creationid="esouser" creationdate="20190603T142849Z">
        <seg>事务型处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional Sink Connectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025317Z" creationid="xccui" creationdate="20190225T025317Z">
        <seg>事务性汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional Writes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151955Z" creationid="esouser" creationdate="20190603T151955Z">
        <seg>事务型写</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T061953Z" creationid="xccui" creationdate="20190226T161728Z">
        <seg>事务型应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional updates are one way to achieve this result, but they can incur substantial performance overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034940Z" creationid="xccui" creationdate="20190606T034907Z">
        <seg>事务性更新是实现该目标的一个方法，但它可能会带来极大的性能开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional updates is one way to achieve this result, however, it can incur substantial performance over&lt;t0/&gt;‐&lt;t1/&gt; head.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044921Z" creationid="xccui" creationdate="20190416T044551Z">
        <seg>事务性更新是达到该结果的一个方法，但它可能会带来极大的性能开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformation operations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152748Z" creationid="xccui" creationdate="20190405T152748Z">
        <seg>转换操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformation operations are single-pass operations that process each event inde&lt;t0/&gt;‐&lt;t1/&gt; pendently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T153157Z" creationid="xccui" creationdate="20190405T152939Z">
        <seg>转换操作是一种"单向"操作，会独立处理每个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformation operations are single-pass operations that process each event inde‐ pendently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T010742Z" creationid="xccui" creationdate="20190606T010742Z">
        <seg>转换操作是一种"单向"操作，会独立处理每个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022706Z" creationid="xccui" creationdate="20190225T022706Z">
        <seg>转换操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations and rolling aggregations process one event at a time to produce out&lt;t0/&gt;‐&lt;t1/&gt; put events and potentially update state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041821Z" creationid="xccui" creationdate="20190406T035950Z">
        <seg>转换操作和滚动聚合每次处理一个事件来产生输出并（可能）更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations and rolling aggregations process one event at a time to produce out‐ put events and potentially update state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011956Z" creationid="xccui" creationdate="20190606T011956Z">
        <seg>转换操作和滚动聚合每次处理一个事件来产生输出并（可能）更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True stream processing does not introduce such artificial delays and therefore can achieve really low latencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T194716Z" creationid="xccui" creationdate="20190401T194107Z">
        <seg>真正的流处理不会引入人为推迟等要素，因此才能实现极低的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True stream processing does not intro‐ duce such artificial delays and thus can achieve really low latencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234321Z" creationid="xccui" creationdate="20190605T234321Z">
        <seg>真正的流处理不会引入人为推迟等要素，因此才能实现极低的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tumbling &lt;t0/&gt;windows assign events into non-overlapping buckets of fixed size.&lt;t1/&gt; &lt;t2/&gt;When the window border is passed, all the events are sent to an evaluation func&lt;t3/&gt;‐&lt;t4/&gt; tion for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022909Z" creationid="xccui" creationdate="20190406T050614Z">
        <seg>滚动窗口（tumbling window）将事件分配到长度固定且互不重叠的桶中。在窗口边界通过后，所有事件会发送给计算函数处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tumbling windows assign events into nonoverlapping buckets of fixed size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013019Z" creationid="xccui" creationdate="20190606T013011Z">
        <seg>滚动窗口（tumbling window）将事件分配到长度固定且互不重叠的桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuning Checkpointing and Recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030028Z" creationid="xccui" creationdate="20190225T030028Z">
        <seg>Checkpointing调试和恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two tasks of a sum operator compute the running sums of all even and odd numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T030906Z" creationid="xccui" creationdate="20190609T030813Z">
        <seg>求和算子的两个任务会分别对它们求和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022759Z" creationid="xccui" creationdate="20190225T022759Z">
        <seg>类型系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical real-world setups can easily have hundreds of such tasks running in parallel on many physical machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T041708Z" creationid="xccui" creationdate="20190415T041636Z">
        <seg>典型的现实设置可以轻松达到在很多物理机器上并行运行数以百计的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical use cases for event-driven applications include</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T024821Z" creationid="xccui" creationdate="20190307T024821Z">
        <seg>事件驱动型应用的典型应用场景有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical use cases for event-driven applications include:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213603Z" creationid="esouser" creationdate="20190603T213603Z">
        <seg>事件驱动型应用的典型应用场景有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical use cases for streaming analytics applications are</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033324Z" creationid="xccui" creationdate="20190319T033305Z">
        <seg>典型的流式分析用例包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, a database system serves multiple applications which often even access the same databases or tables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T184437Z" creationid="xccui" creationdate="20190226T163003Z">
        <seg>通常情况下，多个应用会共用一个数据库系统，更有甚者，这些应用会访问相同的数据库或表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, an external resource manager such as Kubernetes takes care of starting the images and ensures that containers are restarted in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144108Z" creationid="xccui" creationdate="20190606T143951Z">
        <seg>通常情况下，是由外部资源管理器（如：Kubernetes）负责启动映像，并确保在故障时可以重启容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, an external resource manager such as Kubernetes takes care of starting the images and ensuring that of each type a certain number of containers is running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T040551Z" creationid="xccui" creationdate="20190423T040305Z">
        <seg>通常情况下，是由外部资源管理器（如：Kubernetes）负责启动映像，并各类型容器都以指定数量运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, streaming applications store their result in an external data store that supports efficient updates, such as a database or key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T060355Z" creationid="xccui" creationdate="20190317T060355Z">
        <seg>通常情况下，流式应用会把它们的结果保存在某种支持高效更新的外部数据存储中，例如：一般数据库或键值存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, there are multiple TaskManagers running in a Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142319Z" creationid="xccui" creationdate="20190606T142319Z">
        <seg>通常在Flink设置过程中要启动多个TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, there are multiple&lt;t1/&gt; &lt;t2/&gt;TaskManager running in a Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T051413Z" creationid="xccui" creationdate="20190418T051413Z">
        <seg>通常在Flink设置过程中要启动多个TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, there are two classes of queries executed on a data warehouse.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T193921Z" creationid="xccui" creationdate="20190228T192320Z">
        <seg>通常可将数据仓库中的查询分为两类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UDFs are written by the application programmer and implement custom computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T155205Z" creationid="xccui" creationdate="20190405T155205Z">
        <seg>UDF由应用开发人员编写，实现某些自定义的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Union list state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184319Z" creationid="xccui" creationdate="20190607T184319Z">
        <seg>联合列表状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless you specify a parallelism, a program is executed by as many threads as the number of CPU threads of your development machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T053929Z" creationid="xccui" creationdate="20190611T053929Z">
        <seg>除非手工指定并行度，否则程序的线程数会和你开发机器的CPU线程数一样多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until the rise of Apache Hadoop, specialized analytical database systems and data warehouses were the predominant solutions for data analytics workloads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T203754Z" creationid="xccui" creationdate="20190228T194848Z">
        <seg>在Apache Hadoop出现前，专业分析型数据库系统和数据仓库共同占据着数据分析的江山。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until today, more than 470 individuals have contributed to Flink and it has evolved into one of the most sophisticated open source stream processing engines as proven by its widespread adoption.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T222146Z" creationid="xccui" creationdate="20190225T220444Z">
        <seg>时至今日，它已经有超过470名贡献者，并在不断普及的过程中逐渐演变为开源界最为复杂的流处理引擎之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Up to this point, we have considered streaming concepts independently of Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051903Z" creationid="xccui" creationdate="20190416T051823Z">
        <seg>到目前为止，我们考虑的流处理相关概念都是独立于Apache Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating Results by Including Late Events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150802Z" creationid="xccui" creationdate="20190225T023500Z">
        <seg>基于迟到事件更新结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating an Application without Modifying Existing State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024908Z" creationid="xccui" creationdate="20190225T024908Z">
        <seg>保持状态的应用升级</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating the event time of a task with watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025639Z" creationid="xccui" creationdate="20190607T025639Z">
        <seg>利用水位线更新任务的事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon completion of a check‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T150247Z" creationid="xccui" creationdate="20190606T150247Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon the completion of a checkpoint, i.e., when all tasks have successfully written their state into the remote storage, the JobManager writes the state handles to the remote storage and a pointer to this location to ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051010Z" creationid="xccui" creationdate="20190502T050555Z">
        <seg>在checkpoint即将完成之际，如果所有任务已经将各自状态成功写入远程存储，JobManager就会将状态句柄写入远程存储，并将远程位置的指针写入ZooKeeper。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the information and instructions contained in this work is at your own risk.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210741Z" creationid="esouser" creationdate="20190603T210741Z">
        <seg>Use of the information and instructions contained in this work is at your own risk.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used for program listings, as well as within paragraphs to refer to program ele‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210803Z" creationid="esouser" creationdate="20190603T210803Z">
        <seg>Used for program listings, as well as within paragraphs to refer to program ele‐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-defined timestamp assignment functions are usually applied as close to a source operator as possible because it can be very difficult to reason about the order of records and their timestamps after they have been processed by an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T041030Z" creationid="xccui" creationdate="20190607T040633Z">
        <seg>用户自定义的时间戳分配函数通常都会尽可能地靠近数据源算子，因为在经过其他算子处理后，记录顺序和它们的时间戳会变得难以推断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users are organized in teams and the application collects a team’s activity and provides rewards in the game, such as extra lives and level-ups, based on how fast the team’s members meet the game’s goals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152242Z" creationid="xccui" creationdate="20190411T144758Z">
        <seg>用户按团队进行组织，应用会收集团队的活动信息，并基于团队成员完成游戏目标的速度，提供诸如额外生命或等级提升的游戏奖励。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Code Examples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210812Z" creationid="esouser" creationdate="20190603T210812Z">
        <seg>Using Code Examples</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Connected Broadcast State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024605Z" creationid="xccui" creationdate="20190225T024605Z">
        <seg>使用Connected Broadcast State</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210933Z" creationid="xccui" creationdate="20190609T063118Z">
        <seg>保存点的使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using task parallelism you can better uti&lt;t0/&gt;‐&lt;t1/&gt; lize the computing resources of a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034154Z" creationid="xccui" creationdate="20190401T032431Z">
        <seg>通过任务并行，可以更好地利用集群的计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using task parallelism, you can better utilize the computing resources of a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233318Z" creationid="xccui" creationdate="20190605T233318Z">
        <seg>通过任务并行，可以更好地利用集群的计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the CheckpointedFunction Interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024618Z" creationid="xccui" creationdate="20190225T024618Z">
        <seg>使用CheckpointedFunction接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using these exam‐ ples, we will show how Flink applications are executed and debugged in an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T040616Z" creationid="xccui" creationdate="20190610T040506Z">
        <seg>这些示例将向你展示如何在IDE中执行和调试Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually, the program’s</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T051407Z" creationid="xccui" creationdate="20190611T051407Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T215622Z" creationid="xccui" creationdate="20190607T192625Z">
        <seg>单值状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Virtually all data is created as continuous streams of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T034956Z" creationid="xccui" creationdate="20190301T034927Z">
        <seg>几乎所有数据都是以连续事件流的形式产生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wait for all in-flight data to be completely processed, meaning all tasks have pro‐ cessed all their input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223921Z" creationid="xccui" creationdate="20190608T223647Z">
        <seg>等待已经流入系统的数据被完全处理，即所有任务已经处理完所有的输入数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watch us on YouTube: http://www.youtube.com/oreillymedia</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210847Z" creationid="esouser" creationdate="20190603T210847Z">
        <seg>Watch us on YouTube: http://www.youtube.com/oreillymedia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermark Propagation and Event Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144528Z" creationid="xccui" creationdate="20190225T021907Z">
        <seg>水位线传播和事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155415Z" creationid="xccui" creationdate="20190412T155415Z">
        <seg>水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are essential for both event-time win‐ dows and operators handling out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025515Z" creationid="xccui" creationdate="20190606T025515Z">
        <seg>水位线无论对于事件时间窗口还是处理乱序事件的算子都很关键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are essential to both event-time windows and operators handling out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205616Z" creationid="xccui" creationdate="20190412T205616Z">
        <seg>水位线无论对于事件时间窗口还是处理乱序事件的算子都很关键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are related to record timestamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042558Z" creationid="xccui" creationdate="20190523T042558Z">
        <seg>水位线和记录的时间戳紧密相关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are used to derive the current event time at each task in an event-time application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205105Z" creationid="xccui" creationdate="20190606T205105Z">
        <seg>水位线用于推断事件时间应用中每个任务当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are used to derive the current event-time at each task in an event-time application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T041537Z" creationid="xccui" creationdate="20190523T040931Z">
        <seg>水位线用于推断事件时间应用中每个任务当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks flow in a stream of regular records with annotated timestamps as &lt;t0/&gt;Figure 3-8&lt;t1/&gt; shows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042250Z" creationid="xccui" creationdate="20190523T042250Z">
        <seg>如图3-8所示，它像带有注释时间戳的常规记录一样在数据流中移动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks flow in a stream of regular records with annotated time‐ stamps as Figure 3-8 shows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205307Z" creationid="xccui" creationdate="20190606T205307Z">
        <seg>如图3-8所示，它像带有注释时间戳的常规记录一样在数据流中移动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks have two basic properties.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042342Z" creationid="xccui" creationdate="20190523T042339Z">
        <seg>水位线拥有两个基本属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks have two basic properties:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205349Z" creationid="xccui" creationdate="20190606T205348Z">
        <seg>水位线拥有两个基本属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks must be monotonically increasing in order to ensure that the event-time clocks of tasks are progressing and not going backwards.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042533Z" creationid="xccui" creationdate="20190523T042505Z">
        <seg>水位线必须单调递增，这是为了确保任务中的事件时间时钟正确前进，不会倒退。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks provide a configurable trade-off between results confidence and latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210429Z" creationid="xccui" creationdate="20190412T210154Z">
        <seg>水位线允许我们在结果的准确性和延迟之间调整取舍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks provide a configurable tradeoff between results confidence and latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025633Z" creationid="xccui" creationdate="20190606T025603Z">
        <seg>水位线允许我们在结果的准确性和延迟之间做出取舍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks that are very tight, i.e., close to the record timestamps, result in low processing latency because a task will only briefly wait for more records to arrive before finalizing a computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040459Z" creationid="xccui" creationdate="20190529T040214Z">
        <seg>如果水位线很紧密（靠近记录时间戳），得到结果的处理延迟就会很低，因为任务无须等待多少记录到来就可以触发最终计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks that are very tight—close to the record timestamps—result in low processing latency because a task will only briefly wait for more records to arrive before finalizing a computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T210129Z" creationid="xccui" creationdate="20190606T205826Z">
        <seg>如果水位线很紧（靠近记录时间戳），得到结果的处理延迟就会很低，因为任务无须等待多少记录到来就可以触发最终计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks, Latency, and Completeness</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030551Z" creationid="xccui" creationdate="20190225T023059Z">
        <seg>水位线、延迟及完整性问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also assume per&lt;t2/&gt;‐&lt;t3/&gt; fect failure detectors and that no task will intentionally act maliciously; that is, all non-failed tasks follow the above steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043852Z" creationid="xccui" creationdate="20190415T043600Z">
        <seg>我们还假设任何故障都会被检测到，没有任务故意捣乱。换言之，所有正常运行的任务都会遵循上述步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also assume perfect failure detectors and that no task will intentionally act mali‐ ciously, meaning all nonfailed tasks follow the above steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033718Z" creationid="xccui" creationdate="20190606T033718Z">
        <seg>我们还假设任何故障都会被检测到，没有任务故意捣乱。换言之，所有正常运行的任务都会遵循上述步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also discuss Flink’s unique savepoint feature, a “Swiss Army knife”-like tool that addresses many challenges of operating streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154419Z" creationid="xccui" creationdate="20190608T154131Z">
        <seg>此外我们还会讨论Flink所独有的保存点机制，它就像一把瑞士军刀，解决了运行流式应用中的诸多挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also provide complete example applications implemented in Java and Scala in our GitHub repositories.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T034647Z" creationid="xccui" creationdate="20190612T034647Z">
        <seg>我们在Github仓库中同时提供了用Java和Scala实现的完整示例程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We appreciate, but do not require, attribution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210822Z" creationid="esouser" creationdate="20190603T210822Z">
        <seg>We appreciate, but do not require, attribution.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We are grateful to everyone who has contributed to Flink through code, documentation, reviews, bug reports, feature requests, mailing list discussions, trainings, conference talks, meetup organization, and other activities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T043022Z" creationid="xccui" creationdate="20190605T131706Z">
        <seg>感谢所有通过代码、文档、评论、bug报告、功能需求、邮件列表讨论、培训、会议演讲、聚会组织等一切活动为Flink做出过贡献的人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume reliable network connections, and that no records are dropped or duplicated and all events are eventually delivered to their destination in FIFO order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033708Z" creationid="xccui" creationdate="20190606T033648Z">
        <seg>我们假设网络连接是可靠的，不存在记录丢失或重复，所有事件最终都会以先进先出的顺序到达各自终点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume reliable network connections, such that no records are dropped or duplicated and all events are eventually delivered to their destination in FIFO order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043327Z" creationid="xccui" creationdate="20190415T043245Z">
        <seg>我们假设网络连接是可靠的，即不存在记录丢失或重复，所有事件最终都会以先进先出的顺序到达其终点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume the following software is installed as well, although it is not strictly required to develop Flink applications:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T020130Z" creationid="xccui" creationdate="20190611T020130Z">
        <seg>此外虽不强制，但我们假设以下软件也已装好：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We call this type of applications data pipelines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T014229Z" creationid="xccui" creationdate="20190317T014229Z">
        <seg>我们将此类应用称为数据管道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We covered basic streaming operations and how to compute meaningful results on unbounded input data using windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T040418Z" creationid="xccui" creationdate="20190606T040418Z">
        <seg>章节还涵盖了基本的流式操作以及如何利用窗口在无限输入上计算出有意义的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We define sliding windows by providing their length and their &lt;t3/&gt;slide&lt;t4/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024113Z" creationid="xccui" creationdate="20190407T024113Z">
        <seg>我们通过指定长度和滑动间隔来定义滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We define sliding windows by providing their length and their slide.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013255Z" creationid="xccui" creationdate="20190606T013255Z">
        <seg>我们通过指定长度和滑动间隔来定义滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe both notions in the fol&lt;t0/&gt;‐&lt;t1/&gt; lowing sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143746Z" creationid="xccui" creationdate="20190412T143518Z">
        <seg>接下来的几节我们来介绍一下它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe both notions in the fol‐ lowing sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023821Z" creationid="xccui" creationdate="20190606T023752Z">
        <seg>我们将在接下来的几节介绍它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe how to assign operator identifiers in detail in “Specifying Unique Operator Identifiers” on page 168.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T030854Z" creationid="xccui" creationdate="20190610T030851Z">
        <seg>有关分配算子标识的详细内容会在168页"指定唯一算子标识"中介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the classes of applications as distinct patterns to emphasize the versatility of stateful stream processing, but most real-world applications share the properties of more than one class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213322Z" creationid="esouser" creationdate="20190603T212509Z">
        <seg>为了突出状态化流处理的不同用途，我们假设每种应用类别模式单一，但大多数真实应用都会同时具有多种类别的特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the classes of applications as distinct patterns to emphasize the versatility of stateful stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T072714Z" creationid="xccui" creationdate="20190305T155234Z">
        <seg>为了突出状态化流处理的不同用途，我们假设每种应用类别模式单一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the steps for a UNIX environment, but if you are running Windows, we recommend setting up a virtual machine with Linux, Cygwin (a Linux environment for Win‐ dows), or the Windows Subsystem for Linux, introduced with Windows 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122842Z" creationid="xccui" creationdate="20190605T122711Z">
        <seg>我们假设以下步骤都是针对UNIX环境，如果你用Windows，我们建议你配置一个Linux虚拟机，也可以安装Cygwin（一个Windows下的Linux环境）或配置一个Linux子系统（Win10中新加的功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the steps for a UNIX environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060116Z" creationid="xccui" creationdate="20190328T055241Z">
        <seg>我们将以类UNIX环境为例介绍操作步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss Flink’s fault-tolerance algorithm in &lt;t2/&gt;Chapter 3&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045041Z" creationid="xccui" creationdate="20190416T045041Z">
        <seg>我们会在第3章讨论Flink的容错算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss Flink’s fault-tolerance algorithm in “Checkpoints, Save‐ points, and State Recovery” on page 58.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035001Z" creationid="xccui" creationdate="20190606T035001Z">
        <seg>我们会在第58页讨论Flink的容错算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss all these matters in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042314Z" creationid="xccui" creationdate="20190415T042227Z">
        <seg>我们将在本节一一讨论这些问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss how a stream processor can provide accurate results with out-of-order events and how you can perform historical event processing and time travel with streaming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052726Z" creationid="xccui" creationdate="20190409T210351Z">
        <seg>我们将讨论流处理引擎如何基于乱序事件产生精确结果，以及如何进行历史事件和不同历史区间比较的分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss in &lt;t8/&gt;Chapter 10&lt;t9/&gt; how to control the scheduling of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062903Z" creationid="xccui" creationdate="20190424T062903Z">
        <seg>我们将在第10章讨论如何控制任务调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the implementation of a user-defined function in a later sec‐ tion of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054002Z" creationid="xccui" creationdate="20190612T032346Z">
        <seg>有关用户自定义函数的实现会在本章后面部分讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the responsibilities of each component and how it interacts with the other components in the following.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033707Z" creationid="xccui" creationdate="20190418T033707Z">
        <seg>我们接下来讨论各组件的职责以及它们之间是如何交互的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the semantics of all operators available in Flink in &lt;t2/&gt;Chapter 5&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T160141Z" creationid="xccui" creationdate="20190405T160124Z">
        <seg>我们将在第5章讨论Flink中各算子的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the semantics of all operators available in Flink in Chapter 5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011752Z" creationid="xccui" creationdate="20190606T011752Z">
        <seg>我们将在第5章讨论Flink中各算子的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the topic of application deployment in more detail in &lt;t2/&gt;Chap&lt;t3/&gt;‐&lt;t4/&gt; &lt;t5/&gt;ter 10&lt;t6/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041129Z" creationid="xccui" creationdate="20190423T041129Z">
        <seg>我们会在第10章节详细讨论应用部署的相关内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss this difference later in this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184754Z" creationid="xccui" creationdate="20190607T184716Z">
        <seg>详细内容将在本章稍后讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss this function in  detail in “Assigning Timestamps and Generating Watermarks” as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040454Z" creationid="xccui" creationdate="20190607T040402Z">
        <seg>我们同样会在"分配时间戳和生成水位线"一节详细讨论它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss two different styles of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141158Z" creationid="xccui" creationdate="20190606T141158Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discussed Flink’s strategies to scale stateful operators earlier in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T220025Z" creationid="xccui" creationdate="20190609T220025Z">
        <seg>我们已经在本章前面讨论过Flink对于状态化算子的扩缩容策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We dis‐ cuss the topic of application deployment in more detail in “Running and Managing Streaming Applications” on page 245.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144314Z" creationid="xccui" creationdate="20190606T144314Z">
        <seg>我们会在245页的"运行和管理流式应用"一节详细讨论应用部署的相关内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We dis‐ cussed how open source stream processing systems have evolved since their inception in the early 2010s and how stream processing became a viable solution for many use cases of today’s businesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T125656Z" creationid="xccui" creationdate="20190605T125312Z">
        <seg>我们讨论了开源流处理系统如何从二十世纪初逐步进化，成为当今许多企业用例的可行解决方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explain how state is stored and maintained by state backends and how stateful applications can be scaled by redistributing state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T053705Z" creationid="xccui" creationdate="20190607T053446Z">
        <seg>我们将解释如何利用状态后端对状态进行存储和维护，以及状态化应用如何通过状态再分配实现扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explain their semantics and show code examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T025327Z" creationid="xccui" creationdate="20190613T025327Z">
        <seg>我们将结合代码示例对它们的语义进行解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We express these performance requirements in terms of &lt;t4/&gt;latency &lt;t5/&gt;and&lt;t6/&gt; throughput&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151521Z" creationid="xccui" creationdate="20190401T151311Z">
        <seg>我们用延迟和吞吐来表示这两方面的性能需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We express these performance requirements in terms of latency and throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233804Z" creationid="xccui" creationdate="20190605T233804Z">
        <seg>我们用延迟和吞吐来表示这两方面的性能需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have a web page for this book, where we list errata, examples, and any additional information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210842Z" creationid="esouser" creationdate="20190603T210842Z">
        <seg>We have a web page for this book, where we list errata, examples, and any additional information.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have to point out that Flink’s checkpointing and recovery mechanism only resets the internal state of a streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T053624Z" creationid="xccui" creationdate="20190609T053610Z">
        <seg>我们必须指出，Flink的检查点和恢复机制仅能重置流式应用内部的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We hope that after reading this chapter, you will be able to evaluate the features of modern stream processing systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224722Z" creationid="xccui" creationdate="20190605T224722Z">
        <seg>希望阅读过后，你能对当下不同的流处理系统进行功能评估。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We hope that after reading this chapter, you will have gained a better understanding of stream applications requirements and you will be able to evaluate the features of modern stream processing systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T054105Z" creationid="xccui" creationdate="20190329T053836Z">
        <seg>我们希望你在读完本章后能对流处理应用的需求有一个更深刻的理解并可以对当下不同的流处理系统进行功能评估。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We know of a company that decided to built the backend of a social network based on an event log and event-driven applications because of these features.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190313T010445Z" creationid="xccui" creationdate="20190313T010445Z">
        <seg>据我们所知，正是因为上述功能，有公司决定基于事件日志和事件驱动型应用来构建社交网络后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We looked at the dataflow programming model and learned how streaming applications can be expressed as distributed dataflow graphs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035532Z" creationid="xccui" creationdate="20190606T035500Z">
        <seg>我们介绍了Dataflow编程模型以及如何将一个流式应用表示为分布式Dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We now look at these parts in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044534Z" creationid="xccui" creationdate="20190612T044457Z">
        <seg>接下来我们详细介绍一下这些步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We now turn to another extremely important aspect of stream processing—state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031403Z" creationid="xccui" creationdate="20190606T031350Z">
        <seg>我们现在要转向流处理中另一个十分重要的方面——状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We now turn to examine another extremely important aspect of stream processing, state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050456Z" creationid="xccui" creationdate="20190414T050456Z">
        <seg>我们现在要转而研究流处理中另一个十分重要的方面——状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We present the transformations of the DataStream API in four categories:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024132Z" creationid="xccui" creationdate="20190613T024132Z">
        <seg>我们将DataStream API的转换分为四类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We present two different styles of deploying Flink applications and dis&lt;t0/&gt;‐&lt;t1/&gt; cuss how tasks are distributed and executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033310Z" creationid="xccui" creationdate="20190418T033020Z">
        <seg>随后，我们会给出部署Flink应用的两种类型，并讨论如何分配和执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We recommend using IntelliJ IDEA.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T030642Z" creationid="xccui" creationdate="20190611T030642Z">
        <seg>本书建议使用IntelliJ IDEA。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We show the structure and components of a typical Flink streaming application, discuss Flink’s type systems and the supported data types, and present data and partitioning transformations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T032259Z" creationid="xccui" creationdate="20190612T032259Z">
        <seg>我们会介绍典型Flink流式应用的结构及组件，讨论Flink的类型系统和支持的数据类型，并展示数据转换和分区转换操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We start by reviewing conventional data application architectures and point out their limitations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T024821Z" creationid="esouser" creationdate="20190603T163025Z">
        <seg>我们首先将回顾传统数据处理应用架构并指出其局限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We start reviewing conventional data processing application architectures and point out their limitations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T040526Z" creationid="xccui" creationdate="20190225T222520Z">
        <seg>我们首先将回顾传统数据处理应用架构并指出其局限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We started with a recap of traditional data infrastruc‐ tures, how business applications are commonly designed, and how data is collected and analyzed in most companies today.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124846Z" creationid="xccui" creationdate="20190605T124846Z">
        <seg>我们首先回顾了传统的数据基础架构，业务应用的常规设计以及当今大多数公司是如何收集和分析数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We use an example of a simple streaming application to explain the algorithm step by step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061814Z" creationid="xccui" creationdate="20190609T061814Z">
        <seg>我们通过一个简单流式应用的示例来一步一步解释这个算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will be assuming a UNIX-based setup in the rest of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T014324Z" creationid="xccui" creationdate="20190610T054905Z">
        <seg>本章剩余部分假设设置都是基于类UNIX系统来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will be using the Scala repository for the setup, but you should be able to follow the same instructions if you prefer Java.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T035926Z" creationid="xccui" creationdate="20190611T035846Z">
        <seg>我们将选用Scala仓库进行设置，但如果你想用Java，也可以遵循相同的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will briefly discuss the most common keyed state primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T192620Z" creationid="xccui" creationdate="20190607T192620Z">
        <seg>我们接下来简要讨论一下键值状态最常用的几个原语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the con&lt;t4/&gt;‐&lt;t5/&gt; figuration and setup of Flink clusters in detail in &lt;t6/&gt;Chapter 9&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063849Z" creationid="xccui" creationdate="20190424T063840Z">
        <seg>我们会在第9章讨论搭建和配置Flink集群的详细内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the configuration and setup of Flink clusters in detail in Chapter 9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145157Z" creationid="xccui" creationdate="20190606T145157Z">
        <seg>我们会在第9章讨论搭建和配置Flink集群的详细内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the configuration of highly available Flink setups later in &lt;t4/&gt;Chapter 9&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T040756Z" creationid="xccui" creationdate="20190504T040756Z">
        <seg>我们稍后会在第9章节讨论Flink高可用相关配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the configuration of highly available Flink setups later in “Highly Available Setups”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195315Z" creationid="xccui" creationdate="20190606T195259Z">
        <seg>我们稍后会在"高可用性配置"一节讨论Flink高可用相关配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the different state backends and their advantages and disadvantages in more detail in “Choosing a State Backend” on page 169.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T054246Z" creationid="xccui" creationdate="20190608T054230Z">
        <seg>我们会在169页"选择状态后端"一节详细讨论不同状态后端的区别以及它们各自的优劣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss this topic in more detail in “Application Consistency Guarantees” on page 184.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005758Z" creationid="xccui" creationdate="20190613T005758Z">
        <seg>我们会在184页"应用一致性保障"一节详细讨论这一话题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will present Flink’s more sophisticated checkpointing algorithm later in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224913Z" creationid="xccui" creationdate="20190608T224902Z">
        <seg>而是使用了一种更加复杂的检查点算法，我们会在本节后面介绍该算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will start by discussing the required software and where you can get the code examples of this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014744Z" creationid="xccui" creationdate="20190610T040332Z">
        <seg>我们会从所需软件以及怎样获取书中示例代码开始讲起。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will take a brief look into the past to see where open source stream processing came from and where it is today.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T040653Z" creationid="xccui" creationdate="20190322T040653Z">
        <seg>我们将通过简要地历史回顾来探索一下开源流处理技术的前世今生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will take a brief look into the past to see where open source stream pro‐ cessing came from and where it is today.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050803Z" creationid="xccui" creationdate="20190605T050803Z">
        <seg>我们将通过简要地历史回顾来探索一下开源流处理技术的前世今生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will use this example to show‐ case the basic structure of a Flink program and introduce some important features of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035413Z" creationid="xccui" creationdate="20190612T035257Z">
        <seg>通过该示例，我们将展示Flink程序的基本结构并引出DataStream API中的几个重要特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We would like to thank and acknowledge some of them here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T160115Z" creationid="xccui" creationdate="20190605T131312Z">
        <seg>在此由衷地感谢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We’ve also like to thank our technical reviewers who made countless valuable sugges‐ tions helping us to improve the presentation of the content.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T044941Z" creationid="xccui" creationdate="20190605T133326Z">
        <seg>我们还要感谢那些给予我们无数宝贵建议的技术评审员们：Adam Kawa、Aljoscha Krettek、Kenneth Knowles、Lea Giordano、Matthias J. Sax、Stephan Ewen、Ted Malaska以及Tyler Akidau，感谢你们帮助改善内容呈现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What Does One Minute Mean in Stream Processing?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030352Z" creationid="esouser" creationdate="20190603T144036Z">
        <seg>流处理内的分钟含义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What You Will Learn in This Book</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T042821Z" creationid="xccui" creationdate="20190225T042455Z">
        <seg>你能从本书学到什么</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is a task failure?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042327Z" creationid="xccui" creationdate="20190415T042327Z">
        <seg>什么是任务故障？</seg>
      </tuv>
    </tu>
    <tu>
      <note>每分钟还是一分钟？</note>
      <tuv lang="EN-US">
        <seg>What is the meaning of one minute?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T205925Z" creationid="xccui" creationdate="20190225T015542Z">
        <seg>分钟的含义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What should the application do?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T142427Z" creationid="xccui" creationdate="20190411T152000Z">
        <seg>此时应用该怎么处理？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What would &lt;t0/&gt;one minute&lt;t1/&gt; really mean in the context of our streaming application?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T144519Z" creationid="xccui" creationdate="20190409T211131Z">
        <seg>那么一分钟在流式应用的环境下到底是什么含义？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What would one minute really mean in the context of our streaming application?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014710Z" creationid="xccui" creationdate="20190606T014710Z">
        <seg>那么一分钟在流式应用的环境下到底是什么含义？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, by reducing the stream history to a single aggre&lt;t0/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043806Z" creationid="xccui" creationdate="20190406T043701Z">
        <seg>此外，将整条历史流合并为单个聚合值会丢失数据随时间变化的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, by reducing the stream history to a single aggre‐ gate, you lose the information about how your data varies over time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012316Z" creationid="xccui" creationdate="20190606T012316Z">
        <seg>此外，将整条历史流合并为单个聚合值会丢失数据随时间变化的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, streaming applications that process events as they are produced should also be able to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052607Z" creationid="xccui" creationdate="20190409T202149Z">
        <seg>此外，处理实时事件的流处理应用还应以相同的方式处理历史事件，这样才能支持离线分析、甚至那些比较不同历史区间的分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, streaming applica‐ tions that process events as they are produced should also be able to process historical events in the same way, thus enabling offline analytics or even time travel analyses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014506Z" creationid="xccui" creationdate="20190606T014415Z">
        <seg>此外，处理实时事件的流处理应用还应以相同的方式处理历史事件，这样才能支持离线分析，甚至那些比较不同历史区间数据的分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, when combined with re-playable streams, the determinism of time&lt;t0/&gt;‐&lt;t1/&gt; stamps gives you the ability to &lt;t2/&gt;fast-forward&lt;t3/&gt; the past.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T154731Z" creationid="xccui" creationdate="20190412T154437Z">
        <seg>而且结合可重放的数据流，时间戳的确定性允许你对历史数据"快进"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, when combined with replayable streams, the determinism of timestamps gives you the ability to fast forward the past.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025045Z" creationid="xccui" creationdate="20190606T025045Z">
        <seg>而且结合可重放的数据流，时间戳的确定性允许你对历史数据"快进"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s the meaning of one minute in this case?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T142442Z" creationid="xccui" creationdate="20190411T152030Z">
        <seg>在上述示例中一分钟的含义又是什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Flink processes a data stream in event-time mode, it evaluates time-based operators based on the timestamps of records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040225Z" creationid="xccui" creationdate="20190523T040149Z">
        <seg>当Flink以事件时间模式处理数据流时，会根据记录的时间戳触发时间相关算子的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a JobManager fails, all tasks that belong to its application are automatically  cancelled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195013Z" creationid="xccui" creationdate="20190606T194908Z">
        <seg>当JobManager发生故障时，其下应用的所有任务都会自动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a JobManager fails, all tasks that belong to its application are automatically cancelled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T052256Z" creationid="xccui" creationdate="20190502T052211Z">
        <seg>当JobManager发生故障，所有隶属其应用的任务都会自动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a JobManager requests TaskManager slots, the ResourceManager instructs a TaskManager with idle slots to offer them to the JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062025Z" creationid="xccui" creationdate="20190418T050502Z">
        <seg>当JobManager申请TaskManager处理槽时，ResourceManager会指示一个拥有空槽的TaskManager将它们提供给JobManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a checkpoint is triggered, the state backend creates a local copy of the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202934Z" creationid="xccui" creationdate="20190609T202934Z">
        <seg>当检查点生成过程触发时，状态后端会为当前状态创建一个本地拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a container is started from the image, it automatically launches the ResourceManager and JobManager and submits the bundled job for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143744Z" creationid="xccui" creationdate="20190606T143716Z">
        <seg>当容器从映像启动后会自动加载ResourceManager和JobManager，并将绑定的作业提交执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a container is started from this image, it automatically starts a TaskManager, which connects to the ResourceManager and registers its slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042604Z" creationid="xccui" creationdate="20190423T040144Z">
        <seg>当容器启动后会自动运行TaskManager，它负责连接ResourceManager并注册处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a data source task receives the message, it pauses emitting records, triggers a checkpoint of its local state at the state backend, and broadcasts checkpoint barriers with the checkpoint ID via all outgoing stream partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T063446Z" creationid="xccui" creationdate="20190609T063201Z">
        <seg>当一个数据源任务收到消息后，会暂停发出记录，利用状态后端触发生成本地状态的检查点，随后把该检查点分隔符连同检查点编号广播至所有传出的数据流分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a job fin&lt;t0/&gt;‐&lt;t1/&gt; ishes, the result is written to persistent storage, and all operator state is lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053639Z" creationid="xccui" creationdate="20190414T053558Z">
        <seg>当一个作业结束，其结果就会写入持久化存储中，同时所有算子的状态将不复存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a job finishes, the result is written to persistent storage, and all operator state is lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032106Z" creationid="xccui" creationdate="20190606T032106Z">
        <seg>当一个作业结束，其结果就会写入持久化存储中，同时所有算子的状态将不复存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a savepoint is taken, the states of all tasks are copied to a persistent storage location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215054Z" creationid="xccui" creationdate="20190609T214950Z">
        <seg>在生成保存点的时候，所有任务的状态都会拷贝到某个持久化存储位置上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a sender task and a receiver task run in the same TaskManager process, the sender task serializes the outgoing records into a byte buffer and puts the buffer into a queue once it is filled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T192304Z" creationid="esouser" creationdate="20190513T191646Z">
        <seg>当发送任务和接收任务在同一个TaskManager进程时，发送任务会将要发送的记录序列化到一个字节缓冲中，一旦缓冲占满就会被放到一个队列里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a sink task receives a barrier, it performs a barrier alignment, checkpoints its own state, and acknowledges the reception of the barrier to the JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194118Z" creationid="xccui" creationdate="20190609T194118Z">
        <seg>数据汇任务在收到分隔符后会依次执行分隔符对齐，将自身状态写入检查点，向JobManager确认已接收分隔符等一系列动作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task processes a record, it automatically scopes the state access to the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191343Z" creationid="xccui" creationdate="20190607T190932Z">
        <seg>当任务在处理一个记录时，会自动把状态的访问范围限制为当前记录的键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a barrier for a new checkpoint, it waits for the arrival of barriers from all its input partitions for the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162050Z" creationid="xccui" creationdate="20190609T161207Z">
        <seg>当任务收到一个新检查点的分隔符时，会继续等待所有其它输入分区也发来这个检查点的分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a record that violates the watermark property and has smaller time&lt;t4/&gt;‐&lt;t5/&gt; stamps than a previously received watermark, it might be the case that the computa&lt;t6/&gt;‐&lt;t7/&gt; tion it would belong to has already been completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035531Z" creationid="xccui" creationdate="20190529T035229Z">
        <seg>当任务接收到一个违反水位线属性、时间戳小于前一个水位线的记录时，该记录本应参与的计算可能已经完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a record that violates the watermark property and has smaller time‐ stamps than a previously received watermark, it may be that the computation it belongs to has already been completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205709Z" creationid="xccui" creationdate="20190606T205651Z">
        <seg>当任务接收到一个违反水位线属性，时间戳小于前一个水位线的记录时，该记录本应参与的计算可能已经完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a watermark, the following actions take place.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042423Z" creationid="xccui" creationdate="20190529T041904Z">
        <seg>当任务接收到一条水位线记录时会执行以下操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a watermark, the following actions take place:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T212916Z" creationid="xccui" creationdate="20190606T212913Z">
        <seg>当任务接收到一条水位线记录时会执行以下操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is started from a savepoint, Flink redistributes the savepoint data to the tasks of the corresponding operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215608Z" creationid="xccui" creationdate="20190609T215601Z">
        <seg>当应用从保存点启动时，Flink会将保存点的数据分发到对应算子的任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application receives an event, it can perform arbitrary computations that involve reading data from or writing data to the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T030804Z" creationid="xccui" creationdate="20190305T030739Z">
        <seg>应用收到事件后可以执行包括读写状态在内的任意计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application receives an event, it can perform arbi‐ trary computations that involve reading data from or writing data to the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T205844Z" creationid="esouser" creationdate="20190603T205844Z">
        <seg>应用收到事件后可以执行包括读写状态在内的任意计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an container is started from the image, it automatically launches the ResourceManager and the JobMan&lt;t1/&gt;‐&lt;t2/&gt; ager and hands over the bundled job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T035802Z" creationid="xccui" creationdate="20190423T032325Z">
        <seg>当容器从映像启动后会自动加载ResourceManager和JobManager，并提交绑定的作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an event is processed, an application reads its state or updates it by running transac‐ tions against the remote database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T195529Z" creationid="esouser" creationdate="20190603T195529Z">
        <seg>期间每处理一条事件，应用都会通过远程数据库系统的事务来读取或更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an event is processed, an application reads its state or updates its state by run&lt;t0/&gt;‐&lt;t1/&gt; ning transactions against the remote database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T162610Z" creationid="xccui" creationdate="20190226T162548Z">
        <seg>期间每处理一条事件，应用都会通过远程数据库系统的事务来读取或更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an operator receives a watermark with time T, it can assume that no further events with timestamp less than T will be received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205925Z" creationid="xccui" creationdate="20190412T205544Z">
        <seg>当一个算子接收到时间为T的水位线，就可以认为不会再收到任何时间戳小于或等于T的事件了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an operator receives a watermark with time T, it can assume that no further events with time‐ stamp less than T will be received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025434Z" creationid="xccui" creationdate="20190606T025434Z">
        <seg>当一个算子接收到时间为T的水位线，就可以认为不会再收到任何时间戳小于或等于T的事件了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When dealing with a potentially unbounded stream of continuously arriving events, time becomes a central aspect of applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T210942Z" creationid="xccui" creationdate="20190409T210522Z">
        <seg>当处理一个由持续到来事件所组成的潜在无穷数据流，时间就成为了应用中的核心要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When instructed by the ResourceManager, the TaskManager offers one or more of its slots to a JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062127Z" creationid="xccui" creationdate="20190418T051847Z">
        <seg>当接收到ResourceManager的指示时，TaskManager会向JobManager提供一个或多个处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it receives a watermark from a partition, it updates the respective partition watermark to be the maximum of the received value and the current value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T024528Z" creationid="xccui" creationdate="20190607T024528Z">
        <seg>当收到某个分区传来的水位线后，它会以接收值和当前值中较大的那个作为对应分区水位线更新后的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When operating in high- availability mode, the JobManager writes the JobGraph and all required metadata,  such as the application’s JAR file, into a remote persistent storage system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T150048Z" creationid="xccui" creationdate="20190606T150048Z">
        <seg>JobManager在高可用模式下工作时，会将JobGraph以及所有所需的元数据（例如应用的JAR文件）写入到一个远程持久化存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When operating in high-availability mode, the JobManager writes the JobGraph and all required metadata, such as the application’s JAR file, into a remote persistent storage system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T045712Z" creationid="xccui" creationdate="20190502T045505Z">
        <seg>JobManager在高可用模式下工作时，会将JobGraph以及所有所需的元数据（例如应用的JAR文件）写入到一个远程持久化存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When presenting the transformations of the DataStream API, we show the interfaces for all function classes, but mostly use lambda functions instead of function classes in code examples for brevity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T022839Z" creationid="xccui" creationdate="20190613T022648Z">
        <seg>在介绍DataStream API的转换时，我们会展示所有函数类的接口。但出于简洁考虑，在绝大多数示例代码中我们会使用lambda函数而不是函数类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running an application as a library deployment in a container environment, such as Kubernetes, failed JobManager or TaskManager containers are usually auto&lt;t0/&gt;‐&lt;t1/&gt; matically restarted by the container orchestration service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T035643Z" creationid="xccui" creationdate="20190504T035046Z">
        <seg>当在容器环境（如：Kubernetes）中将应用作为库部署运行时，容器编排服务通常会自动重启故障的JobManager或TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running an application as a library deployment in a container environment, such as Kubernetes, failed JobManager or TaskManager containers are usually auto‐ matically restarted by the container orchestration service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195057Z" creationid="xccui" creationdate="20190606T195057Z">
        <seg>当在容器环境（如：Kubernetes）中将应用作为库部署运行时，容器编排服务通常会自动重启故障的JobManager或TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running on YARN   or on Mesos, Flink’s remaining processes trigger the restart of JobManager or Task‐ Manager processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195152Z" creationid="xccui" creationdate="20190606T195108Z">
        <seg>当运行在YARN或Mesos上面时，Flink的其余进程会触发JobManager或TaskManager进程重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running on YARN or on Mesos, Flink’s remaining processes trigger the restart of JobManager or Task&lt;t2/&gt;‐&lt;t3/&gt; Manager processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T035754Z" creationid="xccui" creationdate="20190504T035708Z">
        <seg>当运行在YARN或Mesos上面时，Flink的剩余进程会触发JobManager或TaskManager进程重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the application has been completely defined, it can be executed by call‐ ing StreamExecutionEnvironment.execute().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005845Z" creationid="xccui" creationdate="20190613T005845Z">
        <seg>当应用定义完成后就可以通过调用StreamExecutionEnvironment.execute()来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the first event comes in, it will be immediately processed with the minimum latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234653Z" creationid="xccui" creationdate="20190605T234653Z">
        <seg>当第一个事件到来，系统会立刻以尽可能低的延迟进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the local copy is finished, the task continues its regular processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203350Z" creationid="xccui" creationdate="20190609T203350Z">
        <seg>在本地拷贝创建完成后，任务就可以继续它的常规处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the task receives a new record, it accesses the state to get the current count, increments the count, updates the state, and emits the new count.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055111Z" creationid="xccui" creationdate="20190607T054625Z">
        <seg>当任务收到一个新的记录后，首先会访问状态获取当前统计的记录数目，然后把数目增加并更新状态，最后将更新后的数目发送出去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the train exits the tunnel, she comes back online, and pending events are sent to the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151949Z" creationid="xccui" creationdate="20190411T151545Z">
        <seg>当地铁离开隧道，爱丽丝重新上线，之前缓存的事件才会发送给应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the trigger condition is met, the bucket contents are sent to an evaluation func&lt;t12/&gt;‐&lt;t13/&gt; tion that applies the computation logic on the bucket elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T045744Z" creationid="xccui" creationdate="20190406T045620Z">
        <seg>当触发条件满足时，桶中的内容会发送给一个计算函数（evaluation function），由它来对桶内元素应用计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the trigger condition is met, the bucket contents are sent to an evaluation function that applies the computation logic on the bucket elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012858Z" creationid="xccui" creationdate="20190606T012803Z">
        <seg>当触发条件满足时，桶内数据会发送给一个计算函数（evaluation function），由它来对桶中的元素应用计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the window border is passed, all the events are sent to an evaluation func‐ tion for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013021Z" creationid="xccui" creationdate="20190606T013021Z">
        <seg>在窗口边界通过后，所有事件会发送给计算函数处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using the Scala API or Java 8, the mapper can also be expressed as a lambda function:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T051123Z" creationid="xccui" creationdate="20190613T051123Z">
        <seg>如果使用Scala API或Java 8，还可以通过lambda函数来表示映射器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you enter the coffee shop, there might be other customers inside already.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T152836Z" creationid="xccui" creationdate="20190401T152347Z">
        <seg>当你进门的时候，可能已经有别的顾客在里面了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where to Go from Here?.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152414Z" creationid="esouser" creationdate="20190603T152414Z">
        <seg>还有什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where to go from here?.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030219Z" creationid="xccui" creationdate="20190225T030219Z">
        <seg>还有什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether a data source can reset its input stream depends on its implementation and the external system or interface from which the stream is consumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044432Z" creationid="xccui" creationdate="20190609T044221Z">
        <seg>数据源能否重置其输入流取决于它的具体实现以及所消费外部系统是否提供相关接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Alice’s phone loses connection when inside the tunnel, Bob’s phone remains connected and delivers events to the gaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T152314Z" creationid="xccui" creationdate="20190412T152302Z">
        <seg>当爱丽丝的手机在隧道里没信号的时候，鲍勃的手机依然能联网向后端游戏应用发送事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While a task checkpoints its state, it is blocked and its input is buffered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T200059Z" creationid="xccui" creationdate="20190609T200005Z">
        <seg>任务在将其状态存入检查点的过程中，会出于阻塞状态，此时的输入会放入缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While in the logical dataflow graph the nodes represent operators, in the physical dataflow, the nodes are tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233139Z" creationid="xccui" creationdate="20190401T003341Z">
        <seg>在逻辑Dataflow图中，顶点代表算子；而在物理Dataflow图中，顶点代表任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it is waiting, it continues pro‐ cessing records from stream partitions that did not provide a barrier yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162506Z" creationid="xccui" creationdate="20190609T162226Z">
        <seg>在等待过程中，它会继续处理那些从还未提供分隔符的分区发来的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While period‐ ically loading data into a data analysis system has been the state of the art for many years, it adds considerable latency to the analytics pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T043545Z" creationid="xccui" creationdate="20190605T043429Z">
        <seg>虽然周期性地将数据导入分析系统多年来一直是最先进的方法，但它会给分析管道带来相当大的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While previous stream processors only provided either high throughput or low latency, systems of the third generation are able to serve both ends of the spectrum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T134922Z" creationid="xccui" creationdate="20190327T134531Z">
        <seg>前几代的流处理引擎只能在高吞吐和低延迟之中取其一，而第三代的系统可以兼顾两者，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While previous stream processors only pro‐ vide either high throughput or low latency, systems of the third generation are able to serve both ends of the spectrum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053656Z" creationid="xccui" creationdate="20190605T053538Z">
        <seg>前几代的流处理引擎只能在高吞吐和低延迟之中选其一，而第三代的系统可以兼顾两者，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While processing the data, the task can read and update its state and compute its result based on its input data and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054433Z" creationid="xccui" creationdate="20190607T054433Z">
        <seg>在处理这些数据的过程中，任务可以读取更新其状态，并根据状态和输入数据计算结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While processing time is easy to understand because it is based on the local time of the processing machine, it produces somewhat arbitrary, incon‐ sistent, and nonreproducible results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204212Z" creationid="xccui" creationdate="20190606T204212Z">
        <seg>虽然处理时间是基于处理机器的本地时间，相对容易理解，但它会产生一些较为随意、不一致且无法重现的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While processing-time is easy to understand because it is based on the local time of the processing machine, it produces somewhat arbitrary, inconsistent, and non-reproducible results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T160158Z" creationid="esouser" creationdate="20190514T160158Z">
        <seg>虽然处理时间是基于处理机器的本地时间，相对容易理解，但它会产生一些较为随意、不一致且无法重现的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While scaling stateless opera‐ tors is trivial, changing the parallelism of stateful operators is much more challenging because their state needs to be repartitioned and assigned to more or fewer parallel tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T054759Z" creationid="xccui" creationdate="20190608T054626Z">
        <seg>对于无状态的算子，扩缩容很容易。但对于有状态的算子，改变并发度就会复杂很多，因为我们需要把状态重新分组，分配到与之前数量不等的并行任务之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While some chapters are descriptive and aim to introduce concepts and high-level design, others are more hands-on and contain many code examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191213Z" creationid="xccui" creationdate="20190225T161953Z">
        <seg>书中部分章节会侧重描述概念或高层次的设计理念，而其余章节会更加侧重实践并包含很多示例代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While some chapters are descriptive and aim to introduce high-level design concepts, others are more hands-on and contain many code examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T153029Z" creationid="esouser" creationdate="20190603T152715Z">
        <seg>书中部分章节会侧重描述高层次的设计理念，而其余章节会更加注重实践并包含了很多示例代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the approach of periodically loading data into data analysis systems has been the state-of-the-art for many years, it suffers from a notable drawback.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T031044Z" creationid="xccui" creationdate="20190317T030912Z">
        <seg>虽然周期性地将数据导入分析系统多年来一直是最先进的方法，但它有个明显的缺点，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the first option gives very fast state access, it is limited by the size of the memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053100Z" creationid="xccui" creationdate="20190608T052828Z">
        <seg>前者状态访问会更快一些，但会受到内存大小的限制；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the publisher and the authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210740Z" creationid="esouser" creationdate="20190603T210740Z">
        <seg>While the publisher and the authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this behavior seems to be exactly the same as recovering an application from a failure using a checkpoint, failure recovery is actually just a special case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211834Z" creationid="xccui" creationdate="20190609T211646Z">
        <seg>这个行为看上去和利用检查点将应用从故障中恢复完全一致，但其实故障恢复只是一种特殊情况，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this kind of delay may have been acceptable in the past, applications today must be able to collect data in real-time and immediately act on it (e.g., by adjusting to changing con‐ ditions in a mobile game or by personalizing user experiences for an online retailer).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044455Z" creationid="xccui" creationdate="20190605T043748Z">
        <seg>虽然从过去视角来看，这种延迟可以接受，但当今的应用必须能够实时收集数据并迅速响应（例如调整手游中的某个可变条件或使用户在网购过程中获得个性化体验）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we intended for the book to be read in chapter order when we were writing it, readers familiar with a chapter’s content might want to skip it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041545Z" creationid="esouser" creationdate="20190603T153220Z">
        <seg>尽管我们在写书的时候是按照预期阅读顺序进行的章节编排，但如果你已经对某些章节的内容很熟悉，仍可以选择跳过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While you might get annoyed by this delay, most other customers will still be happy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234149Z" creationid="xccui" creationdate="20190401T160314Z">
        <seg>虽然你可能因为耽搁而不高兴，但这丝毫不会影响其他顾客的心情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While you want latency to be as low as possible, you generally want throughput to be as high as possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234525Z" creationid="xccui" creationdate="20190401T195813Z">
        <seg>通常情况下延迟是越低越好，而显然吞吐则是越高越好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150722Z" creationid="esouser" creationdate="20190603T150722Z">
        <seg>窗口连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023138Z" creationid="xccui" creationdate="20190225T023138Z">
        <seg>窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011951Z" creationid="xccui" creationdate="20190606T011951Z">
        <seg>窗口操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations are closely related to two dominant concepts in stream process&lt;t0/&gt;‐&lt;t1/&gt; ing: time semantics and state management.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T200140Z" creationid="xccui" creationdate="20190409T200114Z">
        <seg>窗口操作与流处理中两个核心概念密切相关：时间语义（time semantics）和状态管理（state management）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations are closely related to two dominant concepts in stream process‐ ing: time semantics and state management.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014214Z" creationid="xccui" creationdate="20190606T014214Z">
        <seg>窗口操作与流处理中两个核心概念密切相关：时间语义（time semantics）和状态管理（state management）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations continuously create finite sets of events called buckets from an unbounded event stream and let us perform computations on these finite sets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022718Z" creationid="xccui" creationdate="20190406T044746Z">
        <seg>窗口操作会持续创建一些称为桶（bucket）的有限事件集合，并允许我们基于这些有限集进行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operators, time-based transformations, stateful operators, and connectors are discussed in the next chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T032830Z" creationid="xccui" creationdate="20190612T032454Z">
        <seg>有关窗口算子、基于时间的转换、状态化算子和连接器的内容将在接下来的几章讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window policies decide when new buckets are created, which events are assigned to which buckets, and when the con&lt;t10/&gt;‐&lt;t11/&gt; tents of a bucket get evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022740Z" creationid="xccui" creationdate="20190406T045304Z">
        <seg>这些窗口策略决定了什么时间创建桶，事件如何分配到桶中以及桶中的内容什么时间参与计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window policies decide when new buckets are created, which events are assigned to which buckets, and when the contents of a bucket get evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012831Z" creationid="xccui" creationdate="20190606T012724Z">
        <seg>这些窗口策略决定了什么时间创建桶，事件如何分配到桶中以及桶内数据什么时间参与计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window transformations are described in detail in “Window Operators” on page 122.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053825Z" creationid="xccui" creationdate="20190612T053825Z">
        <seg>有关窗口转换的详细内容会在122页"窗口算子"一节介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035926Z" creationid="xccui" creationdate="20190406T035926Z">
        <seg>窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a shuffle or broadcast connection, each sending task needs a buffer for each receiving task; the number of required buffers is quadratic to the number of tasks of the involved operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T201749Z" creationid="xccui" creationdate="20190606T201749Z">
        <seg>在shuffle或broadcast连接的情况下，每个发送任务都需要针对每个接收任务提供一个缓冲区，因此所需的缓冲区数量是相关算子并发度的平方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this book, we hope to reach developers, engineers, and streaming enthusiasts around the world and grow the Flink community even larger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T044751Z" creationid="xccui" creationdate="20190605T132916Z">
        <seg>通过本书，我们渴望能够吸引世界各地的开发者、工程师以及流处理爱好者，进一步扩大Flink社区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing a Data‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T013925Z" creationid="xccui" creationdate="20190613T013925Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also know a little bit about the evolution of the open source stream processing space and what a Flink streaming application looks like.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224647Z" creationid="xccui" creationdate="20190605T224647Z">
        <seg>也对开源流处理领域的发展过程以及Flink流式应用有所了解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are probably not surprised that stateful stream processing is the right technology to build low-latency analytics pipelines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T054805Z" creationid="xccui" creationdate="20190317T054517Z">
        <seg>你应该会理所当然地想到状态化流处理就是构建低延迟分析流水线的恰当技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access this page at http://bit.ly/stream-proc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210843Z" creationid="esouser" creationdate="20190603T210843Z">
        <seg>You can access this page at http://bit.ly/stream-proc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also build the JAR file yourself by following the steps in the repository’s README file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123551Z" creationid="xccui" creationdate="20190605T123533Z">
        <seg>你也可以根据代码库中README文件的指示自行构建JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also delete them if you do not need them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010448Z" creationid="xccui" creationdate="20190612T010135Z">
        <seg>如果不需要，也可以删除它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also download the source code of the examples as a zip-archive from GitHub:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040419Z" creationid="xccui" creationdate="20190611T040419Z">
        <seg>你也可以把示例代码以zip压缩包的形式从GitHub上下载下来：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also just take a savepoint to version and archive the state of an applica‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213419Z" creationid="xccui" creationdate="20190609T213419Z">
        <seg>你还可以为保存点设置不同版本并将应用状态归档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can change the Flink version, group and artifact IDs, version, and generated package by changing the respective parameters of the above mvn command.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005618Z" creationid="xccui" creationdate="20190612T005349Z">
        <seg>你可以通过改变上述mvn命令的相应参数来更改Flink版本，Maven的组标识符和项目标识符，项目版本以及生成的包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define breakpoints in the code and debug your application as you would normally do.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T053653Z" creationid="xccui" creationdate="20190611T053048Z">
        <seg>就如同往常一般，在代码里设置断点，开启调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can develop and execute Flink applications on Linux, macOS, and Windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T054036Z" creationid="xccui" creationdate="20190610T040911Z">
        <seg>你可以在Linux、maxOS以及Windows等常见操作系统上开发和运行Flink应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do this by selecting the job in the web dashboard and clicking on the CANCEL button on the top of the page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045547Z" creationid="xccui" creationdate="20190329T045547Z">
        <seg>取消的方式是在Web仪表盘中选定作业，然后点击页面上方的CANCEL按钮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do this by selecting the job in the web dashboard and clicking the Cancel button at the top of the page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124419Z" creationid="xccui" creationdate="20190605T124408Z">
        <seg>取消的方式是在Web仪表盘中选定作业，然后点击页面上方的Cancel按钮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can exploit parallelism in dataflow graphs in different ways.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233216Z" creationid="xccui" creationdate="20190401T022711Z">
        <seg>Dataflow图的并行性可以通过多种方式加以利用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can follow the instruc‐ tions at the IntelliJ IDEA website to download and install it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T030717Z" creationid="xccui" creationdate="20190611T030717Z">
        <seg>你可以按照IntelliJ IDEA官网的说明下载并安装它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can import the project in your IDE following the steps we described in the previ‐ ous section or you can execute the following command to build a JAR file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010443Z" creationid="xccui" creationdate="20190612T010248Z">
        <seg>此时，你可以按照我们在上一节所介绍的步骤把项目导入IDE，也可以执行以下命令来构建一个JAR文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can monitor the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130301Z" creationid="xccui" creationdate="20190605T130301Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can monitor the constantly produced output using the tail command for example as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042619Z" creationid="xccui" creationdate="20190329T042619Z">
        <seg>如下所示，你可以使用tail命令监控持续产生的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can start a different but compatible application from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212000Z" creationid="xccui" creationdate="20190609T212000Z">
        <seg>你可以从保存点启动一个不同但相互兼容的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can start the same application on a different cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212732Z" creationid="xccui" creationdate="20190609T212716Z">
        <seg>你可以在另一个集群上启动相同的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can start the same application with a different parallelism and scale the appli‐ cation out or in.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212646Z" creationid="xccui" creationdate="20190609T212609Z">
        <seg>你可以用不同的并发度启动原应用，从而实现应用的扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of keyed state as a key-value map that is partitioned (or sharded) on  the key across all parallel tasks of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T192142Z" creationid="xccui" creationdate="20190607T192001Z">
        <seg>你可以把键值状态想象成一个在算子所有并行任务上进行分区（或分片）的键值映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of state as a local or instance variable that is accessed by a task’s business logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054049Z" creationid="xccui" creationdate="20190607T054049Z">
        <seg>你可以把状态想象成任务的业务逻辑所需要访问的本地或实例变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a savepoint to pause an application and resume it later.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212928Z" creationid="xccui" creationdate="20190609T212928Z">
        <seg>你可以利用保存点暂停某个应用，稍后再把它启动起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not need to contact us for permission unless you’re reproducing a significant portion of the code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210817Z" creationid="esouser" creationdate="20190603T210817Z">
        <seg>You do not need to contact us for permission unless you’re reproducing a significant portion of the code.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have become familiar with the evolution of the open-source stream processing space and you have got a brief taste of what a Flink streaming application looks like.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T052906Z" creationid="xccui" creationdate="20190329T052313Z">
        <seg>你已经熟悉了开源流处理领域的发展过程，且对Flink流式应用有一个粗略的认识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have learned basic streaming operations and how you can compute meaningful results on unbounded input data using windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051247Z" creationid="xccui" creationdate="20190416T051207Z">
        <seg>你学习了基本的流式操作，并掌握了如何利用窗口在无限输入上计算出有意义的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have probably already noticed that Flink programs are defined and submitted for execution in regular Scala or Java methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043401Z" creationid="xccui" creationdate="20190612T043039Z">
        <seg>你可能已经注意到了，用日常的Scala或Java方法就可以定义并提交Flink程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have seen how rolling aggregations encode the history of the whole stream in an aggregate value and provide us with a low-latency result for every event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043002Z" creationid="xccui" creationdate="20190406T042607Z">
        <seg>你已经了解滚动聚合是如何将整条历史流压缩为一个聚合值，以及如何针对每个事件在极低延迟内产生结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have seen the dataflow programming model and learned how streaming applications can be expressed as distributed dataflow graphs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050548Z" creationid="xccui" creationdate="20190416T050539Z">
        <seg>你了解了dataflow编程模型以及如何将一个流式应用表示为分布式dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have wondered about the meaning of time in stream processing and you have compared the notions of event time and processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051413Z" creationid="xccui" creationdate="20190416T051333Z">
        <seg>你思考了流式应用中时间的含义，并比较了事件时间和处理时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You just installed and started your first local Flink cluster and ran your first Flink DataStream API program!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124508Z" creationid="xccui" creationdate="20190605T124440Z">
        <seg>恭喜你首次成功安装启动了Flink本地集群并运行了你的首个Flink DataStream程序！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You just installed and started your first local Flink cluster and ran your first Flink DataStream program!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T050049Z" creationid="xccui" creationdate="20190328T062213Z">
        <seg>恭喜你首次成功安装启动了Flink本地集群并运行了你第一个Flink DataStream程序！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You learned the mean‐ ing of time in stream processing and compared the notions of event time and pro‐ cessing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T040431Z" creationid="xccui" creationdate="20190606T040431Z">
        <seg>你学习了流式应用中时间的含义，并比较了事件时间和处理时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may be able to lower the latency in our coffee shop example by hiring a more skilled barista—one that prepares coffees faster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235353Z" creationid="xccui" creationdate="20190605T235258Z">
        <seg>为了降低延迟，可以雇佣更娴熟的咖啡师，他们制作咖啡会更快一些。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should now be able to browse and inspect the code of the book exam‐ ples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041822Z" creationid="xccui" creationdate="20190611T041759Z">
        <seg>你现在应该就能浏览和研究书中示例的源码了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see a job listed under “Running Jobs.” If you click on that job, you will see the dataflow and live metrics about the opera‐ tors of the running job similar to the screenshot in Figure 1-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123742Z" creationid="xccui" creationdate="20190605T123657Z">
        <seg>你应该能看到"Running Jobs"列表中有一个作业。点击那个作业，你会看到和图1-9中的截图相类似的数据流程及运行作业中算子的实时指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see a job listed under “Running Jobs”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040122Z" creationid="xccui" creationdate="20190329T040122Z">
        <seg>你会发现"Running Jobs"列表中有一个作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see lines as the following ones being written to the file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042932Z" creationid="xccui" creationdate="20190329T042825Z">
        <seg>你会看到文件中写入了以下文本行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see lines like this being written to the file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123930Z" creationid="xccui" creationdate="20190605T123849Z">
        <seg>你会看到文件中写入了和下面类似的文本行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will find the source code in the src/ directory, grouped by chapter:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040535Z" creationid="xccui" creationdate="20190611T040535Z">
        <seg>你可以在src/目录中找到按照章节分好的源代码：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will learn how to implement a DataStream application and which stream transforma‐ tions, functions, and data types are supported.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T161514Z" creationid="esouser" creationdate="20190603T161436Z">
        <seg>你将从中学到如何实现DataStream应用以及Flink所支持的转换、函数、数据类型等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will learn more about stateful stream processing, failure scenarios, and consistency at the end of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T005148Z" creationid="xccui" creationdate="20190606T005148Z">
        <seg>在本章末尾，你将了解更多有关状态化流处理、错误场景和一致性的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will learn more about stateful stream processing, failure scenarios, and consistency in the end of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151708Z" creationid="xccui" creationdate="20190405T151603Z">
        <seg>在本章末尾，你将了解更多有关状态化流处理、错误场景和一致性的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your service latency is the time you spend in the coffee shop, from the moment you enter until you have the first sip of coffee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T154418Z" creationid="xccui" creationdate="20190401T154008Z">
        <seg>你的服务延迟就是在店内买咖啡的时间，即从你进门的一刻到抿到第一口咖啡的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004818Z" creationid="xccui" creationdate="20190612T004818Z">
        <seg>\</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a filter operation that only preserves white squares.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052257Z" creationid="xccui" creationdate="20190613T052257Z">
        <seg>图5-2展示的filter操作仅保留了白色方块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>acceptable because a prompt reaction to new results or insights did not yield a signifi&lt;t0/&gt;‐&lt;t1/&gt; cant advantage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032923Z" creationid="xccui" creationdate="20190317T032923Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>access intermediate data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T205838Z" creationid="esouser" creationdate="20190603T205838Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and that all input streams are reset to the position up to which they were consumed when the checkpoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044017Z" creationid="xccui" creationdate="20190609T044017Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and video from O’Reilly and 200+ other publishers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210833Z" creationid="esouser" creationdate="20190603T210833Z">
        <seg>and video from O’Reilly and 200+ other publishers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application is represented by the StreamExecutionEnvironment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044952Z" creationid="xccui" creationdate="20190612T044952Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application, fix bugs and repair previously emitted results, migrate an application to a different cluster, or perform A/B tests with different application versions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T211848Z" creationid="esouser" creationdate="20190603T211838Z">
        <seg>该技术不但可用于失败恢复，还可用于应用更新、bug修复、结果修正、集群迁移或针对不同版本应用执行A/B测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032948Z" creationid="xccui" creationdate="20190418T032948Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>avgTemp.print()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042827Z" creationid="xccui" creationdate="20190612T042827Z">
        <seg>avgTemp.print()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>batch storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051915Z" creationid="xccui" creationdate="20190605T051915Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ble.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T041101Z" creationid="xccui" creationdate="20190414T041101Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>buffer channels and serialization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204046Z" creationid="xccui" creationdate="20190606T204046Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Fabian Hueske and Vasiliki Kalavri</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210709Z" creationid="esouser" creationdate="20190603T210709Z">
        <seg>by Fabian Hueske and Vasiliki Kalavri</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class SensorReading( id: String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035705Z" creationid="xccui" creationdate="20190612T035705Z">
        <seg>case class SensorReading( id: String,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T055509Z" creationid="xccui" creationdate="20190319T055509Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cations run continuously and the input is potentially unbounded, there is no notion of total execution time in data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150815Z" creationid="xccui" creationdate="20190401T150815Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cessed, and there is a chance that some of them are processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034626Z" creationid="xccui" creationdate="20190606T034626Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cessor, a speed store, a batch store, and tools to ingest data for the batch processor and scheduling batch jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032758Z" creationid="xccui" creationdate="20190327T032758Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class MyMapFunction extends MapFunction[Int, Int] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020905Z" creationid="xccui" creationdate="20190613T020905Z">
        <seg>class MyMapFunction extends MapFunction[Int, Int] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class MyMapFunction extends MapFunction[SensorReading, String] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050721Z" creationid="xccui" creationdate="20190613T050721Z">
        <seg>class MyMapFunction extends MapFunction[SensorReading, String] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>clearly define its behavior in a failure scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042849Z" creationid="xccui" creationdate="20190415T042849Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>component of a TaskManager collect records in buffers before they are shipped, i.e., records are not shipped one-by-one but batched into buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041706Z" creationid="xccui" creationdate="20190504T041706Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>constantly produced output using the tail command as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123837Z" creationid="xccui" creationdate="20190605T123837Z">
        <seg>你可以使用tail命令监控持续产生的结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>data with other TaskManagers that run tasks of the same application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142702Z" creationid="xccui" creationdate="20190606T142702Z">
        <seg>执行期间，运行同一应用不同任务的TaskManager之间会产生数据交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def main(args: Array[String]) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041920Z" creationid="xccui" creationdate="20190612T041920Z">
        <seg>def main(args: Array[String]) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deploying Flink applications and the way each distributes and executes tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141142Z" creationid="xccui" creationdate="20190606T141058Z">
        <seg>我们对两类部署Flink应用的方式加以讨论，关注它们如何分配及执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not concern us right now.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052907Z" creationid="xccui" creationdate="20190612T052907Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does not automatically clean up savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210957Z" creationid="xccui" creationdate="20190609T210957Z">
        <seg>同时，Flink也不会自动清理保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>duces a new DataStream of the same type as the input DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052158Z" creationid="xccui" creationdate="20190613T052158Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>enterprises across different industries such as (online) retail, social media, telecom‐ munication, gaming, and banking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050311Z" creationid="xccui" creationdate="20190605T050311Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.addSource(new SensorSource)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051430Z" creationid="xccui" creationdate="20190612T051430Z">
        <seg>env.addSource(new SensorSource)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.execute("Compute average sensor temperature")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042809Z" creationid="xccui" creationdate="20190612T042809Z">
        <seg>env.execute("Compute average sensor temperature")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041940Z" creationid="xccui" creationdate="20190612T041940Z">
        <seg>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>environment offers more configuration options, such as setting the program parallel‐ ism and enabling fault tolerance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T050029Z" creationid="xccui" creationdate="20190612T045857Z">
        <seg>执行环境还提供了很多配置选项，例如设置程序并行度，启用容错等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>event, the operator updates the corresponding aggregate value and emits an event with the updated value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052402Z" creationid="xccui" creationdate="20190614T052132Z">
        <seg>每到来一个事件，该算子都会更新相应的聚合结果，并将它以事件形式发送出去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>events with the same key are processed by the same task of the subsequent operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050540Z" creationid="xccui" creationdate="20190614T050540Z">
        <seg>这样一来有着相同键值的事件一定会在后续算子的同一个任务上处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>examples of finite, complete data sets that are generated all at once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T035813Z" creationid="xccui" creationdate="20190301T035813Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fashion, i.e., the data input of a query is fully available and the query terminates after it returned the computed result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194449Z" creationid="xccui" creationdate="20190228T194449Z">
        <seg>即，可以全量获取查询输入且查询会在返回结果后终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fers might become unavailable and data might get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234823Z" creationid="xccui" creationdate="20190605T234823Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>field is the common key, the second field is the sum, and the third field is not defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T060228Z" creationid="xccui" creationdate="20190614T060228Z">
        <seg>结果中的第1个字段是键值，第2个字段是总和，第3个字段没有定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first type are periodic report queries that compute business-relevant statistics such as revenue, user growth, or production output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203039Z" creationid="esouser" creationdate="20190603T203039Z">
        <seg>第一类是定期报告查询，用于计算业务相关的统计信息，如收入、用户增长、产出等，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gate, you lose the information about how your data varies over time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043721Z" creationid="xccui" creationdate="20190406T043721Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ger the execution of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011950Z" creationid="xccui" creationdate="20190613T011950Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>get stronger semantics with weaker guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050116Z" creationid="xccui" creationdate="20190416T050116Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>git clone https://github.com/streaming-with-flink/examples-scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040428Z" creationid="xccui" creationdate="20190611T040428Z">
        <seg>git clone https://github.com/streaming-with-flink/examples-scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://github.com/streaming-with-flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210814Z" creationid="esouser" creationdate="20190603T210814Z">
        <seg>https://github.com/streaming-with-flink.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035452Z" creationid="xccui" creationdate="20190418T035452Z">
        <seg>iii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>implement your own streaming sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054219Z" creationid="xccui" creationdate="20190612T054219Z">
        <seg>你也可以实现自己的流式数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in time, usually the point in time at which the event that is represented by the record happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204807Z" creationid="xccui" creationdate="20190606T204807Z">
        <seg>时间戳将记录和特定时间点进行关联，这些时间点通常是记录所表示事件的发生时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>increase the processing latency of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195732Z" creationid="xccui" creationdate="20190609T195732Z">
        <seg>但它仍会增加应用处理延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ing: transactional processing and analytical processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T194515Z" creationid="esouser" creationdate="20190603T194515Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>internal state, will it update it again after it recovers?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033635Z" creationid="xccui" creationdate="20190606T033635Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>its preceding operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T023212Z" creationid="xccui" creationdate="20190610T023212Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iv</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035723Z" creationid="xccui" creationdate="20190418T035723Z">
        <seg>iv</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iv | Table of Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130312Z" creationid="xccui" creationdate="20190605T130312Z">
        <seg>iv | 目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ix</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040613Z" creationid="xccui" creationdate="20190418T040613Z">
        <seg>ix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ix 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145402Z" creationid="esouser" creationdate="20190603T145402Z">
        <seg>ix 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>key of the current record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191732Z" creationid="xccui" creationdate="20190607T191732Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keyBy</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050132Z" creationid="xccui" creationdate="20190614T050132Z">
        <seg>keyBy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>low latency but results depend on the speed of processing and are not deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031232Z" creationid="xccui" creationdate="20190606T031232Z">
        <seg>总之，虽然处理时间提供了很低的延迟，但它的结果依赖处理速度，具有不确定性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>main method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043220Z" creationid="xccui" creationdate="20190612T043220Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>main() method assembles the dataflow and submits it to a remote JobManager when the StreamExecutionEnvironment.execute() method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T051801Z" creationid="xccui" creationdate="20190611T051412Z">
        <seg>通常情况下程序的main()方法会把dataflow组装好，然后在StreamExecutionEnvironment.execute()方法被调用时将其提交到远程的JobManager上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>max()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053408Z" creationid="xccui" creationdate="20190614T053408Z">
        <seg>max()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>maxBy()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053818Z" creationid="xccui" creationdate="20190614T053818Z">
        <seg>maxBy()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ments such as variable or function names, databases, data types, environment variables, statements, and keywords.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210805Z" creationid="esouser" creationdate="20190603T210805Z">
        <seg>ments such as variable or function names, databases, data types, environment variables, statements, and keywords.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>microservices are strictly decoupled from each other and only communicate over well-defined interfaces, each microservice can be implemented with a different tech‐ nology stack including a programming language, libraries, and datastores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T201016Z" creationid="esouser" creationdate="20190603T200753Z">
        <seg>由于微服务彼此间严格解耦且仅通过定义良好的接口通信，因此每个微服务的实现都可以选用不同的技术栈，包括编程语言、类库和数据存储等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>min()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052719Z" creationid="xccui" creationdate="20190614T052719Z">
        <seg>min()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>minBy()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053534Z" creationid="xccui" creationdate="20190614T053534Z">
        <seg>minBy()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>more processing slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205902Z" creationid="xccui" creationdate="20190428T205902Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mvn archetype:generate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T064642Z" creationid="xccui" creationdate="20190613T064642Z">
        <seg>mvn archetype:generate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mvn clean package -Pbuild-jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T064647Z" creationid="xccui" creationdate="20190613T064647Z">
        <seg>mvn clean package -Pbuild-jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not change the type of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061521Z" creationid="xccui" creationdate="20190614T061521Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>object AverageSensorReadings {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041830Z" creationid="xccui" creationdate="20190612T041830Z">
        <seg>object AverageSensorReadings {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142522Z" creationid="esouser" creationdate="20190603T142522Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one data source and one data sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000316Z" creationid="xccui" creationdate="20190401T000316Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or broadcast connection, each sending task needs a buffer for each receiving task, i.e, the number of required buffers is quadratic to the parallelism of the involved opera&lt;t0/&gt;‐&lt;t1/&gt; tors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045238Z" creationid="xccui" creationdate="20190504T045238Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def map(r: SensorReading): String = r.id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050726Z" creationid="xccui" creationdate="20190613T050726Z">
        <seg>override def map(r: SensorReading): String = r.id</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def map(value: Int): Int = value + 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020909Z" creationid="xccui" creationdate="20190613T020909Z">
        <seg>override def map(value: Int): Int = value + 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>point—when all tasks have successfully written their state into the remote storage— the JobManager writes the state handles to the remote storage and a pointer to this location to ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T194210Z" creationid="xccui" creationdate="20190606T150217Z">
        <seg>在检查点即将完成的时候，如果所有任务已经将各自状态成功写入远程存储，JobManager就会将状态句柄写入远程存储，并将远程位置的指针写入ZooKeeper。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>precede a barrier are included in the barrier’s checkpoint and all modifications due to records that follow the barrier are included in a later checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061733Z" creationid="xccui" creationdate="20190609T061206Z">
        <seg>所有先于分隔符的记录所导致的状态更改都会被包含在分隔符所对应的检查点之中；而所有晚于分隔符的记录所导致的状态更改都会被纳入随后的检查点中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>process historical events in the same way, thus enabling offline analytics or even time travel analyses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T203458Z" creationid="xccui" creationdate="20190409T203458Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rect answers to these questions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025245Z" creationid="xccui" creationdate="20190606T025245Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>repository to your local machine:1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040104Z" creationid="xccui" creationdate="20190611T040104Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>results continuously, maybe every minute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014703Z" creationid="xccui" creationdate="20190606T014703Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>separate tiers for data processing (the application itself) and data storage (a transac&lt;t0/&gt;‐&lt;t1/&gt; tional database system) as shown in &lt;t2/&gt;Figure 1-1&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T155712Z" creationid="xccui" creationdate="20190226T155712Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shown in &lt;t0/&gt;Figure 3-5&lt;t1/&gt; fulfills the requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152232Z" creationid="esouser" creationdate="20190514T152232Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sitively applied to these sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011815Z" creationid="xccui" creationdate="20190613T011815Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>src/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005738Z" creationid="xccui" creationdate="20190612T005738Z">
        <seg>src/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>streams can be ingested from sources such as message queues or files, or also be gen‐ erated on the fly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051324Z" creationid="xccui" creationdate="20190612T051324Z">
        <seg>这些数据流的来源可以是消息队列或文件，也可以实时生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substreams of events that share the same key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T043958Z" creationid="xccui" creationdate="20190614T043958Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>succeed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210830Z" creationid="esouser" creationdate="20190603T210830Z">
        <seg>succeed.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sum()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052601Z" creationid="xccui" creationdate="20190614T052601Z">
        <seg>sum()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>summary can be a count, a sum, a sample of the events seen so far, a window buffer, or a custom data structure that preserves some property interesting to the running application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055808Z" creationid="xccui" creationdate="20190414T055808Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tain information about the events they have received before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235835Z" creationid="xccui" creationdate="20190605T235835Z">
        <seg>相反，状态化算子可能会维护之前接收的事件信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tems use to update materialized views.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044542Z" creationid="xccui" creationdate="20190605T044542Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>text in which the method is invoked.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045223Z" creationid="xccui" creationdate="20190612T045223Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is called a state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051432Z" creationid="xccui" creationdate="20190608T051432Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that returns exactly one output event, possibly of a different type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045224Z" creationid="xccui" creationdate="20190613T045224Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>them in “Defining Keys and Referencing Fields” on page 102.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051537Z" creationid="xccui" creationdate="20190614T051537Z">
        <seg>我们会在102页"定义键值和引用字段中"介绍它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timestamp: Long, temperature: Double)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035709Z" creationid="xccui" creationdate="20190612T035709Z">
        <seg>timestamp: Long, temperature: Double)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tions and reduce.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050128Z" creationid="xccui" creationdate="20190614T050128Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to connect to the source of the sensor measurements and create an initial DataStream of type SensorReading.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051601Z" creationid="xccui" creationdate="20190612T051601Z">
        <seg>来连接传感器测量源，并创建出SensorReading类型的初始DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to instruct our program to interpret time semantics using event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045900Z" creationid="xccui" creationdate="20190612T045805Z">
        <seg>来指定程序使用事件时间作为其时间语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tors collect and process records with possibly unordered timestamps and finalize a computation when their event-time clock, which is advanced by the received water‐ marks, indicates that no more records with relevant timestamps are expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205535Z" creationid="xccui" creationdate="20190606T205535Z">
        <seg>对基于时间算子的任务而言，其收集和处理的记录可能会包含乱序的时间戳。只有当它们的事件时间时钟（由接收的水位线驱动）指示不必再等那些包含相关时间戳的记录时，才会最终触发计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transformation-specific function interface:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020901Z" creationid="xccui" creationdate="20190613T020901Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>truth because it persists the input events and can replay them in an deterministic order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T144509Z" creationid="xccui" creationdate="20190305T061121Z">
        <seg>这缘于于它可以持久化输入事件并以确定顺序将其重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type of parallelism is called task parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032421Z" creationid="xccui" creationdate="20190401T032421Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type of the input stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061554Z" creationid="xccui" creationdate="20190614T061554Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unzip master.zip</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040435Z" creationid="xccui" creationdate="20190611T040435Z">
        <seg>unzip master.zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>up with the events happening now, it can continue as a real-time application using exactly the same program logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155347Z" creationid="xccui" creationdate="20190412T155347Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>v</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040010Z" creationid="xccui" creationdate="20190418T040010Z">
        <seg>v</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val avgTemp: DataStream[SensorReading] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042225Z" creationid="xccui" creationdate="20190612T042225Z">
        <seg>val avgTemp: DataStream[SensorReading] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val celsius = (r.temperature - 32) * (5.0 / 9.0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042259Z" creationid="xccui" creationdate="20190612T042259Z">
        <seg>val celsius = (r.temperature - 32) * (5.0 / 9.0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041917Z" creationid="xccui" creationdate="20190612T041917Z">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val filteredSensors = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053212Z" creationid="xccui" creationdate="20190613T053212Z">
        <seg>val filteredSensors = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val inputStream: DataStream[(Int, Int, Int)] = env.fromElements( (1, 2, 2), (2, 3, 1), (2, 2, 4), (1, 5, 3))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054427Z" creationid="xccui" creationdate="20190614T054427Z">
        <seg>val inputStream: DataStream[(Int, Int, Int)] = env.fromElements( (1, 2, 2), (2, 3, 1), (2, 2, 4), (1, 5, 3))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val localEnv: StreamExecutionEnvironment.createLocalEnvironment()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045612Z" creationid="xccui" creationdate="20190612T045612Z">
        <seg>val localEnv: StreamExecutionEnvironment.createLocalEnvironment()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050713Z" creationid="xccui" creationdate="20190613T050713Z">
        <seg>val readings: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[SensorReadings] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053208Z" creationid="xccui" creationdate="20190613T053208Z">
        <seg>val readings: DataStream[SensorReadings] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val remoteEnv = StreamExecutionEnvironment.createRemoteEnvironment( "host",</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051333Z" creationid="xccui" creationdate="20190612T051333Z">
        <seg>val remoteEnv = StreamExecutionEnvironment.createRemoteEnvironment( "host",</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val resultStream: DataStream[(Int, Int, Int)] = inputStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054459Z" creationid="xccui" creationdate="20190614T054459Z">
        <seg>val resultStream: DataStream[(Int, Int, Int)] = inputStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] =</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054743Z" creationid="xccui" creationdate="20190612T054743Z">
        <seg>val sensorData: DataStream[SensorReading] =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] = env</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042047Z" creationid="xccui" creationdate="20190612T042047Z">
        <seg>val sensorData: DataStream[SensorReading] = env</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorIds: DataStream[String] = readings.map(new MyMapFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050717Z" creationid="xccui" creationdate="20190613T050717Z">
        <seg>val sensorIds: DataStream[String] = readings.map(new MyMapFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorIds: DataStream[String] = readings.map(r =&gt; r.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T051126Z" creationid="xccui" creationdate="20190613T051126Z">
        <seg>val sensorIds: DataStream[String] = readings.map(r =&gt; r.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sentences: DataStream[String] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005237Z" creationid="xccui" creationdate="20190613T005237Z">
        <seg>val sentences: DataStream[String] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val words: DataStream[String] = sentences</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005233Z" creationid="xccui" creationdate="20190613T005233Z">
        <seg>val words: DataStream[String] = sentences</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>value observed so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053815Z" creationid="xccui" creationdate="20190614T053815Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011820Z" creationid="xccui" creationdate="20190606T011820Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vi</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040256Z" creationid="xccui" creationdate="20190418T040256Z">
        <seg>vi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040515Z" creationid="xccui" creationdate="20190418T040515Z">
        <seg>vii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>viii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040559Z" creationid="xccui" creationdate="20190418T040559Z">
        <seg>viii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>viii | Table of Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130320Z" creationid="xccui" creationdate="20190605T130320Z">
        <seg>viii | 目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wait until they bring some from the supply room.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234106Z" creationid="xccui" creationdate="20190605T234106Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wget https://github.com/streaming-with-flink/examples-scala/archive/master.zip</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040424Z" creationid="xccui" creationdate="20190611T040424Z">
        <seg>wget https://github.com/streaming-with-flink/examples-scala/archive/master.zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>windows is defined by a set of policies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012709Z" creationid="xccui" creationdate="20190606T012709Z">
        <seg>窗口的行为是由一系列策略定义的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>windows of 5 seconds:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053745Z" creationid="xccui" creationdate="20190612T053745Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with the same key access the same state and thus can be processed together.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044717Z" creationid="xccui" creationdate="20190614T044414Z">
        <seg>这意味着所有键值相同的事件可以访问相同的状态，因此可以一并处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x | Preface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130336Z" creationid="xccui" creationdate="20190605T130328Z">
        <seg>x | 序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>xii | Preface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130350Z" creationid="xccui" creationdate="20190605T130350Z">
        <seg>xii | 序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052353Z" creationid="xccui" creationdate="20190416T052353Z">
        <seg>|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042813Z" creationid="xccui" creationdate="20190612T042813Z">
        <seg>}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} )</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042307Z" creationid="xccui" creationdate="20190612T042307Z">
        <seg>} )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>│</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040608Z" creationid="xccui" creationdate="20190611T040608Z">
        <seg>│</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040619Z" creationid="xccui" creationdate="20190611T040619Z">
        <seg>└── ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── AverageSensorReadings.scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040611Z" creationid="xccui" creationdate="20190611T040611Z">
        <seg>└── AverageSensorReadings.scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── StreamingJob.scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005810Z" creationid="xccui" creationdate="20190612T005810Z">
        <seg>└── StreamingJob.scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── apache</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005751Z" creationid="xccui" creationdate="20190612T005751Z">
        <seg>└── apache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005756Z" creationid="xccui" creationdate="20190612T005756Z">
        <seg>└── flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── github</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040556Z" creationid="xccui" creationdate="20190611T040556Z">
        <seg>└── github</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── io</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040552Z" creationid="xccui" creationdate="20190611T040552Z">
        <seg>└── io</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── log4j.properties</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005730Z" creationid="xccui" creationdate="20190612T005730Z">
        <seg>└── log4j.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── main</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040540Z" creationid="xccui" creationdate="20190611T040540Z">
        <seg>└── main</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── org</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005748Z" creationid="xccui" creationdate="20190612T005748Z">
        <seg>└── org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── quickstart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005800Z" creationid="xccui" creationdate="20190612T005800Z">
        <seg>└── quickstart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040543Z" creationid="xccui" creationdate="20190611T040543Z">
        <seg>└── scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── streamingwithflink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040559Z" creationid="xccui" creationdate="20190611T040559Z">
        <seg>└── streamingwithflink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── util</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040628Z" creationid="xccui" creationdate="20190611T040628Z">
        <seg>└── util</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040621Z" creationid="xccui" creationdate="20190611T040621Z">
        <seg>├── ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── BatchJob.scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005806Z" creationid="xccui" creationdate="20190612T005806Z">
        <seg>├── BatchJob.scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── chapter1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040604Z" creationid="xccui" creationdate="20190611T040604Z">
        <seg>├── chapter1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── chapter5</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040614Z" creationid="xccui" creationdate="20190611T040614Z">
        <seg>├── chapter5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── resources</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005721Z" creationid="xccui" creationdate="20190612T005721Z">
        <seg>├── resources</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
