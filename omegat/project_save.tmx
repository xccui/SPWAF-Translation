<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.1.5_3_10490" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>"path/to/jarFile.jar") // JAR file to ship to the JobManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045648Z" creationid="xccui" creationdate="20190612T045648Z">
        <seg>"path/to/jarFile.jar") // 需要传输到JobManager的JAR包</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>"thresholds", classOf[String], classOf[Double])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041352Z" creationid="xccui" creationdate="20190702T041352Z">
        <seg>"thresholds", classOf[String], classOf[Double])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#OnTimerContext, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032607Z" creationid="xccui" creationdate="20190622T032607Z">
        <seg>#OnTimerContext, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/flink run \</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040000Z" creationid="xccui" creationdate="20190329T040000Z">
        <seg>$ ./bin/flink run \</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/start-cluster.sh</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045745Z" creationid="xccui" creationdate="20190329T045745Z">
        <seg>$ ./bin/start-cluster.sh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/start-cluster.sh Starting cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123207Z" creationid="xccui" creationdate="20190605T123146Z">
        <seg>$ ./bin/start-cluster.sh Starting cluster.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ ./bin/stop-cluster.sh</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041911Z" creationid="xccui" creationdate="20190329T041911Z">
        <seg>$ ./bin/stop-cluster.sh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ cd flink-1.7.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025034Z" creationid="xccui" creationdate="20190329T025034Z">
        <seg>$ cd flink-1.7.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ tail -f ./log/flink-&lt;user&gt;-taskexecutor-&lt;n&gt;-&lt;hostname&gt;.out</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041713Z" creationid="xccui" creationdate="20190329T041713Z">
        <seg>$ tail -f ./log/flink-&lt;user&gt;-taskexecutor-&lt;n&gt;-&lt;hostname&gt;.out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ tar xvfz flink-1.7.1-bin-scala_2.12.tgz</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024954Z" creationid="xccui" creationdate="20190329T024954Z">
        <seg>$ tar xvfz flink-1.7.1-bin-scala_2.12.tgz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ wget https://streaming-with-flink.github.io/\ examples/download/examples-scala.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123520Z" creationid="xccui" creationdate="20190605T123520Z">
        <seg>$ wget https://streaming-with-flink.github.io/\ examples/download/examples-scala.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$ wget https://streaming-with-flink.github.io/examples/download/examples-scala.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035706Z" creationid="xccui" creationdate="20190329T035706Z">
        <seg>$ wget https://streaming-with-flink.github.io/examples/download/examples-scala.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>("Sarah", 23))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T071033Z" creationid="xccui" creationdate="20190616T071033Z">
        <seg>("Sarah", 23))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>("sensor_2", 10 * 1000L), // forward sensor_2 for 10 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031629Z" creationid="xccui" creationdate="20190622T031629Z">
        <seg>("sensor_2", 10 * 1000L), // 将sensor_2转发10秒</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>("sensor_7", 60 * 1000L)) // forward sensor_7 for 1 minute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031639Z" creationid="xccui" creationdate="20190622T031639Z">
        <seg>("sensor_7", 60 * 1000L)) // 将sensor_7转发1分钟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(List((r.id, r.temperature, tempDiff)), Some(r.temperature))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023256Z" creationid="xccui" creationdate="20190701T023256Z">
        <seg>(List((r.id, r.temperature, tempDiff)), Some(r.temperature))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(List.empty, Some(in.temperature))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023138Z" creationid="xccui" creationdate="20190701T023138Z">
        <seg>(List.empty, Some(in.temperature))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(List.empty, Some(r.temperature))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023336Z" creationid="xccui" creationdate="20190701T023336Z">
        <seg>(List.empty, Some(r.temperature))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(List.fill(mod)(new java.lang.Long(div + 1)) ++</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062849Z" creationid="xccui" creationdate="20190701T062849Z">
        <seg>(List.fill(mod)(new java.lang.Long(div + 1)) ++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(TumblingEventTimeWindows.of(size)) or for window.(TumblingProcessing TimeWindows.of(size)) depending on the configured time characteristic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T051459Z" creationid="xccui" creationdate="20190623T051459Z">
        <seg>具体调用那个方法取决于配置的时间特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(more on this in “Checkpoints, Savepoints, and State Recovery” on page 58), RocksDBStateBackend is a good choice for applications with very large state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T024258Z" creationid="xccui" creationdate="20190704T024258Z">
        <seg>所以对于状态非常大的应用是一个很好的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(r1: (String, Double, Double), r2: (String, Double, Double)) =&gt; { (r1._1, r1._2.min(r2._2), r1._3.max(r2._3))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043611Z" creationid="xccui" creationdate="20190625T043611Z">
        <seg>(r1: (String, Double, Double), r2: (String, Double, Double)) =&gt; { (r1._1, r1._2.min(r2._2), r1._3.max(r2._3))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031643Z" creationid="xccui" creationdate="20190622T031643Z">
        <seg>)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* first results and updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T033955Z" creationid="xccui" creationdate="20190629T033913Z">
        <seg>* 会区分首次结果和后续更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* monotonically increases for 1 second (in processing time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071249Z" creationid="xccui" creationdate="20190621T071249Z">
        <seg>* 则发出警告。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* re-directs them to a side output */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155826Z" creationid="xingcan" creationdate="20190628T155754Z">
        <seg>* 并将其重定向到副输出的ProcessFunction */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* with a temperature below 32F.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023903Z" creationid="xccui" creationdate="20190622T023641Z">
        <seg>* 向副输出发送冷冻警报。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071254Z" creationid="xccui" creationdate="20190621T071254Z">
        <seg>*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DarchetypeArtifactId=flink-quickstart-scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004831Z" creationid="xccui" creationdate="20190612T004831Z">
        <seg>-DarchetypeArtifactId=flink-quickstart-scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DarchetypeGroupId=org.apache.flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004826Z" creationid="xccui" creationdate="20190612T004826Z">
        <seg>-DarchetypeGroupId=org.apache.flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DarchetypeVersion=1.7.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004835Z" creationid="xccui" creationdate="20190612T004835Z">
        <seg>-DarchetypeVersion=1.7.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DartifactId=flink-scala-project</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004842Z" creationid="xccui" creationdate="20190612T004842Z">
        <seg>-DartifactId=flink-scala-project</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DgroupId=org.apache.flink.quickstart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004839Z" creationid="xccui" creationdate="20190612T004839Z">
        <seg>-DgroupId=org.apache.flink.quickstart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-DinteractiveMode=false</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004854Z" creationid="xccui" creationdate="20190612T004854Z">
        <seg>-DinteractiveMode=false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Dpackage=org.apache.flink.quickstart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004850Z" creationid="xccui" creationdate="20190612T004850Z">
        <seg>-Dpackage=org.apache.flink.quickstart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Dversion=0.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004846Z" creationid="xccui" creationdate="20190612T004846Z">
        <seg>-Dversion=0.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-c io.github.streamingwithflink.chapter1.AverageSensorReadings \ examples-scala.jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040003Z" creationid="xccui" creationdate="20190329T040003Z">
        <seg>-c io.github.streamingwithflink.chapter1.AverageSensorReadings \ examples-scala.jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T064032Z" creationid="xccui" creationdate="20190301T040155Z">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.&lt;t0/&gt; &lt;t1/&gt;ix 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035437Z" creationid="xccui" creationdate="20190418T035437Z">
        <seg>.&lt;t0/&gt; &lt;t1/&gt;ix 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.addSource(new SensorSource)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042142Z" creationid="xccui" creationdate="20190612T042142Z">
        <seg>.addSource(new SensorSource)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.aggregate(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040348Z" creationid="xccui" creationdate="20190625T040348Z">
        <seg>.aggregate(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.aggregate(new AvgTempFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005454Z" creationid="xccui" creationdate="20190624T005454Z">
        <seg>.aggregate(new AvgTempFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.allowedLateness(Time.seconds(5))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165249Z" creationid="xingcan" creationdate="20190628T165249Z">
        <seg>.allowedLateness(Time.seconds(5))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.apply(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040149Z" creationid="xccui" creationdate="20190628T040149Z">
        <seg>.apply(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.apply(new TemperatureAverager)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042735Z" creationid="xccui" creationdate="20190612T042735Z">
        <seg>.apply(new TemperatureAverager)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.assignAscendingTimestamps(e =&gt; e.timestamp)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052008Z" creationid="xccui" creationdate="20190620T052008Z">
        <seg>.assignAscendingTimestamps(e =&gt; e.timestamp)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.assignTimestampsAndWatermarks(new MyAssigner())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044656Z" creationid="xccui" creationdate="20190620T044656Z">
        <seg>.assignTimestampsAndWatermarks(new MyAssigner())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.assignTimestampsAndWatermarks(new SensorTimeAssigner)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042218Z" creationid="xccui" creationdate="20190612T042218Z">
        <seg>.assignTimestampsAndWatermarks(new SensorTimeAssigner)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.between(&lt;lower-bound&gt;, &lt;upper-bound&gt;) // bounds with respect to input1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025903Z" creationid="xccui" creationdate="20190628T025903Z">
        <seg>.between(&lt;lower-bound&gt;, &lt;upper-bound&gt;) // 相对于input1的上下界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.broadcast(broadcastStateDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024340Z" creationid="xccui" creationdate="20190702T024340Z">
        <seg>.broadcast(broadcastStateDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.connect(broadcastThresholds)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024509Z" creationid="xccui" creationdate="20190702T024509Z">
        <seg>.connect(broadcastThresholds)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.connect(filterSwitches)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031704Z" creationid="xccui" creationdate="20190622T031704Z">
        <seg>.connect(filterSwitches)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.connect(second.broadcast())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T051829Z" creationid="xccui" creationdate="20190615T051829Z">
        <seg>.connect(second.broadcast())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.connect(two)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050150Z" creationid="xccui" creationdate="20190615T050150Z">
        <seg>.connect(two)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.connect(two.keyBy(0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050438Z" creationid="xccui" creationdate="20190615T050438Z">
        <seg>.connect(two.keyBy(0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.equalTo(...)   // specify key attributes for input2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040016Z" creationid="xccui" creationdate="20190628T040016Z">
        <seg>.equalTo(...)   // 为input2指定键值属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.filter( r =&gt; r.temperature &gt;= 25 )</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053216Z" creationid="xccui" creationdate="20190613T053216Z">
        <seg>.filter( r =&gt; r.temperature &gt;= 25 )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.flatMap(id =&gt; id.split(" "))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005229Z" creationid="xccui" creationdate="20190613T005229Z">
        <seg>.flatMap(id =&gt; id.split(" "))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.flatMap(new TemperatureAlertFunction(1.1))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024139Z" creationid="xccui" creationdate="20190703T024139Z">
        <seg>.flatMap(new TemperatureAlertFunction(1.1))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.flatMap(new TemperatureAlertFunction(1.7))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062430Z" creationid="xccui" creationdate="20190630T062430Z">
        <seg>.flatMap(new TemperatureAlertFunction(1.7))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.flatMapWithState[(String, Double, Double), Double] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023019Z" creationid="xccui" creationdate="20190701T023019Z">
        <seg>.flatMapWithState[(String, Double, Double), Double] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.fromCollection(Seq(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031609Z" creationid="xccui" creationdate="20190622T031609Z">
        <seg>.fromCollection(Seq(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getIndexOfThisSubtask</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052356Z" creationid="xccui" creationdate="20190701T052356Z">
        <seg>.getIndexOfThisSubtask</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getSideOutput(new  OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155646Z" creationid="xingcan" creationdate="20190628T155646Z">
        <seg>.getSideOutput(new  OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getSideOutput(new OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155129Z" creationid="xingcan" creationdate="20190628T155129Z">
        <seg>.getSideOutput(new OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.getSideOutput(new OutputTag[String]("freezing-alarms"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022914Z" creationid="xccui" creationdate="20190622T022914Z">
        <seg>.getSideOutput(new OutputTag[String]("freezing-alarms"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041334Z" creationid="xccui" creationdate="20190622T041334Z">
        <seg>.keyBy(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062236Z" creationid="xccui" creationdate="20190614T062236Z">
        <seg>.keyBy(0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(0) // key on first field of the tuple</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054716Z" creationid="xccui" creationdate="20190614T054452Z">
        <seg>.keyBy(0) // 以元组第1个字段为键值进行分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(0, 0) // key both input streams on first attribute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050311Z" creationid="xccui" creationdate="20190615T050311Z">
        <seg>.keyBy(0, 0) // 两个数据流都以第1个属性作为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(_._1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002503Z" creationid="xccui" creationdate="20190624T002503Z">
        <seg>.keyBy(_._1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(_.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042408Z" creationid="xccui" creationdate="20190612T042408Z">
        <seg>.keyBy(_.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(_.id, _._1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031732Z" creationid="xccui" creationdate="20190622T031732Z">
        <seg>.keyBy(_.id, _._1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(r =&gt; r.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051709Z" creationid="xccui" creationdate="20190614T051709Z">
        <seg>.keyBy(r =&gt; r.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.keyBy(…)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025835Z" creationid="xccui" creationdate="20190628T025835Z">
        <seg>.keyBy(…)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map( r =&gt; {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042255Z" creationid="xccui" creationdate="20190612T042255Z">
        <seg>.map( r =&gt; {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(new MyMapper).setParallelism(defaultP * 2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061721Z" creationid="xccui" creationdate="20190616T061721Z">
        <seg>.map(new MyMapper).setParallelism(defaultP * 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(r =&gt; (r.id, r.temperature))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002456Z" creationid="xccui" creationdate="20190624T002456Z">
        <seg>.map(r =&gt; (r.id, r.temperature))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(r =&gt; (r.id, r.temperature, r.temperature))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043556Z" creationid="xccui" creationdate="20190625T043556Z">
        <seg>.map(r =&gt; (r.id, r.temperature, r.temperature))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.map(t -&gt; new Person(t.f0, t.f1))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062217Z" creationid="xccui" creationdate="20190617T062217Z">
        <seg>.map(t -&gt; new Person(t.f0, t.f1))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.print()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022917Z" creationid="xccui" creationdate="20190622T022917Z">
        <seg>.print()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.print().setParallelism(2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T015337Z" creationid="xccui" creationdate="20190617T015337Z">
        <seg>.print().setParallelism(2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061520Z" creationid="xccui" creationdate="20190623T061520Z">
        <seg>.process(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(ProcessJoinFunction) // process pairs of matched events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025916Z" creationid="xccui" creationdate="20190628T025916Z">
        <seg>.process(ProcessJoinFunction) // 处理匹配的事件对</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new CountFunction())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155052Z" creationid="xingcan" creationdate="20190628T155052Z">
        <seg>.process(new CountFunction())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new FreezingMonitor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022815Z" creationid="xccui" creationdate="20190622T022815Z">
        <seg>.process(new FreezingMonitor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new HighAndLowTempProcessFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030647Z" creationid="xccui" creationdate="20190625T030647Z">
        <seg>.process(new HighAndLowTempProcessFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new LateReadingsFilter)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155624Z" creationid="xingcan" creationdate="20190628T155624Z">
        <seg>.process(new LateReadingsFilter)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new ReadingFilter)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031750Z" creationid="xccui" creationdate="20190622T031750Z">
        <seg>.process(new ReadingFilter)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new TempIncreaseAlertFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071117Z" creationid="xccui" creationdate="20190621T071117Z">
        <seg>.process(new TempIncreaseAlertFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new TemperatureAverager)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T045129Z" creationid="xccui" creationdate="20190623T045129Z">
        <seg>.process(new TemperatureAverager)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new UpdatableTemperatureAlertFunction())</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024512Z" creationid="xccui" creationdate="20190702T024512Z">
        <seg>.process(new UpdatableTemperatureAlertFunction())</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.process(new UpdatingWindowCountFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165340Z" creationid="xingcan" creationdate="20190628T165340Z">
        <seg>.process(new UpdatingWindowCountFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.reduce(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040338Z" creationid="xccui" creationdate="20190625T040338Z">
        <seg>.reduce(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002511Z" creationid="xccui" creationdate="20190624T002511Z">
        <seg>.reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.reduce((x, y) =&gt; (x._1, x._2 ::: y._2))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062241Z" creationid="xccui" creationdate="20190614T062241Z">
        <seg>.reduce((x, y) =&gt; (x._1, x._2 ::: y._2))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.reduce/aggregate/process(...) // specify the window function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041358Z" creationid="xccui" creationdate="20190622T041358Z">
        <seg>.reduce/aggregate/process(...) // 指定窗口函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.returns(Types.POJO(Person.class));</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062253Z" creationid="xccui" creationdate="20190617T062253Z">
        <seg>.returns(Types.POJO(Person.class));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.setMaxParallelism(1024)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025203Z" creationid="xccui" creationdate="20190703T025203Z">
        <seg>.setMaxParallelism(1024)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.sideOutputLateData(new OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154958Z" creationid="xingcan" creationdate="20190628T154958Z">
        <seg>.sideOutputLateData(new OutputTag[SensorReading]("late-readings"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.split(t =&gt; if (t._1 &gt; 1000) Seq("large") else Seq("small"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064105Z" creationid="xccui" creationdate="20190615T064105Z">
        <seg>.split(t =&gt; if (t._1 &gt; 1000) Seq("large") else Seq("small"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.sum(1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054503Z" creationid="xccui" creationdate="20190614T054503Z">
        <seg>.sum(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040334Z" creationid="xccui" creationdate="20190625T040334Z">
        <seg>.timeWindow(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.hours(1), Time(minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060213Z" creationid="xccui" creationdate="20190623T060213Z">
        <seg>.timeWindow(Time.hours(1), Time(minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.seconds(1))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T053729Z" creationid="xccui" creationdate="20190623T053729Z">
        <seg>.timeWindow(Time.seconds(1))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.seconds(10))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154936Z" creationid="xingcan" creationdate="20190628T154936Z">
        <seg>.timeWindow(Time.seconds(10))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.seconds(15))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002507Z" creationid="xccui" creationdate="20190624T002507Z">
        <seg>.timeWindow(Time.seconds(15))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.timeWindow(Time.seconds(5))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042713Z" creationid="xccui" creationdate="20190612T042713Z">
        <seg>.timeWindow(Time.seconds(5))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.uid("TempAlert")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024132Z" creationid="xccui" creationdate="20190703T024132Z">
        <seg>.uid("TempAlert")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.union(tokyoStream, rioStream)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064856Z" creationid="xccui" creationdate="20190614T064856Z">
        <seg>.union(tokyoStream, rioStream)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.where(...)  // specify key attributes for input1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040006Z" creationid="xccui" creationdate="20190628T040006Z">
        <seg>.where(...)  // 为input1指定键值属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041337Z" creationid="xccui" creationdate="20190622T041337Z">
        <seg>.window(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(...) // specify the WindowAssigner [.trigger(...)] // optional: specify a Trigger [.evictor(...)] // optional: specify an Evictor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040210Z" creationid="xccui" creationdate="20190628T040145Z">
        <seg>.window(...) // 指定WindowAssigner [.trigger(...)] // 选择性地指定Trigger [.evictor(...)] // 选择性地指定Evictor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(EventTimeSessionWindows.withGap(Time.minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061515Z" creationid="xccui" creationdate="20190623T061515Z">
        <seg>.window(EventTimeSessionWindows.withGap(Time.minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(ProcessingTimeSessionWindows.withGap(Time.minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061554Z" creationid="xccui" creationdate="20190623T061554Z">
        <seg>.window(ProcessingTimeSessionWindows.withGap(Time.minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(SlidingEventTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060110Z" creationid="xccui" creationdate="20190623T060110Z">
        <seg>.window(SlidingEventTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(SlidingProcessingTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060140Z" creationid="xccui" creationdate="20190623T060140Z">
        <seg>.window(SlidingProcessingTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(TumblingEventTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054538Z" creationid="xccui" creationdate="20190623T054538Z">
        <seg>.window(TumblingEventTimeWindows.of(Time.hours(1), Time.minutes(15)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(TumblingEventTimeWindows.of(Time.seconds(1)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T045125Z" creationid="xccui" creationdate="20190623T045125Z">
        <seg>.window(TumblingEventTimeWindows.of(Time.seconds(1)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.window(TumblingProcessingTimeWindows.of(Time.seconds(1)))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T050101Z" creationid="xccui" creationdate="20190623T050101Z">
        <seg>.window(TumblingProcessingTimeWindows.of(Time.seconds(1)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.windowAll(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041446Z" creationid="xccui" creationdate="20190622T041446Z">
        <seg>.windowAll(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/**</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030655Z" creationid="xccui" creationdate="20190625T030655Z">
        <seg>/**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** A ProcessFunction that filters out late sensor readings and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155735Z" creationid="xingcan" creationdate="20190628T155735Z">
        <seg>/** 用于过滤出迟到的传感器读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** A counting WindowProcessFunction that distinguishes between</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T033840Z" creationid="xccui" creationdate="20190629T033840Z">
        <seg>/** 用于计数的WindowProcessFunction，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** A custom window that groups events into 30-second tumbling windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042719Z" creationid="xccui" creationdate="20190626T042645Z">
        <seg>/** 将事件按照每30秒滚动窗口进行分组的自定义窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** A trigger that fires early.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200135Z" creationid="xccui" creationdate="20190626T200135Z">
        <seg>/** 可提前触发的触发器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** Emits a warning if the temperature of a sensor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071241Z" creationid="xccui" creationdate="20190621T071241Z">
        <seg>/** 如果某传感器的温度在1秒（处理时间）内持续增加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/** Emits freezing alarms to a side output for readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023624Z" creationid="xccui" creationdate="20190622T023402Z">
        <seg>/** 对于温度低于32F的读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060223Z" creationid="xccui" creationdate="20190616T060223Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 1 min in ms</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051052Z" creationid="xccui" creationdate="20190620T051052Z">
        <seg>// 1分钟的毫秒数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A context object that is given to Evictor methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202140Z" creationid="xccui" creationdate="20190627T202124Z">
        <seg>// 用于移除器内方法的上下文对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A context object that is given to Trigger methods to allow them</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192513Z" creationid="xccui" creationdate="20190626T192513Z">
        <seg>// 用于触发器中方法的上下文对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A context that gives access to the current processing time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041941Z" creationid="xccui" creationdate="20190626T041941Z">
        <seg>// 用于访问当前处理时间的上下文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// An AggregateFunction to compute the average tempeature per sensor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005524Z" creationid="xccui" creationdate="20190624T005518Z">
        <seg>// 用于计算每个传感器平均温度的AggregateFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called for every element that gets added to a window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185959Z" creationid="xccui" creationdate="20190626T185959Z">
        <seg>// 每当有元素添加到窗口中时都会调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called when a processing-time timer fires public abstract TriggerResult onProcessingTime( long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190106Z" creationid="xccui" creationdate="20190626T190106Z">
        <seg>// 在处理时间计时器触发时调用 public abstract TriggerResult onProcessingTime( long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called when an event-time timer fires</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190125Z" creationid="xccui" creationdate="20190626T190125Z">
        <seg>// 在事件时间计时器触发时调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Called when several windows have been merged into one window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190218Z" creationid="xccui" creationdate="20190626T190218Z">
        <seg>// 当多个窗口合并为一个窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Clears any state that the trigger might hold for the given window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192245Z" creationid="xccui" creationdate="20190626T192245Z">
        <seg>// 在触发器中清除那些为给定窗口保存的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Continue.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200637Z" creationid="xccui" creationdate="20190626T200637Z">
        <seg>// 继续。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// DataStream of Tuple2&lt;String, Integer&gt; for Person(name, age) DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; persons = env.fromElements( Tuple2.of("Adam", 17),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035155Z" creationid="xccui" creationdate="20190617T035155Z">
        <seg>// DataStream of Tuple2&lt;String, Integer&gt; for Person(name, age) DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; persons = env.fromElements( Tuple2.of("Adam", 17),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// DataStream of Tuple2[String, Integer] for Person(name, age) val persons: DataStream[(String, Integer)] = env.fromElements( ("Adam", 17),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041104Z" creationid="xccui" creationdate="20190616T071009Z">
        <seg>// DataStream的类型Tuple2[String, Integer]表示Person(name, age) val persons: DataStream[(String, Integer)] = env.fromElements( ("Adam", 17),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Deletes a processing-time timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192706Z" creationid="xccui" creationdate="20190626T192706Z">
        <seg>// 删除一个处理时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Deletes an event-time timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192717Z" creationid="xccui" creationdate="20190626T192717Z">
        <seg>// 删除一个事件时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Deletes any custom per-window state when the window is purged</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024334Z" creationid="xccui" creationdate="20190624T010617Z">
        <seg>// 在窗口清除时删除自定义的单个窗口状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Emits a record to the side output identified by the OutputTag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010948Z" creationid="xccui" creationdate="20190624T010948Z">
        <seg>// 向OutputTag标识的副输出发送记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Evaluates the window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010513Z" creationid="xccui" creationdate="20190624T010513Z">
        <seg>// 对窗口执行计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Extension of TriggerContext that is given to the Trigger.onMerge() method</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193024Z" creationid="xccui" creationdate="20190626T193024Z">
        <seg>// 用于Trigger.onMerge()方法的TriggerContext扩展</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// IN1: the type of the first input stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042818Z" creationid="xccui" creationdate="20190615T042818Z">
        <seg>// IN1：第一条输入流的类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// IN2: the type of the second input stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042841Z" creationid="xccui" creationdate="20190615T042841Z">
        <seg>// IN2：第二条输入流的类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// IN: the type of the split elements OutputSelector[IN]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061011Z" creationid="xccui" creationdate="20190615T061011Z">
        <seg>// IN：拆分流的元素类型 OutputSelector[IN]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Indicates whether this assigner creates event-time windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041916Z" creationid="xccui" creationdate="20190626T041916Z">
        <seg>// 表明此分配器是否创建基于事件时间的窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// KEY: the type of the key KeySelector[IN, KEY]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051050Z" creationid="xccui" creationdate="20190618T051050Z">
        <seg>// KEY：键值类型 KeySelector[IN, KEY]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Merges per-window state of the trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193052Z" creationid="xccui" creationdate="20190626T193052Z">
        <seg>// 合并触发器中的单个窗口状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// O: the type of output elements FlatMapFunction[T, O]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T061027Z" creationid="xccui" creationdate="20190613T061027Z">
        <seg>// O：输出元素的类型 FlatMapFunction[T, O]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// O: the type of output elements MapFunction[T, O]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050340Z" creationid="xccui" creationdate="20190613T050340Z">
        <seg>// O输出元素的类型 MapFunction[T, O]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// OUT: the type of the output elements CoFlatMapFunction[IN1, IN2, OUT]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042914Z" creationid="xccui" creationdate="20190615T042914Z">
        <seg>// OUT：输出元素的类型 CoFlatMapFunction[IN1, IN2, OUT]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// OUT: the type of the output elements CoMapFunction[IN1, IN2, OUT]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042855Z" creationid="xccui" creationdate="20190615T042855Z">
        <seg>// OUT：输出元素的类型 CoMapFunction[IN1, IN2, OUT]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Optionally evicts elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201836Z" creationid="xccui" creationdate="20190627T201836Z">
        <seg>// 选择性地移除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Registers a processing-time timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192628Z" creationid="xccui" creationdate="20190626T192628Z">
        <seg>// 注册一个处理时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Registers an event-time timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192648Z" creationid="xccui" creationdate="20190626T192648Z">
        <seg>// 注册一个事件时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Retrieves a state object that is scoped to the window and the key of the trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192922Z" creationid="xccui" creationdate="20190626T192915Z">
        <seg>// 获取一个作用域为触发器键值和当前窗口的状态对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns a collection of windows to which the element is assigned</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041644Z" creationid="xccui" creationdate="20190626T041644Z">
        <seg>// 返回元素分配的目标窗口集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the TypeSerializer for the windows of this WindowAssigner public abstract TypeSerializer&lt;W&gt; getWindowSerializer( ExecutionConfig executionConfig);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041816Z" creationid="xccui" creationdate="20190626T041816Z">
        <seg>// 返回WindowAssigner中窗口的TypeSerializer public abstract TypeSerializer&lt;W&gt; getWindowSerializer( ExecutionConfig executionConfig);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the current event time watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202209Z" creationid="xccui" creationdate="20190627T202209Z">
        <seg>// 返回当前事件时间水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the current event-time watermark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010748Z" creationid="xccui" creationdate="20190624T010748Z">
        <seg>// 返回当前事件时间水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the current processing time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010733Z" creationid="xccui" creationdate="20190624T010733Z">
        <seg>// 返回当前处理时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the current processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202152Z" creationid="xccui" creationdate="20190627T202152Z">
        <seg>// 返回当前处理时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the current watermark time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192614Z" creationid="xccui" creationdate="20190626T192605Z">
        <seg>// 返回当前水位线时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the default Trigger of the WindowAssigner public abstract Trigger&lt;T, W&gt; getDefaultTrigger( StreamExecutionEnvironment env);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041742Z" creationid="xccui" creationdate="20190626T041742Z">
        <seg>// 返回WindowAssigner的默认触发器 public abstract Trigger&lt;T, W&gt; getDefaultTrigger( StreamExecutionEnvironment env);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns the metadata of the window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010721Z" creationid="xccui" creationdate="20190624T010721Z">
        <seg>// 返回窗口的元数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Returns true if this trigger supports merging of trigger state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190151Z" creationid="xccui" creationdate="20190626T190151Z">
        <seg>// 如果触发器支持合并触发器状态则返回true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Scala object that defines the DataStream program in the main() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041823Z" creationid="xccui" creationdate="20190612T041823Z">
        <seg>// 在main()方法中定义DataStream程序的Scala对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// State accessor for per-key global state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010914Z" creationid="xccui" creationdate="20190624T010914Z">
        <seg>// 用于每个键值全局状态的访问器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// State accessor for per-window state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024341Z" creationid="xccui" creationdate="20190624T010837Z">
        <seg>// 用于单个窗口状态的访问器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// T: the element type ReduceFunction[T]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061908Z" creationid="xccui" creationdate="20190614T061908Z">
        <seg>// T：元素类型 ReduceFunction[T]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// T: the type of elements FilterFunction[T]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053022Z" creationid="xccui" creationdate="20190613T053018Z">
        <seg>// T：元素类型 FilterFunction[T]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// T: the type of input elements</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050329Z" creationid="xccui" creationdate="20190613T050329Z">
        <seg>// T：输入元素的类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The accumulator holds the sum of temperatures and an event count.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005549Z" creationid="xccui" creationdate="20190624T005549Z">
        <seg>// 累加器用于保存温度总和及事件数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The context holding window metadata</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010711Z" creationid="xccui" creationdate="20190624T010711Z">
        <seg>// 保存窗口元数据的上下文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The state to be merged must support merging</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193113Z" creationid="xccui" creationdate="20190626T193107Z">
        <seg>// 目标状态自身需要支持合并</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This method is called when a window is purged</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192344Z" creationid="xccui" creationdate="20190626T192330Z">
        <seg>// 该方法会在清除窗口时调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TypeInformation for Java Tuples TypeInformation&lt;Tuple2&lt;Long, String&gt;&gt; tupleType = Types.TUPLE(Types.LONG, Types.STRING);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053842Z" creationid="xccui" creationdate="20190617T053631Z">
        <seg>// Java元组的TypeInformation TypeInformation&lt;Tuple2&lt;Long, String&gt;&gt; tupleType = Types.TUPLE(Types.LONG, Types.STRING);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TypeInformation for POJOs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053657Z" creationid="xccui" creationdate="20190617T053657Z">
        <seg>// POJO的TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TypeInformation for Scala Tuples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053836Z" creationid="xccui" creationdate="20190617T053836Z">
        <seg>// Scala元组的TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TypeInformation for case classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053913Z" creationid="xccui" creationdate="20190617T053913Z">
        <seg>// 样例类的TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// TypeInformation for primitive types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053611Z" creationid="xccui" creationdate="20190617T053611Z">
        <seg>// 原始类型的TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a filter lambda function that checks if tweets contains the word "flink"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055912Z" creationid="xccui" creationdate="20190618T055912Z">
        <seg>// 用于检查是否包含"flink"一词的过滤器lambda函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// add an input element to the accumulator and return the accumulator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004439Z" creationid="xccui" creationdate="20190624T004439Z">
        <seg>// 向累加器中添加一个输入元素并返回累加器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// alternative: connect two keyed streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T205951Z" creationid="xccui" creationdate="20190615T050418Z">
        <seg>// 或者是联结两个已经按键值分好区的数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// and the state of the triggers needs to be merged</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190949Z" creationid="xccui" creationdate="20190626T190949Z">
        <seg>// 且需要合并触发器状态时调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// apply ProcessFunction to monitor temperatures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071114Z" creationid="xccui" creationdate="20190621T071114Z">
        <seg>// 使用KeyedProcessFunction来监测温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// apply a stateful FlatMapFunction on the keyed stream which</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064858Z" creationid="xccui" creationdate="20190630T062142Z">
        <seg>// 在键值分区数据流上应用一个状态化的FlatMapFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// apply filtering CoProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031748Z" creationid="xccui" creationdate="20190622T031748Z">
        <seg>// 应用过滤CoProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// assign record timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054920Z" creationid="xccui" creationdate="20190620T054920Z">
        <seg>// 为记录分配时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// assign timestamps and generate watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044653Z" creationid="xccui" creationdate="20190620T044653Z">
        <seg>// 分配时间戳并生成水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// assign timestamps and watermarks (required for event time)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042213Z" creationid="xccui" creationdate="20190612T042213Z">
        <seg>// 分配时间戳和水位线（事件时间所需)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// both fields are public public String name; public int age;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044828Z" creationid="xccui" creationdate="20190617T044828Z">
        <seg>// 两个字段都是公有类型 public String name; public int age;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// broadcast second input stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T051818Z" creationid="xccui" creationdate="20190615T051818Z">
        <seg>// 将第二条输入流广播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// check if temperature is high</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162300Z" creationid="xccui" creationdate="20190702T162300Z">
        <seg>//检查温度是否过高</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// check if we have a threshold</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042721Z" creationid="xccui" creationdate="20190702T042721Z">
        <seg>// 检查阈值是否已经存在</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// check if we may forward the reading if (forwardingEnabled.value()) { out.collect(reading)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032301Z" creationid="xccui" creationdate="20190622T032301Z">
        <seg>// 检查是否可以转发读数 if (forwardingEnabled.value()) { out.collect(reading)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// check if we need to emit an alert</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064446Z" creationid="xccui" creationdate="20190630T064446Z">
        <seg>// 检查是否需要发出警报</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// clear all state for the key lastTempState.clear() lastTimerState.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210846Z" creationid="xccui" creationdate="20190704T210846Z">
        <seg>// 清除当前键值的所有状态 lastTempState.clear() lastTimerState.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// clear trigger state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200942Z" creationid="xccui" creationdate="20190626T200942Z">
        <seg>// 清除触发器状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compare record timestamp with current watermark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155905Z" creationid="xingcan" creationdate="20190628T155905Z">
        <seg>// 比较记录时间戳和当前水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compare temperature difference with threshold val tempDiff = (r.temperature - lastTemp.get).abs if (tempDiff &gt; 1.7) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023227Z" creationid="xccui" creationdate="20190701T023227Z">
        <seg>// 比较温度差和阈值 val tempDiff = (r.temperature - lastTemp.get).abs if (tempDiff &gt; 1.7) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compares the temperature readings and raises alerts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062424Z" creationid="xccui" creationdate="20190630T062424Z">
        <seg>// 来比较读数并发出警报</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compute average temperature using a user-defined function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042729Z" creationid="xccui" creationdate="20190612T042729Z">
        <seg>// 使用用户自定义函数计算平均温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compute the result from the accumulator and return it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004735Z" creationid="xccui" creationdate="20190624T004735Z">
        <seg>// 根据累加器计算并返回结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compute time for next early firing by rounding watermark to second</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200550Z" creationid="xccui" creationdate="20190626T200550Z">
        <seg>// 将水位线上取整到秒来计算下一次触发时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// compute timestamp of new clean up timer as record timestamp + one hour</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210546Z" creationid="xccui" creationdate="20190704T210515Z">
        <seg>// 将清理状态的计时器设置为比记录时间戳晚一小时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// configure a new threshold for the sensor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042639Z" creationid="xccui" creationdate="20190702T042607Z">
        <seg>// 为指定传感器配置新的阈值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// configure path for checkpoints on the remote filesystem</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025722Z" creationid="xccui" creationdate="20190704T025722Z">
        <seg>// 远程文件系统检查点配置路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// configure the state backend</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025733Z" creationid="xccui" creationdate="20190704T025733Z">
        <seg>// 配置状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// connect keyed sensor stream and broadcasted rules stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024501Z" creationid="xccui" creationdate="20190702T024501Z">
        <seg>// 联结键值分区传感数据流和广播的规则流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// connect readings and switches</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210051Z" creationid="xccui" creationdate="20190622T031702Z">
        <seg>// 联结读数和开关</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// connect streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T205938Z" creationid="xccui" creationdate="20190615T040821Z">
        <seg>// 将两条流联结</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// connect streams with broadcast</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210009Z" creationid="xccui" creationdate="20190615T051801Z">
        <seg>// 利用广播联结数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// convert Fahrenheit to Celsius with an inline lambda function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053316Z" creationid="xccui" creationdate="20190612T042248Z">
        <seg>// 使用内联lambda函数把华氏温度转为摄氏温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// count readings and update results if late readings arrive</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034051Z" creationid="xingcan" creationdate="20190628T165338Z">
        <seg>// 如果遇到迟到读数，则重新计数并更新结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// count readings per window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155050Z" creationid="xingcan" creationdate="20190628T155050Z">
        <seg>// 计算每个窗口内的读数个数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// count the number of readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034415Z" creationid="xccui" creationdate="20190629T034024Z">
        <seg>// 计算读数个数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create 1h event-time windows every 15 minutes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060053Z" creationid="xccui" creationdate="20190623T060053Z">
        <seg>// 每隔15分钟创建1小时的事件时间窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create 1h processing-time windows every 15 minutes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060138Z" creationid="xccui" creationdate="20190623T060138Z">
        <seg>// // 每隔15分钟创建1小时的处理时间窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a DataStream[SensorReading] from a stream source</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042034Z" creationid="xccui" creationdate="20190612T042034Z">
        <seg>// 从流式数据源中创建DataStream[SensorReading]对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a local stream execution environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045528Z" creationid="xccui" creationdate="20190612T045528Z">
        <seg>// 创建一个本地流式执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a new accumulator to start a new aggregate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004409Z" creationid="xccui" creationdate="20190624T004327Z">
        <seg>// 创建一个累加器来启动聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a remote stream execution environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045541Z" creationid="xccui" creationdate="20190612T045541Z">
        <seg>// 创建一个远程流式执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create event-time session windows with a 15 min gap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061512Z" creationid="xccui" creationdate="20190623T061512Z">
        <seg>// 创建15分钟间隔的事件时间会话窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create keyed state descriptor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041828Z" creationid="xccui" creationdate="20190702T041828Z">
        <seg>// 创建键值分区状态描述符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create processing-time session windows with a 15 min gap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061550Z" creationid="xccui" creationdate="20190623T061550Z">
        <seg>// 创建15分钟间隔的处理时间会话窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create state descriptor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064304Z" creationid="xccui" creationdate="20190630T064304Z">
        <seg>// 创建状态描述符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// default constructor is present</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044839Z" creationid="xccui" creationdate="20190617T044839Z">
        <seg>// 提供了默认构造函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// define a keyed window operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041328Z" creationid="xccui" creationdate="20190622T041328Z">
        <seg>// 定义键值分区窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// define a nonkeyed window-all operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041641Z" creationid="xccui" creationdate="20190622T041443Z">
        <seg>// 定义一个非键值分区的全量窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// define a side output tag</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023928Z" creationid="xccui" creationdate="20190622T023928Z">
        <seg>// 定义副输出标签</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// delete previous timer and register new timer ctx.timerService().deleteEventTimeTimer(curTimer) ctx.timerService().registerEventTimeTimer(newTimer)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210630Z" creationid="xccui" creationdate="20190704T210630Z">
        <seg>// 删除前一个计时器并注册一个新的计时器 ctx.timerService().deleteEventTimeTimer(curTimer) ctx.timerService().registerEventTimeTimer(newTimer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do not emit a watermark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054855Z" creationid="xccui" creationdate="20190620T054855Z">
        <seg>// 不发出水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do some cleanup, e.g., close connections to external systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034545Z" creationid="xccui" creationdate="20190619T034545Z">
        <seg>// 做一些清理工作，例如关闭和外部系统的连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do some initialization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034334Z" creationid="xccui" creationdate="20190619T034334Z">
        <seg>// 进行一些初始化工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do some more processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034522Z" creationid="xccui" creationdate="20190619T034459Z">
        <seg>// 做一些额外处理工作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// e.g., establish a connection to an external system</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034357Z" creationid="xccui" creationdate="20190619T034357Z">
        <seg>// 例如和外部系统建立连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emit freezing alarm if temperature is below 32F</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T024013Z" creationid="xccui" creationdate="20190622T024013Z">
        <seg>// 如果温度低于32F则发出冷冻警报</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emit late readings to a side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154955Z" creationid="xingcan" creationdate="20190628T154955Z">
        <seg>// 将迟到读数发至副输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emit new counters</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162604Z" creationid="xccui" creationdate="20190702T162604Z">
        <seg>// 发出新的计数器值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emit update with subtask index and counter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052656Z" creationid="xccui" creationdate="20190701T052656Z">
        <seg>// 发出由子任务编号和数目组成的更新元组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emit watermark if reading is from sensor_1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054836Z" creationid="xccui" creationdate="20190620T054836Z">
        <seg>// 如果读数来自sensor_1则发出水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// emitting the corresponding time window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044217Z" creationid="xccui" creationdate="20190626T044132Z">
        <seg>// 传出相应的时间窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// enable reading forwarding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032317Z" creationid="xccui" creationdate="20190622T032317Z">
        <seg>// 开启读数转发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// event-time session windows assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061436Z" creationid="xccui" creationdate="20190623T061436Z">
        <seg>// 事件时间会话窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// event-time sliding windows assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055959Z" creationid="xccui" creationdate="20190623T055959Z">
        <seg>// 事件时间滑动窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// execute application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044712Z" creationid="xccui" creationdate="20190612T042805Z">
        <seg>// 开始执行应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// fetch the last temperature from state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064415Z" creationid="xccui" creationdate="20190630T064415Z">
        <seg>// 从状态中获取上一次的温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// filter for persons of age &gt; 18</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041250Z" creationid="xccui" creationdate="20190616T071056Z">
        <seg>// 过滤出那些年龄大于18的人</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// filter for persons with age &gt; 18</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041258Z" creationid="xccui" creationdate="20190617T041209Z">
        <seg>// 过滤出那些年龄大于18的人</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// filter switches enable forwarding of readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031601Z" creationid="xccui" creationdate="20190622T031601Z">
        <seg>// 开启读数转发的过滤开关</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// final evaluation and purge window state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200753Z" creationid="xccui" creationdate="20190626T200736Z">
        <seg>// 进行最终计算并清除窗口状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// finalize result in ProcessWindowFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043634Z" creationid="xccui" creationdate="20190625T043634Z">
        <seg>// 在ProcessWindowFunction中计算最终结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// fire trigger to evaluate window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200900Z" creationid="xccui" creationdate="20190626T200900Z">
        <seg>// 触发进行窗口计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// first evaluation, emit first result out.collect((id, ctx.window.getEnd, cnt, "first")) isUpdate.update(true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034424Z" creationid="xccui" creationdate="20190629T034424Z">
        <seg>// 首次计算并发出结果 out.collect((id, ctx.window.getEnd, cnt, "first")) isUpdate.update(true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// first stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040749Z" creationid="xccui" creationdate="20190615T040720Z">
        <seg>// 第一条流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// firstSeen will be false if not set yet</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200329Z" creationid="xccui" creationdate="20190626T200329Z">
        <seg>// 如果之前没有设置过值firstSeen为false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// forward all readings to the regular output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T024045Z" creationid="xccui" creationdate="20190622T024045Z">
        <seg>//将所有读数发到常规输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// generate watermarks every 5 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045800Z" creationid="xccui" creationdate="20190620T045800Z">
        <seg>// 每5秒生成一次水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// generated watermark with 1 min tolerance</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051127Z" creationid="xccui" creationdate="20190620T051127Z">
        <seg>// 生成具有1分钟容忍度的水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get broadcasted state handle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042551Z" creationid="xccui" creationdate="20190702T042551Z">
        <seg>// 获取广播状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get default parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061553Z" creationid="xccui" creationdate="20190616T061553Z">
        <seg>// 获取默认并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get default parallelism as configured in the cluster config or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060212Z" creationid="xccui" creationdate="20190616T054814Z">
        <seg>// 获取通过集群配置或提交客户端指定的默认并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get previous temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071425Z" creationid="xccui" creationdate="20190621T071425Z">
        <seg>// 获取前一个温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get read-only broadcast state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042705Z" creationid="xccui" creationdate="20190702T042705Z">
        <seg>// 获取只读广播状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get threshold for sensor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042738Z" creationid="xccui" creationdate="20190702T042738Z">
        <seg>// 获取指定传感器的阈值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// get timestamp of current timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210606Z" creationid="xccui" creationdate="20190704T210606Z">
        <seg>// 获取当前计时器的时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// group readings in 1 hour windows with 15 min offset</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054519Z" creationid="xccui" creationdate="20190623T054519Z">
        <seg>// 将读数按照大小1小时、偏移量15分钟的时间窗口分组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// group readings in 1s event-time windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054536Z" creationid="xccui" creationdate="20190623T042926Z">
        <seg>// 将读数按照1秒事件时间窗口分组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// group readings in 1s processing-time windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054528Z" creationid="xccui" creationdate="20190623T045155Z">
        <seg>// 将读数按照1秒处理时间窗口分组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// group readings in 5 second tumbling windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042710Z" creationid="xccui" creationdate="20190612T042607Z">
        <seg>// 将读数按5秒的滚动窗口分组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// hold timestamp of currently active disable timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032225Z" creationid="xccui" creationdate="20190622T032225Z">
        <seg>// 用于保存当前活动的停止计时器的时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// hostname of JobManager</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045601Z" creationid="xccui" creationdate="20190612T045601Z">
        <seg>// JobManager的主机名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// increment counter if threshold is exceeded</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052519Z" creationid="xccui" creationdate="20190701T052519Z">
        <seg>// 如果超过阈值计数器加一</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// incrementally compute min and max temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043609Z" creationid="xccui" creationdate="20190625T043609Z">
        <seg>// 增量计算最低和最高温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// index of the subtask</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052350Z" creationid="xccui" creationdate="20190701T052350Z">
        <seg>// 子任务的编号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ingest sensor readings with a SensorSource SourceFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042138Z" creationid="xccui" creationdate="20190612T042134Z">
        <seg>// 利用SensorSource SourceFunction获取传感器读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ingest sensor stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T072814Z" creationid="xccui" creationdate="20190619T072814Z">
        <seg>// 读入传感器流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initialize keyed state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162956Z" creationid="xccui" creationdate="20190702T162956Z">
        <seg>// 初始化键值分区状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initialize local variable with state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163420Z" creationid="xccui" creationdate="20190702T163338Z">
        <seg>// 利用算子状态初始化本地的变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initialize operator state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163216Z" creationid="xccui" creationdate="20190702T163216Z">
        <seg>// 初始化算子状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// key by sensor id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T070917Z" creationid="xccui" creationdate="20190621T070917Z">
        <seg>// 以传感器id为键值分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// key by sensor ids</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031728Z" creationid="xccui" creationdate="20190622T031728Z">
        <seg>// 以传感器id为键值进行分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// keyBy two connected streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T205947Z" creationid="xccui" creationdate="20190615T050140Z">
        <seg>// 对两个联结后的数据流按键值分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// local count variable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052543Z" creationid="xccui" creationdate="20190701T052412Z">
        <seg>// 本地计数器变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// local variable for the operator high temperature cnt</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162232Z" creationid="xccui" creationdate="20190702T162232Z">
        <seg>// 在本地用于存储算子实例高温数目的变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// main() defines and executes the DataStream program</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041854Z" creationid="xccui" creationdate="20190612T041854Z">
        <seg>// 通过main()方法定义并执行DataStream程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// merge two accumulators and return the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004856Z" creationid="xccui" creationdate="20190624T004856Z">
        <seg>// 合并两个累加器并返回合并结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// monitor stream for readings with freezing temperatures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022810Z" creationid="xccui" creationdate="20190622T022810Z">
        <seg>// 监控冷冻温度数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// no previous temperature defined; just update the last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023135Z" creationid="xccui" creationdate="20190701T023135Z">
        <seg>// 之前的温度还未定义，只需更新前一个温度值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// not the first evaluation, emit an update</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034446Z" creationid="xccui" creationdate="20190629T034446Z">
        <seg>// 并非首次计算，发出更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// obtain the keyed state handle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041843Z" creationid="xccui" creationdate="20190702T041843Z">
        <seg>// 获取键值分区状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// obtain the state handle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064429Z" creationid="xccui" creationdate="20190630T064324Z">
        <seg>// 获得状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// optional: specify the evictor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014922Z" creationid="xccui" creationdate="20190626T014922Z">
        <seg>// 可选项：指定移除器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// optional: specify the trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014906Z" creationid="xccui" creationdate="20190626T014906Z">
        <seg>// 可选项：指定触发器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// organize readings by sensor id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042353Z" creationid="xccui" creationdate="20190612T042353Z">
        <seg>// 按照传感器id组织数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// output the lowest and highest temperature reading every 5 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030641Z" creationid="xccui" creationdate="20190625T030641Z">
        <seg>// 每5秒输出最低温和最高温读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// override the application-wide value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025201Z" creationid="xccui" creationdate="20190703T025142Z">
        <seg>// 会覆盖应用级别的数值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// partition and key the stream on the sensor ID</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062056Z" creationid="xccui" creationdate="20190630T062056Z">
        <seg>// 根据传感器ID进行键值分区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// port of JobManager process</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045623Z" creationid="xccui" creationdate="20190612T045623Z">
        <seg>// JobManager的端口号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// print result stream to standard out</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042754Z" creationid="xccui" creationdate="20190612T042754Z">
        <seg>// 将结果流打印到标准输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// print the main output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022926Z" creationid="xccui" creationdate="20190622T022926Z">
        <seg>// 打印主输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// process late readings for 5 additional seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165246Z" creationid="xingcan" creationdate="20190628T165246Z">
        <seg>// 额外处理5秒的迟到读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// processing-time session windows assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061532Z" creationid="xccui" creationdate="20190623T061532Z">
        <seg>// 处理时间会话窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// processing-time sliding windows assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060124Z" creationid="xccui" creationdate="20190623T060124Z">
        <seg>// 处理时间滑动窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// provide TypeInformation for the map lambda function's return type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062250Z" creationid="xccui" creationdate="20190617T062250Z">
        <seg>// 为map lambda函数的返回类型提供TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// provide the TypeInformation for the output data type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061937Z" creationid="xccui" creationdate="20190617T061937Z">
        <seg>// 为输出数据类型提供TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// register initial timer only for first element</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200413Z" creationid="xccui" creationdate="20190626T200413Z">
        <seg>// 仅为第一个元素注册初始计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// register next early firing timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200822Z" creationid="xccui" creationdate="20190626T200822Z">
        <seg>// 注册下一个用于提前触发的计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// register state for last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210327Z" creationid="xccui" creationdate="20190704T210327Z">
        <seg>// 注册用于最近一次温度的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// register state for last timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210431Z" creationid="xccui" creationdate="20190704T210348Z">
        <seg>// 注册用于前一个计时器的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// register timer for the window end ctx.registerEventTimeTimer(window.getEnd) firstSeen.update(true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200624Z" creationid="xccui" creationdate="20190626T200624Z">
        <seg>// 为窗口结束时间注册计时器 ctx.registerEventTimeTimer(window.getEnd) firstSeen.update(true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// remember current timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T071725Z">
        <seg>// 记住当前的计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// remove all state; forward switch will be false by default</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032654Z" creationid="xccui" creationdate="20190622T032654Z">
        <seg>// 移除所有状态，默认情况下转发开关关闭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// remove current timer and register new timer ctx.timerService().deleteEventTimeTimer(curTimerTimestamp) ctx.timerService().registerProcessingTimeTimer(timerTimestamp) disableTimer.update(timerTimestamp)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190622T032411Z">
        <seg>// 移除当前计时器并注册一个新的 ctx.timerService().deleteEventTimeTimer(curTimerTimestamp) ctx.timerService().registerProcessingTimeTimer(timerTimestamp) disableTimer.update(timerTimestamp)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// remove threshold for the sensor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042634Z" creationid="xccui" creationdate="20190702T042618Z">
        <seg>// 删除该传感器的阈值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// restore state by adding all longs of the list</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052858Z" creationid="xccui" creationdate="20190701T052858Z">
        <seg>// 将状态恢复为列表中的全部long值之和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// restores the state of the function from the provided list</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T045521Z" creationid="xccui" creationdate="20190701T045521Z">
        <seg>// 根据提供的列表恢复函数状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// retrieve and print the freezing alarms side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023910Z" creationid="xccui" creationdate="20190622T022908Z">
        <seg>// 获取并打印包含冷冻警报的副输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// retrieve late readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155640Z" creationid="xingcan" creationdate="20190628T155640Z">
        <seg>// 获取迟到读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// retrieve the late events from the side output as a stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155122Z" creationid="xingcan" creationdate="20190628T155122Z">
        <seg>// 从副输出中获取迟到事件的数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// return count as ten parts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062844Z" creationid="xccui" creationdate="20190701T062844Z">
        <seg>// 将计数值作为10个子部分返回</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// return record timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051156Z" creationid="xccui" creationdate="20190620T051156Z">
        <seg>// 返回记录的时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a snapshot the state of the function as a list</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T045506Z" creationid="xccui" creationdate="20190701T045506Z">
        <seg>// 以列表形式返回一个函数状态的快照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// rounding down by 30 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044057Z" creationid="xccui" creationdate="20190626T044057Z">
        <seg>// 30秒取余</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// second stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040744Z" creationid="xccui" creationdate="20190615T040744Z">
        <seg>// 第二条流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set checkpointing interval to 10 seconds (10000 milliseconds)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204847Z" creationid="xccui" creationdate="20190702T204847Z">
        <seg>// 将检查点的生成周期设置为10秒（10000毫秒）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set disable forward timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032334Z" creationid="xccui" creationdate="20190622T032334Z">
        <seg>// 设置停止计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set parallelism of the environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060453Z" creationid="xccui" creationdate="20190616T060453Z">
        <seg>// 设置环境的并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set processing time timer for now + 1 second</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T071708Z">
        <seg>// 以当前时间+1秒设置处理时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set the 2nd field to 42</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040517Z" creationid="xccui" creationdate="20190617T040501Z">
        <seg>// 将第二个字段设为42</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set the event time characteristic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044631Z" creationid="xccui" creationdate="20190620T044631Z">
        <seg>// 设置为事件时间特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set the maximum parallelism for this application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025101Z" creationid="xccui" creationdate="20190703T025044Z">
        <seg>// 为此应用设置最大并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set the maximum parallelism for this operator and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025128Z" creationid="xccui" creationdate="20190703T025128Z">
        <seg>// 为此算子设置最大并行度，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// set up the streaming execution environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044717Z" creationid="xccui" creationdate="20190612T041910Z">
        <seg>// 设置流式执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shortcut for window.(SlidingEventTimeWindow.of(size, slide))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060210Z" creationid="xccui" creationdate="20190623T060210Z">
        <seg>// window.(SlidingEventTimeWindow.of(size, slide))的简写</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shortcut for window.(TumblingEventTimeWindows.of(size))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T053727Z" creationid="xccui" creationdate="20190623T053727Z">
        <seg>// window.(TumblingEventTimeWindows.of(size))的简写</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// sliding windows assigner using a shortcut method</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060157Z" creationid="xccui" creationdate="20190623T060157Z">
        <seg>// 使用窗口分配器简写方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// snapshot state as list with a single count</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T053234Z" creationid="xccui" creationdate="20190701T053234Z">
        <seg>// 将一个包含单个数目值的列表作为状态快照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// specify the JoinFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040220Z" creationid="xccui" creationdate="20190628T040220Z">
        <seg>// 指定JoinFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// specify the window assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041351Z" creationid="xccui" creationdate="20190622T041351Z">
        <seg>// 指定窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// split count into ten partial counts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062725Z" creationid="xccui" creationdate="20190701T062725Z">
        <seg>// 将计数值分成10个子部分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// state to check if this is the first evaluation of the window or not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034320Z" creationid="xccui" creationdate="20190629T034320Z">
        <seg>// 该状态用于标识是否是第一次对窗口进行计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// stores temperature of last sensor reading</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071510Z" creationid="xccui" creationdate="20190621T071334Z">
        <seg>// 存储最近一次传感器温度读数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// stores timestamp of currently active timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T071403Z">
        <seg>// 存储当前活动计时器的时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// subtasks are 0-indexed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034418Z" creationid="xccui" creationdate="20190619T034418Z">
        <seg>// 子任务编号从0开始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// sum the second field of the tuple in place</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054727Z" creationid="xccui" creationdate="20190614T054550Z">
        <seg>// 滚动计算每个分区内元组第2个字段的总和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// switch to enable forwarding</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032055Z" creationid="xccui" creationdate="20190622T032055Z">
        <seg>// 开启转发的开关</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// temperature changed by more than the threshold</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064508Z" creationid="xccui" creationdate="20190630T064508Z">
        <seg>// 温度变化超过阈值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// temperature decreased; delete current timer ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp) currentTimer.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T071603Z">
        <seg>// 温度下降，删除当前计时器 ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp) currentTimer.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// temperature increased and we have not set a timer yet</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T071647Z">
        <seg>// 温度升高并且还未设置计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// temperature increased by more than the threshold</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042813Z" creationid="xccui" creationdate="20190702T042813Z">
        <seg>// 温度增加超过阈值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the descriptor of the broadcast state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024323Z" creationid="xccui" creationdate="20190702T024323Z">
        <seg>// 广播状态的描述符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the descriptor of the broadcast state private lazy val thresholdStateDescriptor = new MapStateDescriptor[String, Double](</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041348Z" creationid="xccui" creationdate="20190702T041348Z">
        <seg>// 广播状态的描述符 private lazy val thresholdStateDescriptor = new MapStateDescriptor[String, Double](</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the keyed state handle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190702T041407Z">
        <seg>// 键值分区状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the keyed state handle for the last registered timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210438Z" creationid="xccui" creationdate="20190704T210223Z">
        <seg>// 前一个注册的计时器的键值分区状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the keyed state handle for the last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205652Z" creationid="xccui" creationdate="20190704T205652Z">
        <seg>// 用于存储最近一次温度的键值分区状态句柄</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the map parallelism is set to double the default parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061644Z" creationid="xccui" creationdate="20190616T061644Z">
        <seg>// 设置map的并行度为默认并行度的两倍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the print sink parallelism is fixed to 2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061714Z" creationid="xccui" creationdate="20190616T061714Z">
        <seg>// print数据汇的并行度固定为2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the source runs with the default parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061610Z" creationid="xccui" creationdate="20190616T061610Z">
        <seg>// 数据源以默认并行度运行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the state handle object</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064308Z" creationid="xccui" creationdate="20190630T064223Z">
        <seg>// 状态句柄对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this is a late reading =&gt; redirect it to the side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155935Z" creationid="xingcan" creationdate="20190628T155935Z">
        <seg>// 将迟到读数重定向到副输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// threshold exceeded; emit an alert and update the last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023316Z" creationid="xccui" creationdate="20190701T023253Z">
        <seg>// 超出阈值，发出警报并更新前一个温度值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// threshold not exceeded; just update the last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023334Z" creationid="xccui" creationdate="20190701T023310Z">
        <seg>// 没有超出阈值，仅更新前一个温度值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// to register timer callbacks and deal with state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192549Z" creationid="xccui" creationdate="20190626T192549Z">
        <seg>// 使其可以注册计时器回调并处理状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update keyed high temp counter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162525Z" creationid="xccui" creationdate="20190702T162525Z">
        <seg>// 更新键值分区的高温计数器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update last temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071505Z" creationid="xccui" creationdate="20190621T071505Z">
        <seg>// 更新最近一次的温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update lastTemp state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064711Z" creationid="xccui" creationdate="20190630T064711Z">
        <seg>// 更新lastTemp状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update local operator high temp counter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162537Z" creationid="xccui" creationdate="20190702T162458Z">
        <seg>// 更新本地算子实例的高温计数器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update maximum timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051141Z" creationid="xccui" creationdate="20190620T051141Z">
        <seg>// 更新最大时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update operator state with local state opCntState.clear() opCntState.add(opHighTempCnt)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163406Z" creationid="xccui" creationdate="20190702T163406Z">
        <seg>// 利用本地的状态更新算子状态 opCntState.clear() opCntState.add(opHighTempCnt)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// update timer timestamp state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210642Z" creationid="xccui" creationdate="20190704T210642Z">
        <seg>//更新计时器时间戳状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// use event time for the application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041934Z" creationid="xccui" creationdate="20190612T041934Z">
        <seg>// 在应用中使用事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144704Z" creationid="esouser" creationdate="20190603T144704Z">
        <seg>1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 Flink’s batch processing API, the DataSet API, and its operators are separate from their corresponding streaming counterparts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122153Z" creationid="xccui" creationdate="20190605T122123Z">
        <seg>1 虽然Flink用于批处理的DataSet API及其算子都独立于对应的流处理部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 ListState and its performance characteristics are discussed in detail in Chapter 7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040517Z" creationid="xccui" creationdate="20190625T040517Z">
        <seg>1 有关ListState以及它的性能特征会在第7章详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 We also provide an examples-Java repository with all the examples implemented in Java.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040200Z" creationid="xccui" creationdate="20190611T040200Z">
        <seg>1 我们同时提供了一个examples-Java库，里面的示例都是用Java完成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144730Z" creationid="esouser" creationdate="20190603T144730Z">
        <seg>10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10 | Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130755Z" creationid="xccui" creationdate="20190605T130755Z">
        <seg>10 | 第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040413Z" creationid="xccui" creationdate="20190418T040413Z">
        <seg>10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>100</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035718Z" creationid="xccui" creationdate="20190418T035718Z">
        <seg>100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>100 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045154Z" creationid="xccui" creationdate="20190619T045154Z">
        <seg>100 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1005</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210838Z" creationid="esouser" creationdate="20190603T210838Z">
        <seg>1005</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>101</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035748Z" creationid="xccui" creationdate="20190418T035748Z">
        <seg>101</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>102</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035752Z" creationid="xccui" creationdate="20190418T035752Z">
        <seg>102</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>103</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145347Z" creationid="esouser" creationdate="20190603T145347Z">
        <seg>103</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>104</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145634Z" creationid="esouser" creationdate="20190603T145634Z">
        <seg>104</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>104 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045340Z" creationid="xccui" creationdate="20190619T045340Z">
        <seg>104 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>105</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035758Z" creationid="xccui" creationdate="20190418T035758Z">
        <seg>105</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>106</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145646Z" creationid="esouser" creationdate="20190603T145646Z">
        <seg>106</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>106 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045400Z" creationid="xccui" creationdate="20190619T045400Z">
        <seg>106 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>107</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145648Z" creationid="esouser" creationdate="20190603T145648Z">
        <seg>107</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>108</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035803Z" creationid="xccui" creationdate="20190418T035803Z">
        <seg>108</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>108 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045411Z" creationid="xccui" creationdate="20190619T045411Z">
        <seg>108 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>109</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145701Z" creationid="esouser" creationdate="20190603T145701Z">
        <seg>109</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040518Z" creationid="xccui" creationdate="20190418T040518Z">
        <seg>11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>110 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041850Z" creationid="xccui" creationdate="20190629T041850Z">
        <seg>110 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>111</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145756Z" creationid="esouser" creationdate="20190603T145756Z">
        <seg>111</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>112 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041907Z" creationid="xccui" creationdate="20190629T041907Z">
        <seg>112 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>113</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035807Z" creationid="xccui" creationdate="20190418T035807Z">
        <seg>113</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>115</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035811Z" creationid="xccui" creationdate="20190418T035811Z">
        <seg>115</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>116</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035815Z" creationid="xccui" creationdate="20190418T035815Z">
        <seg>116</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>117</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035819Z" creationid="xccui" creationdate="20190418T035819Z">
        <seg>117</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>118 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041922Z" creationid="xccui" creationdate="20190629T041922Z">
        <seg>118 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>119</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145851Z" creationid="esouser" creationdate="20190603T145851Z">
        <seg>119</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144741Z" creationid="esouser" creationdate="20190603T144741Z">
        <seg>12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>120</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035823Z" creationid="xccui" creationdate="20190418T035823Z">
        <seg>120</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>120 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041936Z" creationid="xccui" creationdate="20190629T041936Z">
        <seg>120 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>121</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035827Z" creationid="xccui" creationdate="20190418T035827Z">
        <seg>121</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>122</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035830Z" creationid="xccui" creationdate="20190418T035830Z">
        <seg>122</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>122 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041957Z" creationid="xccui" creationdate="20190629T041957Z">
        <seg>122 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>123</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150326Z" creationid="esouser" creationdate="20190603T150326Z">
        <seg>123</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1234,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054737Z" creationid="xccui" creationdate="20190612T054737Z">
        <seg>1234,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>124</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035833Z" creationid="xccui" creationdate="20190418T035833Z">
        <seg>124</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>125</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035837Z" creationid="xccui" creationdate="20190418T035837Z">
        <seg>125</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>126</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035840Z" creationid="xccui" creationdate="20190418T035840Z">
        <seg>126</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>127</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035847Z" creationid="xccui" creationdate="20190418T035847Z">
        <seg>127</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>129</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035856Z" creationid="xccui" creationdate="20190418T035856Z">
        <seg>129</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>13</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144752Z" creationid="esouser" creationdate="20190603T144752Z">
        <seg>13</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>130 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042016Z" creationid="xccui" creationdate="20190629T042016Z">
        <seg>130 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>131</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035859Z" creationid="xccui" creationdate="20190418T035859Z">
        <seg>131</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>132 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042020Z" creationid="xccui" creationdate="20190629T042020Z">
        <seg>132 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>134</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150328Z" creationid="esouser" creationdate="20190603T150328Z">
        <seg>134</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>135</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035903Z" creationid="xccui" creationdate="20190418T035903Z">
        <seg>135</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>136</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035913Z" creationid="xccui" creationdate="20190418T035913Z">
        <seg>136</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>137</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035917Z" creationid="xccui" creationdate="20190418T035917Z">
        <seg>137</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>14 | Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130837Z" creationid="xccui" creationdate="20190605T130837Z">
        <seg>14 | 10 | 第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>140</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035921Z" creationid="xccui" creationdate="20190418T035921Z">
        <seg>140</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>140 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042025Z" creationid="xccui" creationdate="20190629T042025Z">
        <seg>140 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>141</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035925Z" creationid="xccui" creationdate="20190418T035925Z">
        <seg>141</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>142</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035928Z" creationid="xccui" creationdate="20190418T035928Z">
        <seg>142</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>142 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042030Z" creationid="xccui" creationdate="20190629T042030Z">
        <seg>142 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>143</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035932Z" creationid="xccui" creationdate="20190418T035932Z">
        <seg>143</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>144</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035936Z" creationid="xccui" creationdate="20190418T035936Z">
        <seg>144</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>145</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150330Z" creationid="esouser" creationdate="20190603T150330Z">
        <seg>145</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>146</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210747Z" creationid="esouser" creationdate="20190603T210747Z">
        <seg>146</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>146 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042033Z" creationid="xccui" creationdate="20190629T042033Z">
        <seg>146 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>148</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210748Z" creationid="esouser" creationdate="20190603T210748Z">
        <seg>148</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>149</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035940Z" creationid="xccui" creationdate="20190418T035940Z">
        <seg>149</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>15</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014613Z" creationid="xccui" creationdate="20190225T014613Z">
        <seg>15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>150</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150822Z" creationid="esouser" creationdate="20190603T150822Z">
        <seg>150</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>150 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042039Z" creationid="xccui" creationdate="20190629T042039Z">
        <seg>150 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>152</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150824Z" creationid="esouser" creationdate="20190603T150824Z">
        <seg>152</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>152 | Chapter 6: Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042046Z" creationid="xccui" creationdate="20190629T042046Z">
        <seg>152 | 第6章：基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>153</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150825Z" creationid="esouser" creationdate="20190603T150825Z">
        <seg>153</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>154</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150827Z" creationid="esouser" creationdate="20190603T150827Z">
        <seg>154</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>156</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035944Z" creationid="xccui" creationdate="20190418T035944Z">
        <seg>156</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>158</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150921Z" creationid="esouser" creationdate="20190603T150921Z">
        <seg>158</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>16</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172722Z" creationid="xccui" creationdate="20190228T172722Z">
        <seg>16</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>160</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150929Z" creationid="esouser" creationdate="20190603T150929Z">
        <seg>160</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>164</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151101Z" creationid="esouser" creationdate="20190603T151101Z">
        <seg>164</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>166</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151123Z" creationid="esouser" creationdate="20190603T151123Z">
        <seg>166</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>167</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035947Z" creationid="xccui" creationdate="20190418T035947Z">
        <seg>167</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>168</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151126Z" creationid="esouser" creationdate="20190603T151126Z">
        <seg>168</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>169</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035951Z" creationid="xccui" creationdate="20190418T035951Z">
        <seg>169</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>17</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045711Z" creationid="xccui" creationdate="20190329T045711Z">
        <seg>17</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>170</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035954Z" creationid="xccui" creationdate="20190418T035954Z">
        <seg>170</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>171</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035958Z" creationid="xccui" creationdate="20190418T035958Z">
        <seg>171</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>172</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040002Z" creationid="xccui" creationdate="20190418T040002Z">
        <seg>172</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>174</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040006Z" creationid="xccui" creationdate="20190418T040006Z">
        <seg>174</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>175</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040024Z" creationid="xccui" creationdate="20190418T040024Z">
        <seg>175</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>176</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040028Z" creationid="xccui" creationdate="20190418T040028Z">
        <seg>176</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>177</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151128Z" creationid="esouser" creationdate="20190603T151128Z">
        <seg>177</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>179</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151753Z" creationid="esouser" creationdate="20190603T151753Z">
        <seg>179</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>18</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014603Z" creationid="xccui" creationdate="20190225T014603Z">
        <seg>18</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>18 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041412Z" creationid="xccui" creationdate="20190606T041310Z">
        <seg>18 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>180</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040032Z" creationid="xccui" creationdate="20190418T040032Z">
        <seg>180</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>182</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040043Z" creationid="xccui" creationdate="20190418T040043Z">
        <seg>182</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>183</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151755Z" creationid="esouser" creationdate="20190603T151755Z">
        <seg>183</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>184</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151757Z" creationid="esouser" creationdate="20190603T151757Z">
        <seg>184</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>185</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040048Z" creationid="xccui" creationdate="20190418T040048Z">
        <seg>185</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>186</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152029Z" creationid="esouser" creationdate="20190603T152029Z">
        <seg>186</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>187</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040052Z" creationid="xccui" creationdate="20190418T040052Z">
        <seg>187</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>188</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040055Z" creationid="xccui" creationdate="20190418T040055Z">
        <seg>188</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>189</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040059Z" creationid="xccui" creationdate="20190418T040059Z">
        <seg>189</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>19</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045716Z" creationid="xccui" creationdate="20190329T045716Z">
        <seg>19</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>190</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040104Z" creationid="xccui" creationdate="20190418T040104Z">
        <seg>190</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>191</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040107Z" creationid="xccui" creationdate="20190418T040107Z">
        <seg>191</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>192</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040111Z" creationid="xccui" creationdate="20190418T040111Z">
        <seg>192</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>193</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040114Z" creationid="xccui" creationdate="20190418T040114Z">
        <seg>193</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>194</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210750Z" creationid="esouser" creationdate="20190603T210750Z">
        <seg>194</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>195</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040118Z" creationid="xccui" creationdate="20190418T040118Z">
        <seg>195</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>196</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040121Z" creationid="xccui" creationdate="20190418T040121Z">
        <seg>196</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>197</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040125Z" creationid="xccui" creationdate="20190418T040125Z">
        <seg>197</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>198</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040128Z" creationid="xccui" creationdate="20190418T040128Z">
        <seg>198</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>199</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040132Z" creationid="xccui" creationdate="20190418T040132Z">
        <seg>199</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1&gt; SensorReading(sensor_38,1515014051000,14.781835420242471)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043437Z" creationid="xccui" creationdate="20190611T043437Z">
        <seg>1&gt; SensorReading(sensor_38,1515014051000,14.781835420242471)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144708Z" creationid="esouser" creationdate="20190603T144708Z">
        <seg>2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035445Z" creationid="xccui" creationdate="20190418T035445Z">
        <seg>2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>20</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152503Z" creationid="xccui" creationdate="20190307T152503Z">
        <seg>20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>20 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041409Z" creationid="xccui" creationdate="20190606T041349Z">
        <seg>20 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>200</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040135Z" creationid="xccui" creationdate="20190418T040135Z">
        <seg>200</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2019-04-03: First Release</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210733Z" creationid="esouser" creationdate="20190603T210733Z">
        <seg>2019-04-03: First Release</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>202</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040138Z" creationid="xccui" creationdate="20190418T040138Z">
        <seg>202</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>203</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152055Z" creationid="esouser" creationdate="20190603T152055Z">
        <seg>203</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>204</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040141Z" creationid="xccui" creationdate="20190418T040141Z">
        <seg>204</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>205</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040153Z" creationid="xccui" creationdate="20190418T040153Z">
        <seg>205</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>206</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152112Z" creationid="esouser" creationdate="20190603T152112Z">
        <seg>206</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>207</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152114Z" creationid="esouser" creationdate="20190603T152114Z">
        <seg>207</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>208</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040157Z" creationid="xccui" creationdate="20190418T040157Z">
        <seg>208</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>209</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040201Z" creationid="xccui" creationdate="20190418T040201Z">
        <seg>209</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>21</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045720Z" creationid="xccui" creationdate="20190329T045720Z">
        <seg>21</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>212</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040206Z" creationid="xccui" creationdate="20190418T040206Z">
        <seg>212</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>216</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040209Z" creationid="xccui" creationdate="20190418T040209Z">
        <seg>216</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>218</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040212Z" creationid="xccui" creationdate="20190418T040212Z">
        <seg>218</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>219</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152116Z" creationid="esouser" creationdate="20190603T152116Z">
        <seg>219</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>22</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045724Z" creationid="xccui" creationdate="20190329T045724Z">
        <seg>22</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>22 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041429Z" creationid="xccui" creationdate="20190606T041429Z">
        <seg>22 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>221</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040216Z" creationid="xccui" creationdate="20190418T040216Z">
        <seg>221</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>223</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152140Z" creationid="esouser" creationdate="20190603T152140Z">
        <seg>223</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>224</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040219Z" creationid="xccui" creationdate="20190418T040219Z">
        <seg>224</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>225</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040223Z" creationid="xccui" creationdate="20190418T040223Z">
        <seg>225</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>227</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040226Z" creationid="xccui" creationdate="20190418T040226Z">
        <seg>227</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>228</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040230Z" creationid="xccui" creationdate="20190418T040230Z">
        <seg>228</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>23</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045729Z" creationid="xccui" creationdate="20190329T045729Z">
        <seg>23</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>230</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040234Z" creationid="xccui" creationdate="20190418T040234Z">
        <seg>230</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>231</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040244Z" creationid="xccui" creationdate="20190418T040244Z">
        <seg>231</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>232</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152149Z" creationid="esouser" creationdate="20190603T152149Z">
        <seg>232</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>233</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152208Z" creationid="esouser" creationdate="20190603T152208Z">
        <seg>233</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>234</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152229Z" creationid="esouser" creationdate="20190603T152229Z">
        <seg>234</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>235</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152242Z" creationid="esouser" creationdate="20190603T152242Z">
        <seg>235</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>236</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152243Z" creationid="esouser" creationdate="20190603T152243Z">
        <seg>236</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>237</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152254Z" creationid="esouser" creationdate="20190603T152254Z">
        <seg>237</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>238</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040248Z" creationid="xccui" creationdate="20190418T040248Z">
        <seg>238</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>239</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152259Z" creationid="esouser" creationdate="20190603T152259Z">
        <seg>239</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>24</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045734Z" creationid="xccui" creationdate="20190329T045734Z">
        <seg>24</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>240</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152301Z" creationid="esouser" creationdate="20190603T152301Z">
        <seg>240</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>241</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040252Z" creationid="xccui" creationdate="20190418T040252Z">
        <seg>241</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>242</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152303Z" creationid="esouser" creationdate="20190603T152303Z">
        <seg>242</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>243</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040304Z" creationid="xccui" creationdate="20190418T040304Z">
        <seg>243</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>244</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152336Z" creationid="esouser" creationdate="20190603T152336Z">
        <seg>244</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>245</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152338Z" creationid="esouser" creationdate="20190603T152338Z">
        <seg>245</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>246</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040311Z" creationid="xccui" creationdate="20190418T040311Z">
        <seg>246</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>247</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040319Z" creationid="xccui" creationdate="20190418T040319Z">
        <seg>247</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>25</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032750Z" creationid="xccui" creationdate="20190327T032750Z">
        <seg>25</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>251</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040329Z" creationid="xccui" creationdate="20190418T040329Z">
        <seg>251</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>252</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152340Z" creationid="esouser" creationdate="20190603T152340Z">
        <seg>252</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>255</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040332Z" creationid="xccui" creationdate="20190418T040332Z">
        <seg>255</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>256</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040336Z" creationid="xccui" creationdate="20190418T040336Z">
        <seg>256</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>257</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040340Z" creationid="xccui" creationdate="20190418T040340Z">
        <seg>257</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>258</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040344Z" creationid="xccui" creationdate="20190418T040344Z">
        <seg>258</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>259</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040347Z" creationid="xccui" creationdate="20190418T040347Z">
        <seg>259</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>26</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042440Z" creationid="xccui" creationdate="20190328T042440Z">
        <seg>26</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>260</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152342Z" creationid="esouser" creationdate="20190603T152342Z">
        <seg>260</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>261</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040350Z" creationid="xccui" creationdate="20190418T040350Z">
        <seg>261</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>262</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040354Z" creationid="xccui" creationdate="20190418T040354Z">
        <seg>262</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>263</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040357Z" creationid="xccui" creationdate="20190418T040357Z">
        <seg>263</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>264</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040400Z" creationid="xccui" creationdate="20190418T040400Z">
        <seg>264</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>265</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040404Z" creationid="xccui" creationdate="20190418T040404Z">
        <seg>265</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>266</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040408Z" creationid="xccui" creationdate="20190418T040408Z">
        <seg>266</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>267</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040417Z" creationid="xccui" creationdate="20190418T040417Z">
        <seg>267</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>268</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040422Z" creationid="xccui" creationdate="20190418T040422Z">
        <seg>268</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>269</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040426Z" creationid="xccui" creationdate="20190418T040426Z">
        <seg>269</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>27</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045740Z" creationid="xccui" creationdate="20190329T045740Z">
        <seg>27</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>270</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152403Z" creationid="esouser" creationdate="20190603T152403Z">
        <seg>270</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>273</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152405Z" creationid="esouser" creationdate="20190603T152405Z">
        <seg>273</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>274</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040430Z" creationid="xccui" creationdate="20190418T040430Z">
        <seg>274</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>278</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152406Z" creationid="esouser" creationdate="20190603T152406Z">
        <seg>278</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>279</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040434Z" creationid="xccui" creationdate="20190418T040434Z">
        <seg>279</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>28</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042035Z" creationid="xccui" creationdate="20190329T042035Z">
        <seg>28</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>28 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041447Z" creationid="xccui" creationdate="20190606T041447Z">
        <seg>28 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>280</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152407Z" creationid="esouser" creationdate="20190603T152407Z">
        <seg>280</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>281</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152417Z" creationid="esouser" creationdate="20190603T152417Z">
        <seg>281</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>282</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040438Z" creationid="xccui" creationdate="20190418T040438Z">
        <seg>282</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>283</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040442Z" creationid="xccui" creationdate="20190418T040442Z">
        <seg>283</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>285</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040446Z" creationid="xccui" creationdate="20190418T040446Z">
        <seg>285</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>288</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040449Z" creationid="xccui" creationdate="20190418T040449Z">
        <seg>288</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>289</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040453Z" creationid="xccui" creationdate="20190418T040453Z">
        <seg>289</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>29</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041918Z" creationid="xccui" creationdate="20190329T041918Z">
        <seg>29</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>292</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040457Z" creationid="xccui" creationdate="20190418T040457Z">
        <seg>292</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>295</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040501Z" creationid="xccui" creationdate="20190418T040501Z">
        <seg>295</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2&gt; SensorReading(sensor_31,1515014051000,23.924656183848732)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043428Z" creationid="xccui" creationdate="20190611T043428Z">
        <seg>2&gt; SensorReading(sensor_31,1515014051000,23.924656183848732)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144712Z" creationid="esouser" creationdate="20190603T144712Z">
        <seg>3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024959Z" creationid="xccui" creationdate="20190329T024959Z">
        <seg>3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>30</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041931Z" creationid="xccui" creationdate="20190329T041931Z">
        <seg>30</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>300</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040504Z" creationid="xccui" creationdate="20190418T040504Z">
        <seg>300</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>301</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040508Z" creationid="xccui" creationdate="20190418T040508Z">
        <seg>301</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>302</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040511Z" creationid="xccui" creationdate="20190418T040511Z">
        <seg>302</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>303</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040524Z" creationid="xccui" creationdate="20190418T040524Z">
        <seg>303</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>305</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040528Z" creationid="xccui" creationdate="20190418T040528Z">
        <seg>305</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>307</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040548Z" creationid="xccui" creationdate="20190418T040548Z">
        <seg>307</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>309</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040556Z" creationid="xccui" creationdate="20190418T040556Z">
        <seg>309</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>31</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144754Z" creationid="esouser" creationdate="20190603T144754Z">
        <seg>31</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>32</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144246Z" creationid="esouser" creationdate="20190603T144246Z">
        <seg>32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>32°F.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023250Z" creationid="xccui" creationdate="20190622T023250Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>33</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000312Z" creationid="xccui" creationdate="20190401T000312Z">
        <seg>33</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>34</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032117Z" creationid="xccui" creationdate="20190401T032117Z">
        <seg>34</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>34 | Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041516Z" creationid="xccui" creationdate="20190606T041516Z">
        <seg>34 | 第2章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>35</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142146Z" creationid="xccui" creationdate="20190401T142146Z">
        <seg>35</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>36</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195532Z" creationid="xccui" creationdate="20190401T195532Z">
        <seg>36</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>37</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195520Z" creationid="xccui" creationdate="20190401T195520Z">
        <seg>37</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>38</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210323Z" creationid="xccui" creationdate="20190402T210323Z">
        <seg>38</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>38 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032532Z" creationid="xccui" creationdate="20190610T032532Z">
        <seg>38 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>39</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152744Z" creationid="xccui" creationdate="20190405T152744Z">
        <seg>39</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3&gt; SensorReading(sensor_34,1515014051000,23.871433252250583)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043441Z" creationid="xccui" creationdate="20190611T043441Z">
        <seg>3&gt; SensorReading(sensor_34,1515014051000,23.871433252250583)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144716Z" creationid="esouser" creationdate="20190603T144716Z">
        <seg>4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4 | Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130806Z" creationid="xccui" creationdate="20190605T130806Z">
        <seg>4 | 第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035634Z" creationid="xccui" creationdate="20190418T035634Z">
        <seg>4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>40</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035845Z" creationid="xccui" creationdate="20190406T035845Z">
        <seg>40</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>41</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043712Z" creationid="xccui" creationdate="20190406T043712Z">
        <seg>41</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>42</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023551Z" creationid="xccui" creationdate="20190407T023551Z">
        <seg>42</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>43</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052401Z" creationid="xccui" creationdate="20190416T052401Z">
        <seg>43</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>44</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052407Z" creationid="xccui" creationdate="20190416T052407Z">
        <seg>44</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>45</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152127Z" creationid="xccui" creationdate="20190411T152127Z">
        <seg>45</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>46</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150539Z" creationid="xccui" creationdate="20190412T150539Z">
        <seg>46</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>46 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032601Z" creationid="xccui" creationdate="20190610T032601Z">
        <seg>46 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>47</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150532Z" creationid="xccui" creationdate="20190412T150532Z">
        <seg>47</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>48</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155341Z" creationid="xccui" creationdate="20190412T155341Z">
        <seg>48</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>48 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032635Z" creationid="xccui" creationdate="20190610T032635Z">
        <seg>48 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>49</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T041055Z" creationid="xccui" creationdate="20190414T041055Z">
        <seg>49</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4&gt; SensorReading(sensor_32,1515014051000,4.118569049862492)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043432Z" creationid="xccui" creationdate="20190611T043432Z">
        <seg>4&gt; SensorReading(sensor_32,1515014051000,4.118569049862492)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035624Z" creationid="xccui" creationdate="20190329T035624Z">
        <seg>5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>50</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055624Z" creationid="xccui" creationdate="20190414T055624Z">
        <seg>50</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>51</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042843Z" creationid="xccui" creationdate="20190415T042843Z">
        <seg>51</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>52</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041533Z" creationid="xccui" creationdate="20190416T041533Z">
        <seg>52</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>53</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050113Z" creationid="xccui" creationdate="20190416T050113Z">
        <seg>53</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>54</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052001Z" creationid="xccui" creationdate="20190416T052001Z">
        <seg>54</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>54 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032746Z" creationid="xccui" creationdate="20190610T032746Z">
        <seg>54 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>55</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032942Z" creationid="xccui" creationdate="20190418T032942Z">
        <seg>55</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>56</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035459Z" creationid="xccui" creationdate="20190418T035459Z">
        <seg>56</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>57</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035503Z" creationid="xccui" creationdate="20190418T035503Z">
        <seg>57</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>58</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035507Z" creationid="xccui" creationdate="20190418T035507Z">
        <seg>58</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>59</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035514Z" creationid="xccui" creationdate="20190418T035514Z">
        <seg>59</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144719Z" creationid="esouser" creationdate="20190603T144719Z">
        <seg>6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035852Z" creationid="xccui" creationdate="20190418T035852Z">
        <seg>6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>60</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144757Z" creationid="esouser" creationdate="20190603T144757Z">
        <seg>60</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>60 | Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032806Z" creationid="xccui" creationdate="20190610T032806Z">
        <seg>60 | 第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>61</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035518Z" creationid="xccui" creationdate="20190418T035518Z">
        <seg>61</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>62</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044716Z" creationid="xccui" creationdate="20190504T044716Z">
        <seg>62</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>63</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035522Z" creationid="xccui" creationdate="20190418T035522Z">
        <seg>63</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>64</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T154733Z" creationid="esouser" creationdate="20190514T154733Z">
        <seg>64</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>65</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035526Z" creationid="xccui" creationdate="20190418T035526Z">
        <seg>65</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>66</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035530Z" creationid="xccui" creationdate="20190418T035530Z">
        <seg>66</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>67</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035534Z" creationid="xccui" creationdate="20190418T035534Z">
        <seg>67</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>69</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144652Z" creationid="esouser" creationdate="20190603T144652Z">
        <seg>69</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040015Z" creationid="xccui" creationdate="20190418T040015Z">
        <seg>7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>70</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035544Z" creationid="xccui" creationdate="20190418T035544Z">
        <seg>70</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>707-829-0104 (fax)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210841Z" creationid="esouser" creationdate="20190603T210841Z">
        <seg>707-829-0104 (fax)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>71</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035548Z" creationid="xccui" creationdate="20190418T035548Z">
        <seg>71</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>72</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035552Z" creationid="xccui" creationdate="20190418T035552Z">
        <seg>72</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>72 | Chapter 4: Setting Up a Development Environment for Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T142736Z" creationid="xccui" creationdate="20190611T040223Z">
        <seg>72 | 第4章：设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>73</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035600Z" creationid="xccui" creationdate="20190418T035600Z">
        <seg>73</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>74</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035605Z" creationid="xccui" creationdate="20190418T035605Z">
        <seg>74</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>74 | Chapter 4: Setting Up a Development Environment for Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T142736Z" creationid="xccui" creationdate="20190612T012857Z">
        <seg>74 | 设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>75</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144915Z" creationid="esouser" creationdate="20190603T144915Z">
        <seg>75</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>76</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035608Z" creationid="xccui" creationdate="20190418T035608Z">
        <seg>76</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>77</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035612Z" creationid="xccui" creationdate="20190418T035612Z">
        <seg>77</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>78</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035616Z" creationid="xccui" creationdate="20190418T035616Z">
        <seg>78</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>79</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035621Z" creationid="xccui" creationdate="20190418T035621Z">
        <seg>79</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144723Z" creationid="esouser" creationdate="20190603T144723Z">
        <seg>8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040147Z" creationid="xccui" creationdate="20190418T040147Z">
        <seg>8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>800-998-9938 (in the United States or Canada) 707-829-0515 (international or local)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210840Z" creationid="esouser" creationdate="20190603T210840Z">
        <seg>800-998-9938 (in the United States or Canada) 707-829-0515 (international or local)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>81</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145036Z" creationid="esouser" creationdate="20190603T145036Z">
        <seg>81</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>82</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145105Z" creationid="esouser" creationdate="20190603T145105Z">
        <seg>82</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>82 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045214Z" creationid="xccui" creationdate="20190619T045214Z">
        <seg>82 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>83</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145112Z" creationid="esouser" creationdate="20190603T145112Z">
        <seg>83</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>84</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035625Z" creationid="xccui" creationdate="20190418T035625Z">
        <seg>84</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>84 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045231Z" creationid="xccui" creationdate="20190619T045231Z">
        <seg>84 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>86 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045250Z" creationid="xccui" creationdate="20190619T045250Z">
        <seg>86 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>87</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035628Z" creationid="xccui" creationdate="20190418T035628Z">
        <seg>87</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>89</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035642Z" creationid="xccui" creationdate="20190418T035642Z">
        <seg>89</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144727Z" creationid="esouser" creationdate="20190603T144727Z">
        <seg>9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040300Z" creationid="xccui" creationdate="20190418T040300Z">
        <seg>9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>90</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035645Z" creationid="xccui" creationdate="20190418T035645Z">
        <seg>90</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>92</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035652Z" creationid="xccui" creationdate="20190418T035652Z">
        <seg>92</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>93</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035656Z" creationid="xccui" creationdate="20190418T035656Z">
        <seg>93</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>94</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035701Z" creationid="xccui" creationdate="20190418T035701Z">
        <seg>94</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>96</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145618Z" creationid="esouser" creationdate="20190603T145618Z">
        <seg>96</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>97</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035705Z" creationid="xccui" creationdate="20190418T035705Z">
        <seg>97</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>978-1-491-97429-2 [LSI]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210743Z" creationid="esouser" creationdate="20190603T210743Z">
        <seg>978-1-491-97429-2 [LSI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>98</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145619Z" creationid="esouser" creationdate="20190603T145619Z">
        <seg>98</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>98 | Chapter 5: The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045312Z" creationid="xccui" creationdate="20190619T045312Z">
        <seg>98 | 第5章：DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>99</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035714Z" creationid="xccui" creationdate="20190418T035714Z">
        <seg>99</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;S extends State&gt; S getPartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192924Z" creationid="xccui" creationdate="20190626T192924Z">
        <seg>&lt;S extends State&gt; S getPartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Eager &lt;t1/&gt;watermarks ensure low latency but provide lower confidence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210541Z" creationid="xccui" creationdate="20190412T210445Z">
        <seg>激进的水位线策略保证了低延迟，但随之而来的是低可信度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 1-4&lt;t1/&gt; shows a stateful Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T033047Z" creationid="xccui" creationdate="20190305T033047Z">
        <seg>图1-4展示了一个状态化的Flink应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 1-5&lt;t1/&gt; sketches a service architecture composed of event-driven streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152610Z" creationid="xccui" creationdate="20190307T152501Z">
        <seg>图1-5粗略展示了一个由事件驱动型应用组成的服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 2-1&lt;t1/&gt; shows a dataflow program that extracts and counts hashtags from an input stream of tweets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021625Z" creationid="xccui" creationdate="20190401T000354Z">
        <seg>图2-1展示了一个从推文输入流中提取并计算主题标签数目的dataflow程序，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Figure 3-2&lt;t1/&gt; visualizes the relationship of TaskManag&lt;t2/&gt;‐&lt;t3/&gt; ers, slots, tasks, and operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042900Z" creationid="xccui" creationdate="20190423T042900Z">
        <seg>图3-2展示了TaskManager、处理槽、任务以及算子之间的关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;Parallelization becomes complicated, since results depend on&lt;t1/&gt; &lt;t2/&gt;both the state and incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035629Z" creationid="xccui" creationdate="20190415T033359Z">
        <seg>由于结果需要同时依赖状态和到来的事件，状态并行化变得异常复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0/&gt;The third and biggest challenge that comes with stateful opera&lt;t1/&gt;‐&lt;t2/&gt; &lt;t3/&gt;tors is ensuring that state can be recovered and results will be correct even in the presence of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035117Z" creationid="xccui" creationdate="20190415T034953Z">
        <seg>最后一个也是最大的挑战在于，状态化算子需要保证状态可以恢复，即便出现故障也要确保结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t13/&gt;Figure 2-9&lt;t14/&gt; shows a session win&lt;t15/&gt;‐&lt;t16/&gt; dow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193517Z" creationid="xccui" creationdate="20190409T193517Z">
        <seg>图2-9展示了一个会话窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t2/&gt;Figure 2-5 &lt;t3/&gt;shows a rolling minimum aggregation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035707Z" creationid="xccui" creationdate="20190406T035523Z">
        <seg>图2-5展示了一个求最小值的滚动聚合，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t2/&gt;Figure 3-7&lt;t3/&gt; show the same pipeline would be executed without task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155109Z" creationid="esouser" creationdate="20190514T154644Z">
        <seg>图3-7展示了同一个流水线如何非任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t3/&gt;The truth is that processing time can indeed&lt;t4/&gt; &lt;t5/&gt;be useful in some cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043840Z" creationid="xccui" creationdate="20190414T040757Z">
        <seg>事实上，处理时间在某些情况下确有其用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 2-13&lt;t5/&gt; shows that an event-time window would correctly place events in a window, reflecting the reality of how things happened, even though some events were &lt;t6/&gt;delayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150703Z" creationid="xccui" creationdate="20190412T150441Z">
        <seg>如图2-13所示，即便事件有延迟，事件时间窗口也能准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 2-2&lt;t5/&gt; shows a physical dataflow graph for the logical graph of &lt;t6/&gt;Figure 2-1&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T003231Z" creationid="xccui" creationdate="20190401T003231Z">
        <seg>图2-2展示了图2-1中逻辑图对应的物理dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 3-3&lt;t5/&gt; illustrates this design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051331Z" creationid="xccui" creationdate="20190502T051232Z">
        <seg>图3-3阐明了这一设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t4/&gt;Figure 3-4&lt;t5/&gt; visualizes this architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044158Z" creationid="xccui" creationdate="20190504T043809Z">
        <seg>图3-4展示了这一架构，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t5/&gt;Figure 2-6&lt;t6/&gt; shows a count-based tumbling window that discretizes the input stream into buckets of 4 elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023319Z" creationid="xccui" creationdate="20190407T022549Z">
        <seg>图2-6中基于数量的滚动窗口将输入流按每4个元素一组分配到不同的通中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t6/&gt;Figure 2-10&lt;t7/&gt; shows a parallel count-based tumbling window of length 2 which is partitioned by event color.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195846Z" creationid="xccui" creationdate="20190409T195846Z">
        <seg>图2-10展示了一个按事件颜色划分、基于数量2的并行滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t7/&gt;Figure 2-7&lt;t8/&gt; shows a time-based tumbling window that gathers events into buckets and triggers computation every 10 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023521Z" creationid="xccui" creationdate="20190407T023312Z">
        <seg>图2-7中基于时间的滚动窗口将事件汇集到桶中，每10分钟触发一次计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t8/&gt;Figure 1-2&lt;t9/&gt; depicts a microservice architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172840Z" creationid="xccui" creationdate="20190228T172718Z">
        <seg>图1-2描绘了微服务的架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; filter(T): Boolean</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052938Z" creationid="xccui" creationdate="20190613T052938Z">
        <seg>&gt; filter(T): Boolean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; flatMap(T, Collector[O]): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T061035Z" creationid="xccui" creationdate="20190613T061035Z">
        <seg>&gt; flatMap(T, Collector[O]): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; flatMap1(IN1, Collector[OUT]): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042926Z" creationid="xccui" creationdate="20190615T042926Z">
        <seg>&gt; flatMap1(IN1, Collector[OUT]): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; flatMap2(IN2, Collector[OUT]): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042921Z" creationid="xccui" creationdate="20190615T042921Z">
        <seg>&gt; flatMap2(IN2, Collector[OUT]): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; getKey(IN): KEY</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051101Z" creationid="xccui" creationdate="20190618T051101Z">
        <seg>&gt; getKey(IN): KEY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; map(T): O</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050345Z" creationid="xccui" creationdate="20190613T050345Z">
        <seg>&gt; map(T): O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; map1(IN1): OUT</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042859Z" creationid="xccui" creationdate="20190615T042859Z">
        <seg>&gt; map1(IN1): OUT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; map2(IN2): OUT</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042906Z" creationid="xccui" creationdate="20190615T042906Z">
        <seg>&gt; map2(IN2): OUT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; reduce(T, T): T</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061913Z" creationid="xccui" creationdate="20190614T061913Z">
        <seg>&gt; reduce(T, T): T</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt; select(IN): Iterable[String]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061016Z" creationid="xccui" creationdate="20190615T061016Z">
        <seg>&gt; select(IN): Iterable[String]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052010Z" creationid="xccui" creationdate="20190612T052010Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Bit of History</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030041Z" creationid="esouser" creationdate="20190603T143127Z">
        <seg>历史回顾</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink DataStream application can assign timestamps and generate watermarks to a stream in three ways:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033951Z" creationid="xccui" creationdate="20190607T033951Z">
        <seg>Flink DataStream应用可以通过三种方式分配时间戳和生成水位线：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink setup consists for four different components that work together to execute streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033459Z" creationid="xccui" creationdate="20190418T033431Z">
        <seg>Flink的设置包含4个不同组件，它们相互协作，共同执行流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink setup consists of four different components that work together to execute streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T055536Z" creationid="xccui" creationdate="20190606T141214Z">
        <seg>Flink的搭建需要四个不同组件，它们相互协作、共同执行流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Flink setup consists of multiple processes that typically run distributed across multiple machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T043917Z" creationid="xccui" creationdate="20190418T030126Z">
        <seg>它的搭建涉及多个进程，它们通常会分布在多台机器上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Function Cannot Choose Which ConnectedStreams to Read</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T043536Z" creationid="xccui" creationdate="20190615T043536Z">
        <seg>函数无法选择从哪条流读取数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Java JRE is not sufficient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T015648Z" creationid="xccui" creationdate="20190611T015626Z">
        <seg>只有Java JRE是不够的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeySelector function extracts a key from an input event:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051016Z" creationid="xccui" creationdate="20190618T050945Z">
        <seg>它可以从输入事件中提取键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeySelector function receives an input item and returns a key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051811Z" creationid="xccui" creationdate="20190618T051811Z">
        <seg>KeySelector函数接受一个输入项，返回一个键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Keyed Stream is constructed by calling the DataStream.keyBy() method that defines a key on a stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T040405Z" creationid="xccui" creationdate="20190630T040405Z">
        <seg>你可以通过在一条数据流上调用定义键值的DataStream.keyBy()方法来构造一个KeyedStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyedProcessFunction that emits a warning if the temperature of a sensor monotonically increases for 1 second in processing time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T055114Z" creationid="xccui" creationdate="20190620T055114Z">
        <seg>KeyedProcessFunction，如果传感器温度在处理时间1秒内单调增加，则发出警告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyedStream can be processed using the map, flatMap, and filter transformations that you saw earlier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T045801Z" creationid="xccui" creationdate="20190614T045801Z">
        <seg>KeyedStream也支持使用你之前看到过的map、flatMap和filter等转换进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A KeyedStream is partitioned on the specified key and remembers the key definition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T040446Z" creationid="xccui" creationdate="20190630T040446Z">
        <seg>KeyedStream会根据指定键值进行分区并会记住键值的定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ProcessFunction that emits records to a side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023338Z" creationid="xccui" creationdate="20190622T023338Z">
        <seg>向副输出发送记录的ProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ProcessFunction that filters out late sensor readings and redirects them to a side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155618Z" creationid="xingcan" creationdate="20190628T155618Z">
        <seg>用于过滤出迟到的传感器读数并将其重定向到副输出的ProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ProcessWindowFunction that computes the lowest and highest temperature</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030825Z" creationid="xccui" creationdate="20190625T030825Z">
        <seg>该ProcessWindowFunction用于计算每个窗口内的最低和最高温度读数，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ProcessWindowFunction that utilizes per- window state needs to implement its clear() method to clean up any window-</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024757Z" creationid="xccui" creationdate="20190624T024757Z">
        <seg>使用了单个窗口状态的ProcessWindowFunction需要实现clear()方法，在窗口清除前清理仅供当前窗口使用的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Quick Look at Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143155Z" creationid="esouser" creationdate="20190603T143155Z">
        <seg>Flink快览</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Quick Look at Flink | 13</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130830Z" creationid="xccui" creationdate="20190605T130830Z">
        <seg>Flink快览| 13</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A ReduceFunction accepts two values of the same type and combines them into a single value of the same type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T225024Z" creationid="xccui" creationdate="20190623T224729Z">
        <seg>ReduceFunction接收两个同类型的值并将它们组合成一个类型不变的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A RichFlatMapFunction with operator list state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052313Z" creationid="xccui" creationdate="20190701T052313Z">
        <seg>使用了算子列表状态的RichFlatMapFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager can execute several tasks at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T070611Z" creationid="xccui" creationdate="20190423T041158Z">
        <seg>一个TaskManager允许同时执行多个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager executes its tasks multi-threaded in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062942Z" creationid="xccui" creationdate="20190424T062935Z">
        <seg>TaskManager会在同一个JVM进程内以多线程的方式执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager executes its tasks multithreaded in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144850Z" creationid="xccui" creationdate="20190606T144850Z">
        <seg>TaskManager会在同一个JVM进程内以多线程的方式执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager needs one dedicated network buffer for each receiving task that any of its tasks need to send data to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T192438Z" creationid="xccui" creationdate="20190504T043448Z">
        <seg>对于每一个接收任务，TaskManager都要提供一个专用的网络缓冲区，用于接收其他任务发来的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager offers a certain number of processing slots to control the number of tasks it is able to concurrently execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T063916Z" creationid="xccui" creationdate="20190606T144350Z">
        <seg>TaskManager通过提供固定数量的处理槽来控制可以并行执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager process (and with it, all tasks running on it) may fail at any point in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053627Z" creationid="xccui" creationdate="20190608T053527Z">
        <seg>由于TaskManager进程以及它上面所有运行的任务都可能在任意时间出现故障，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A TaskManager provides a certain number of processing slots to control the number of tasks that it can concurrently execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042642Z" creationid="xccui" creationdate="20190423T042443Z">
        <seg>TaskManager通过提供一定数量的处理槽来控制可以并发执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Taste of Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T063919Z" creationid="xccui" creationdate="20190225T014731Z">
        <seg>初识Flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Welcoming Community</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152601Z" creationid="esouser" creationdate="20190603T152601Z">
        <seg>欢迎加入社区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A WindowAssigner is typed to the type of the incoming elements and the type of the windows to which the elements are assigned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042056Z" creationid="xccui" creationdate="20190626T042056Z">
        <seg>WindowAssigner的类型由到达元素的类型以及元素分配的目标窗口类型组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A background thread asynchronously copies the local snapshot to the remote storage and notifies the task once it completes the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203709Z" creationid="xccui" creationdate="20190609T203432Z">
        <seg>后台进程会异步将本地状态快照拷贝到远程存储，然后在完成检查点后通知任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call to this</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T055532Z" creationid="xccui" creationdate="20190630T055532Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A checkpoint barrier carries a checkpoint ID to identify the checkpoint it belongs to  and logically splits a stream into two parts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060953Z" creationid="xccui" creationdate="20190609T060708Z">
        <seg>为了标识所属的检查点，每个检查点分隔符都会带有一个检查点编号，这样就把一条数据流从逻辑上分成了两个部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A checkpoint is initiated by the JobManager by sending a message with a new check‐ point ID to each data source task as shown in Figure 3-20.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T063006Z" creationid="xccui" creationdate="20190609T062451Z">
        <seg>如图3-20所示，JobManager会向每个数据源任务发送一个新的检查点编号，以此来启动检查点生成流程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common case is when a task per&lt;t0/&gt;‐&lt;t1/&gt; forms idempotent operations, like maximum or minimum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050227Z" creationid="xccui" creationdate="20190416T050227Z">
        <seg>一个常见情况就是某个任务执行一些诸如求最大值或最小值的幂等操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common case is when a task performs idempotent operations, like maximum or min‐ imum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035358Z" creationid="xccui" creationdate="20190606T035358Z">
        <seg>一个常见情况就是某个任务执行一些诸如求最大值或最小值的幂等操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common reason for growing state is keyed state on an evolving key domain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T140355Z" creationid="xccui" creationdate="20190704T140355Z">
        <seg>导致状态增长的一个常见原因是键值状态的键值域不断发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common requirement for streaming applications is to adjust the parallelism of operators due to increasing or decreasing input rates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T054428Z" creationid="xccui" creationdate="20190608T054343Z">
        <seg>流式应用的一项基本需求是根据输入数据到达速率的变化调整算子并发度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common requirement in streaming applications is to distribute the same informa‐ tion to all parallel instances of a function and maintain it as recoverable state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T202835Z" creationid="xccui" creationdate="20190701T202835Z">
        <seg>流式应用的一个常见需求是要将相同信息发送到函数的全部并行实例上，并将它们作为可恢复的状态进行维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common requirement of many applications is to process groups of events that share a certain property together.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044428Z" creationid="xccui" creationdate="20190614T043547Z">
        <seg>在很多应用中需要将事件按照某个属性分组后再进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common requirement when working with streams is to connect or join the events of two streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210057Z" creationid="xccui" creationdate="20190627T204650Z">
        <seg>操作数据流时的另一个常见需求是对两条数据流中的事件进行联结或Join。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common use case for timers is to clear keyed state after some period of inactivity for a key or to implement custom time-based windowing logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190621T061800Z">
        <seg>它的常见用途是在某些键值不再使用后清除键值分区状态或实现一些基于时间的自定义窗口逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consistent checkpoint of a stateful streaming application is a copy of the state of each of its tasks at a point when all tasks have processed exactly the same input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223148Z" creationid="xccui" creationdate="20190608T155358Z">
        <seg>状态化流式应用的一致性检查点是在所有任务处理完等量的原始输入后对全部任务状态进行的一个拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consistent checkpoint of a streaming application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T225015Z" creationid="xccui" creationdate="20190608T225008Z">
        <seg>某流式应用的一致性检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A container that is started from this image automati‐ cally starts a TaskManager, which connects to the ResourceManager and registers its slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T063413Z" creationid="xccui" creationdate="20190606T143759Z">
        <seg>容器通过映像启动后会自动运行TaskManager，后者可以连接ResourceManager并注册处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A custom trigger may fire several times, computing new or updated results</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185857Z" creationid="xccui" creationdate="20190626T185623Z">
        <seg>自定义触发器可能会触发多次，你不但可以计算全新的结果或对已有结果进行更新，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A data source can ingest data from a TCP socket, a file, a Kafka topic, or a sensor data interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060131Z" creationid="xccui" creationdate="20190405T152258Z">
        <seg>数据源可以从TCP套接字、文件、Kafka主题或传感器数据接口中获取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A data stream is a potentially unbounded sequence of events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142859Z" creationid="xccui" creationdate="20190401T142812Z">
        <seg>数据流是一个可能无限的事件序列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A data warehouse is a specialized database system for analytical query workloads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T184243Z" creationid="xccui" creationdate="20190228T184243Z">
        <seg>数据仓库是一个用来执行分析类查询的专业化数据库系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dataflow graph must have at least</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000307Z" creationid="xccui" creationdate="20190401T000240Z">
        <seg>一个dataflow图至少要有一个数据源和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dataflow graph must have at least one data source and one data sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224932Z" creationid="xccui" creationdate="20190605T224929Z">
        <seg>一个Dataflow图至少要有一个数据源和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dependency that is added to the classpath like this is available to (and might interfere with) all applications that run on the Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T042001Z" creationid="xccui" creationdate="20190619T042001Z">
        <seg>像这样加入classpath的依赖会对一个Flink设置中所有运行的应用可见（可能会产生干扰）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failure can occur during any of these steps and the system has to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042813Z" creationid="xccui" creationdate="20190415T042639Z">
        <seg>上述任何一个步骤都可能发生故障，系统必须在故障场景下明确定义其行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failure can occur during any of these steps and the system has to clearly define its behavior in a failure scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T190655Z" creationid="xccui" creationdate="20190606T033607Z">
        <seg>上述任何一个步骤都可能发生故障，而系统必须在故障情况下明确定义其行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A filter operation that only retains white values</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052343Z" creationid="xccui" creationdate="20190613T052343Z">
        <seg>仅保留白色值的filter操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A filter transformation is specified by calling the DataStream.filter() method and pro‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052155Z" creationid="xccui" creationdate="20190613T052155Z">
        <seg>通过调用DataStream.filter()方法可以指定filter转换产生一个相同数据类型的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A flatMap operation that outputs white squares, duplicates black squares, and drops gray squares</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054751Z" creationid="xccui" creationdate="20190613T054718Z">
        <seg>输出白色方块，复制黑色方块，丢弃灰色方块的flatMap操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A full data type can be selected using the wildcard field expression "_" (underscore character):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050750Z" creationid="xccui" creationdate="20190618T050750Z">
        <seg>可以使用通配符字段表达式"_"（英文下划线）选择全部字段：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function can work with operator list state by implementing the ListCheckpointed interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T040044Z" creationid="xccui" creationdate="20190701T040044Z">
        <seg>若要在函数中使用算子列表状态，需要实现ListCheckpointed接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function implementing the CheckpointedFunction interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T154746Z" creationid="xccui" creationdate="20190702T154746Z">
        <seg>实现了CheckpointedFunction接口的函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function is implemented by implementing the interface or extending the abstract class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T053826Z" creationid="xccui" creationdate="20190618T053826Z">
        <seg>因此可以通过实现接口或继承抽象类的方式实现函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function with broadcast state is applied on two streams in three steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040831Z" creationid="xccui" creationdate="20190702T040401Z">
        <seg>为了在两条数据流上应用带有广播状态的函数需要经过三个步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function with keyed state must be applied on a KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062552Z" creationid="xccui" creationdate="20190630T062503Z">
        <seg>使用键值分区状态的函数必须作用在KeyedStream上，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A highly available Flink setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T194903Z" creationid="xccui" creationdate="20190606T194859Z">
        <seg>Flink高可用设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A highly-available Flink Setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051925Z" creationid="xccui" creationdate="20190502T051925Z">
        <seg>Flink高可用设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key group is a partition of keys and Flink’s  way of assigning keys to   tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060044Z" creationid="xccui" creationdate="20190608T055919Z">
        <seg>键值组包含了部分键值，Flink以此为单位把键值分配给不同任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A keyBy operation that partitions events based on color</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051146Z" creationid="xccui" creationdate="20190614T051146Z">
        <seg>基于颜色对事件进行分区的keyBy操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A late element is an element that arrives at an operator when a computation to which it would need to contribute has already been performed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T152220Z" creationid="xingcan" creationdate="20190628T151903Z">
        <seg>所谓迟到指的是元素到达算子后，它本应参与贡献的计算已经执行完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A logical dataflow graph to continuously count hashtags (nodes represent operators and edges denote data dependencies)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044508Z" creationid="xccui" creationdate="20190605T224959Z">
        <seg>一个持续统计主题标签数目的Dataflow逻辑图（顶点表示算子，边表示数据依赖）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A logical dataflow graph to continuously count hashtags.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T001230Z" creationid="xccui" creationdate="20190401T001056Z">
        <seg>持续计算主题标签数量的dataflow逻辑图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A map operation that transforms every square into a circle of the same color</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045716Z" creationid="xccui" creationdate="20190613T045716Z">
        <seg>将方形转换为相同颜色圆形的map操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A microservice architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172821Z" creationid="xccui" creationdate="20190228T172821Z">
        <seg>微服务架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A microservices architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T201100Z" creationid="esouser" creationdate="20190603T201100Z">
        <seg>微服务架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more challenging problem than TaskManager failures are JobManager failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T043044Z" creationid="xccui" creationdate="20190502T042522Z">
        <seg>和TaskManager相比，JobManager发生故障会更为棘手。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new JobManager that takes over the work of the failed master performs the following steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190503T192209Z" creationid="xccui" creationdate="20190502T052425Z">
        <seg>新接手工作的JobManager会执行以下步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new JobManager that takes over the work of the failed master performs the following steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195042Z" creationid="xccui" creationdate="20190606T195042Z">
        <seg>新接手工作的JobManager会执行以下步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new watermark is emitted if the method returns a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054517Z" creationid="xccui" creationdate="20190620T054517Z">
        <seg>如果该方法返回一个非空、且大于之前值的水位线，算子就会将这个新水位线发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parallel count-based tumbling window of length 2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014208Z" creationid="xccui" creationdate="20190606T014058Z">
        <seg>基于数量2的并行滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parallel count-based tumbling window of length 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195913Z" creationid="xccui" creationdate="20190409T195913Z">
        <seg>基于数量2的并行滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A periodic watermark assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051030Z" creationid="xccui" creationdate="20190620T051030Z">
        <seg>周期性水位线分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A physical dataflow plan for counting hashtags (nodes represent tasks)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044512Z" creationid="xccui" creationdate="20190605T233201Z">
        <seg>主题标签计数的物理Dataflow计划（顶点表示任务）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A physical dataflow plan for counting hashtags.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021747Z" creationid="xccui" creationdate="20190401T021452Z">
        <seg>主题标签计数的物理dataflow计划，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A process function can easily filter out late events by comparing their timestamps with the current watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T153933Z" creationid="xingcan" creationdate="20190628T153844Z">
        <seg>处理函数可以通过比较事件时间戳和当前水位线的方式轻松过滤掉迟到事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A process function can identify late events by comparing event timestamps with the current watermark and emitting them using the regular side-output API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155410Z" creationid="xingcan" creationdate="20190628T155348Z">
        <seg>处理函数可以通过比较事件时间戳和当前水位线来识别迟到事件，并使用常规的副输出API将其发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing slot can execute one slice of an application—one parallel task of each operator of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T070721Z" creationid="xccui" creationdate="20190606T144414Z">
        <seg>每个处理槽可以执行应用的一部分，即算子的一个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing slot is able to execute one slice of an application, i.e., one parallel task of each operator of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042814Z" creationid="xccui" creationdate="20190423T042808Z">
        <seg>每个处理槽可以执行应用的一部分，即应用内算子的一个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window continues counting time even after Alice’s phone gets disconnected</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023919Z" creationid="xccui" creationdate="20190606T023909Z">
        <seg>在爱丽丝手机离线后继续计时的处理时间窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window continues counting time when Alice’s phone gets disconnected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145324Z" creationid="xccui" creationdate="20190412T145316Z">
        <seg>在爱丽丝手机离线后继续计时的处理时间窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window includes all events that happen to have arrived at the window operator within a time period, as meas&lt;t2/&gt;‐&lt;t3/&gt; ured by the wall-clock of its machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T144411Z" creationid="xccui" creationdate="20190412T144411Z">
        <seg>基于处理时间的窗口包含了那些恰好在一段时间内到达窗口算子的事件，这里的时间段是按照机器时间测量的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A processing-time window includes all events that happen to have arrived at the window operator within a time period, as meas‐ ured by the wall clock of its machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155618Z" creationid="xccui" creationdate="20190606T023838Z">
        <seg>基于处理时间的窗口会包含那些恰好在一段时间内到达窗口算子的事件，这里的时间段是按照机器时间测量的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A project import wizard will guide you though the next steps, such as selecting the Maven project to import (there should only be one), selecting the SDK, and naming the project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041529Z" creationid="xccui" creationdate="20190611T041529Z">
        <seg>根据导入向导的指示完成后续步骤，例如：选择要导入的Maven项目（应该只有一个），选择SDK，为项目命名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A punctuated watermark assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054747Z" creationid="xccui" creationdate="20190620T054747Z">
        <seg>定点水位线分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A receiving task grants some credit to a sending task, i.e., a number of network buffers that are reserved to receive its data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T143724Z" creationid="esouser" creationdate="20190513T210814Z">
        <seg>一个接收任务会给一个发送任务授予一定的信用度，其实就是保留一些用来接收它数据的网络缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A receiving task grants some credit to a sending task, the number of network buffers that are reserved to receive its data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194828Z" creationid="xccui" creationdate="20190606T202733Z">
        <seg>接收任务会给发送任务授予一定的信用值，其实就是保留一些用来接收它数据的网络缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recent approach to overcome the tight bundling of applications is the microservice design pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190227T233935Z" creationid="xccui" creationdate="20190227T042104Z">
        <seg>近些年提出的微服务模式可以克服这种应用紧耦合情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recent approach to overcoming the tight bundling of applications is the microservices design pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200619Z" creationid="esouser" creationdate="20190603T200240Z">
        <seg>近些年提出的微服务设计模式可以克服这种应用紧耦合情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reduce transformation does</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061533Z" creationid="xccui" creationdate="20190614T061516Z">
        <seg>reduce转换不会改变数据流的类型，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A return value of true preserves the input event and forwards it to the output, and false results in dropping the event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052016Z" creationid="xccui" creationdate="20190613T052016Z">
        <seg>如果返回值为true则会保留并输入事件并将其转发到输出，否则会把事件丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling aggregation does not require a user-defined func‐ tion but receives an argument that specifies on which field the aggregate is computed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052539Z" creationid="xccui" creationdate="20190614T052539Z">
        <seg>虽然滚动聚合不需要用户自定义函数，但需要接收一个用于指定聚合计算字段的参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling aggregation is an aggregation, such as sum, minimum, and maximum, that is continuously updated for each input event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061147Z" creationid="xccui" creationdate="20190406T034203Z">
        <seg>滚动聚合（例如求和、求最小值和求最大值）会根据每个到来的事件持续更新结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling aggre‐ gate operator keeps an aggregated value for every observed key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052118Z" creationid="xccui" creationdate="20190614T052118Z">
        <seg>滚动聚合算子会对每一个遇到的键值保存一个聚合结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling maximum of the input stream on the specified field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053531Z" creationid="xccui" creationdate="20190614T053531Z">
        <seg>滚动计算输入流中指定字段的最大值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling maximum of the input stream that returns the event with the highest</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053838Z" creationid="xccui" creationdate="20190614T053838Z">
        <seg>滚动计算输入流中迄今为止最大值，返回该值所在事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum aggregation operation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011943Z" creationid="xccui" creationdate="20190606T011943Z">
        <seg>求最小值的滚动聚合操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum aggregation operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035912Z" creationid="xccui" creationdate="20190406T035912Z">
        <seg>求最小值的滚动聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum of the input stream on the specified field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052715Z" creationid="xccui" creationdate="20190614T052715Z">
        <seg>滚动计算输入流中指定字段的最小值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling minimum of the input stream that returns the event with the lowest</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053812Z" creationid="xccui" creationdate="20190614T053741Z">
        <seg>滚动计算输入流中迄今为止最小值，返回该值所在事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rolling sum of the input stream on the specified field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052657Z" creationid="xccui" creationdate="20190614T052657Z">
        <seg>滚动计算输入流中指定字段的和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A second, job-independent image is used to deploy TaskManager containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143748Z" creationid="xccui" creationdate="20190606T143748Z">
        <seg>另一个和作业无关的映像负责部署TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A second, job-independent image is used to deploy TaskManagers containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T035719Z" creationid="xccui" creationdate="20190423T035719Z">
        <seg>另一个和作业无关的映像负责部署TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A session window assigner places elements into nonoverlapping windows of activity of varying size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060814Z" creationid="xccui" creationdate="20190623T060814Z">
        <seg>会话窗口将元素放入活动长度可变且不重叠的窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A session window assigner places elements into varying size windows defined</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061311Z" creationid="xccui" creationdate="20190623T061311Z">
        <seg>会话窗口分配器将元素置于由会话间隔决定的大小的可变窗口中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A shorter checkpointing interval causes higher overhead during regu‐ lar processing but can enable faster recovery because less data needs to be reproc‐ essed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T205930Z" creationid="xccui" creationdate="20190702T205930Z">
        <seg>较短的间隔会为常规处理带来较大的开销，但由于恢复时要重新处理的数据量较小，所以恢复速度会更快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A side output is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T015023Z" creationid="xccui" creationdate="20190622T015023Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A similar effect appears for operators with two input streams whose watermarks sig‐ nificantly diverge.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033052Z" creationid="xccui" creationdate="20190607T033031Z">
        <seg>算子两个输入流的水位线差距很大时，也会产生类似影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple example is a task that continuously counts how many records it receives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054633Z" creationid="xccui" creationdate="20190607T054544Z">
        <seg>我们以一个持续计算接收到多少条记录的简单任务为例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sliding window assigner places elements into fixed-size, possibly overlap‐ ping windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054822Z" creationid="xccui" creationdate="20190623T054822Z">
        <seg>滑动窗口分配器将元素置于大小固定且可能重叠的窗口中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A so-called type extractor analyzes the generic types and return types of all functions to obtain the respective TypeInformation objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T052355Z" creationid="xccui" creationdate="20190617T052355Z">
        <seg>一个类型提取器会分析所有函数的泛型类型及返回类型，以获取相应的TypeInformation对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A solution for this problem is to remove the state of expired keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T141917Z" creationid="xccui" creationdate="20190704T141917Z">
        <seg>该问题的解决方案是从状态中删除那些过期的键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A source function emits a stream of records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034220Z" creationid="xccui" creationdate="20190607T034220Z">
        <seg>源函数会发出一条记录流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A split operation that splits the input stream into a stream of white events and a stream of others</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T054207Z" creationid="xccui" creationdate="20190615T054207Z">
        <seg>将输入流拆分为白色事件和其他颜色事件的split操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A state backend is responsible for two things: local state management and checkpointing state to a remote location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155046Z" creationid="xccui" creationdate="20190608T051505Z">
        <seg>状态后端主要负责两件事：本地状态管理和将状态检查点写入远程存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A state backend takes care of checkpointing the state of a task to a remote and persistent storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155107Z" creationid="xccui" creationdate="20190608T053657Z">
        <seg>状态后端负责将任务状态以检查点形式写入远程持久化存储，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A state primitive defines the struc‐ ture of the state for an individual key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T040912Z" creationid="xccui" creationdate="20190630T040912Z">
        <seg>状态原语定义了单个键值下的状态结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stateful KeyedProcessFunction that cleans its state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205611Z" creationid="xccui" creationdate="20190704T205553Z">
        <seg>可以清除状态的KeyedProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stateful stream processing task</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054231Z" creationid="xccui" creationdate="20190607T054231Z">
        <seg>带有状态的流处理任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stateful streaming application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T033106Z" creationid="xccui" creationdate="20190305T033106Z">
        <seg>状态化流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream processor that operates a data pipeline should also feature many source and sink connectors to read data from and write data to various storage sys‐ tems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T061644Z" creationid="xccui" creationdate="20190605T042729Z">
        <seg>执行数据管道应用的流处理引擎为了支持不同外部系统的数据读写，还需要提供多样化的数据源、汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream processor that operates data pipelines should also fea&lt;t0/&gt;‐&lt;t1/&gt; ture many source and sink connectors to read data from and write data to various storage systems and formats.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014637Z" creationid="xccui" creationdate="20190317T015024Z">
        <seg>执行数据管道的流处理引擎为了支持不同格式或外部系统的数据读写，还需要提供多样化的数据源、汇连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream that is written to an event log can be read many times by the same or different consumers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T054850Z" creationid="xccui" creationdate="20190305T054850Z">
        <seg>写入事件日志的数据流可以被相同或不同的消费者重复读取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream transformation is applied on one or more streams and converts them into one or more output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T013355Z" creationid="xccui" creationdate="20190613T013226Z">
        <seg>流式转换会将一个或多个输入流转换成一个或多个输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream with timestamped records and watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T015017Z" creationid="xccui" creationdate="20190606T205321Z">
        <seg>包含带有时间戳的记录和水位线的数据流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stream with timestamped records and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042320Z" creationid="xccui" creationdate="20190523T042320Z">
        <seg>带有时间戳记录和水位线的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming analytics application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044651Z" creationid="xccui" creationdate="20190605T044651Z">
        <seg>流式分析应用示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming analytics application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062137Z" creationid="xccui" creationdate="20190317T062137Z">
        <seg>流式分析应用示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming applica&lt;t0/&gt;‐&lt;t1/&gt; tion cannot continue processing if the responsible JobManager process disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T043208Z" creationid="xccui" creationdate="20190502T043155Z">
        <seg>如果负责管理的JobManager进程消失，流式应用将无法继续处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming applica‐ tion cannot continue processing if the responsible JobManager process disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145814Z" creationid="xccui" creationdate="20190606T145814Z">
        <seg>如果负责管理的JobManager进程消失，流式应用将无法继续处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming operator with a UDF that turns each incoming event into a black event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T155750Z" creationid="xccui" creationdate="20190405T155317Z">
        <seg>带有UDF的流式算子会将每个到来的事件变黑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A streaming operator with a function that turns each incoming event into a darker event</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060814Z" creationid="xccui" creationdate="20190606T011608Z">
        <seg>带有函数的流式算子会将每个到来事件的颜色变深</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task maintains a partition watermark for each input partition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T024125Z" creationid="xccui" creationdate="20190607T024100Z">
        <seg>一个任务会为它的每个输入分区都维护一个分区水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task of a stateful operator typically reads and updates its state for each incoming record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051142Z" creationid="xccui" creationdate="20190607T230111Z">
        <seg>状态化算子的任务通常会对每一条到来的记录读写状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A task receives some input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054300Z" creationid="xccui" creationdate="20190607T054300Z">
        <seg>任务首先会接收一些输入数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A textbook setup consists of a stream processor, a batch pro&lt;t4/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032914Z" creationid="xccui" creationdate="20190327T032745Z">
        <seg>一个典型的配置需要包含流处理引擎、批处理引擎、"提速"存储、批量存储和一系列负责向批处理引擎中加载数据及调度任务的工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A third option to specify keys are KeySelector functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050950Z" creationid="xccui" creationdate="20190618T050826Z">
        <seg>第三种指定键值的方法是使用KeySelector函数，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A traditional approach to synchronize data in different storage systems is periodic ETL jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T062152Z" creationid="xccui" creationdate="20190604T055001Z">
        <seg>在不同存储系统间同步数据的传统方式是定期执行ETL作业，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A traditional data warehouse architecture for data analytics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203717Z" creationid="esouser" creationdate="20190603T203647Z">
        <seg>用于数据分析的传统数据仓库架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A traditional data warehouse architecture for data analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194730Z" creationid="xccui" creationdate="20190228T194625Z">
        <seg>用于数据分析的传统数据仓库架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A trigger can decide based on assigned elements or registered timers (similar to a process function) to evaluate or purge the contents of its window at specific points in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053247Z" creationid="xccui" creationdate="20190625T053247Z">
        <seg>触发器可以根据已分配的元素或注册的计时器（类似处理函数）来决定在某些特定时刻执行计算或清除窗口中的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A trigger can decide to fire based on progress in time- or data-specific conditions, such as element count or certain observed element values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T181750Z" creationid="xccui" creationdate="20190626T181714Z">
        <seg>它的触发因素可以是时间，也可以是某些特定的数据条件，如元素数量或某些观测到的元素值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A trigger can define and use custom, per-window and per-key state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T034923Z" creationid="xccui" creationdate="20190626T034923Z">
        <seg>触发器中可以定义和使用针对每个窗口、每个键值的自定义状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A trigger can register timers to be called back at certain points in time—for example, to evaluate a window or purge its contents.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040457Z" creationid="xccui" creationdate="20190626T034731Z">
        <seg>可以在触发器中注册计时器，用于在将来某个时间点触发回调（例如，对窗口进行计算或清理其内容）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tumbling window assigner places elements into fixed-size, nonoverlapping windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042229Z" creationid="xccui" creationdate="20190623T042229Z">
        <seg>滚动窗口分配器将元素置于大小固定且互不重叠的窗口中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tumbling window assigner places elements into nonoverlapping, fixed-size win‐ dows, as shown in Figure 6-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042155Z" creationid="xccui" creationdate="20190623T042155Z">
        <seg>如图6-1所示，滚动窗口分配器将元素置于大小固定且相互不重叠的窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tumbling window assigner receives one parameter, the window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042554Z" creationid="xccui" creationdate="20190623T042447Z">
        <seg>滚动窗口分配器只接收一个参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A typical example is a stream of click events where clicks have a session id attribute that expires after some time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T141432Z" creationid="xccui" creationdate="20190704T141225Z">
        <seg>一个典型的例子是有一条包含会话id属性的点击事件流，其中的会话id会在一段时间后过期。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A union operation that merges two input streams into one</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064258Z" creationid="xccui" creationdate="20190614T064258Z">
        <seg>将两条输入流合二为一的union操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark is a global progress metric that indicates a certain point in time when we are confident that no more delayed events will arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205155Z" creationid="xccui" creationdate="20190412T204632Z">
        <seg>水位线是一个全局进度指标，表示我们确信再不会有延迟事件到来的某个时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark is a global progress metric that indicates the point in time when we are confident that no more delayed events will arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160912Z" creationid="xccui" creationdate="20190606T025336Z">
        <seg>水位线是一个全局进度指标，表示我们确信不会再有延迟事件到来的某个时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark tells operators that no more events with a timestamp less than or equal to the watermark are expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T020532Z" creationid="xccui" creationdate="20190620T020532Z">
        <seg>水位线告知算子不必再等那些时间戳小于或等于水位线的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark with a timestamp T indi‐ cates that all subsequent records should have timestamps &gt; T.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205434Z" creationid="xccui" creationdate="20190606T205434Z">
        <seg>一个拥有时间戳t的水位线表示，接下来所有记录的时间戳一定都大于t。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A watermark with a timestamp t indicates that all subsequent records should have timestamps &gt; t.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042656Z" creationid="xccui" creationdate="20190523T042649Z">
        <seg>一个拥有时间戳t的水位线表示，接下来所有记录的时间戳一定都大于t。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A welcoming community</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030250Z" creationid="xccui" creationdate="20190225T030250Z">
        <seg>欢迎加入社区</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window assigner for tumbling event-time windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042315Z" creationid="xccui" creationdate="20190626T042315Z">
        <seg>用于滚动事件时间窗口的窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window assigner produces a WindowedStream (or All WindowedStream if applied on a nonkeyed DataStream).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T035710Z" creationid="xccui" creationdate="20190622T035710Z">
        <seg>窗口分配器会产生一个WindowedStream（如果用在非键值分区的DataStream上则是AllWindowedStream）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window assigner that determines how the elements of the input stream are grouped into windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T035445Z" creationid="xccui" creationdate="20190622T035445Z">
        <seg>一个用于决定输入流中的元素该如何分组的窗口分配器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window consists of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033005Z" creationid="xccui" creationdate="20190626T033005Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window function that is applied on a WindowedStream (or AllWindowedStream)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T040059Z" creationid="xccui" creationdate="20190622T035910Z">
        <seg>一个作用于WindowedStream（或AllWindowedStream）上用于处理分配到窗口中元素的窗口函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window is created when the WindowAssigner assigns the first element to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032622Z" creationid="xccui" creationdate="20190626T032622Z">
        <seg>窗口会在WindowAssigner首次对它分配元素时创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window only stores the current result of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T225105Z" creationid="xccui" creationdate="20190623T225105Z">
        <seg>窗口只需要存储当前聚合结果——</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window operator creates and typically also deletes windows while it processes incoming stream elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T031225Z" creationid="xccui" creationdate="20190626T031225Z">
        <seg>窗口算子在处理到达的数据流元素时需要新建窗口，并且通常还需要将其删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window operator with a full window function (the circles in each window represent its collected raw input records)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054032Z" creationid="xccui" creationdate="20190625T054003Z">
        <seg>配置了全量窗口函数的窗口算子（每个窗口内的圆圈表示收集的原始输入记录）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window operator with allowed lateness will not delete a window and its state after the watermark passes the window’s end timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164620Z" creationid="xingcan" creationdate="20190628T164432Z">
        <seg>配置了该属性的窗口算子在水位线超过窗口的结束时间戳之后不会立即删除窗口，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window operator with an incremental aggregation and full window func‐ tion (the single circle in each window represents its aggregated window state)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T214226Z" creationid="xccui" creationdate="20190625T214226Z">
        <seg>配置了增量聚合及全量窗口函数的窗口算子（每个窗口内的单个圆圈表示聚合后的窗口状态）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A window operator with an incremental aggregation function (the single cir‐ cle in each window represents its aggregated window state)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T214234Z" creationid="xccui" creationdate="20190625T053641Z">
        <seg>配置了增量聚合函数的窗口算子（每个窗口内的单个圆圈表示聚合后的窗口状态）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040532Z" creationid="xccui" creationdate="20190418T040532Z">
        <seg>A.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ACC add(IN value, ACC accumulator);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004442Z" creationid="xccui" creationdate="20190624T004442Z">
        <seg>ACC add(IN value, ACC accumulator);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ACC createAccumulator();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004329Z" creationid="xccui" creationdate="20190624T004329Z">
        <seg>ACC createAccumulator();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ACC merge(ACC a, ACC b);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004858Z" creationid="xccui" creationdate="20190624T004858Z">
        <seg>ACC merge(ACC a, ACC b);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>API, each WindowAssigner has a default trigger that is used unless an explicit trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T025712Z" creationid="xccui" creationdate="20190626T024913Z">
        <seg>对于没有显式定义触发器的WindowAssigner都会提供一个默认的触发器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ability to run streaming applications 24/7 with very little downtime due to its highly available setup (no single point of failure), tight integration with Kuber‐ netes, YARN, and Apache Mesos, fast recovery from failures, and the ability to dynamically scale jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T143456Z" creationid="xccui" creationdate="20190605T121543Z">
        <seg>支持高可用性配置（无单点失效），和Kubernetes、YARN、Apache Mesos紧密集成，快速故障恢复，动态扩容作业等。基于上述特点，它可以7×24小时运行流式应用，几乎无须停机。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ability to update the application code of jobs and migrate jobs to different Flink clusters without losing the state of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T121551Z" creationid="xccui" creationdate="20190605T121551Z">
        <seg>允许在不丢失应用状态的前提下更新作业的程序代码或进行跨Flink集群的作业迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access to timestamps and watermarks through the API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042406Z" creationid="xccui" creationdate="20190529T042406Z">
        <seg>通过API访问时间戳和水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing state stored by the RocksDB state back‐ end is slower but its state may grow very large.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053243Z" creationid="xccui" creationdate="20190608T053046Z">
        <seg>后者状态访问会慢一些，但允许状态变得很大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acknowledgments</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210942Z" creationid="esouser" creationdate="20190603T210849Z">
        <seg>致谢</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acquisitions Editor: Rachel Roumeliotis Development Editor: Alicia Young Production Editor: Katherine Tozer Copyeditor: Christina Edwards Proofreader: Charles Roumeliotis</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210719Z" creationid="esouser" creationdate="20190603T210719Z">
        <seg>Acquisitions Editor: Rachel Roumeliotis Development Editor: Alicia Young Production Editor: Katherine Tozer Copyeditor: Christina Edwards Proofreader: Charles Roumeliotis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Actually, every 5 seconds, Flink invokes the getCurrentWatermark() method of AssignerWithPeriodicWatermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045929Z" creationid="xccui" creationdate="20190620T045929Z">
        <seg>实际上，Flink会每隔5秒调用一次AssignerWithPeriodicWatermarks中的getCurrentWatermark()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ad-hoc analysis of live data in consumer technology</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045434Z" creationid="xccui" creationdate="20190605T045434Z">
        <seg>消费者技术中的实时数据即席分析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ad-hoc analysis of live data in consumer technology.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033630Z" creationid="xccui" creationdate="20190319T033607Z">
        <seg>消费者技术中的实时数据即席分析等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding external dependencies is a common requirement when implementing Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034846Z" creationid="xccui" creationdate="20190619T034645Z">
        <seg>在实现Flink应用时经常需要添加一些外部依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional require&lt;t2/&gt;‐&lt;t3/&gt; ments to successfully support streaming analytics applications are support for event-time processing in order to produce correct and deterministic results and the ability to process large amounts of data in little time, i.e., high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033210Z" creationid="xccui" creationdate="20190319T033109Z">
        <seg>为了成功支持流式分析应用，还有一些额外需求：支持事件时间处理以便产生正确及确定的结果，能够在短时间内处理大量数据（高吞吐）等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional requirements for data pipelines are the ability to process large amounts of data in short time, i.e., support for high throughput, and the capability to scale an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T014732Z" creationid="xccui" creationdate="20190317T014732Z">
        <seg>它的额外需求是能够在短时间内处理大批量数据，即高吞吐和支持应用扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, a KeyedPro cessFunction[KEY, IN, OUT] provides the following two methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053335Z" creationid="xccui" creationdate="20190621T053335Z">
        <seg>除此之外，KeyedProcessFunction[KEY, IN, OUT]还提供了以下两个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the stream processor needs to ensure internal state consistency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044439Z" creationid="xccui" creationdate="20190416T044427Z">
        <seg>此外，流处理引擎需要确保内部状态的一致性，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you can fast forward the computation to the present so that once your program catches up with the events happening now, it can continue as a real-time application using exactly the same program logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025218Z" creationid="xccui" creationdate="20190606T025120Z">
        <seg>此外，你可以把计算"快进"到现在，这样一旦你的程序赶上了当前事件产生的进度，它能够以完全相同的程序逻辑作为实时应用继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you can fast-forward the computation to the present so that once your program catches</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155334Z" creationid="xccui" creationdate="20190412T154959Z">
        <seg>此外，你可以把计算"快进"到现在，这样一旦你的程序赶上了当前事件产生的进度，它能够以相同的程序逻辑作为实时应用继续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T213219Z" creationid="xccui" creationdate="20190704T213219Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all barriers are sent out, the source continues its regu‐ lar operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T154506Z" creationid="xccui" creationdate="20190609T154335Z">
        <seg>在将所有分隔符发出后，数据源将恢复常规工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all buffered records have been emitted, the task continues processing its input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193332Z" creationid="xccui" creationdate="20190609T193332Z">
        <seg>待所有缓冲的记录处理完后，任务就会继续处理输入流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After an application is restarted from a checkpoint, its internal state is exactly the same as when the checkpoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T051833Z" creationid="xccui" creationdate="20190609T051324Z">
        <seg>在应用从检查点恢复以后，它的内部状态会和生成检查点的时候完全一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After it has been started, a TaskManager registers its slots at the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062107Z" creationid="xccui" creationdate="20190418T051651Z">
        <seg>在TaskManager启动后，会将它的处理槽在ResourceManager中注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After it has been started, a TaskManager registers its slots to the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061234Z" creationid="xccui" creationdate="20190606T142555Z">
        <seg>TaskManager在启动后，会向ResourceManager注册它的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After reading this chapter, you will know how to implement a stream processing application with basic functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T032952Z" creationid="xccui" creationdate="20190612T032952Z">
        <seg>本章过后，你将了解如何实现一个具有基本功能的流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, Flink does all of this.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T042759Z" creationid="xccui" creationdate="20190605T042752Z">
        <seg>Flink同样可以做到上述一切。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, Flink provides all required features to success&lt;t2/&gt;‐&lt;t3/&gt; fully operate data pipelines and includes many connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T024845Z" creationid="xccui" creationdate="20190317T024845Z">
        <seg>Flink 同样为执行数据管道提供了全部所需特性以及多种连接器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AggregateFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002621Z" creationid="xccui" creationdate="20190624T002621Z">
        <seg>AggregateFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregating State.get() computes the final result and returns it as an Iterable with a single element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061143Z" creationid="xccui" creationdate="20190630T061056Z">
        <seg>AggregatingState.get()方法会计算最终结果并将其作为Iterable中唯一的元素返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AggregatingState[I, O] behaves similar to ReducingState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T060850Z" creationid="xccui" creationdate="20190630T060752Z">
        <seg>AggregatingState[I, O]和ReducingState行为类似，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregation operations are stateful and combine the current state with the incoming event to produce an updated aggregate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061239Z" creationid="xccui" creationdate="20190606T011759Z">
        <seg>聚合操作都是状态化的，它们通过将新到来的事件合并到已有状态来生成更新后的聚合值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Aggregation operations are stateful and combine the current state with the incoming event to produce an updated aggregate value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T034808Z" creationid="xccui" creationdate="20190406T034634Z">
        <seg>这些聚合操作是状态化的，它们通过将新到来的事件合并到已有状态来生成更新后的聚合值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alice is a devoted player who plays the game every morning during her commute to work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T150319Z" creationid="xccui" creationdate="20190411T150319Z">
        <seg>爱丽丝是个铁杆玩家，每天早晨上班路上都会玩这个游戏。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alice keeps on playing and the game events are buffered in her phone.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154630Z" creationid="xccui" creationdate="20190411T151259Z">
        <seg>爱丽丝继续玩她的，此时游戏产生的事件会缓存在手机里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All Java and Scala primitive types, such as Int (or Integer for Java), String, and Double, are supported.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070306Z" creationid="xccui" creationdate="20190616T070259Z">
        <seg>Flink支持所有Java和Scala的原始类型，例如Int（Java中是Integer）、String、Double。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All assigners we discuss here are time-based and were introduced in “Operations on Data Streams” on page 22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T032624Z" creationid="xccui" creationdate="20190623T032624Z">
        <seg>所有接下来要讨论的分配器都是基于时间的，我们在第22页"数据流上的操作"对它们都有介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All built-in window assigners provide a default trigger that triggers the evaluation of a window once the (processing or event) time passes the end of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T033331Z" creationid="xccui" creationdate="20190623T033331Z">
        <seg>所有内置的窗口分配器都提供了一个默认的触发器，一旦（处理或事件）时间超过了窗口的结束时间就会触发窗口计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All events of the broadcasted stream are replicated and sent to all parallel operator instances of the subsequent processing function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T052019Z" creationid="xccui" creationdate="20190615T051939Z">
        <seg>所有广播流的事件都会被复制多份并分别发往后续处理函数所在算子的每个实例；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All events that are pro‐ cessed in the same parallel task of an operator have access to the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T035609Z" creationid="xccui" creationdate="20190701T035437Z">
        <seg>因此同一算子并行任务中所处理的事件都可以访问相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All fields are public or accessible through getters and setters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T043446Z" creationid="xccui" creationdate="20190617T043446Z">
        <seg>所有字段都是公有的或提供了相应的getter及setter方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All fields have types that are supported by Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044633Z" creationid="xccui" creationdate="20190617T044620Z">
        <seg>所有字段类型都必须是Flink所支持的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All functions are evaluated by an individual task running in a dedicated thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T202032Z" creationid="esouser" creationdate="20190514T154729Z">
        <seg>其中每个函数都交由单独的任务、在特定线程内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All issues related to state consistency, failure handling, and efficient storage and access are taken care of by Flink so that developers can focus on the logic of their applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055747Z" creationid="xccui" creationdate="20190607T055712Z">
        <seg>所有和状态一致性，故障处理，高效存取相关的问题都由Flink负责搞定，这样开发人员就可以专注于自己的应用逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the previously mentioned use cases for savepoints follow the same pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214212Z" creationid="xccui" creationdate="20190609T214125Z">
        <seg>所有之前提到的保存点相关用例都遵循同一个模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these systems are typically designed with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T155645Z" creationid="xccui" creationdate="20190226T155406Z">
        <seg>如图1-1所示，上述类型的应用系统通常都会设置独立的数据处理层（应用程序自身）和数据存储层（事务性数据库系统）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these systems store data in different formats and data structures that provide the best performance for their specific access pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T153625Z" creationid="xccui" creationdate="20190604T053820Z">
        <seg>为了在各自访问模式下都能达到最佳性能，上述系统将数据存储为不同格式或数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these systems store data in different representations and data structures that provide the best performance for their specific purpose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T065328Z" creationid="xccui" creationdate="20190314T065141Z">
        <seg>为了达到各自场景下的最佳性能，上述系统会以不同表示形式或数据结构存储数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other dependencies an application requires must be explicitly provided.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035737Z" creationid="xccui" creationdate="20190619T035725Z">
        <seg>对于应用的其它依赖则必须显式提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All process functions implement the RichFunction interface and hence offer open(), close(), and getRuntimeContext() methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053257Z" creationid="xccui" creationdate="20190621T053257Z">
        <seg>所有处理函数都实现了RichFunction接口，因此可以提供open()、close()、getRunteimContext()等方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All records that are processed by a Flink event-time streaming application must be accompanied by a timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035343Z" creationid="xccui" creationdate="20190523T035328Z">
        <seg>所有利用Flink基于事件时间的流式应用进行处理的记录都必须包含时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All rights reserved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210712Z" creationid="esouser" creationdate="20190603T210712Z">
        <seg>All rights reserved.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All state modifications due to records that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061818Z" creationid="xccui" creationdate="20190609T061818Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All state primitives can be cleared by calling State.clear().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061253Z" creationid="xccui" creationdate="20190630T061253Z">
        <seg>所有状态原语都支持调用State.clear()方法来进行清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far are &lt;t0/&gt;global&lt;t1/&gt; windows and operate on the full stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193652Z" creationid="xccui" creationdate="20190409T193652Z">
        <seg>至今为止你所见到的所有窗口都是基于全流数据的全局窗口（global window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far are windows that operate on the full stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063859Z" creationid="xccui" creationdate="20190606T013831Z">
        <seg>迄今为止你所见到的所有窗口都是基于全流数据的全局窗口（global window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far need to buffer data before performing an operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T204023Z" creationid="xccui" creationdate="20190409T203631Z">
        <seg>至今为止所有你看到的窗口类型都要在执行实际操作前缓冲数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the window types that you have seen so far need to buffer data before producing a result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064341Z" creationid="xccui" creationdate="20190606T014514Z">
        <seg>至今为止你见到的所有窗口类型都要在生成结果前缓冲数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All these use cases require collecting real-time data, analyzing it with low latency, and immediately reacting to the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T054203Z" creationid="xccui" creationdate="20190317T053847Z">
        <seg>所有这些用例都需要收集实时数据、进行低延迟地分析并立即响应结果，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All transformations in this section produce a DataStream whereas keyBy() results in a KeyedStream, on which transformation with access to keyed state can be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190615T070620Z">
        <seg>所有本节介绍的转换都会生成一个DataStream，而keyBy()会生成一个KeyedStream。基于后者可以应用那些能够访问键值分区状态的转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allowed lateness can be specified using the allowedLateness() method as Example 6-22 demonstrates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165139Z" creationid="xingcan" creationdate="20190628T165139Z">
        <seg>如示例6-22所示，我们可以使用allowedLateness()方法指定延迟容忍度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Along with the previously discussed window functions, these components work together in a window operator to group and process elements in windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T051506Z" creationid="xccui" creationdate="20190625T051506Z">
        <seg>这些组件和之前讨论的窗口函数协同工作，一起实现对于元素的窗口化分组和处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also the internals of a stream processor that supports event-time are more involved than the internals of a system that purely operates in processing-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T033738Z" creationid="xccui" creationdate="20190523T033738Z">
        <seg>此外，相比纯粹使用处理时间，支持事件时间的流处理引擎内部要更加复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also used for module and package names, and to show commands or other text that should be typed literally by the user and the output of commands.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210806Z" creationid="esouser" creationdate="20190603T210806Z">
        <seg>Also used for module and package names, and to show commands or other text that should be typed literally by the user and the output of commands.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the ProcessWindowFunction.clear() method is invoked to clean up all custom per-window state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184923Z" creationid="xccui" creationdate="20190626T184905Z">
        <seg>同时，调用ProcessWindowFunction.clear()方法来清理那些自定义的单个窗口状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the internals of a stream processor that supports event time are more involved than the internals of a system that purely operates in processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204405Z" creationid="xccui" creationdate="20190606T204405Z">
        <seg>此外，相比纯粹使用处理时间，支持事件时间的流处理引擎内部要更加复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alterna&lt;t4/&gt;‐&lt;t5/&gt; tively, Flink provides a feature called queryable state which allows users to expose the state of an application as a key-lookup table and make it accessible for external appli&lt;t6/&gt;‐&lt;t7/&gt; cations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T060943Z" creationid="xccui" creationdate="20190317T060535Z">
        <seg>而Flink提供了一项名为可查询状态（queryable state）的功能，允许用户将应用的状态以键查表（key-lookup table）的形式发布出去，供其他外部应用访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, a 95th-percentile latency value of 10 ms means that 95% of events are processed within 10 ms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234036Z" creationid="xccui" creationdate="20190605T234036Z">
        <seg>而第95百分位延迟在10毫秒意味着95%的事件会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070120Z" creationid="xccui" creationdate="20190615T070120Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, it is also possible to explicitly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T071607Z" creationid="xccui" creationdate="20190630T071607Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can spec‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054159Z" creationid="xccui" creationdate="20190623T054159Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although a program is executed in a single JVM, records are serialized for cross- thread communication and possibly state persistance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T054835Z" creationid="xccui" creationdate="20190611T054835Z">
        <seg>虽然程序运行在单个JVM内，但出于跨线程通信或可能存在的状态持久化考虑，记录都会被序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although not being covered in this book but certainly worth mentioning is that Flink also provides support for analytical SQL queries over streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T040637Z" creationid="xccui" creationdate="20190319T040637Z">
        <seg>虽然本书中并未涉及，但值得一提的是，Flink还支持基于数据流的分析型SQL查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this means Flink processes some messages twice (before and after the failure), the mechanism still achieves exactly-once state consistency because the state of all operators was reset to a point that had not seen this data yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T053520Z" creationid="xccui" creationdate="20190609T053400Z">
        <seg>虽然这意味着Flink进程会重复处理部分消息，但上述机制仍然可以实现精确一次的状态一致性，因为所有算子的状态都会重置到过去还没有处理过那些数据的时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although we don’t cover it here, Flink also provides support for analytical SQL quer‐ ies over streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160052Z" creationid="xccui" creationdate="20190605T045441Z">
        <seg>虽然本书中没有过多涉及，但值得一提的是，Flink还支持对于数据流的分析型SQL查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T202926Z" creationid="xccui" creationdate="20190701T202926Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An ETL process extracts data from a transactional database, transforms it into a common representation that might include validation, value normalization, encoding, deduplication, and schema trans‐ formation, and finally loads it into the analytical database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T064753Z" creationid="esouser" creationdate="20190603T202811Z">
        <seg>ETL的基本流程是：从事务型数据库中提取数据，将其转换为通用表示形式（可能包含数据验证、数据归一化、编码、去重、格式转换等工作），最终加载到分析型数据库中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An ETL process extracts data from a transactional database, transforms it into a common representation which might include validation, value normalization, encoding, de-duplication, and schema transformation, and finally loads it into the analytical database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192143Z" creationid="xccui" creationdate="20190228T190902Z">
        <seg>ETL的基本流程是：从事务型数据库中提取数据，将其转换为通用表示形式（可能包含数据验证、数据归一化、编码、去重、格式转换等工作），最终写入到分析型数据库中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An IDE for Java and/or Scala development.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T020738Z" creationid="xccui" creationdate="20190611T020738Z">
        <seg>用于Java/Scala开发的IDE。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative is to use an event log to distribute updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T062315Z" creationid="xccui" creationdate="20190604T062308Z">
        <seg>另一个替代方案是使用事件日志系统来分发更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application consists of multiple operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214439Z" creationid="xccui" creationdate="20190609T214422Z">
        <seg>每个应用都会包含很多算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application is recovered in three steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040030Z" creationid="xccui" creationdate="20190609T040030Z">
        <seg>应用恢复要经过3个步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application receiving game events would experience a gap when the train goes through a tunnel and network con&lt;t0/&gt;‐&lt;t1/&gt; nection is lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152946Z" creationid="xccui" creationdate="20190411T152813Z">
        <seg>当地铁进入隧道断网时，应用接收游戏事件会经历一段间隙。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application receiving online mobile game events played on the subway would experience a gap when the network connection is lost, but events are buffered in the player’s phone and delivered when the connection is restored</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023511Z" creationid="xccui" creationdate="20190606T015305Z">
        <seg>当地铁进入隧道断网时，应用接收游戏事件会中断一会，此时事件会缓存在玩家手机中，并在网络恢复后发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An attribution usually includes the title, author, publisher, and ISBN.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210823Z" creationid="esouser" creationdate="20190603T210823Z">
        <seg>An attribution usually includes the title, author, publisher, and ISBN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An early firing trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200121Z" creationid="xccui" creationdate="20190626T200121Z">
        <seg>可提前触发的触发器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An element can be added to zero, one, or multiple windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041408Z" creationid="xccui" creationdate="20190626T041408Z">
        <seg>每个元素可以被加到零个、一个或多个窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An element of the first input will not be joined with an element of the second input even if they are just 1 second apart from each other but assigned to two different windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T143512Z" creationid="xccui" creationdate="20190628T055552Z">
        <seg>那么一旦来自两个输入的元素没有被划分到同一窗口，它们就无法Join在一起，即使二者彼此仅相差1秒钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An embedded execution mode starts Flink applications as a single JVM process which can be used to run and debug Flink jobs within an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T053733Z" creationid="xccui" creationdate="20190328T053510Z">
        <seg>Flink的嵌入式执行模式可将应用以单个JVM进程的方式启动，方便在IDE里运行和调试Flink作业，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event log stores and distributes event streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T054357Z" creationid="xccui" creationdate="20190305T054122Z">
        <seg>事件日志负责存储事件流并将其分布式化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event time window computation will yield the same result no matter how fast the stream is pro‐ cessed or when the events arrive at the operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024326Z" creationid="xccui" creationdate="20190606T024326Z">
        <seg>无论数据流的处理速度如何、事件到达算子的顺序怎样，基于事件时间的窗口都会生成同样的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-driven application architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213914Z" creationid="esouser" creationdate="20190603T213914Z">
        <seg>事件驱动型应用架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-driven application architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152556Z" creationid="xccui" creationdate="20190307T152556Z">
        <seg>事件驱动型应用架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-time window computation will yield the same result no matter how fast the stream is pro&lt;t0/&gt;‐&lt;t1/&gt; cessed or when the events arrive at the operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T151505Z" creationid="xccui" creationdate="20190412T151505Z">
        <seg>无论数据流的处理速度如何、事件到达算子的顺序怎样，基于事件时间的窗口都会生成同样的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An event-time window triggers when the watermarks declare that all timestamps for a certain time interval have been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071049Z" creationid="xccui" creationdate="20190619T071049Z">
        <seg>当水位线表明某个时间间隔内所有时间戳都已接收时，事件时间窗口才会触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An evictor can remove collected elements from the con‐ tents of a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014627Z" creationid="xccui" creationdate="20190626T014450Z">
        <seg>它可以用来从窗口中删除已经收集的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example application would be a real-time monitoring dashboard that displays event aggregates as they are received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031104Z" creationid="xccui" creationdate="20190414T043802Z">
        <seg>一个常见示例应用是实时监控仪表盘，它会接收并展示事件聚合结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance of the function class can then be passed as an argument to the filter transformation:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054126Z" creationid="xccui" creationdate="20190618T054126Z">
        <seg>随后可将函数类的实例作为参数传递给filter转换：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interesting property of watermarks is that they allow an application to control result completeness and latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035910Z" creationid="xccui" creationdate="20190529T035835Z">
        <seg>水位线的一个有趣之处在于，它们允许应用控制结果的完整性和延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interval</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025805Z" creationid="xccui" creationdate="20190628T025805Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interval join joining two streams A and B</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025304Z" creationid="xccui" creationdate="20190628T025154Z">
        <seg>流A和流B上基于间隔的Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An interval join needs to buffer records from one or both inputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T031036Z" creationid="xccui" creationdate="20190628T031036Z">
        <seg>基于间隔的Join需要同时对双流的记录进行缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An on-going effort of the Flink community is to evolve Flink towards a system with a unified batch and streaming API and runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T061543Z" creationid="xccui" creationdate="20190328T061256Z">
        <seg>社区正在努力的一个方向就是将Flink发展成为在API及运行时层面都能做到批流统一的系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An ongoing effort of the Flink community is to evolve Flink toward a system with a truly unified batch and streaming API and runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122304Z" creationid="xccui" creationdate="20190605T122304Z">
        <seg>社区正在努力的一个方向就是将Flink发展成为在API及运行时层面都能做到批流统一的系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An online retailer is able to recommend products to users while they are browsing on the retailer’s website; mobile games can give virtual gifts to users to keep them in a game or offer in-game purchases at the right moment; manufacturers can monitor the behavior of machines and trigger maintenance actions to reduce production outages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T053555Z" creationid="xccui" creationdate="20190317T053555Z">
        <seg>在线商家可以在用户浏览店铺页面的同时为其推荐产品；移动游戏为了提高用户粘性可以适时为其发放虚拟礼品或提供内购折扣；制造商可以通过监测机器行为及时触发维护，从而减少生产中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator based on event time uses watermarks to determine the completeness of its ingested records and the progress of its operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031058Z" creationid="xccui" creationdate="20190621T031058Z">
        <seg>基于事件时间的算子使用水位线来判断输入记录的完整度以及自身的操作进度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator pipeline that complies with the requirements of task chaining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T200254Z" creationid="xccui" creationdate="20190606T203431Z">
        <seg>满足任务链接条件的算子流水线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator pipeline that complies with the requirements of task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152418Z" creationid="esouser" creationdate="20190514T152418Z">
        <seg>满足任务链接需求的算子流水线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator that is applied on a KeyedStream is applied in the context</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T040812Z" creationid="xccui" creationdate="20190630T040707Z">
        <seg>用在KeyedStream上的算子会同时拥有它的键值定义上下文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator that supports recomputing and updating of emitted results needs to pre‐ serve all state required for the computation after the first result was emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T162344Z" creationid="xingcan" creationdate="20190628T162344Z">
        <seg>支持重新计算和对已发出结果进行更新的算子需要保留那些用于再次计算结果的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An opera‐ tor that is applied on a connected and keyed stream has access to keyed state.3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190615T051502Z">
        <seg>应用于已经按照键值分区且已连通数据流上的算子可以访问键值分区状态。3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Analytical Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142900Z" creationid="esouser" creationdate="20190603T142900Z">
        <seg>分析型处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Analyzing user behavior in mobile applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045426Z" creationid="xccui" creationdate="20190605T045425Z">
        <seg>移动应用中的用户行为分析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Analyzing user behavior in mobile applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033623Z" creationid="xccui" creationdate="20190319T033421Z">
        <seg>移动应用中的用户行为分析，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And everyone knows that the mobile inter&lt;t0/&gt;‐&lt;t1/&gt; net connection in the Berlin subway is lousy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151131Z" creationid="xccui" creationdate="20190411T150417Z">
        <seg>而众所周知，柏林地铁上手机网络信号很差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And everyone knows that the mobile internet connection in the Berlin subway is lousy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T015018Z" creationid="xccui" creationdate="20190606T014954Z">
        <seg>而众所周知，柏林地铁上手机上网信号很差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And how do we even know that data will be delayed?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T203758Z" creationid="xccui" creationdate="20190412T161851Z">
        <seg>此外，我们如何得知数据会产生延迟？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And in those cases, will the output be deterministic?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043528Z" creationid="xccui" creationdate="20190415T043222Z">
        <seg>在上述情况下，结果是否确定？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And in those cases, will the out‐ put be deterministic?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033643Z" creationid="xccui" creationdate="20190606T033643Z">
        <seg>在上述情况下，结果是否确定？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anomaly detection (e.g., to detect attempts to intrude a computer network)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055449Z" creationid="esouser" creationdate="20190603T213713Z">
        <seg>异常检测（例如：计算机网络入侵检测）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anomaly detection, e.g., to detect attempts to intrude a computer network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T151741Z" creationid="xccui" creationdate="20190307T151741Z">
        <seg>异常检测（例如：计算机网络入侵检测）等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another approach that works for many storage systems is idempotent updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054318Z" creationid="xccui" creationdate="20190609T054237Z">
        <seg>另一种适用于很多存储系统的方法是幂等更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another case is when you need to periodically report results in real time, independently of their accuracy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180821Z" creationid="xccui" creationdate="20190606T031009Z">
        <seg>另一种情况是，你需要周期性地实时报告结果而无论其准确性如何。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another case is when you need to periodically report results in real-time, independently of their accuracy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043410Z" creationid="xccui" creationdate="20190414T043410Z">
        <seg>另一种情况是，你需要周期性地实时报告结果，而不考虑其准确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another factor that affects latency and consequently throughput is the time it takes to process an event, or the time it takes for each customer to be served in the coffee shop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T205647Z" creationid="xccui" creationdate="20190402T205438Z">
        <seg>影响延迟和相应吞吐的另一因素是处理单个事件的时间，即在咖啡店服务每一名顾客所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another feature are per-window and per-key global states.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024317Z" creationid="xccui" creationdate="20190624T012333Z">
        <seg>另一项功能是单个窗口以及每个键值的全局状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another good practice is to update state only once per function call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T034315Z" creationid="xccui" creationdate="20190704T034315Z">
        <seg>还有一个好的习惯是每个函数调用只更新一次状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another improvement was the dissolution of the latency-throughput trade-off.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T134512Z" creationid="xccui" creationdate="20190327T134512Z">
        <seg>系统另一方面的改进是消除了延迟和吞吐的代价权衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another improvement was the dissolu‐ tion of the latency/throughput tradeoff.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T194501Z" creationid="xccui" creationdate="20190605T053453Z">
        <seg>它的另一项改进是无需让用户在延迟和吞吐之间做出困难的抉择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another state backend serializes state objects and puts them into RocksDB, which writes them to local hard disks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T052613Z" creationid="xccui" creationdate="20190608T052302Z">
        <seg>另一类状态后端会把状态对象序列化后存到RocksDB里面，RocksDB负责将它们写到本地硬盘上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another technique to reduce the checkpointing algorithm’s impact on the processing latency is to tweak the barrier alignment step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T204202Z" creationid="xccui" creationdate="20190609T204102Z">
        <seg>我们还可以调整分隔符对齐这一步，来降低检查点算法对处理延迟的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve equivalent functionality is using record acknowledgements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T043605Z" creationid="xccui" creationdate="20190416T043447Z">
        <seg>另一个实现同样功能的途径是启用记录确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve equivalent functionality is using record acknowledgments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193821Z" creationid="xccui" creationdate="20190606T034729Z">
        <seg>还有一个实现同样功能的途径是启用记录确认。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve the same result is to hire a second barista and exploit parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054629Z" creationid="xccui" creationdate="20190605T235436Z">
        <seg>另一个殊途同归的办法是再雇一个咖啡师，即利用并行解决问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to achieve the same result is to hire a second barista, that is, to exploit parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211453Z" creationid="xccui" creationdate="20190402T211202Z">
        <seg>另一个殊途同归的办法是再雇一个咖啡师，即利用并发解决问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to define keys and select fields is by using String-based field expres‐ sions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T041602Z" creationid="xccui" creationdate="20190618T041433Z">
        <seg>另一种定义键值和选择字段的方法是使用基于字符串的字段表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Answering a question by citing this book and quoting example code does not require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210820Z" creationid="esouser" creationdate="20190603T210820Z">
        <seg>Answering a question by citing this book and quoting example code does not require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any application that processes a stream of events and does not just perform trivial record-at-a-time transformations needs to be stateful, i.e., have the ability to store and access intermediate data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T030539Z" creationid="xccui" creationdate="20190305T030539Z">
        <seg>任何需要处理事件流的应用程序，如果支持跨多条记录的转换操作，则必须是状态化的，因为需要存储和访问中间结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any application that processes a stream of events and does not just perform trivial record-at-a-time transformations needs to be stateful, with the ability to store and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T073044Z" creationid="esouser" creationdate="20190603T205538Z">
        <seg>任何一个处理事件流的应用，如果要支持跨多条记录的转换操作，都必须是状态化的，即能够存储和访问中间结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Cassandra Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025211Z" creationid="xccui" creationdate="20190225T025211Z">
        <seg>Apache Cassandra汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T042850Z" creationid="xccui" creationdate="20190606T042850Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink checks all these boxes and is a very good choice to run event-driven applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T064114Z" creationid="xccui" creationdate="20190314T062533Z">
        <seg>Apache Flink 能够同时涵盖上述全部特性，是运行事件驱动型应用的一个非常好的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink checks all these boxes and is a very good choice to run this class of applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T074800Z" creationid="xccui" creationdate="20190604T053710Z">
        <seg>Apache Flink能够同时涵盖上述全部特性，是运行该类应用的一个非常好的选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink is a distributed stream processor of the third generation with a compet&lt;t0/&gt;‐&lt;t1/&gt; itive feature set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T041127Z" creationid="xccui" creationdate="20190328T002907Z">
        <seg>Apache Flink是一个集众多具有竞争力的特性于一身的第三代流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink is a distributed stream processor with intuitive and expressive APIs to implement stateful stream processing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014455Z" creationid="xccui" creationdate="20190225T191847Z">
        <seg>Apache Flink是一个分布式流处理引擎，它提供了直观且极富表达力的API来实现状态化流处理应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink is a third-generation distributed stream processor with a competitive feature set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054018Z" creationid="xccui" creationdate="20190605T054018Z">
        <seg>Apache Flink是一个集众多具有竞争力的特性于一身的第三代流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink stores application state locally in memory or in an embedded database and not in a remote database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T031826Z" creationid="xccui" creationdate="20190305T031826Z">
        <seg>Apache Flink使用本地内存和嵌入式数据库（而非远程数据库）存储状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Flink stores the application state locally in memory or in an embedded data‐ base.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210000Z" creationid="esouser" creationdate="20190603T205946Z">
        <seg>Apache Flink使用本地内存和嵌入式数据库存储状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Hadoop YARN</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040315Z" creationid="xccui" creationdate="20190418T040315Z">
        <seg>Apache Hadoop YARN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Kafka Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025141Z" creationid="xccui" creationdate="20190225T025141Z">
        <seg>Apache Kafka汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Kafka Source Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025132Z" creationid="xccui" creationdate="20190225T025132Z">
        <seg>Apache Kafka源连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apache Maven 3.x.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T020152Z" creationid="xccui" creationdate="20190611T020152Z">
        <seg>Apache Maven 3.x版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from having a practical value, windows also enable semantically interesting queries on streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T042412Z" creationid="xccui" creationdate="20190406T042112Z">
        <seg>除了产生单个有用的结果，窗口操作还支持数据流上一些语义很有趣的查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appendix Title.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040542Z" creationid="xccui" creationdate="20190418T040542Z">
        <seg>附录标题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application Consistency Guarantees</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025111Z" creationid="xccui" creationdate="20190225T025111Z">
        <seg>应用的一致性保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application Deployment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021747Z" creationid="xccui" creationdate="20190225T021747Z">
        <seg>应用部署</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application submission and component interactions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143131Z" creationid="xccui" creationdate="20190606T143129Z">
        <seg>应用提交及组件交互</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Application submission and component interactions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024603Z" creationid="xccui" creationdate="20190423T024603Z">
        <seg>应用提交及组件交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications are usually connected to external services or face human users and con‐ tinuously process incoming events such as orders, email, or clicks on a website.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T052224Z" creationid="esouser" creationdate="20190603T195414Z">
        <seg>这些应用通常会连接外部服务或实际用户，并持续处理诸如订单、邮件、网站点击等传入的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications can also be individually operated and scaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055838Z" creationid="esouser" creationdate="20190603T214115Z">
        <seg>同时，所有应用都支持独立操作和扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications can be individually operated and scaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T073447Z" creationid="xccui" creationdate="20190308T073358Z">
        <seg>同时，全部应用都支持独立操作和扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications consume the results by merging approximated results from the speed table and the accurate results from the batch table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052646Z" creationid="xccui" creationdate="20190605T052414Z">
        <seg>为了获取最终结果，应用需要将"提速表"中的近似结果以及批处理表中的精确结果合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications consume the results from the Serving Layer by merging the most recent but only approximated results from the speed table and the older but accurate result from the batch table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T045050Z" creationid="xccui" creationdate="20190322T053047Z">
        <seg>应用通过合并"提速表"中的较新的近似结果以及批处理表中较旧的精确结果来从服务层获取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications need to explicitly enable the periodic checkpointing mechanism via the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204732Z" creationid="xccui" creationdate="20190702T204629Z">
        <seg>应用需要像示例7-9中那样，显式地在StreamExecutionEnvironment中启用周期性检查点机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145100Z" creationid="esouser" creationdate="20190603T145053Z">
        <seg>应用转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply streaming transformations to implement the application logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043619Z" creationid="xccui" creationdate="20190612T043619Z">
        <seg>通过一系列流式转换来实现应用逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022606Z" creationid="xccui" creationdate="20190225T022606Z">
        <seg>应用转换操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying Functions on Windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023223Z" creationid="xccui" creationdate="20190225T023223Z">
        <seg>在窗口上应用函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a CoProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031414Z" creationid="xccui" creationdate="20190622T031414Z">
        <seg>应用CoProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a FlatMapFunction with a keyed ValueState</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062303Z" creationid="xccui" creationdate="20190630T062017Z">
        <seg>应用一个带有键值分区ValueState的FlatMapFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a ProcessFunction that emits to a side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022710Z" creationid="xccui" creationdate="20190622T022702Z">
        <seg>利用ProcessFunction将数据发送至副输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a ReduceFunction for incremental aggregation and a ProcessWindowFunction for finalizing the window result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043549Z" creationid="xccui" creationdate="20190625T043549Z">
        <seg>使用ReduceFunction执行增量聚合，使用ProcessWindowFunction计算最终结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a reduce lambda function on a WindowedStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002403Z" creationid="xccui" creationdate="20190624T002403Z">
        <seg>在WindowedStream上应用reduce lambda函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying an AggregateFunction on a WindowedStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005444Z" creationid="xccui" creationdate="20190624T005444Z">
        <seg>在WindowedStream上应用AggregateFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>April 2019:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210727Z" creationid="esouser" creationdate="20190603T210727Z">
        <seg>April 2019:</seg>
      </tuv>
    </tu>
    <tu>
      <note>后面加了一个service</note>
      <tuv lang="EN-US">
        <seg>Architecture and Enabling Queryable State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151548Z" creationid="xccui" creationdate="20190225T025000Z">
        <seg>可查询式状态服务的架构及启用方式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguably, one could use an external system to also manage streaming state, even though this design choice might introduce additional latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T054652Z" creationid="xccui" creationdate="20190414T054541Z">
        <seg>讲道理，虽然可能引入额外延迟，但完全可以同样用一个外部系统来管理流式状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguably, we could use an external system to also manage streaming state, even though this design choice might introduce additional latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182838Z" creationid="xccui" creationdate="20190606T032201Z">
        <seg>按理说，我们也可以使用外部系统来管理流处理过程中的状态，即便这样可能会引入额外延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays, Lists, Maps, Enums, and other special types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T045252Z" creationid="xccui" creationdate="20190617T045252Z">
        <seg>数组、列表、映射、枚举以及其他特殊类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a Windows user you can use the Windows subsystem for Linux (WSL), Cygwin, or a Linux virtual machine to run Flink in a UNIX environ‐ ment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T014711Z" creationid="xccui" creationdate="20190611T014711Z">
        <seg>如果你是Windows用户，可以使用自带的（译者注：Win10版本以上）Linux子系统（WSL）、Cygwin或Linux虚拟机来在类UNIX环境下运行Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a con‐ sequence, an application with default operator identifiers is very limited in how it can be evolved without losing state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T030644Z" creationid="xccui" creationdate="20190610T025637Z">
        <seg>因此使用默认算子标识的应用如果不想丢失状态，那么改动空间比较有限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed before, Flink requires a sufficient amount of processing slots in order to execute all tasks of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205357Z" creationid="xccui" creationdate="20190428T205349Z">
        <seg>如前所述，为了执行应用的全部任务，Flink需要足够数量的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed before, Flink requires a sufficient number of processing slots in order to execute all tasks of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145426Z" creationid="xccui" creationdate="20190606T145426Z">
        <seg>如前所述，为了执行应用的全部任务，Flink需要足够数量的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed before, elements are assigned to windows by</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T031512Z" creationid="xccui" creationdate="20190626T031512Z">
        <seg>如前所述，元素会通过WindowAssigner分配给窗口，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in “A Quick Look at Flink” on page 12, the program generates read events for multiple thermal sensors, converts the temperature of the events from Fahrenheit to Celsius, and computes the average temperature of each sensor every second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053343Z" creationid="xccui" creationdate="20190611T042330Z">
        <seg>我们在第12页"Flink快览"中讲过，这个程序会模拟生成多个热传感器的读数事件，将其中的温度由华氏度改为摄氏度，然后计算每个传感器每秒钟的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in “Checkpoints, Savepoints, and State Recovery” on page 58, a check‐ point is only successful if all operator tasks successfully checkpointed their states to the checkpoint storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T201859Z" creationid="xccui" creationdate="20190702T201740Z">
        <seg>正如第58页"检查点、保存点及状态恢复"中所述，在所有算子任务都成功将其状态写入检查点存储后，整体的检查点才算创建成功。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in “Event-Time Processing” on page 47, your application needs to pro‐ vide two important pieces of information to Flink in order to operate in event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T014946Z" creationid="xccui" creationdate="20190620T014933Z">
        <seg>我们在第47页"事件时间处理"一节中讲到，为了在事件时间模式下工作，应用需要向Flink提供两项重要信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in “Scaling Stateful Operators” on page 56, the list struc‐ ture supports changing the parallelism of functions with operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T054835Z" creationid="xccui" creationdate="20190701T054835Z">
        <seg>其实这个问题的答案已经在第56页"状态化算子扩缩容"中提到了——列表结构支持对使用了算子状态的函数修改并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed, watermarks can be used to balance result completeness and result latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T144503Z" creationid="xingcan" creationdate="20190628T144503Z">
        <seg>如前所述，水位线可用来平衡结果的完整性和延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As explained in “Com‐ ponents of a Flink Setup” on page 38, a Flink application is submitted to the JobMan‐ ager (master), which distributes execution tasks to one or more TaskManagers (workers).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T051138Z" creationid="xccui" creationdate="20190611T051138Z">
        <seg>正如之前第38页"Flink设置组件"中所介绍的，Flink应用会提交至JobManager（master），后者负责将需要执行的任务分配给一个或多个TaskManager（worker）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As for the tuples, we filter the DataStream by age:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041121Z" creationid="xccui" creationdate="20190617T041008Z">
        <seg>和元组的情况一样，我们对DataStream按照年龄进行过滤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As indicated by name, these functions are applicable in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T052024Z" creationid="xccui" creationdate="20190621T051948Z">
        <seg>从名字就能看出，这些函数适用于不同的上下文环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As motivated in &lt;t2/&gt;Chapter 2&lt;t3/&gt;, a certain degree of timestamp out-of-orderness is given in basically all real-world use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040054Z" creationid="xccui" creationdate="20190523T040054Z">
        <seg>正如第2章所述，基本上所有现实世界的应用场景都会出现一定程度的时间戳乱序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As one could imagine, supporting stateful operators comes with a few implementa&lt;t0/&gt;‐&lt;t1/&gt; tion challenges:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T033138Z" creationid="xccui" creationdate="20190414T055834Z">
        <seg>不难想象，支持状态化算子将面临很多实现上的挑战：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As previously stated, stateful stream processing is a versatile and flexible design archi‐ tecture that can be used for many different use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T073635Z" creationid="esouser" creationdate="20190603T211912Z">
        <seg>综上所述，状态化流处理是一类用途广泛、灵活多变的设计模式，它可用来解决很多不同的用例问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As previously stated, stateful streaming processing is a versatile and flexible design pattern and can be used to address many different use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T145813Z" creationid="xccui" creationdate="20190305T145258Z">
        <seg>如上所述，状态化流处理是一种用途广泛、灵活多变的设计模式，可用来解决很多不同的用例问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As seen in “Time Semantics”, a certain degree of timestamp out-of- orderness is given in basically all real-world use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204914Z" creationid="xccui" creationdate="20190606T204903Z">
        <seg>正如"时间语义"一节所述，基本上所有现实世界的应用场景都会出现一定程度的时间戳乱序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in &lt;t3/&gt;Figure 1-8&lt;t4/&gt;, you will see some statistics about the local Flink cluster you just started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035221Z" creationid="xccui" creationdate="20190329T035158Z">
        <seg>如图1-8所示，你会看到一些有关刚刚启动的本地Flink集群的统计信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in &lt;t4/&gt;Figure 2-12&lt;t5/&gt;, in Alice’s case, a processing-time window would continue counting time when her phone gets discon&lt;t6/&gt;‐&lt;t7/&gt; nected, thus not accounting for her game activity during that time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145241Z" creationid="xccui" creationdate="20190412T144815Z">
        <seg>如图2-12所示，在爱丽丝的例子中，处理时间窗口在她手机离线后会继续计时，因此不会把她在那段时间的活动考虑在内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in Figure 1-8, you will see some statistics about the local Flink cluster you just started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123250Z" creationid="xccui" creationdate="20190605T123250Z">
        <seg>如图1-8所示，你会看到一些有关刚刚启动的本地Flink集群的统计信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in Figure 2-12, in Alice’s case, a processing-time window would continue counting time when her phone gets discon‐ nected, thus not accounting for her game activity during that time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155718Z" creationid="xccui" creationdate="20190606T023852Z">
        <seg>如图2-12所示，在爱丽丝的例子中，处理时间窗口在她手机离线后会继续计时，因此不会把她离线那段时间的活动考虑在内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in Figure 3-4, each of the four sender tasks needs at least four network buf‐ fers to send data to each of the receiver tasks and each receiver task requires at least four buffers to receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193121Z" creationid="xccui" creationdate="20190606T200713Z">
        <seg>如图3-4所示，每个发送端任务至少需要4个网络缓冲区来向任一接收端任务发送数据。而同样，每个接收端任务也需要至少4个缓冲区来接收数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as a task has received barriers from all its input partitions, it initiates a check‐ point at the state backend and broadcasts the checkpoint barrier to all of its down‐ stream connected tasks as shown in Figure 3-23.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T192605Z" creationid="xccui" creationdate="20190609T175243Z">
        <seg>如图3-23所示，任务在收齐全部输入分区发送的分隔符后，就会通知状态后端开始生成检查点，同时把检查点分隔符广播到下游相连的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as one parti‐ tion does not advance its watermarks or becomes completely idle and does not ship any records or watermarks, the event-time clock of a task will not advance and the timers of the task will not trigger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190607T032231Z">
        <seg>只要有一个分区的水位线没有前进或分区完全空闲下来不再发送任何记录或水位线，任务的事件时间时钟就不会前进，继而导致计时器无法触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the first event comes in, it will be immediately processed with the minimum latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T205859Z" creationid="xccui" creationdate="20190401T204654Z">
        <seg>当第一个事件到来，系统会立刻以尽可能低的延迟进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the key space evolves, the state of expired keys becomes stale and useless.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T141808Z" creationid="xccui" creationdate="20190704T141808Z">
        <seg>随着键值空间的不断变化，状态中那些过期的键值就会变得陈旧且毫无价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the name suggests, a dataflow program describes how data flows between opera&lt;t0/&gt;‐&lt;t1/&gt; tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T175511Z" creationid="xccui" creationdate="20190329T175404Z">
        <seg>顾名思义，dataflow程序描述了数据如何在操作之间流动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the name suggests, a dataflow program describes how data flows between opera‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T043133Z" creationid="xccui" creationdate="20190605T224746Z">
        <seg>顾名思义，Dataflow程序描述了数据如何在不同操作之间流动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the name suggests, the window join is based on Flink’s windowing mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T034142Z" creationid="xccui" creationdate="20190628T034142Z">
        <seg>顾名思义，基于窗口的Join需要用到Flink中的窗口机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As usual, result records are emitted by passing them to the Collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053914Z" creationid="xccui" creationdate="20190621T053914Z">
        <seg>照例，在其中可以将结果记录传递给Collector发送出去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see in Example 6-13, the ReduceFunction and ProcessWindowFunction are both defined in the reduce() method call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T044915Z" creationid="xccui" creationdate="20190625T044805Z">
        <seg>可以看到，示例6-13在调用reduce()方法时既用到了ReduceFunction也用到了ProcessWindowFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, the Trigger API can be used to implement sophisticated logic by pro‐ viding access to time and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193725Z" creationid="xccui" creationdate="20190626T193725Z">
        <seg>如你所见，Trigger API的时间和状态访问机制允许你用它来实现复杂逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you learned in “Time Semantics”, Flink’s time- based operators can be applied with different notions of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T050236Z" creationid="xccui" creationdate="20190619T050204Z">
        <seg>正如你在"时间语义"一节所学到的，Flink内部基于时间的算子可以在不同的时间概念下使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you learned in “Timestamps” on page 47, time‐ stamps either exist in the data before entering the data processing pipeline, or are assigned by the application at the sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070828Z" creationid="xccui" creationdate="20190619T070828Z">
        <seg>在第47页"时间戳"一节，你了解到了时间戳在数据进入处理管道之前就已经存在其中或者由应用在数据源处分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you might imagine, supporting stateful operators comes with a few implementa‐ tion challenges:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032848Z" creationid="xccui" creationdate="20190606T032848Z">
        <seg>不难想象，支持状态化算子将面临很多实现上的挑战：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you saw in “Data Parallelism and Task Parallelism” on page 18, Flink splits data streams into partitions and processes each partition in parallel by a separate operator task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T014811Z" creationid="xccui" creationdate="20190607T014501Z">
        <seg>正如第18页"数据并行和任务并行"一节所述，Flink会将数据流划分为不同的分区，交由不同的算子任务来并行执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigner with periodic watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045349Z" creationid="xccui" creationdate="20190620T045349Z">
        <seg>周期性水位线分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigner with punctuated watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T053715Z" creationid="xccui" creationdate="20190620T053715Z">
        <seg>定点水位线分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning Timestamps and Generating Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040510Z" creationid="esouser" creationdate="20190603T145731Z">
        <seg>分配时间戳和生成水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning timestamps and generating watermarks in a SourceFunction is discussed in “Source Functions, Timestamps, and Watermarks” on page 204.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T021119Z" creationid="xccui" creationdate="20190620T021059Z">
        <seg>在SourceFunction中分配时间戳和生成水位线将在204页"源函数、时间戳和水位线"一节讨论，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning unique identifiers to operators is mandatory for most application changes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T030857Z" creationid="xccui" creationdate="20190705T030857Z">
        <seg>大多数应用的改动都需要以分配算子唯一标识为前提。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning watermarks periodically means that we instruct the system to emit water‐ marks and advance the event time in fixed intervals of machine time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045615Z" creationid="xccui" creationdate="20190620T045615Z">
        <seg>周期性分配水位线的含义是我们会指示系统以固定的机器时间间隔来发出水位线并推动事件时间前进。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Asynchronous checkpointing significantly reduces the time until a task continues to process data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203815Z" creationid="xccui" creationdate="20190609T203754Z">
        <seg>异步生成检查点可以有效降低任务恢复数据处理所需等待的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Asynchronously Accessing External Systems</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T060014Z" creationid="xccui" creationdate="20190225T025331Z">
        <seg>异步访问外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At high load, this change will also increase through&lt;t2/&gt;‐&lt;t3/&gt; put, because more customers will be served in the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211113Z" creationid="xccui" creationdate="20190402T210925Z">
        <seg>这样在高峰时段，相同时间内可以服务的顾客数量多了，吞吐量也自然会提高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At high load, this change will also increase throughput, because more customers will be served in the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054612Z" creationid="xccui" creationdate="20190605T235407Z">
        <seg>这样在高峰时段，相同时间内可以服务的顾客数量多了，吞吐量自然也会提高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the book’s GitHub page, you will find one repository with Scala examples and one repository with Java exam‐ ples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T035852Z" creationid="xccui" creationdate="20190611T035708Z">
        <seg>在书籍的GitHub页面上，你会看到两个分别包含Scala示例和Java示例的代码仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the same time, long-running applications need to be maintained.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T212353Z" creationid="xccui" creationdate="20190702T212353Z">
        <seg>同时，我们也需要对长时间运行的应用进行一些维护，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the same time, the result completeness might suffer because relevant records might not be included in the result and would be considered as late records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040404Z" creationid="xccui" creationdate="20190529T040337Z">
        <seg>但同时结果的完整性可能受到影响，因为会有部分相关记录被视为迟到记录，没能参与运算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the source: Timestamps and watermarks can be assigned and generated by a SourceFunction when a stream is ingested into an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034107Z" creationid="xccui" creationdate="20190607T034006Z">
        <seg>在数据源完成：可以利用SourceFunction在应用读入数据流的时候分配时间戳和生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point the system has reached the peak throughput and further increasing the event rate will only result in worse latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T201509Z" creationid="xccui" creationdate="20190402T201054Z">
        <seg>此时系统吞吐已到极限，一味提高事件到达速率只会让延迟更糟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, it should be clear that latency and throughput are not independent met‐ rics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053804Z" creationid="xccui" creationdate="20190605T234918Z">
        <seg>至此你应该已经清楚，延迟和吞吐并非相互独立的指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, it should be quite clear that latency and throughput are not independ&lt;t0/&gt;‐&lt;t1/&gt; ent metrics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T203113Z" creationid="xccui" creationdate="20190402T203103Z">
        <seg>至此你应该很清楚，延迟和吞吐并非相互独立的指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, the system has reached its peak throughput and further increasing the event rate will only result in worse latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234736Z" creationid="xccui" creationdate="20190605T234736Z">
        <seg>此时系统吞吐已到极限，一味提高事件到达速率只会让延迟更糟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, you might be wondering why we would even bother with processing time if event time solves all of our problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180343Z" creationid="xccui" creationdate="20190606T030452Z">
        <seg>此刻你可能会有些疑惑：既然事件时间能够解决所有问题，为何还要去操心处理时间？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, you might be wondering: &lt;t0/&gt;Since event time solves all of our problems, why&lt;t1/&gt; &lt;t2/&gt;even bother considering processing time?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T040412Z" creationid="xccui" creationdate="20190414T040247Z">
        <seg>此刻你可能会有些疑惑：既然事件时间能够解决所有问题，为什么还去费劲地考虑处理时间呢？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-Least-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050818Z" creationid="xccui" creationdate="20190415T050818Z">
        <seg>至少一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-Most-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050811Z" creationid="xccui" creationdate="20190415T050757Z">
        <seg>至多一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-least-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034515Z" creationid="xccui" creationdate="20190606T034515Z">
        <seg>至少一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-most-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034320Z" creationid="xccui" creationdate="20190606T034320Z">
        <seg>至多一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-most-once is the trivial case that guarantees processing of each event at most once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T192042Z" creationid="xccui" creationdate="20190606T034341Z">
        <seg>至多一次是一种最简单的情况，它保证每个事件至多被处理一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At-most-once is the trivial case that guarantees processing of each event at-most-once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T184428Z" creationid="xccui" creationdate="20190415T184345Z">
        <seg>至多一次也是最简单的情况，它保证每个事件至多被处理一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Average values hide the true distribution of processing delays and might make it hard to detect problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051114Z" creationid="xccui" creationdate="20190401T155435Z">
        <seg>平均值会掩盖处理延迟的真实分布，从而导致难以发现问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avro-generated classes are automatically identified by Flink and handled as POJOs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T045142Z" creationid="xccui" creationdate="20190617T045142Z">
        <seg>Flink还会将Avro自动生成的类识别为POJO进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Based on the key, the events of the stream are assigned to partitions, so that all</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050345Z" creationid="xccui" creationdate="20190614T050345Z">
        <seg>根据键值，流中的事件会被分配到不同分区，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Based on the received watermarks, the operator computes a point in time up to which it expects to have received relevant input records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031819Z" creationid="xccui" creationdate="20190621T031242Z">
        <seg>根据收到的水位线，算子会计算一个所有相关输入记录都已接收完毕的预期时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022712Z" creationid="xccui" creationdate="20190225T022712Z">
        <seg>基本转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic transformations are transformations on individual events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T065149Z" creationid="xccui" creationdate="20190613T024209Z">
        <seg>基本转换是作用于单条事件的转换；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic transformations process individual events, meaning that each output record was produced from a single input record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T025056Z" creationid="xccui" creationdate="20190613T024932Z">
        <seg>基本转换用于单独处理每个事件，也就是说每条输出记录都是由单条输入记录所生成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Batch applications can - in addition to pipelined communication - exchange data by collecting outgoing data at the sender.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045346Z" creationid="xccui" creationdate="20190504T045346Z">
        <seg>批处理应用除了流水线式通信，还可以在发送端收集全部需要发出的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Batch applications can—in addition to pipelined communication—exchange data by collecting outgoing data at the sender.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193021Z" creationid="xccui" creationdate="20190606T200625Z">
        <seg>批处理应用除了流水线式通信之外，还可以在发送端收集需要发出的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200742Z" creationid="esouser" creationdate="20190603T200742Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because efficient state access is crucial to processing records with low latency, each parallel task locally maintains its state to ensure fast state accesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051223Z" creationid="xccui" creationdate="20190608T051037Z">
        <seg>因此高效的状态访问对于记录处理的低延迟而言至关重要。为了保证快速访问状态，每个并行任务都会把状态维护在本地。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it writes data to disk and supports incremental checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T024204Z" creationid="xccui" creationdate="20190704T024204Z">
        <seg>因为它能够将数据写入磁盘，且支持增量检查点（详见第58页"检查点、保存点及状态恢复"一节），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because local state can be maintained and checkpointed in different ways, state backends are pluggable—two applications can use different state backend implementations to maintain their states.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221421Z" creationid="xccui" creationdate="20190703T214504Z">
        <seg>由于本地状态的维护及写入检查点的方式多种多样，所以状态后端被设计为可插拔的（pluggable）——两个应用可以选用不同的状态后端实现来维护其状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because microservices are strictly decoupled from each other and only communicate over well defined inter&lt;t4/&gt;‐&lt;t5/&gt; faces, each microservice can be implemented with a custom technology stack includ&lt;t6/&gt;‐&lt;t7/&gt; ing programming language, libraries, and data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172603Z" creationid="xccui" creationdate="20190227T234310Z">
        <seg>由于微服务彼此间严格解耦且仅通过定义良好的接口通信，因此每个微服务可以选用不同的技术栈，即编程语言、类库和数据存储等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the choice of the timestamp is application-specific and the watermarks depend on the timestamps and characteris‐ tics of the stream, applications have to explicitly assign timestamps and generate watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033908Z" creationid="xccui" creationdate="20190607T033908Z">
        <seg>由于不同的应用会选择不同的时间戳，而水位线依赖于时间戳和数据流本身的特征，应用必须显式地分配时间戳和生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this strategy replicates data and involves network communication, it is fairly expensive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233449Z" creationid="xccui" creationdate="20190401T135000Z">
        <seg>该策略会把数据复制多份且涉及网络通信，因此代价十分昂贵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before comparing the temperature measurements and updating the last temperature,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T212613Z" creationid="xccui" creationdate="20190704T211924Z">
        <seg>在对温度值进行比较并更新最近一次温度之前，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before execution, these are translated into physical dataflow graphs of connected parallel tasks, each running some operator logic, consuming input streams and producing output streams for other tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185357Z" creationid="xccui" creationdate="20190606T033145Z">
        <seg>在实际执行前，它们需要被翻译成物理Dataflow图，其中会包含很多相连的并行任务。每个任务都要运行一部分算子逻辑，消费输入流并为其他任务生成输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before execution, these are translated into physical dataflow graphs of many connected parallel tasks, each running some operator logic, consuming input streams and producing output streams for other tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T041429Z" creationid="xccui" creationdate="20190415T041131Z">
        <seg>在执行之前，他们需要被翻译为连接很多并行任务的物理dataflow图。其中每个任务都要运行一部分算子逻辑，消费输入流并为其他任务生成输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before the rise of modern stream processors, a common approach to process unbounded data was to repeatedly schedule jobs over small batches of incoming events on a batch processing system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182116Z" creationid="xccui" creationdate="20190606T031812Z">
        <seg>在现代流处理引擎兴起之前，处理无限数据的通用办法是将到来事件分成小批次，然后不停地在批处理系统上调度并运行作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we delve into the fundamentals of stream processing, let’s look at the back‐ ground on dataflow programming and the terminology we will use throughout this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T043338Z" creationid="xccui" creationdate="20190605T224735Z">
        <seg>在深入探索流处理的基础知识之前，我们需要先介绍Dataflow编程的必要背景，并建立起贯穿整书的术语体系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we delve into the fundamentals of stream processing, we must first introduce the necessary background on &lt;t0/&gt;dataflow&lt;t1/&gt; programming and establish the terminology that we will use throughout this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T175319Z" creationid="xccui" creationdate="20190329T054324Z">
        <seg>在深入研究流处理的基本知识之前，我们需要先介绍dataflow编程的必要背景，建立起贯穿整书的术语体系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we describe the different types of guarantees, we need to clarify a few points that are often the source of confusion when discussing task failures in stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044835Z" creationid="xccui" creationdate="20190415T044718Z">
        <seg>在讨论不同类型的保障之前，我们需要澄清一些在讨论流处理引擎任务故障时容易导致困惑的点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we describe the different types of guarantees, we need to clarify a few points that are often the source of confusion when discussing task failures in stream pro‐ cessors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034159Z" creationid="xccui" creationdate="20190606T034159Z">
        <seg>在讨论不同类型的保障之前，我们需要澄清一些在讨论流处理引擎任务故障时容易导致困惑的点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we discuss its use cases, we briefly explain how stateful stream process&lt;t2/&gt;‐&lt;t3/&gt; ing works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T203558Z" creationid="xccui" creationdate="20190301T203506Z">
        <seg>在讨论这些用例之前，我们首先简要解释一下状态化流处理的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before we discuss its use cases, we briefly explain how stateful stream processing works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T030447Z" creationid="esouser" creationdate="20190603T205531Z">
        <seg>在讨论这些场景之前，我们首先简要解释一下状态化流处理的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beijing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210636Z" creationid="esouser" creationdate="20190603T210636Z">
        <seg>Beijing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the much shorter time needed for an event to be incorporated into an analyt‐ ics result, there is another, less obvious, advantage of streaming analytics applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155621Z" creationid="xccui" creationdate="20190605T044658Z">
        <seg>除了将事件整合到分析结果的用时更短，流式分析应用还有另一个不太明显的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the much smaller time for an event to be incorporated into an analytics result, there is another, less obvious, advantage of streaming analytics applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062434Z" creationid="xccui" creationdate="20190317T062251Z">
        <seg>除了将事件整合到分析结果用时较短，流式分析应用还有另一个不太显眼的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides watermarks, Flink has many features to tweak the exact behavior of time-based oper‐ ations, such as process functions and window triggers, and offers different ways to handle late data, which are discussed in “Handling Late Data” on page 148.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T043032Z" creationid="xccui" creationdate="20190621T042913Z">
        <seg>除了水位线，Flink还有很多功能可用于调整那些时间相关操作（例如：处理函数和窗口触发器）的具体行为。此外，它还提供了不同的方法来处理迟到数据，相关内容会在148页"处理迟到数据"一节进行讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Black squares are duplicated, and gray squares are filtered out.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054533Z" creationid="xccui" creationdate="20190613T054410Z">
        <seg>如果是黑色方块会将其复制；如果是灰色方块会将其过滤掉。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bob and Alice play the same game but have different mobile pro‐ viders.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160457Z" creationid="xccui" creationdate="20190606T024443Z">
        <seg>虽然玩的游戏相同，但鲍勃和爱丽丝的移动网络供应商不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bob and Alice play the same game but they have different mobile providers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T152216Z" creationid="xccui" creationdate="20190412T152216Z">
        <seg>鲍勃和爱丽丝虽然玩的游戏相同，但他们的移动网络供应商不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bootstrap a Flink Maven Project</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004254Z" creationid="esouser" creationdate="20190603T145025Z">
        <seg>创建Flink Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bootstrap a Flink Maven project</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022358Z" creationid="xccui" creationdate="20190225T022358Z">
        <seg>启用Flink Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boston</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210638Z" creationid="esouser" creationdate="20190603T210638Z">
        <seg>Boston</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both aspects are discussed in later sections of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T185654Z" creationid="xccui" creationdate="20190607T185654Z">
        <seg>我们同样会在本章稍后讨论它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both context objects offer a method getBroad castState(MapStateDescriptor) that provides access to a broadcast state handle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T051303Z" creationid="xccui" creationdate="20190702T051303Z">
        <seg>虽然两个上下文对象都提供了getBroadcastState(MapStateDescriptor)方法来获得广播状态句柄，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both functions are typed on the types of the first and second input stream and on the type of the output stream and define two methods—one for each input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T041643Z" creationid="xccui" creationdate="20190615T041305Z">
        <seg>两个函数的类型都是两条输入流的类型再加上数据流的类型，它们同时为两条输入流定义了各自的处理方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both input streams are keyed on their key attributes and the common window assigner maps events of both streams to common windows, meaning a window stores</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T052627Z" creationid="xccui" creationdate="20190628T052614Z">
        <seg>两条的输入流都会根据各自的键值属性进行分区，公共窗口分配器会将二者的事件映射到公共窗口（其中同时存储了两条流中数据）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both kinds of queries are executed by a data warehouse in a batch processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194232Z" creationid="xccui" creationdate="20190228T194049Z">
        <seg>无论哪一类查询，都是在数据仓库中以批处理的方式执行，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both kinds of queries are executed by a data warehouse in a batch processing fashion, as shown in Figure 1-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203619Z" creationid="esouser" creationdate="20190603T203548Z">
        <seg>如图1-3所示，无论哪一类查询，都是在数据仓库中以批处理的方式执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both methods are called with an Iterable that serves all elements that were added to the window, the number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203311Z" creationid="xccui" creationdate="20190627T202634Z">
        <seg>它们的参数都是一个针对窗口内已有元素的Iterable对象、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both were covered in Chapter 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T204316Z" creationid="xccui" creationdate="20190704T204316Z">
        <seg>我们已经在第6章对它们进行了介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184737Z" creationid="xccui" creationdate="20190607T184737Z">
        <seg>广播状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast state can be combined with a regular DataStream or KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T203704Z" creationid="xccui" creationdate="20190701T203650Z">
        <seg>它可以和常规的DataStream或KeyedStream结合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcast state is an improved version of the broadcast()- connect() transformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T052518Z" creationid="xccui" creationdate="20190615T052518Z">
        <seg>广播状态是broadcast()-connect()转换的一个改进版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BroadcastProcessFunc tion does not expose a timer service to register timers and consequently does not offer an onTimer() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T053727Z" creationid="xccui" creationdate="20190702T053727Z">
        <seg>BroadcastProcessFunction没有提供用于注册计时器的时间服务，因此也就没有onTimer()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BroadcastProcessFunction and KeyedBroadcastProcessFunction differ from a regular CoProcessFunction because the element processing methods are not sym‐ metric.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T045838Z" creationid="xccui" creationdate="20190702T045716Z">
        <seg>BroadcastProcessFunction和KeyedBroadcastProcessFunction与常规CoProcessFunction不同，它们针对两条流内元素的处理方法是非对称的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BroadcastStream must be put as an argument in the connect() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040905Z" creationid="xccui" creationdate="20190702T040905Z">
        <seg>BroadcastStream必须以参数形式传给connect()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Broadcasted Events Might Not Arrive in Deterministic Order</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T055306Z" creationid="xccui" creationdate="20190702T055306Z">
        <seg>广播事件的到达顺序可能不固定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffering is a mandatory technique to fully utilize the bandwidth of network connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T210224Z" creationid="esouser" creationdate="20190513T210224Z">
        <seg>若想充分利用网络连接带宽，缓冲是一项必要技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffering is needed to fully utilize the bandwidth of network connec‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194605Z" creationid="xccui" creationdate="20190606T202532Z">
        <seg>若想充分利用网络连接带宽，就需要对数据进行缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffers that need to be sent to the other TaskManager are multiplexed over the same network connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T201324Z" creationid="xccui" creationdate="20190606T200905Z">
        <seg>所有需要向对方TaskManager传输数据的缓冲区会复用同一个网络连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffers which need to be sent to the other Task&lt;t0/&gt;‐&lt;t1/&gt; Manager are multiplexed over the same network connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044411Z" creationid="xccui" creationdate="20190504T044411Z">
        <seg>需要发往同一个TaskManager的缓冲区数据会复用同一个网络连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bugs need to be fixed, functionality adjusted, added, or removed, or the parallelism of the operator needs to be adjusted to account for higher or lower data rates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T212532Z" creationid="xccui" creationdate="20190702T212532Z">
        <seg>例如，修复Bug，添加、删除或调整功能，或者针对不同的数据到来速率调整算子的并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Building a so-called fat JAR file is the preferred way to handle application dependen‐ cies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T042139Z" creationid="xccui" creationdate="20190619T042139Z">
        <seg>我们推荐使用构建所谓胖JAR的方式来处理应用依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-in Window Assigners</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023153Z" creationid="xccui" creationdate="20190225T023153Z">
        <seg>内置窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bundle all dependencies into the application JAR file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041343Z" creationid="xccui" creationdate="20190619T041343Z">
        <seg>将所有依赖打进应用的JAR包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bundling and Deploying Applications in Containers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025949Z" creationid="xccui" creationdate="20190225T025949Z">
        <seg>在容器中打包并部署应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But first, let’s define the term data stream: a data stream is a potentially unbounded sequence of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045638Z" creationid="xccui" creationdate="20190605T233637Z">
        <seg>在此之前我们先给出数据流的定义：数据流是一个可能无限的事件序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But first, we define the term &lt;t0/&gt;data stream&lt;t1/&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142649Z" creationid="xccui" creationdate="20190401T142637Z">
        <seg>在此之前需要先定义数据流：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But in practice you might want to partition a stream into multiple logical streams and define parallel windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013841Z" creationid="xccui" creationdate="20190606T013841Z">
        <seg>但在实际应用中，你可能会想将数据流划分为多条逻辑流并定义一些并行窗口（parallel window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But it differs from regular list state in how it is restored in the case of a failure or when an application is started from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184651Z" creationid="xccui" creationdate="20190607T184610Z">
        <seg>但在进行故障恢复或从某个保存点启动应用时，状态的恢复方式和普通列表状态有所不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But there are much more time-critical applications whose semantics we need to guarantee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155411Z" creationid="xccui" creationdate="20190411T154442Z">
        <seg>但其实还有更多时间敏感应用，需要我们对其处理语义进行保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By computing results only based on the actual data, these systems are also able to process historical data in the same way as “live” data, i.e., data which is inges&lt;t0/&gt;‐&lt;t1/&gt; ted as soon as it is produced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T134332Z" creationid="xccui" creationdate="20190327T051803Z">
        <seg>由于只需依靠实际数据本身计算结果，此类系统可以将历史数据当做"实时"数据进行处理，如同它们一产生就传入系统一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By configuring only a single slot per TaskManager, you can isolate applications across TaskManagers, i.e., run only tasks of a single application on a TaskManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063739Z" creationid="xccui" creationdate="20190424T063555Z">
        <seg>通过将每个TaskManager配置成只有一个处理槽，可以将应用在TaskManager级别进行隔离，即每个TaskManager只运行单个应用的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By configuring only a single slot per TaskManager, you can isolate applications across TaskManagers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071718Z" creationid="xccui" creationdate="20190606T144935Z">
        <seg>如果将每个TaskManager配置成只有一个处理槽，则可以限制应用在TaskManager级别进行隔离，即每个TaskManager只运行单个应用的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Flink assigns unique operator identifiers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T023152Z" creationid="xccui" creationdate="20190609T220319Z">
        <seg>默认情况下，Flink会给每个算子分配一个唯一标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Flink will not start applications that do not restore all states that are con‐ tained in a savepoint to avoid losing the state in the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043338Z" creationid="xccui" creationdate="20190705T043338Z">
        <seg>为了避免保存点中的状态丢失，Flink在默认情况下不会启动那些无法将保存点中的状态全部恢复的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T064253Z" creationid="xccui" creationdate="20190621T064253Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, connect() does not establish a relationship</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045619Z" creationid="xccui" creationdate="20190615T045619Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, only the core API dependencies (DataStream and DataSet APIs) are loaded by a Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035728Z" creationid="xccui" creationdate="20190619T035618Z">
        <seg>默认情况下，Flink集群只会加载核心API依赖（DataStream和DataSet API），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the parallelism of all operators of an application is set as the parallelism of the application’s execution environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051647Z" creationid="xccui" creationdate="20190616T051647Z">
        <seg>默认情况下，应用内所有算子的并行度都会设置为应用执行环境的并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, tumbling windows are aligned to the epoch time, 1970-01-01-00:00:00.000.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T053903Z" creationid="xccui" creationdate="20190623T053903Z">
        <seg>默认情况下，滚动窗口会和纪元时间1970-01-01-00:00:00.000对齐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By injecting the barrier into its output stream, the source function defines the stream position on which the checkpoint is taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T154906Z" creationid="xccui" creationdate="20190609T154731Z">
        <seg>通过向输出流中注入分隔符，数据源函数定义了需要在流中哪些位置生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By lever&lt;t0/&gt;‐&lt;t1/&gt; aging thread-parallelism inside of a TaskManager and the option to deploy several TaskManager processes per host, Flink offers a lot of flexibility to trade off perfor&lt;t2/&gt;‐&lt;t3/&gt; mance and resource isolation when deploying applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T064328Z" creationid="xccui" creationdate="20190424T063958Z">
        <seg>通过在TaskManager内部采用线程并行以及支持在每个主机上部署多个TaskManager进程，Flink为部署应用时性能和资源隔离的取舍提供了极大的自由度，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By leveraging thread parallelism inside a TaskManager and deploying several TaskMan‐ ager processes per host, Flink offers a lot of flexibility to trade off performance and resource isolation when deploying applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071701Z" creationid="xccui" creationdate="20190606T145021Z">
        <seg>通过在TaskManager内部采用线程并行以及在每个主机上部署多个TaskManager进程，Flink为部署应用时性能和资源隔离的取舍提供了极大的自由度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By only computing results based on actual data, these systems are also able to process historical data in the same way as “live” data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T194411Z" creationid="xccui" creationdate="20190605T053408Z">
        <seg>由于只需依靠实际数据计算结果，此类系统可以将历史数据当做"实时"数据进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By processing several streams in parallel, you can lower the latency while processing more events at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T212443Z" creationid="xccui" creationdate="20190402T212226Z">
        <seg>通过并行处理多条数据流，你可以在处理更多事件的同时降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By processing several streams in parallel, you lower the latency while processing more events at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235732Z" creationid="xccui" creationdate="20190605T235730Z">
        <seg>通过并行处理多条数据流，可以在处理更多事件的同时降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By providing a list of state objects, functions with operator state can implement this logic using the snapshotState() and restoreState() methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T060350Z" creationid="xccui" creationdate="20190701T060050Z">
        <seg>而通过提供状态对象列表，有状态函数就能使用snapshotState()和restoreState()方法来实现自动化逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By relying on event time, we can guarantee result correctness even in cases of out-of- order data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025039Z" creationid="xccui" creationdate="20190606T024500Z">
        <seg>依靠事件时间，我们可以保证在数据乱序的情况下结果依然正确，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By relying on event time, we can guarantee result correctness even in such cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T154750Z" creationid="xccui" creationdate="20190412T154249Z">
        <seg>依靠事件时间，我们可以保证上述情况中结果正确，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By resetting the state of a (possibly modified) application and replaying the input, it is possible to fix a bug of the applica&lt;t2/&gt;‐&lt;t3/&gt; tion and repair its effects, deploy new versions of an application without losing its state, or run what-if or A/B tests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T063011Z" creationid="xccui" creationdate="20190312T215231Z">
        <seg>通过重置（变更后）应用的状态并重放输入，可以修复应用bug或消除影响，在不丢失状态的情况下部署新版本，进行假设验证或A/B测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191706Z" creationid="xccui" creationdate="20190225T191706Z">
        <seg>第1章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053436Z" creationid="xccui" creationdate="20190329T045754Z">
        <seg>第2章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053535Z" creationid="xccui" creationdate="20190416T053535Z">
        <seg>第3章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 4</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T042834Z" creationid="xccui" creationdate="20190606T042834Z">
        <seg>第4章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 5</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014844Z" creationid="xccui" creationdate="20190612T014822Z">
        <seg>第5章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 6</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045924Z" creationid="xccui" creationdate="20190619T045924Z">
        <seg>第6章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CHAPTER 7</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042404Z" creationid="xccui" creationdate="20190629T042404Z">
        <seg>第7章</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CONTINUE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184358Z" creationid="xccui" creationdate="20190626T184358Z">
        <seg>CONTINUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CPU</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025545Z" creationid="xccui" creationdate="20190225T025545Z">
        <seg>CPU</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Called after windowing function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201923Z" creationid="xccui" creationdate="20190627T201923Z">
        <seg>在窗口函数之后调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Called before windowing function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201901Z" creationid="xccui" creationdate="20190627T201901Z">
        <seg>在窗口函数之前调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Case class fields are accessed by name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040708Z" creationid="xccui" creationdate="20190617T040708Z">
        <seg>样例类的字段可以按名称访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chained task execution with fused function in a single thread and data pass&lt;t0/&gt;‐&lt;t1/&gt; ing via method calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153822Z" creationid="esouser" creationdate="20190514T153152Z">
        <seg>在结合多个函数的链接任务执行过程中，数据通过方法调用传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chained task execution with fused functions in a single thread and data passing via method calls</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T201402Z" creationid="xccui" creationdate="20190606T203806Z">
        <seg>单线程执行的链接任务"融合"了多个函数，并通过方法调用进行数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the Input Data Type of Built-in Stateful Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T041125Z" creationid="xccui" creationdate="20190705T041125Z">
        <seg>改变内置状态化算子的输入数据类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 1 gives an overview of stateful stream processing, data processing appli‐ cation architectures, application designs, and the benefits of stream processing over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T061459Z" creationid="esouser" creationdate="20190603T155541Z">
        <seg>第1章是概述，我们在其中概括了状态化流处理、数据处理应用的架构和设计以及流处理和传统方法相比的优势所在，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 1 is an overview of stateful stream processing, data processing application architectures, application designs, and benefits over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T165303Z" creationid="xccui" creationdate="20190225T163756Z">
        <seg>第1章是概览，我们在其中回顾了状态化流处理、数据处理应用的架构和设计以及和传统方法相比的优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 covers operation, monitoring, and maintenance of streaming applications that run 24/7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T170937Z" creationid="xccui" creationdate="20190225T170900Z">
        <seg>第10章涵盖了针对7*24小时运行的流处理任务的操作、监控和运维等内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 covers operation, monitoring, and maintenance of streaming applica‐ tions that run 24/7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T143453Z" creationid="esouser" creationdate="20190603T162607Z">
        <seg>第10章涵盖了针对7×24小时运行的流处理应用的操作、监控和运维等内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 describes how to trigger and dispose savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211146Z" creationid="xccui" creationdate="20190609T211058Z">
        <seg>第10章介绍了如何触发生成和销毁保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 explains how to take savepoints of running applications and how to start a new application from an existing savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T031041Z" creationid="xccui" creationdate="20190705T031041Z">
        <seg>第10章介绍了如何为运行中的应用创建保存点以及如何从现有的保存点启动一个新的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 gives guidance on how to operate stateful applications—taking and restoring from application savepoints, rescaling applications, and performing application upgrades.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="xccui" creationdate="20190630T033104Z">
        <seg>第10章指导你如何操纵状态化应用，具体包括创建和恢复应用保存点，对应用进行扩缩容以及应用更新等内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 10 will discuss how the DataStream API allows to control the assignment and grouping of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210039Z" creationid="xccui" creationdate="20190428T210014Z">
        <seg>在第10章会讨论如何通过DataStream API控制任务分配及分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 1: Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172807Z" creationid="xccui" creationdate="20190228T172807Z">
        <seg>第1章：状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2 discussed important concepts of distributed stream processing, such as parallelization, time, and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T042610Z" creationid="xccui" creationdate="20190606T135925Z">
        <seg>我们在第2章主要讨论了分布式流处理中的一些重要概念，例如：并行、时间和状态等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2 discusses fundamental concepts and challenges of stream processing and its content is rather independent of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T165317Z" creationid="xccui" creationdate="20190225T164744Z">
        <seg>第2章主要讨论流处理的基本概念和挑战，这些内容都是独立于Flink而存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2 discusses the fundamental concepts and challenges of stream process‐ ing, independent of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T223303Z" creationid="esouser" creationdate="20190603T155834Z">
        <seg>第2章主要讨论流处理的基本概念和挑战，这些内容均是独立于Flink而存在的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2: Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032105Z" creationid="xccui" creationdate="20190401T032105Z">
        <seg>第二章：流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 3 describes Flink’s system architecture and internals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T061520Z" creationid="xccui" creationdate="20190225T164833Z">
        <seg>第3章是描述Flink的系统架构和内部实现，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 3: The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053634Z" creationid="xccui" creationdate="20190416T053630Z">
        <seg>第3章：Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 4 explains how to set up an environment to develop and debug Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T061543Z" creationid="esouser" creationdate="20190603T161023Z">
        <seg>第4章讲解如何配置用于开发和调试Flink应用的环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 5 introduces you to the basics of the Flink’s DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031541Z" creationid="esouser" creationdate="20190603T161252Z">
        <seg>第5章介绍Flink DataStream API的基础知识，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 5 will introduce you to the basics of the DataStream API, and Chapters 6, 7, and 8 will introduce everything you need to know about time-based operators, state‐ ful functions, and source and sink connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012744Z" creationid="xccui" creationdate="20190612T011507Z">
        <seg>我们会在第5章介绍DataStream API的基础知识，在第6、7、8章介绍有关基于时间的算子、状态化函数以及数据源（汇）连接器的全部内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 6 discusses the time-based operators of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T061640Z" creationid="esouser" creationdate="20190603T161540Z">
        <seg>第6章讨论DataStream API中基于时间的算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 7 explains how to implement stateful functions and discusses everything around this topic, such as the performance, robustness, and evolution of stateful functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T062553Z" creationid="esouser" creationdate="20190603T162033Z">
        <seg>第7章介绍如何实现有状态函数以及一些与之相关的问题，例如性能、健壮性、状态函数演变等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 8 presents Flink’s most commonly used source and sink connectors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T051434Z" creationid="esouser" creationdate="20190603T162256Z">
        <seg>第8章介绍Flink中最常用的数据源（Data Source）和数据汇（Data Sink）连接器，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 9 discusses how to set up and configure Flink clusters in various environments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162601Z" creationid="esouser" creationdate="20190603T162601Z">
        <seg>第9章讨论如何针对不同环境搭建和配置Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 9 discusses how to setup and configure Flink clusters in various environ&lt;t0/&gt;‐&lt;t1/&gt; ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T170602Z" creationid="xccui" creationdate="20190225T170602Z">
        <seg>第9章讨论如何针对不同环境搭建和配置Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 9 explains how to set up and configure Flink to reliably process stateful applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T032855Z" creationid="xccui" creationdate="20190630T032457Z">
        <seg>第9章介绍了如何设置Flink使其能够可靠地处理状态化应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapters 2 and 3 discussed the foundations of stateful stream processing and related details of Flink’s architecture, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T032617Z" creationid="xccui" creationdate="20190630T032445Z">
        <seg>第2、3两章分别讨论了状态化流处理的基础以及Flink架构的相关细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapters 4 to 8 is where you get our hands dirty and start developing Flink applica&lt;t0/&gt;‐&lt;t1/&gt; tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191540Z" creationid="xccui" creationdate="20190225T165503Z">
        <seg>第4到8章会带你着手开发Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CheckpointedFunction instead of the ListCheckpointed interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063643Z" creationid="xccui" creationdate="20190701T063643Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpointing and State Backends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154914Z" creationid="xccui" creationdate="20190225T025624Z">
        <seg>检查点和状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints are implemented based on barriers that flow with the data and therefore avoid global synchronization across all operators of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163830Z" creationid="xccui" creationdate="20190702T163830Z">
        <seg>检查点是基于和数据一起流动的分隔符来实现的，因此可以避免在应用所有算子间的全局同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints are periodically taken and automatically discarded according to a configurable policy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T205603Z" creationid="xccui" creationdate="20190609T205454Z">
        <seg>检查点会周期性地生成，而且会根据配置的策略自动丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints, Savepoints, and State Recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154749Z" creationid="xccui" creationdate="20190225T022126Z">
        <seg>检查点、保存点及状态恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checkpoints, Savepoints, and State Recovery | 59</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032759Z" creationid="xccui" creationdate="20190610T032759Z">
        <seg>检查点、保存点及状态恢复 | 59</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choosing a State Backend</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T055659Z" creationid="xccui" creationdate="20190225T024742Z">
        <seg>选择状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choosing a State Primitive</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024815Z" creationid="xccui" creationdate="20190225T024815Z">
        <seg>选择状态原语</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CoMapFunction and CoFlatMapFunction as argument respectively.2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T041022Z" creationid="xccui" creationdate="20190615T041022Z">
        <seg>它们分别接收一个CoMapFunction和一个CoFlatMapFunction作为参数。2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CoProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210745Z" creationid="esouser" creationdate="20190603T210745Z">
        <seg>CoProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collections.singletonList(new TimeWindow(startTime, endTime))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044135Z" creationid="xccui" creationdate="20190626T044135Z">
        <seg>Collections.singletonList(new TimeWindow(startTime, endTime))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining events of two streams is a very common requirement in stream process‐ ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T160725Z" creationid="xccui" creationdate="20190613T160725Z">
        <seg>在流处理中，合并两条数据流中的事件是一个非常普遍的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common challenges that distributed systems need to address are allocation and man&lt;t0/&gt;‐&lt;t1/&gt; agement of compute resources in a cluster, process coordination, durable and avail&lt;t2/&gt;‐&lt;t3/&gt; able data storage, and failure recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T031359Z" creationid="xccui" creationdate="20190418T031209Z">
        <seg>分布式系统需要应对的常见挑战包括分配和管理集群计算资源、进程协调、持久化及可用数据存储、故障恢复等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common challenges that distributed systems need to address are allocation and man‐ agement of compute resources in a cluster, process coordination, durable and highly available data storage, and failure recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T044118Z" creationid="xccui" creationdate="20190606T140641Z">
        <seg>分布式系统需要应对的常见挑战包括分配和管理集群计算资源，进程协调，持久且高可用的数据存储及故障恢复等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common choices are IntelliJ IDEA, Eclipse, or Netbeans with the appropriate plugins (such as for Maven, Git, and Scala support).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T030527Z" creationid="xccui" creationdate="20190611T030527Z">
        <seg>常见选项有IntelliJ IDEA、Eclipse或Netbeans，它们都需要相应安装一些插件（例如Maven插件、Git插件以及Scala插件）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Companies employ many different applications to run their business, such as enter&lt;t0/&gt;‐&lt;t1/&gt; prise resource planning (ERP) systems, customer relationship management (CRM) software, or web-based applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T184326Z" creationid="xccui" creationdate="20190226T155328Z">
        <seg>一般公司都会使用很多不同种类的应用来运营业务，例如企业资源规划（ERP）系统、客户关系管理（CRM）软件、基于web的应用等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Companies use all kinds of applications for their day-to-day business activities, such as enterprise resource planning (ERP) systems, customer relationship management (CRM) software, and web-based applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T051250Z" creationid="esouser" creationdate="20190603T194537Z">
        <seg>公司在日常业务运营过程中会用到各类应用，例如企业资源规划（ERP）系统、客户关系管理（CRM）软件、基于web的应用等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compared to field positions and field expressions, an advantage of KeySelector functions is that the resulting key is strongly typed due to the generic types of the KeySelector class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052507Z" creationid="xccui" creationdate="20190618T052507Z">
        <seg>和使用字段位置以及字段表达式相比，KeySelector函数的一大好处是它返回的键值是强类型的，因为KeySelector类需要提供泛型参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Complex data structures can also be stored as value state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T215859Z" creationid="xccui" creationdate="20190607T215731Z">
        <seg>该值也可以是某个复杂数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Components of a Flink Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T215253Z" creationid="xccui" creationdate="20190225T021731Z">
        <seg>搭建Flink所需组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Composite keys consisting of more than one tuple field can also be defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T033803Z" creationid="xccui" creationdate="20190618T033324Z">
        <seg>还可以利用多个元组字段定义复合键值，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computation results can be updated based on late events and updates have to be emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T153102Z" creationid="xingcan" creationdate="20190628T153009Z">
        <seg>可以根据迟到事件更新并发出计算结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compute the average temperature every 5 seconds for a stream of sensors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041632Z" creationid="xccui" creationdate="20190612T041632Z">
        <seg>针对传感器数据流每5秒计算一次平均温度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computing the minimum and maximum temperature per sensor and window using a ProcessWindowFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030617Z" creationid="xccui" creationdate="20190625T030617Z">
        <seg>使用ProcessWindowFunction计算每个传感器在每个窗口内的最低温和最高温。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concep‐ tually, the list entries of all parallel operator tasks are collected and evenly redistrib‐ uted to a smaller or larger number of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060531Z" creationid="xccui" creationdate="20190608T060433Z">
        <seg>理论上，所有并行算子任务的列表项目会被统一收集起来，随后均匀分配到数量改变的任务之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuration parameter is only used by the DataSet API and not by the Data‐ Stream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T061335Z" creationid="xccui" creationdate="20190618T061320Z">
        <seg>注意，Configuration参数只在DataSet API中使用而并没有在DataStream API中用到，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Checkpointing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T213355Z" creationid="xccui" creationdate="20190225T030042Z">
        <seg>配置检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030108Z" creationid="xccui" creationdate="20190225T030108Z">
        <seg>配置故障恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring RocksDBStateBackend for an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025642Z" creationid="xccui" creationdate="20190704T025642Z">
        <seg>为应用配置RocksDBStateBackend</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring State Backends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030054Z" creationid="xccui" creationdate="20190225T030054Z">
        <seg>配置状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Time Characteristics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023020Z" creationid="xccui" creationdate="20190225T023020Z">
        <seg>配置时间特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Time Characteristics | 111</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041858Z" creationid="xccui" creationdate="20190629T041858Z">
        <seg>配置时间特征 | 111</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring the Logging Behavior</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030154Z" creationid="xccui" creationdate="20190225T030154Z">
        <seg>配置日志行为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connect, coMap, and coFlatMap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T065150Z" creationid="xccui" creationdate="20190614T065132Z">
        <seg>Connect，coMap，coFlatMap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connecting a broadcast stream and keyed event stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024304Z" creationid="xccui" creationdate="20190702T024304Z">
        <seg>联结广播流和键值分区事件流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connecting a stateful streaming application running on Flink and an event log is interesting for multiple reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T073449Z" creationid="xccui" creationdate="20190305T060607Z">
        <seg>出于很多原因，将运行在Flink之上的状态化流处理应用和事件日志系统相连会很有意思。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connectors to the most commonly used storage systems such as Apache Kafka, Apache Cassandra, Elasticsearch, JDBC, Kinesis, and (distributed) filesystems such as HDFS and S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T121502Z" creationid="xccui" creationdate="20190605T121502Z">
        <seg>用于最常见存储系统的连接器，如Apache Kafka、Apache Cassandra、Elasticsearch、JDBC、Kinesis以及（分布式）文件系统（HDFS和S3等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, a running application needs to be replaced by an updated version usually without losing the state of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T021139Z" creationid="xccui" creationdate="20190704T214350Z">
        <seg>这往往要求我们在不丢失状态的前提下对当前运行的应用进行版本更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, all records with the same key access the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191837Z" creationid="xccui" creationdate="20190607T191804Z">
        <seg>因此所有键值一样的记录都能访问到相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, most Flink applications do not only depend on Flink’s Data‐ Stream API dependency and the Java SDK but also on additional third-party and Flink-internal dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035413Z" creationid="xccui" creationdate="20190619T035413Z">
        <seg>因此大多数Flink应用不仅需要依赖Flink的DataStream API和Java SDK，还需要额外的第三方库和Flink内部依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, records of both inputs are processed based on the same event-time clock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T030644Z" creationid="xccui" creationdate="20190607T030436Z">
        <seg>这就导致所有输入的记录都必须基于同一个事件时间时钟来处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, the GlobalWindows assigner requires a custom trigger and possibly an evictor to selectively</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044706Z" creationid="xccui" creationdate="20190626T044523Z">
        <seg>因此，GlobalWindows分配器需要一个自定义的触发器，可能还需要一个移除器来选择性地将元素从窗口状态中删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, the processing latencies and state size of time-based opera‐ tors can significantly increase if a task does not receive new watermarks from all input tasks at regular intervals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T032904Z" creationid="xccui" creationdate="20190607T032902Z">
        <seg>因此，如果一个任务没有从全部输入任务以常规间隔接收新的水位线，就会导致时间相关算子的处理延迟或状态大小激增。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, these functions should only be used if the key values are from a constant and bounded domain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T183553Z" creationid="xccui" creationdate="20190704T183511Z">
        <seg>所以说，只有在键值域不变或有界的前提下才能使用这些函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consequently, you should either ensure the value of the broadcast state does not depend on the order in which the broadcasted mes‐ sages are received or ensure the parallelism of the broadcasting operator is set to 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T055655Z" creationid="xccui" creationdate="20190702T055655Z">
        <seg>因此你需要确保广播状态的值不依赖于收到广播消息的顺序，或者将上游广播算子的并行度设置为1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conse‐ quently, GlobalWindows will never be completely cleaned up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044816Z" creationid="xccui" creationdate="20190626T044806Z">
        <seg>因此，它永远不会被彻底清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conse‐ quently, an application can only be operated under exactly-once state consistency if all input streams are consumed by resettable data sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T053412Z" creationid="xccui" creationdate="20190609T050740Z">
        <seg>因此只有所有输入流都是来自于可重置的数据源，应用才支持精确一次的状态一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conse‐ quently, there is no window without at least one element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032952Z" creationid="xccui" creationdate="20190626T032733Z">
        <seg>因此，每个窗口至少会有一个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consid&lt;t0/&gt;‐&lt;t1/&gt; ering that streaming applications might run for several days, months, or even years, you need to make sure that state can be reliably recovered under failures and that your system can guarantee accurate results even if things break.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T205442Z" creationid="xccui" creationdate="20190409T205052Z">
        <seg>考虑到流式应用可能需要成日、甚至长年累月地运行，因此必须保证出错时状态能进行可靠的恢复，即使发生故障系统也能提供准确的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider Bob, another player of the online mobile game, who happens to be on the same train as Alice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160443Z" creationid="xccui" creationdate="20190412T152139Z">
        <seg>假设有另一位名叫鲍勃的玩家也在玩那个在线手游，他恰好和爱丽丝在同一趟地铁上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider a program that analyzes events generated by users playing an online mobile game.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T153748Z" creationid="xccui" creationdate="20190606T014733Z">
        <seg>假设有某个应用程序会分析用户玩在线手游时产生的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider a program that analyzes events generated by users playing online mobile games.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T211520Z" creationid="xccui" creationdate="20190409T211346Z">
        <seg>考虑某程序会分析用户玩在线手游时产生的事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that ana&lt;t3/&gt;‐&lt;t4/&gt; lyzes online user behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025233Z" creationid="xccui" creationdate="20190407T025046Z">
        <seg>假设有一个应用要在线分析用户行为，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that analyzes online user behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013553Z" creationid="xccui" creationdate="20190606T013553Z">
        <seg>假设有一个应用要在线分析用户行为，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that monitors a forest area and outputs an alert when‐ ever there is a high risk of fire.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T035523Z" creationid="xccui" creationdate="20190615T035523Z">
        <seg>假设有一个森林区域监控应用会在火灾发生风险很高时报警。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider an application that provides real-time traffic information to drivers so that they can avoid congested routes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043400Z" creationid="xccui" creationdate="20190406T043152Z">
        <seg>假设有一个应用能向司机提供实时路况信息以帮助他们躲避拥堵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider for example a streaming join opera&lt;t2/&gt;‐&lt;t3/&gt; tion or a holistic aggregate, such as median.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041531Z" creationid="xccui" creationdate="20190406T041221Z">
        <seg>例如：流连接或是像求中位数的整体聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the case where Alice starts popping bubbles while her phone is connected to the network and sends events to the analysis application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151136Z" creationid="xccui" creationdate="20190411T150723Z">
        <seg>因此考虑如下情况：爱丽丝开始消泡泡的时候手机还能联网向分析应用发送事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the case where Alice starts pop‐ ping bubbles while her phone is connected to the network and sends events to the analysis application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154618Z" creationid="xccui" creationdate="20190606T015023Z">
        <seg>因此考虑如下情况：爱丽丝开始消泡泡的时候手机还能联网向分析应用发送事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following case classes:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T045952Z" creationid="xccui" creationdate="20190618T045952Z">
        <seg>考虑以下样例类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following example of keying a stream of Tuple3[Int, Int, Int] on the first field and computing a rolling sum on the second field:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054958Z" creationid="xccui" creationdate="20190614T054424Z">
        <seg>以下示例中，我们对一个Tuple3[Int, Int, Int]类型的数据流按照第1个字段进行键值分区，然后滚动计算第2个字段的总和：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider, for example, a streaming join opera‐ tion or a holistic aggregate, such as the median function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151824Z" creationid="xccui" creationdate="20190606T012013Z">
        <seg>例如：流式Join或者像是求中位数的整体聚合（holistic aggregate）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considering that streaming applications might run for several days, months, or even years, you need to make sure that state can be reliably recovered under failures and that your system can guarantee accurate results even if things break.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064633Z" creationid="xccui" creationdate="20190606T014534Z">
        <seg>考虑到流式应用可能需要整日、甚至长年累月地运行，因此必须保证出错时其状态能进行可靠的恢复，并且即使系统发生故障系统也能提供准确的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Considering the color of the input event as the key, Figure 5-4 assigns black events to one partition and all other events to another partition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051108Z" creationid="xccui" creationdate="20190614T051108Z">
        <seg>我们假设以输入事件的颜色作为键值，在图5-4中会将所有黑色事件分到一个分区，而将其他事件分到另一个分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consistent Checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154728Z" creationid="xccui" creationdate="20190225T022145Z">
        <seg>一致性检查点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant width</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210802Z" creationid="esouser" creationdate="20190603T210802Z">
        <seg>Constant width</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant width italic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210807Z" creationid="esouser" creationdate="20190603T210807Z">
        <seg>Constant width italic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consult “State Management” on page 53 for more details on keyed state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T040059Z">
        <seg>有关键值分区状态的详细信息请参照第53页"状态管理"一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consumers of the log incorporate the updates into the affected data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154237Z" creationid="xccui" creationdate="20190605T040435Z">
        <seg>日志的消费方会将这些更新整合到相关数据存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Context object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T015116Z" creationid="xccui" creationdate="20190622T015116Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controlling Task Chaining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030013Z" creationid="xccui" creationdate="20190225T030013Z">
        <seg>控制任务链接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controlling Task Scheduling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025953Z" creationid="xccui" creationdate="20190225T025953Z">
        <seg>控制任务调度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions Used in This Book</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210758Z" creationid="esouser" creationdate="20190603T210758Z">
        <seg>Conventions Used in This Book</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright 2019 Fabian Hueske and Vasiliki Kalavri, 978-1-491-97429-2.”</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210826Z" creationid="esouser" creationdate="20190603T210826Z">
        <seg>Copyright 2019 Fabian Hueske and Vasiliki Kalavri, 978-1-491-97429-2.”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright © 2019 Fabian Hueske, Vasiliki Kalavri.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210711Z" creationid="esouser" creationdate="20190603T210711Z">
        <seg>Copyright © 2019 Fabian Hueske, Vasiliki Kalavri.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-Based Windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T035233Z" creationid="xccui" creationdate="20190623T035233Z">
        <seg>基于数量的窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-based tumbling window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013112Z" creationid="xccui" creationdate="20190606T013111Z">
        <seg>基于数量的滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-based tumbling window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023544Z" creationid="xccui" creationdate="20190407T023544Z">
        <seg>基于数量的滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Count-based tumbling windows define how many events are collected before triggering evaluation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063415Z" creationid="xccui" creationdate="20190406T051102Z">
        <seg>基于数量的（count-based）滚动窗口定义了在触发计算前需要集齐多少条事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating Type Information for Data Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145213Z" creationid="esouser" creationdate="20190603T145213Z">
        <seg>为数据类型创建类型信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating TypeInformation for data types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022835Z" creationid="xccui" creationdate="20190225T022835Z">
        <seg>为数据类型创建TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-Based Flow Control</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202504Z" creationid="esouser" creationdate="20190603T144321Z">
        <seg>基于信用值的流量控制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-based Flow Control</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T143815Z" creationid="xccui" creationdate="20190225T021817Z">
        <seg>基于信用度的流量控制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-based flow control reduces latency because senders can ship data as soon as the receiver has enough resources to accept it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T195422Z" creationid="xccui" creationdate="20190606T203100Z">
        <seg>由于发送端可以在接收端有足够资源时立即传输数据，所以基于信用值的流量控制可以有效降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Credit-based flow control reduces the latency because senders can ship data as soon as the receiver has enough resources to accept it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T144033Z" creationid="esouser" creationdate="20190514T143810Z">
        <seg>由于发送端可以在接收端有足够资源时立即传输数据，因此基于信用度的流量控制可以降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, Flink offers three state backends, the MemoryStateBackend, the FsState Backend, and the RocksDBStateBackend:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221736Z" creationid="xccui" creationdate="20190703T221736Z">
        <seg>目前Flink提供了三种状态后端：MemoryStateBackend，FsStateBackend以及RocksDBStateBackend：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, Flink provides eight different process functions: ProcessFunction, Keyed ProcessFunction, CoProcessFunction, ProcessJoinFunction, BroadcastProcess Function, KeyedBroadcastProcessFunction, ProcessWindowFunction, and ProcessAllWindowFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T051333Z" creationid="xccui" creationdate="20190621T051333Z">
        <seg>目前，Flink提供了8种不同的处理函数：ProcessFunction、KeyedProcessFunction、CoProcessFunction、ProcessJoinFunction、BroadcastProcessFunction、KeyedBroadcastProcessFunction、ProcessWindowFunction以及ProcessAllWindowFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050033Z" creationid="xccui" creationdate="20190616T050033Z">
        <seg>自定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom window operators are discussed in detail later in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T042043Z" creationid="xccui" creationdate="20190622T042043Z">
        <seg>详细内容会在本节稍后讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom-defined state in a trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T034823Z" creationid="xccui" creationdate="20190626T034823Z">
        <seg>触发器中的自定义状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom-defined trigger state and registered trigger timers are not cleared because this state is opaque to the window operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040724Z" creationid="xccui" creationdate="20190626T040339Z">
        <seg>自定义触发器状态和触发器中注册的计时器将不会被清除，因为这些状态对于窗口算子而言是不可见的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Customizing Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023237Z" creationid="xccui" creationdate="20190225T023237Z">
        <seg>自定义窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051345Z" creationid="xccui" creationdate="20190612T051345Z">
        <seg>Data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data &lt;t0/&gt;ingestion&lt;t1/&gt; is the operation of fetching raw data from exter&lt;t2/&gt;‐&lt;t3/&gt; nal sources and converting it into a format that is suitable for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152000Z" creationid="xccui" creationdate="20190405T152000Z">
        <seg>数据接入操作从外部数据源获取原始数据并将其转换成适合后续处理的格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data &lt;t6/&gt;egress&lt;t7/&gt; is the operation of producing output in a form that is suitable for consumption by external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152354Z" creationid="xccui" creationdate="20190405T152354Z">
        <seg>数据输出操作将数据以适合外部系统使用的格式输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Exchange Strategies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143856Z" creationid="esouser" creationdate="20190603T143856Z">
        <seg>数据交换策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Parallelism and Task Parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054700Z" creationid="esouser" creationdate="20190603T143838Z">
        <seg>数据并行和任务并行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Pipelines</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142926Z" creationid="esouser" creationdate="20190603T142926Z">
        <seg>数据管道</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Pipelines and Real-time ETL</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014644Z" creationid="xccui" creationdate="20190225T014644Z">
        <seg>数据管道和实时ETL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Transfer between TaskManagers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T043826Z" creationid="xccui" creationdate="20190504T043826Z">
        <seg>TaskManager之间的数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Transfer in Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021809Z" creationid="xccui" creationdate="20190225T021809Z">
        <seg>Flink中的数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Transfer in Flink | 45</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032549Z" creationid="xccui" creationdate="20190610T032549Z">
        <seg>Flink中的数据传输 | 45</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data and data processing have been omnipresent in businesses for many decades.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063852Z" creationid="esouser" creationdate="20190603T193512Z">
        <seg>几十年来，数据和数据处理在各类商业领域中无处不在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data arriving to the Lambda architecture is ingested by the stream processor as well as written to a batch storage such as HDFS.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014858Z" creationid="xccui" creationdate="20190322T044236Z">
        <seg>该架构中到来的数据会同时发往流处理引擎和写入批量存储（如：HDFS）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data arriv‐ ing at the lambda architecture is ingested by the stream processor and also written to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T035717Z" creationid="xccui" creationdate="20190605T051850Z">
        <seg>在该架构中，到来的数据会同时发往流处理引擎和写入批量存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data egress is the operation of producing output in a form suitable for consumption by external sys‐ tems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060157Z" creationid="xccui" creationdate="20190606T010152Z">
        <seg>数据输出操作是将数据以适合外部系统使用的格式输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015028Z" creationid="xccui" creationdate="20190225T015028Z">
        <seg>数据交换策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies can be automatically chosen by the execu&lt;t0/&gt;‐&lt;t1/&gt; tion engine depending on the semantics of the operators or explicitly imposed by the dataflow programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034641Z" creationid="xccui" creationdate="20190401T034618Z">
        <seg>这些策略可以由执行引擎根据算子的语义自动选择，也可以由dataflow编码人员显式指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies can be automatically chosen by the execu‐ tion engine depending on the semantics of the operators or explicitly imposed by the dataflow programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233342Z" creationid="xccui" creationdate="20190605T233342Z">
        <seg>这些策略可以由执行引擎根据算子的语义自动选择，也可以由Dataflow编程人员显式指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies define how data items are assigned to tasks in a physical dataflow graph.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044914Z" creationid="xccui" creationdate="20190401T034226Z">
        <seg>数据交换策略定义了如何将数据项分配给物理Dataflow图中的不同任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data exchange strategies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142204Z" creationid="xccui" creationdate="20190401T142204Z">
        <seg>数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data ingestion and data egress</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151752Z" creationid="xccui" creationdate="20190405T151752Z">
        <seg>数据接入和数据输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data ingestion and data egress operations allow the stream processor to communicate with external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151836Z" creationid="xccui" creationdate="20190405T151836Z">
        <seg>数据接入和数据输出操作允许流处理引擎和外部系统进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data ingestion is the operation of fetching raw data from exter‐ nal sources and converting it into a format suitable for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060212Z" creationid="xccui" creationdate="20190606T005219Z">
        <seg>数据接入操作是从外部数据源获取原始数据并将其转换成适合后续处理的格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data parallelism and task parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015011Z" creationid="xccui" creationdate="20190225T015011Z">
        <seg>数据并发度和任务并发度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data parallelism is use&lt;t2/&gt;‐&lt;t3/&gt; ful because it allows for processing large volumes of data and spreading the computa&lt;t4/&gt;‐&lt;t5/&gt; tion load across several computing nodes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T031923Z" creationid="xccui" creationdate="20190401T031116Z">
        <seg>数据并行非常有用，因为它支持处理大规模数据，能够将计算负载分配到多个节点上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data parallelism is use‐ ful because it allows for processing large volumes of data and spreading the computa‐ tion load across several computing nodes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044756Z" creationid="xccui" creationdate="20190605T233252Z">
        <seg>数据并行非常有用，因为它能够将计算负载分配到多个节点上从而允许处理大规模的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data pipelines must be able to process large amounts of data in a short time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T042639Z" creationid="xccui" creationdate="20190605T042639Z">
        <seg>它需要在短时间内处理大批量数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data stream processing is not a novel technology.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045907Z" creationid="xccui" creationdate="20190319T041222Z">
        <seg>数据流处理并非是一项新技术，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data that resides in such storage systems can be queried with and processed by a SQL-on-Hadoop engine, for example Apache Hive, Apache Drill, or Apache Impala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T072705Z" creationid="esouser" creationdate="20190603T203856Z">
        <seg>而它们中的数据也可以通过很多基于Hadoop的SQL引擎（如Apache Hive、Apache Drill或Apache Impala）进行查询和处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data that resides in such storage systems is accessible to several SQL-on-Hadoop engines, as for example Apache Hive, Apache Drill, or Apache Impala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T032911Z" creationid="xccui" creationdate="20190301T032911Z">
        <seg>而它们中的数据也可以通过很多基于Hadoop的SQL引擎（如：Apache Hive、Apache Drill、Apache Impala）进行访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data transfer between TaskManagers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T200559Z" creationid="xccui" creationdate="20190606T200556Z">
        <seg>TaskManager之间的数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream but reorganize it by partitioning or grouping.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052753Z" creationid="xccui" creationdate="20190612T052753Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream&lt;Person&gt; persons = env.fromElements(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044917Z" creationid="xccui" creationdate="20190617T044917Z">
        <seg>DataStream&lt;Person&gt; persons = env.fromElements(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream&lt;Person&gt; persons = tuples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062214Z" creationid="xccui" creationdate="20190617T062214Z">
        <seg>DataStream&lt;Person&gt; persons = tuples</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; tuples = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062211Z" creationid="xccui" creationdate="20190617T062211Z">
        <seg>DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; tuples = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataStream&lt;Tuple3&lt;Integer, String, Long&gt;&gt; javaInput = ... javaInput.keyBy("f2") // key Java tuple by 3rd field</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T043408Z" creationid="xccui" creationdate="20190618T043408Z">
        <seg>DataStream&lt;Tuple3&lt;Integer, String, Long&gt;&gt; javaInput = ... javaInput.keyBy("f2") // Java元组以第3个字段为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow Graphs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143808Z" creationid="esouser" creationdate="20190603T143808Z">
        <seg>Dataflow图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow graphs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015000Z" creationid="xccui" creationdate="20190225T015000Z">
        <seg>Dataflow图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow graphs like the one in Figure 2-1 are called logical because they convey a high-level view of the computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044138Z" creationid="xccui" creationdate="20190605T233042Z">
        <seg>类似图2-1的Dataflow图被称作逻辑图，因为它们表达了高层视角下的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow graphs like the one of &lt;t0/&gt;Figure 2-1&lt;t1/&gt; are called logical because they convey a high-level view of the computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T002544Z" creationid="xccui" creationdate="20190401T001357Z">
        <seg>诸如图2-1之类的dataflow图被称作逻辑图，因为它们描述了高层视角下的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow programs are commonly represented as directed graphs, where nodes are called operators and represent computations and edges represent data dependen&lt;t2/&gt;‐&lt;t3/&gt; cies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190331T214808Z" creationid="xccui" creationdate="20190331T060933Z">
        <seg>dataflow程序通常会表示为有向图。其中节点称为算子（operator），表示计算；而边表示数据间的依赖关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dataflow programs are commonly represented as directed graphs, where nodes are called operators and represent computations and edges represent data dependen‐ cies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044422Z" creationid="xccui" creationdate="20190605T224809Z">
        <seg>Dataflow程序通常会以有向图进行表示。图中顶点称为算子，表示计算；而边表示数据间的依赖关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug Flink Applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144924Z" creationid="esouser" creationdate="20190603T144924Z">
        <seg>在IDE中调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug Flink applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022345Z" creationid="xccui" creationdate="20190225T022345Z">
        <seg>在IDE中调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Keyed State at RuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="esouser" creationdate="20190603T150900Z">
        <seg>在RuntimeContext中声明键值分区状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Keyed State at the RuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024537Z" creationid="xccui" creationdate="20190225T024537Z">
        <seg>在RuntimeContext中声明Keyed State</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Keys and Referencing Fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062314Z" creationid="esouser" creationdate="20190603T145323Z">
        <seg>定义键值和引用字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Keys and Referencing Fields | 103</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045324Z" creationid="xccui" creationdate="20190619T045324Z">
        <seg>定义键值和引用字段 | 103</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Slot Sharing Groups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030021Z" creationid="xccui" creationdate="20190225T030021Z">
        <seg>定义Slot共享组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Slot-Sharing Groups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152401Z" creationid="esouser" creationdate="20190603T152401Z">
        <seg>定义处理槽共享组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023144Z" creationid="xccui" creationdate="20190225T023144Z">
        <seg>定义窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a window operator with a side output for late events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154911Z" creationid="xingcan" creationdate="20190628T154911Z">
        <seg>在窗口算子中为迟到事件定义副输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a window operator with an allowed lateness of 5 seconds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165202Z" creationid="xingcan" creationdate="20190628T165202Z">
        <seg>定义延迟容忍度为5秒的窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining keys and referencing fields</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022905Z" creationid="xccui" creationdate="20190225T022905Z">
        <seg>定义key和引用字段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining the Maximum Parallelism of Keyed State Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190225T024714Z">
        <seg>为使用键值分区状态的算子定义最大并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depend&lt;t0/&gt;‐&lt;t1/&gt; ing on the application, you might care about &lt;t2/&gt;average&lt;t3/&gt; latency, &lt;t4/&gt;maximum&lt;t5/&gt; latency, or &lt;t6/&gt;percentile &lt;t7/&gt;latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T154750Z" creationid="xccui" creationdate="20190401T154546Z">
        <seg>根据应用的不同，你可能会关注平均延迟，最大延迟或延迟的百分位数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dependencies included in the classpath of Flink processes by default are automatically excluded from the JAR file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T043234Z" creationid="xccui" creationdate="20190619T043140Z">
        <seg>默认情况下，JAR包中会自动排除那些Flink进程的classpath中所包含的依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on    the environment (YARN, Mesos, Kubernetes, standalone cluster), some steps can be omitted or components might run in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T062647Z" creationid="xccui" creationdate="20190606T143213Z">
        <seg>根据环境的不同（YARN、Mesos、Kubernetes或独立集群），图中某些步骤其实可以省略，同时也可会有多个组件运行在同一JVM进程中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on how an application is submitted for execution (discussed in the next section), a dispatcher might not be required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024404Z" creationid="xccui" creationdate="20190423T024404Z">
        <seg>根据应用提交执行的方式（会在下节讨论），dispatcher可能并非必需。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on how an application is submitted for execution (dis‐ cussed in “Application Deployment”), a dispatcher might not be required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061935Z" creationid="xccui" creationdate="20190606T142947Z">
        <seg>某些应用提交执行的方式（我们会在"应用部署"一节讨论）可能用不到Dispatcher。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on how an operator is connected with its predecessor or successor operators, its tasks can receive records and water‐ marks from one or more input partitions and emit records and watermarks to one or more output partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T015225Z" creationid="xccui" creationdate="20190607T015151Z">
        <seg>根据算子和它上下游的连接情况，其任务可能同时从多个输入分区接收记录和水位线，也可能需要将它们发送到多个输出分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the application requirements, you might want to ignore such events, log them, or use them to correct previous results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T040224Z" creationid="xccui" creationdate="20190414T032650Z">
        <seg>根据应用需求的不同，你可能想直接忽略那些事件，将它们写入日志或利用它们去修正之前的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the business logic, an event-driven application can trigger actions such as sending an alert or an email or write events to an outgoing event stream that is possibly consumed by another event-driven application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T024745Z" creationid="xccui" creationdate="20190307T024745Z">
        <seg>根据业务逻辑的不同，此类应用可能触发告警或发送电子邮件之类的操作，也支持将事件写入输出流以供其他同类应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the business logic, an event-driven application can trigger actions such as sending an alert or an email or write events to an outgoing event stream to be consumed by another event-driven application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T033752Z" creationid="esouser" creationdate="20190603T213520Z">
        <seg>根据业务逻辑的不同，此类应用可支持触发警报或发送电子邮件之类的操作，也可支持将事件写入输出流以供其他同类应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the business requirements, late data can later be integrated into the results of the streaming application with a periodic backfill process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154732Z" creationid="xingcan" creationdate="20190628T154732Z">
        <seg>根据业务需求，迟到数据可通过定期回填过程（backfill process）集成到流式应用的结果中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the scheduling intervals it may take hours or days until a data point is included in a report.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T031535Z" creationid="xccui" creationdate="20190317T031535Z">
        <seg>根据调度周期的不同，数据可能会在数小时或数天后才出现在报告中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the sink operators of an application, some result records might be emitted multiple times to downstream sys‐ tems, such as an event log, a filesystem, or a database, during the recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054005Z" creationid="xccui" creationdate="20190609T053722Z">
        <seg>根据应用所采用的数据汇算子，在恢复期间，某些结果记录可能会向下游系统（如事件日志系统、文件系统或数据库）发送多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the the environment (YARN, Mesos, Kubernetes, stand-alone cluster), some steps can be omitted or components might run in the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024812Z" creationid="xccui" creationdate="20190423T024729Z">
        <seg>根据环境的不同（YARN、Mesos、Kubernetes、独立集群），有些步骤其实可以省略，同时可能会有多个组件运行在同一个JVM进程中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the type of execution environment, a JobManager is started as a local thread (local execution environment) or the JobGraph is sent to a remote JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T012430Z" creationid="xccui" creationdate="20190613T012430Z">
        <seg>根据执行环境类型的不同，可能会将JobManager作为本地线程启动（本地执行环境），也可能会将JobGraph发送到远程JobManager上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the use case and data store, the updates need to be processed before they can be incorporated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062601Z" creationid="xccui" creationdate="20190314T073211Z">
        <seg>根据用例和数据存储系统的不同，需要在更新的数据整合前对它们进行一些处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the use case, it is possible to apply an initial filtering or transformation on the input stream before</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T031942Z" creationid="xccui" creationdate="20190620T031942Z">
        <seg>根据用例，如果某些初始化的过滤或其他转换操作不会引起元素的重新分发，那么可以考虑在分配时间戳之前将它们用于输入流上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the use case, the transferred data may need to be normalized, enriched with external data, or aggregated before it is ingested by the target data store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154401Z" creationid="xccui" creationdate="20190605T041712Z">
        <seg>根据用例的不同，转存的数据可能需要归一化，利用外部输入丰富数据或在写入目标存储之前进行数据聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on whether the other stream is keyed or not, a KeyedBroadcastProcessFunction or BroadcastPro cessFunction can be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041206Z" creationid="xccui" creationdate="20190702T041041Z">
        <seg>根据另一条流是否已经按键值分区，该函数可能是KeyedBroadcastProcessFunction或BroadcastProcessFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depend‐ ing on the application, you might care about average latency, maximum latency, or percentile latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234017Z" creationid="xccui" creationdate="20190605T234017Z">
        <seg>根据应用的不同，你可能会关注平均延迟，最大延迟或延迟的百分位数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deployment Modes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025408Z" creationid="xccui" creationdate="20190225T025402Z">
        <seg>部署模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designed for the special case where the state of each task of an operator is identi‐ cal.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T185523Z" creationid="xccui" creationdate="20190607T184956Z">
        <seg>专门为一类特殊场景而设计——算子的每个任务都要保持相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Detailed and customizable collection of system and application metrics help to identify and react to problems ahead of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052524Z" creationid="xccui" creationdate="20190328T052451Z">
        <seg>详细、可自由定制的系统及应用指标集合有助于提前定位和响应问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Detailed and customizable collection of system and application metrics to iden‐ tify and react to problems ahead of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195844Z" creationid="xccui" creationdate="20190605T121631Z">
        <seg>提供了详细、可自由定制的系统及应用指标（metrics）集合，用于提前定位和响应问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disk Storage</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025610Z" creationid="xccui" creationdate="20190225T025610Z">
        <seg>磁盘存储</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution  Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064528Z" creationid="xccui" creationdate="20190615T064528Z">
        <seg>分发转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022750Z" creationid="xccui" creationdate="20190225T022750Z">
        <seg>分发转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution transformations reorganize stream events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024707Z" creationid="xccui" creationdate="20190613T024707Z">
        <seg>分发转换会将流中的事件重新组织。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not evaluate per element</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200646Z" creationid="xccui" creationdate="20190626T200646Z">
        <seg>不会针对每个元素都计算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Docker</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040308Z" creationid="xccui" creationdate="20190418T040308Z">
        <seg>Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does it include the time Alice was offline or not?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152409Z" creationid="xccui" creationdate="20190411T152118Z">
        <seg>需要把爱丽丝离线的时间考虑在内吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Download the JAR file that includes all example programs of this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035848Z" creationid="xccui" creationdate="20190329T035651Z">
        <seg>下载涵盖本书所有示例程序的JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Download the JAR file that includes examples in this book:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123515Z" creationid="xccui" creationdate="20190605T123435Z">
        <seg>下载涵盖本书所有示例的JAR文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dropping Late Events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150747Z" creationid="xccui" creationdate="20190225T023339Z">
        <seg>丢弃迟到事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dropping late events is the default behavior for event-time window operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T153632Z" creationid="xingcan" creationdate="20190628T153548Z">
        <seg>这也是事件时间窗口的默认行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to its checkpointing mechanism, Flink can achieve very good performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163923Z" creationid="xccui" creationdate="20190702T163923Z">
        <seg>得益于该检查点机制，Flink的性能会非常高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the append-only property of the log, events are always published to all consumers in exactly the same order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T060020Z" creationid="xccui" creationdate="20190305T054916Z">
        <seg>得益于日志的追加特性，无论向消费者发布几次，事件的顺序都能保持一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the single JVM execution mode, it is also possible to debug Flink applications in an IDE almost like any other program in your IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T053500Z" creationid="xccui" creationdate="20190611T052843Z">
        <seg>由于单JVM执行模式的存在，你可以像调试其他程序那样在IDE中调试Flink应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to these limitations, MemoryStateBackend is only rec‐ ommended for development and debugging purposes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T021722Z" creationid="xccui" creationdate="20190704T020912Z">
        <seg>由于存在这些限制，我们建议仅将MemoryStateBackend用于开发和调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to this replication of data, the data stores must be kept in sync.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T070309Z" creationid="xccui" creationdate="20190314T070309Z">
        <seg>由于数据存在多个副本，这些数据存储系统之间需要保持同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Duplicate processing might be acceptable if application correctness only depends on the completeness of information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T042104Z" creationid="xccui" creationdate="20190416T042059Z">
        <seg>如果正确性仅依赖信息的完整度，那重复处理或许可以接受。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dupli‐ cate processing might be acceptable if application correctness only depends on the completeness of information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034633Z" creationid="xccui" creationdate="20190606T034633Z">
        <seg>如果正确性仅依赖信息的完整度，那重复处理或许可以接受。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During exe&lt;t6/&gt;‐&lt;t7/&gt; cution, the JobManager is responsible for all actions that require a central coordi&lt;t8/&gt;‐&lt;t9/&gt; nation such as the coordination of checkpoints (see later section).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T050152Z" creationid="xccui" creationdate="20190418T035245Z">
        <seg>在执行过程中，JobManager负责所有需要集中协调的行为，例如：checkpoint协调（下节会提到）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, a TaskManager exchanges</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142706Z" creationid="xccui" creationdate="20190606T142706Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, a TaskManager exchanges data with other TaskManagers that run tasks of the same application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T052434Z" creationid="xccui" creationdate="20190418T052055Z">
        <seg>执行期间，运行同一应用不同任务的TaskManager之间会产生数据交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, the JobManager is responsible for all actions that require a central coordination such as the coordination of check‐ points (see “Checkpoints, Savepoints, and State Recovery”).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060319Z" creationid="xccui" creationdate="20190606T141827Z">
        <seg>在执行过程中，JobManager还要负责所有需要集中协调的操作，例如，创建检查点（见"检查点、保存点及状态恢复"）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the execution of a streaming application, Flink periodically takes consistent checkpoints of the application’s state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T033400Z" creationid="xccui" creationdate="20190609T031849Z">
        <seg>在流式应用执行过程中，Flink会周期性地为应用状态生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the execution of an application, the JobManager receives the state handles (storage locations) of the individual task checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073145Z" creationid="xccui" creationdate="20190502T045939Z">
        <seg>在应用执行过程中，JobManager会接收每个任务检查点的状态句柄（存储位置）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL jobs periodically import data into a data store and the data is pro&lt;t0/&gt;‐&lt;t1/&gt; cessed by ad-hoc or scheduled queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T025952Z" creationid="xccui" creationdate="20190317T025429Z">
        <seg>ELT作业周期性地把数据导入数据存储系统，并通过即席或计划查询处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL jobs periodically import data into a datastore and the data is processed by ad-hoc or scheduled queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154640Z" creationid="xccui" creationdate="20190605T042806Z">
        <seg>ELT作业会周期性地把数据导入数据存储系统，并通过即席或计划查询处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL processes can be quite complex and often require technically sophisticated solutions to meet performance requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T064825Z" creationid="xccui" creationdate="20190228T191045Z">
        <seg>该流程可能会非常麻烦，通常需要复杂的技术方案来满足性能要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ETL processes need to run periodically to keep the data in the data warehouse synchronized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T024853Z" creationid="esouser" creationdate="20190603T202915Z">
        <seg>为了保持数据仓库中的数据同步，ETL过程需要周期性地执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TaskManager has a pool of network buffers (by default 32 KB in size) to send and receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T191455Z" creationid="xccui" creationdate="20190606T195742Z">
        <seg>每个TaskManager都有一个用于收发数据的网络缓冲池（默认32KB大小）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TaskManager has a pool of network buffers (by default 32KB in size) which are used to send and receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042430Z" creationid="xccui" creationdate="20190504T042430Z">
        <seg>每个TaskManager有一个用于收发数据的网络缓冲区池（默认32KB大小）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each TaskManager provides a certain number of slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061037Z" creationid="xccui" creationdate="20190418T051523Z">
        <seg>每个TaskManager提供一定数量的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each application can be stateful and can locally manage its own state without accessing external datastores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214101Z" creationid="esouser" creationdate="20190603T214101Z">
        <seg>每个应用都可以是状态化的，只需要管理自身状态而无须访问外部数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each application can be stateful, i.e., locally manage its own state without accessing external data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T073303Z" creationid="xccui" creationdate="20190308T073224Z">
        <seg>每个应用都可以是状态化的，只需要管理自身状态而无须访问外部数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each component has the follow‐ ing responsibilities:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141429Z" creationid="xccui" creationdate="20190606T141429Z">
        <seg>它们各自的职责如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each component provides its own guarantees and the end-to-end guarantee of the complete pipeline would be the weakest of each of its components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194657Z" creationid="xccui" creationdate="20190416T045936Z">
        <seg>在每个组件都提供自身的保障情况下，整个处理管道上端到端的保障会受制于保障最弱的那个组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each descriptor defines a separate broadcast state of the function that is later applied on the BroadcastStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040738Z" creationid="xccui" creationdate="20190702T040738Z">
        <seg>每个描述符都会为将来用于BroadcastStream的函数定义一个单独的广播状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each event carries a timestamp and the logical time of the system is defined by watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070339Z" creationid="xccui" creationdate="20190619T070339Z">
        <seg>每个事件时间都带有一个时间戳，而系统的逻辑时间是由水位线来定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each event must be associated with a timestamp that typically indicates when the event actually happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T015417Z" creationid="xccui" creationdate="20190620T015417Z">
        <seg>每个事件都需要关联一个时间戳，该时间戳通常用来表示事件的实际发生时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each incoming event can be routed to zero, one, or more output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053929Z" creationid="xccui" creationdate="20190615T053929Z">
        <seg>每一个到来的事件都可以被发往零个、一个或多个输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator can define one or more keyed and operator states.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214508Z" creationid="xccui" creationdate="20190609T214500Z">
        <seg>每个算子可以定义一个或多个的键值或算子状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each operator is parallelized into one or multiple tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051232Z" creationid="xccui" creationdate="20190616T051232Z">
        <seg>每个算子都会产生一个或多个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each partition is a stream of timestamped records and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T014920Z" creationid="xccui" creationdate="20190607T014705Z">
        <seg>每个分区作为一个数据流，都会包含带有时间戳的记录以及水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each partition is processed by a task that computes the sum  of all received numbers and forwards the updated sum to a sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062301Z" creationid="xccui" creationdate="20190609T062128Z">
        <seg>每一部分都会有一个任务负责对收到的全部数字求和，并将结果值更新至下游数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each reading will be added to four win‐ dows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055727Z" creationid="xccui" creationdate="20190623T055727Z">
        <seg>每个读数将被放入四个窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each sender task needs at least four network buffers to send data to each receiver task and each receiver task requires at least four buffers to receive data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044254Z" creationid="xccui" creationdate="20190504T044254Z">
        <seg>每个发送端任务至少需要4个网络缓冲区来向任一接收端任务发送数据；同理每个接收端任务也需要至少4个缓冲区来接收数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each state backend provides imple‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221558Z" creationid="xccui" creationdate="20190703T221558Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each state is registered with a name that must be unique for the function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T065034Z" creationid="xccui" creationdate="20190702T065034Z">
        <seg>每个状态在注册时都要提供一个在函数内唯一的名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each task will process a subset of the operator’s input stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051313Z" creationid="xccui" creationdate="20190616T051313Z">
        <seg>每个任务负责处理算子输入流的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each win‐ dow object has an end timestamp that defines the point in time after which the window and its state can be deleted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T034136Z" creationid="xccui" creationdate="20190626T034136Z">
        <seg>每个窗口对象都有一个结束时间戳，它定义了可以安全删除窗口及其状态的时间点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eager watermarks ensure low latency but provide lower confidence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025637Z" creationid="xccui" creationdate="20190606T025637Z">
        <seg>激进的水位线策略保证了低延迟，但随之而来的是低可信度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements are removed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203429Z" creationid="xccui" creationdate="20190627T203429Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements of both input streams are assigned to common windows and joined (or cogrouped) when a window is complete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T034504Z" creationid="xccui" creationdate="20190628T034504Z">
        <seg>其原理是将两条输入流中的元素分配到公共窗口中并在窗口完成时进行Join（或Cogroup）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements that are assigned to a window will be immediately aggregated</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T035755Z" creationid="xccui" creationdate="20190625T035728Z">
        <seg>对分配给窗口的元素立即执行聚合，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emitting to Side Outputs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023126Z" creationid="xccui" creationdate="20190225T023126Z">
        <seg>向副输出发送数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enabling Failure Recovery for Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T055441Z" creationid="xccui" creationdate="20190225T024644Z">
        <seg>为状态化应用开启故障恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enabling checkpointing for an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204806Z" creationid="xccui" creationdate="20190702T204806Z">
        <seg>为应用开启检查点功能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End- to-end guarantees refer to result correctness across the whole data processing pipe‐ line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035307Z" creationid="xccui" creationdate="20190606T035307Z">
        <seg>端到端的保障指的是在整个数据处理管道上结果都是正确的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end Exactly-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045106Z" creationid="xccui" creationdate="20190416T045106Z">
        <seg>端到端的精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end exactly-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035007Z" creationid="xccui" creationdate="20190606T035007Z">
        <seg>端到端的精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End-to-end guarantees refer to result cor&lt;t0/&gt;‐&lt;t1/&gt; rectness across the data processing pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045541Z" creationid="xccui" creationdate="20190416T045541Z">
        <seg>端到端的保障指的是在整个数据处理管道上结果都是正确的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring low latency is critical for many streaming applications, such as fraud detec&lt;t0/&gt;‐&lt;t1/&gt; tion, raising alarms, network monitoring, and offering services with strict service level agreements (SLAs).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T191615Z" creationid="xccui" creationdate="20190401T191318Z">
        <seg>保证低延迟对很多流式应用而言至关重要，例如：诈骗识别、警报触发、网络监测以及遵循服务级别协议（SLA）的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring low latency is critical for many streaming applications, such as fraud detec‐ tion, system alarms, network monitoring, and offering services with strict service- level agreements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234228Z" creationid="xccui" creationdate="20190605T234208Z">
        <seg>保证低延迟对很多流式应用而言至关重要，例如：诈骗识别、系统告警、网络监测以及遵循服务级别协议（SLA）的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ensuring the Maintainability of Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024655Z" creationid="xccui" creationdate="20190225T024655Z">
        <seg>确保状态化应用的可维护性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Essentially, it is the time interval between receiving an event and seeing the effect of processing this event in the output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050738Z" creationid="xccui" creationdate="20190401T151641Z">
        <seg>本质上，它是从接收事件到在输出中观察到事件处理效果的时间间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Estimates mean there is room for errors, in which case you might gen‐ erate watermarks that are inaccurate, resulting in late data or an unnecessary increase in the application’s latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T033508Z" creationid="xccui" creationdate="20190621T033508Z">
        <seg>既然是估计，就会有误差，这意味着你可能会生成不准确的水位线，导致出现迟到数据或应用处理延迟的无谓增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluation functions can be aggregations like sum or minimum or custom operations applied on the buck&lt;t14/&gt;‐&lt;t15/&gt; et’s collected elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T050152Z" creationid="xccui" creationdate="20190406T045737Z">
        <seg>这些计算函数可以是某些聚合，例如：求和、求最小值或一些直接作用于桶内收集好元素的自定义聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluation functions can be aggregations like sum or minimum or custom operations applied on the bucket’s col‐ lected elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063031Z" creationid="xccui" creationdate="20190606T012907Z">
        <seg>这些计算函数可以是某些聚合，例如：求和、求最小值，也可以是一些直接作用于桶内收集元素的自定义操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though Flink is a distributed data processing system, you will typically develop and run initial tests on your local machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T032142Z" creationid="xccui" creationdate="20190611T031040Z">
        <seg>虽然Flink是一个分布式的数据处理系统，但你通常可以在本地计算机上进行开发并运行一些初始测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though low latency is an attractive feature of stream processing, its true value is way beyond just fast analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014221Z" creationid="xccui" creationdate="20190606T014221Z">
        <seg>尽管低延迟是流处理中一个很吸引人的特性，但流处理的真正价值远不止提供快速分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though low latency is an attractive feature of stream processing, its true value is way beyond just offering fast analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T201052Z" creationid="xccui" creationdate="20190409T200416Z">
        <seg>尽管低延迟是流处理中一个很吸引人的特性，但流处理的真正价值远不止提供快速分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though time information and watermarks are crucial to many streaming appli‐ cations, you might have noticed that we cannot access them through the basic Data‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T043212Z" creationid="xccui" creationdate="20190621T043212Z">
        <seg>虽然时间信息和水位线对于很多流式应用而言至关重要，但你可能已经注意到我们无法通过前面介绍的DataStream API转换来访问它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though when writing the book we intended for it to be read in chapter order, readers familiar with a chapter’s content might want to skip it and readers excited about writing Flink code right away might want to read the practical chapters first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191312Z" creationid="xccui" creationdate="20190225T162157Z">
        <seg>尽管我们在写书的时候是按照预期的阅读顺序进行章节编排，但如果你已经对某些章节的内容很熟悉，仍然可以选择跳过；或者如果你迫不及待想接触Flink代码也可以选择先阅读实践章节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144203Z" creationid="esouser" creationdate="20190603T144203Z">
        <seg>事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event Time Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021843Z" creationid="xccui" creationdate="20190225T021843Z">
        <seg>事件时间处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020346Z" creationid="xccui" creationdate="20190225T020346Z">
        <seg>事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time completely decouples the processing speed from the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024245Z" creationid="xccui" creationdate="20190606T024245Z">
        <seg>事件时间将处理速度和结果内容彻底解耦。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time correctly places events in a window, reflecting the reality of how things happened</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024225Z" creationid="xccui" creationdate="20190606T024225Z">
        <seg>事件时间准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time is based on a &lt;t0/&gt;timestamp&lt;t1/&gt; that is attached on the events of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150123Z" creationid="xccui" creationdate="20190412T145549Z">
        <seg>它源自附加在流中事件的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time is based on a timestamp that is attached to the events of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155814Z" creationid="xccui" creationdate="20190606T023937Z">
        <seg>它以附加在数据流中事件的时间戳为依据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event time is the time when an event in the stream actually happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023932Z" creationid="xccui" creationdate="20190606T023925Z">
        <seg>事件时间是数据流中事件实际发生的时间，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-Driven Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142916Z" creationid="esouser" creationdate="20190603T142916Z">
        <seg>事件驱动型应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-Time Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144458Z" creationid="esouser" creationdate="20190603T144458Z">
        <seg>事件时间处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-Time Processing | 47</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032621Z" creationid="xccui" creationdate="20190610T032621Z">
        <seg>事件时间处理 | 47</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014553Z" creationid="xccui" creationdate="20190225T014553Z">
        <seg>事件驱动型应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are an evolution of microservices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213735Z" creationid="esouser" creationdate="20190603T213735Z">
        <seg>事件驱动型应用本质上是之前讨论的微服务的演变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are an evolution of the previously discussed microservices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T151857Z" creationid="xccui" creationdate="20190307T151857Z">
        <seg>事件驱动型应用本质上是之前讨论的微服务的演变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are an interesting design pattern because they offer several benefits compared to the traditional architecture of separate storage and compute tiers or the popular microservice architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190312T212111Z" creationid="xccui" creationdate="20190308T073918Z">
        <seg>事件驱动型应用的设计模式之所以引起大家关注，主要是因为它和计算存储相互独立的传统架构以及流行的微服务架构相比，有很多优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are stateful streaming applications that ingest event streams and apply business logic on the received events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T015819Z" creationid="xccui" creationdate="20190307T015819Z">
        <seg>事件驱动型应用是一类通过接收事件流触发业务逻辑的状态化流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications are stateful streaming applications that ingest event streams and process the events with application-specific business logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213515Z" creationid="esouser" creationdate="20190603T213335Z">
        <seg>事件驱动型应用是一类通过接收事件流触发特定应用业务逻辑的状态化流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications have quite high requirements on the stream processor that runs them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014619Z" creationid="xccui" creationdate="20190313T010614Z">
        <seg>事件驱动型应用对作为载体的底层流处理引擎具有极高的要求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-driven applications offer several benefits compared to transactional applica‐ tions or microservices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T034025Z" creationid="esouser" creationdate="20190603T214152Z">
        <seg>与事务型应用和微服务架构相比，事件驱动型应用有很多优势：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time and processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054041Z" creationid="xccui" creationdate="20190605T054041Z">
        <seg>同时支持事件时间和处理时间语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time completely decouples the processing speed from the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150740Z" creationid="xccui" creationdate="20190412T150740Z">
        <seg>事件时间将处理速度和结果内容彻底解耦。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time correctly places events in a window, reflecting the reality of how things happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150649Z" creationid="xccui" creationdate="20190412T150619Z">
        <seg>事件时间准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time is the time when an event in the stream actually happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145554Z" creationid="xccui" creationdate="20190412T145346Z">
        <seg>事件时间是数据流中事件实际发生的时间，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time provides consistent and accurate results despite out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042352Z" creationid="xccui" creationdate="20190328T042125Z">
        <seg>事件时间能够针对无序事件提供一致、精确的结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time semantics provide consis‐ tent and accurate results despite out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054107Z" creationid="xccui" creationdate="20190605T054107Z">
        <seg>事件时间语义能够针对无序事件提供一致、精确的结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time streams also need to carry watermarks from which operators infer the current event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T015531Z" creationid="xccui" creationdate="20190620T015531Z">
        <seg>此外事件时间数据流还需要携带水位线，以供算子推断当前事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time timers fire when the next watermark is processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T070525Z">
        <seg>事件时间计时器会在处理下一条水位线的时候触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Event-time windows compute deterministic results even when events arrive out of order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071120Z" creationid="xccui" creationdate="20190619T071120Z">
        <seg>即便事件乱序到达，事件时间窗口也会计算出确定的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EventTime</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070157Z" creationid="xccui" creationdate="20190619T070157Z">
        <seg>EventTime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EventTimeTrigger.create()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044159Z" creationid="xccui" creationdate="20190626T044159Z">
        <seg>EventTimeTrigger.create()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are buffered in the player’s phone and delivered to the application when the network connection is restored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T153031Z" creationid="xccui" creationdate="20190411T153031Z">
        <seg>事件会缓存在玩家的手机里，网络恢复后才会发给应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are usually assigned to buckets based on data properties or based on time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T044950Z" creationid="xccui" creationdate="20190406T044901Z">
        <seg>事件通常会根据其时间或其他数据属性分配到不同桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are written to a durable, append-only log which means that the order of written events cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T054925Z" creationid="xccui" creationdate="20190305T054304Z">
        <seg>由于事件只能以追加的形式写入持久化日志中，因此其顺序无法在后期改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events are written to a durable, append-only log, which means that the order of written events cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210612Z" creationid="esouser" creationdate="20190603T210612Z">
        <seg>由于事件只能以追加的形式写入持久化日志中，因此其顺序无法在后期改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events in a data stream can represent monitoring data, sensor measurements, credit card transactions, weather station observations, online user interactions, web searches, etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045805Z" creationid="xccui" creationdate="20190401T143030Z">
        <seg>数据流中的事件可以表示监控数据、传感器测量值、信用卡交易、气象站观测数据、在线用户交互以及网络搜索等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Events with different keys can be processed by the same task, but the keyed state of a task’s function is always accessed in the scope of the current event’s key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190614T050816Z">
        <seg>虽然键值不同的事件也可能会在同一个任务上处理，但任务函数所能访问的键值分区状态始终会被约束在当前事件键值的范围内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eventually, the checkpoint barriers arrive at a sink task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193734Z" creationid="xccui" creationdate="20190609T193734Z">
        <seg>最终检查点分隔符到达数据汇任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every input event is emitted to the next operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064709Z" creationid="xccui" creationdate="20190614T064709Z">
        <seg>每个输入消息都会发给下游算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every record contains an average temperature of a sensor over a period of 5 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054643Z" creationid="xccui" creationdate="20190612T054622Z">
        <seg>每条记录都会包含对应传感器在5秒内的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time a trigger is called it produces a TriggerResult that determines what should happen to the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184327Z" creationid="xccui" creationdate="20190626T184327Z">
        <seg>每次调用触发器都会生成一个TriggerResult，它用于决定窗口在接下来的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time an element is added to a window, it is also passed to the trigger of the win‐ dow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052727Z" creationid="xccui" creationdate="20190625T052727Z">
        <seg>每个元素在加入窗口后还会被传递至该窗口的触发器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Everything contained in a user func‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055230Z" creationid="xccui" creationdate="20190618T055230Z">
        <seg>用户函数中的全部内容都必须是可序列化的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>EvictorContext evictorContext);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201910Z" creationid="xccui" creationdate="20190627T201910Z">
        <seg>EvictorContext evictorContext);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evictors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201305Z" creationid="xccui" creationdate="20190626T201305Z">
        <seg>移除器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evictors are often applied on a GlobalWindow for partial cleaning of the window— without purging the complete window state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T204119Z" creationid="xccui" creationdate="20190627T204119Z">
        <seg>移除器常用于GlobalWindow，它只会清理部分窗口内容而不会完全清除整个窗口状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evictors iterate over a list of elements in a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203535Z" creationid="xccui" creationdate="20190627T203535Z">
        <seg>移除器会遍历窗口中的元素列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evolving Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024857Z" creationid="xccui" creationdate="20190225T024857Z">
        <seg>状态化应用的演变</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-Once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050839Z" creationid="xccui" creationdate="20190415T050839Z">
        <seg>精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034738Z" creationid="xccui" creationdate="20190606T034738Z">
        <seg>精确一次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once is the strictest guarantee and hard to achieve.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034820Z" creationid="xccui" creationdate="20190606T034802Z">
        <seg>精确一次是最严格，也是最难实现的一类保障，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once means that not only will there be no event loss, but also updates on the internal state will be applied exactly once for each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194128Z" creationid="xccui" creationdate="20190606T034808Z">
        <seg>它表示不但没有事件丢失，而且每个事件对于内部状态的更新都只有一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once result guarantees means that not only there will be no event loss, but also updates on the internal state will be applied exactly once for each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044034Z" creationid="xccui" creationdate="20190416T043928Z">
        <seg>精确一次结果保障意味着不但没有事件丢失，而且每个事件对于内部状态的更新都只有一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exactly-once state consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195336Z" creationid="xccui" creationdate="20190605T054206Z">
        <seg>提供精确一次（exactly-once）的状态一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035805Z" creationid="xccui" creationdate="20190612T035805Z">
        <seg>示例5-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-2 splits a stream of numbers into a stream of large numbers and a stream of small numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061613Z" creationid="xccui" creationdate="20190615T061613Z">
        <seg>示例5-2将一条数字流分成一条大数字流和一条小数字流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061618Z" creationid="xccui" creationdate="20190615T061618Z">
        <seg>示例 5-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-3 shows the methods of a RichFLatMapFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034219Z" creationid="xccui" creationdate="20190619T034206Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 5-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T031010Z" creationid="xccui" creationdate="20190618T031010Z">
        <seg>示例 5-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-1 shows how to set the time characteristic by revisiting the sensor stream‐ ing application code you wrote in “Hello, Flink!” on page 79.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T072550Z" creationid="xccui" creationdate="20190619T072317Z">
        <seg>示例6-1回顾了你在79页完成的"Hello, Flink!"流式应用代码中是如何设置时间特性的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T072525Z" creationid="xccui" creationdate="20190619T072359Z">
        <seg>示例6-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-10 shows a reduce lambda function that computes the mininum tempera‐ ture per sensor every 15 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002241Z" creationid="xccui" creationdate="20190624T002241Z">
        <seg>示例6-10展示的lambda函数会计算每15秒的最低温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002248Z" creationid="xccui" creationdate="20190624T002248Z">
        <seg>示例6-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-11 shows how to use an AggregateFunction to compute the average tem‐ perature of sensor readings per window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005208Z" creationid="xccui" creationdate="20190624T005208Z">
        <seg>示例6-11展示了如何使用AggregateFunction计算每个窗口内传感器读数的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005411Z" creationid="xccui" creationdate="20190624T005411Z">
        <seg>示例6-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-12 groups the sensor reading stream into tumbling windows of 5 seconds and uses a ProcessWindowFunction to compute the lowest and highest temperature that occur within the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030330Z" creationid="xccui" creationdate="20190625T030330Z">
        <seg>示例6-12将传感器读数流按照每5秒的滚动窗口进行分组，随后使用ProcessWindowFunction计算每个窗口内的最低温和最高温。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T205813Z" creationid="xccui" creationdate="20190623T205813Z">
        <seg>示例6-12，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043448Z" creationid="xccui" creationdate="20190625T043448Z">
        <seg>示例6-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-14.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045020Z" creationid="xccui" creationdate="20190625T045020Z">
        <seg>示例6-14，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-15.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042257Z" creationid="xccui" creationdate="20190626T042257Z">
        <seg>示例6-15，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-16 shows a trigger that fires early, before the end time of the window is reached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195643Z" creationid="xccui" creationdate="20190626T195643Z">
        <seg>示例6-16展示的触发器会在到达窗口结束时间之前提前触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200014Z" creationid="xccui" creationdate="20190626T200014Z">
        <seg>示例6-16，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-17 shows the Evictor interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201639Z" creationid="xccui" creationdate="20190626T201639Z">
        <seg>示例6-17中展示了Evictor接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-17.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201540Z" creationid="xccui" creationdate="20190627T201540Z">
        <seg>示例6-17，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-18.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025815Z" creationid="xccui" creationdate="20190628T025815Z">
        <seg>示例6-18，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-19 shows how to define a window join.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T034533Z" creationid="xccui" creationdate="20190628T034533Z">
        <seg>示例6-19展示了如何定义基于窗口的Join。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T034538Z" creationid="xccui" creationdate="20190628T034538Z">
        <seg>示例6-19，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044608Z" creationid="xccui" creationdate="20190620T044608Z">
        <seg>示例6-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-20 shows how to specify a window operator with a side output for late events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154837Z" creationid="xingcan" creationdate="20190628T154837Z">
        <seg>示例6-20展示了如何在窗口算子中为迟到事件指定副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-20.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154842Z" creationid="xingcan" creationdate="20190628T154842Z">
        <seg>示例6-20，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-21 shows a ProcessFunction that filters out late sensor readings from its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155512Z" creationid="xingcan" creationdate="20190628T155512Z">
        <seg>示例6-21展示了ProcessFunction如何从输入中过滤出迟到的传感器读数，并将其重定位到副输出流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-21.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155521Z" creationid="xingcan" creationdate="20190628T155521Z">
        <seg>示例6-21，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165144Z" creationid="xingcan" creationdate="20190628T165144Z">
        <seg>示例6-22，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-3 shows an assigner with periodic timestamps that produces watermarks by keeping track of the maximum element timestamp it has seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T050837Z" creationid="xccui" creationdate="20190620T050837Z">
        <seg>示例6-3展示了一个周期性水位线分配器，它通过跟踪至今所见最大的元素时间戳来生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051021Z" creationid="xccui" creationdate="20190620T051021Z">
        <seg>示例6-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-4 shows a punctuated watermark assigner that emits a watermark for every reading it receives from the sensor with the ID "sensor_1".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054733Z" creationid="xccui" creationdate="20190620T054733Z">
        <seg>示例6-4展示的定点水位线生成器为从ID为"sensor_1"的传感器接收到的所有读数产生水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054737Z" creationid="xccui" creationdate="20190620T054737Z">
        <seg>示例6-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054957Z" creationid="xccui" creationdate="20190620T054957Z">
        <seg>示例6-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-6 shows how to emit data from a ProcessFunction via DataStream of a side output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022628Z" creationid="xccui" creationdate="20190622T022628Z">
        <seg>示例6-6展示了如何从ProcessFunction利用副输出的DataStream发送数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022633Z" creationid="xccui" creationdate="20190622T022633Z">
        <seg>示例6-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-7 shows the FreezingMonitor function that monitors a stream of sensor readings and emits a warning to a side output for readings with a temperature below</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023536Z" creationid="xccui" creationdate="20190622T023245Z">
        <seg>示例6-7所示的FreezingMonitor函数用于监控传感器读数流，它对于读数温度低于32°F的记录向副输出发送警告。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023256Z" creationid="xccui" creationdate="20190622T023256Z">
        <seg>示例6-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-8 shows how to apply a CoProcessFunction to combine two streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031359Z" creationid="xccui" creationdate="20190622T031359Z">
        <seg>示例6-8展示了如何应用CoProcessFunction来结合两条数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031407Z" creationid="xccui" creationdate="20190622T031407Z">
        <seg>示例6-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 6-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031933Z" creationid="xccui" creationdate="20190622T031933Z">
        <seg>示例图6-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-1 shows how to apply a FlatMapFunction with a keyed ValueState on a stream of sensor measurements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062254Z" creationid="xccui" creationdate="20190630T061537Z">
        <seg>示例7-1展示了如何在一条传感数据测量流上应用一个带有键值分区ValueState的FlatMapFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061957Z" creationid="xccui" creationdate="20190630T061957Z">
        <seg>示例7-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024115Z" creationid="xccui" creationdate="20190703T024115Z">
        <seg>示例7-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024958Z" creationid="xccui" creationdate="20190703T024958Z">
        <seg>示例7-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-12 shows how to configure a state backend (here, RocksDBStateBackend) for an application and all its stateful functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025623Z" creationid="xccui" creationdate="20190704T025623Z">
        <seg>示例7-12展示了如何为应用及其状态化函数配置状态后端（此处选用RocksDBStateBackend）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025628Z" creationid="xccui" creationdate="20190704T025628Z">
        <seg>示例7-12，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-13 shows a KeyedProcessFunction that compares two subsequent tem‐ perature measurements and raises an alert if the difference is greater than a certain</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205113Z" creationid="xccui" creationdate="20190704T204924Z">
        <seg>示例7-13展示的KeyedProcessFunction会对两个连续的温度测量值进行比较，如果二者的差值大于一个特定阈值就会发出警报。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T024303Z" creationid="xccui" creationdate="20190704T024303Z">
        <seg>示例7-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-2 shows the implementation of a FlatMapFunction with a keyed Value State that checks whether the measured temperature changed more than a config‐ ured threshold.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064132Z" creationid="xccui" creationdate="20190630T064132Z">
        <seg>示例7-2展示了如何实现带有键值分区ValueState的FlatMapFunction，该函数用来检测温度测量值的变化是否超过配置的阈值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064135Z" creationid="xccui" creationdate="20190630T064135Z">
        <seg>示例7-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-3 shows how to implement the previous example with the shortcut.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T022755Z" creationid="xccui" creationdate="20190701T022755Z">
        <seg>示例7-3展示了如何利用简写来实现上一个示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T022801Z" creationid="xccui" creationdate="20190701T022801Z">
        <seg>示例7-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-4 shows how to implement the ListCheckpointed interface for a function that counts temperature measurements that exceed a threshold per partition, for each</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052212Z" creationid="xccui" creationdate="20190701T052212Z">
        <seg>示例7-4展示了如何利用ListCheckpointed接口实现一个函数，其作用是在每个函数并行实例内，计算该分区数据超过某一阈值的温度值数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052219Z" creationid="xccui" creationdate="20190701T052219Z">
        <seg>实例7-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062303Z" creationid="xccui" creationdate="20190701T062303Z">
        <seg>示例7-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-6 shows how to implement a tem‐ perature alert application with thresholds that can be dynamically configured via a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024117Z" creationid="xccui" creationdate="20190701T204421Z">
        <seg>示例7-6展示了如何实现用广播流动态配置阈值的温度报警应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024131Z" creationid="xccui" creationdate="20190702T024131Z">
        <seg>示例7-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-7 shows the implementation of a KeyedBroadcastProcessFunction that supports the dynamic configuration of sensor thresholds at runtime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041312Z" creationid="xccui" creationdate="20190702T041312Z">
        <seg>示例7-7展示了一个KeyedBroadcastProcessFunction的实现，它支持在运行时动态配置传感器阈值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041315Z" creationid="xccui" creationdate="20190702T041315Z">
        <seg>示例7-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-8 shows how the CheckpointedFunction interface is used to create a func‐ tion with keyed and operator state that counts per key and operator instance how</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T154649Z" creationid="xccui" creationdate="20190702T154649Z">
        <seg>示例7-8展示了如何使用CheckpointedFunciton接口创建一个函数，该函数分别利用键值分区状态和算子状态来计算每个键值分区内和每个算子实例内传感器读数超过指定阈值数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041753Z" creationid="xccui" creationdate="20190702T041753Z">
        <seg>示例7-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example 7-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204740Z" creationid="xccui" creationdate="20190702T204740Z">
        <seg>示例7-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except from experiencing network delays, streams might be affected by many other factors resulting in events arriving &lt;t0/&gt;out-of-order&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T152014Z" creationid="xccui" creationdate="20190412T151943Z">
        <seg>除了遇到网络延迟外，数据流还可能受很多其他因素的影响，从而导致事件乱序到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035744Z" creationid="xccui" creationdate="20190418T035744Z">
        <seg>执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execute the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044410Z" creationid="xccui" creationdate="20190612T044410Z">
        <seg>运行程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly Providing Type Information</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145233Z" creationid="esouser" creationdate="20190603T145233Z">
        <seg>显式提供类型信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly providing TypeInformation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022853Z" creationid="xccui" creationdate="20190225T022853Z">
        <seg>显式提供TypeInformation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exposing Queryable State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151726Z" creationid="xccui" creationdate="20190225T025031Z">
        <seg>对外暴露可查询式状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extract the archive file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024939Z" creationid="xccui" creationdate="20190329T024915Z">
        <seg>提取归档文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extract the archive file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T040942Z" creationid="xccui" creationdate="20190605T123035Z">
        <seg>解压文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIRE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184406Z" creationid="xccui" creationdate="20190626T184406Z">
        <seg>FIRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIRE_AND_PURGE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184925Z" creationid="xccui" creationdate="20190626T184925Z">
        <seg>FIRE_AND_PURGE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FIRE_AND_PURGE: Evaluates the window first (FIRE) and subsequently removes all state and metadata (PURGE).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185109Z" creationid="xccui" creationdate="20190626T185109Z">
        <seg>先进行窗口计算（FIRE），随后删除所有状态及元数据（PURGE）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fabian Hueske and Vasiliki Kalavri</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T062527Z" creationid="esouser" creationdate="20190603T142832Z">
        <seg>费比安·霍斯克，瓦西里基·卡拉夫里</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Farnham</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210639Z" creationid="esouser" creationdate="20190603T210639Z">
        <seg>Farnham</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Expressions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145343Z" creationid="esouser" creationdate="20190603T145343Z">
        <seg>字段表达式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field Positions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145330Z" creationid="esouser" creationdate="20190603T145330Z">
        <seg>字段位置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Field expressions work for tuples, POJOs, and case classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050859Z" creationid="xccui" creationdate="20190618T041522Z">
        <seg>它可用于元组、POJO以及样例类，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T051343Z" creationid="xccui" creationdate="20190226T155724Z">
        <seg>图1-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-2 depicts a microservices architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T201038Z" creationid="esouser" creationdate="20190603T201038Z">
        <seg>图1-2描绘了微服务的架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T201055Z" creationid="xccui" creationdate="20190228T172811Z">
        <seg>图1-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203636Z" creationid="xccui" creationdate="20190228T194722Z">
        <seg>图1-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210546Z" creationid="xccui" creationdate="20190305T033052Z">
        <seg>图1-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-5 shows a service architecture composed of event-driven streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055536Z" creationid="esouser" creationdate="20190603T213855Z">
        <seg>图1-5粗略展示了一个由事件驱动型应用组成的服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213901Z" creationid="xccui" creationdate="20190307T152532Z">
        <seg>图1-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044636Z" creationid="xccui" creationdate="20190317T061404Z">
        <seg>图1-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051830Z" creationid="xccui" creationdate="20190322T043259Z">
        <seg>图1-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123342Z" creationid="xccui" creationdate="20190329T035536Z">
        <seg>图1-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 1-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123747Z" creationid="xccui" creationdate="20190329T041504Z">
        <seg>图1-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-1 shows a dataflow program that extracts and counts hashtags from an input stream of tweets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T043916Z" creationid="xccui" creationdate="20190605T224942Z">
        <seg>图2-1展示了一个从推文输入流中提取并统计主题标签的Dataflow程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000821Z" creationid="xccui" creationdate="20190401T000821Z">
        <seg>图2-1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-10 shows a parallel count- based tumbling window of length 2 that is partitioned by event color.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014052Z" creationid="xccui" creationdate="20190606T014052Z">
        <seg>图2-10展示了一个按事件颜色划分、基于数量2的并行滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195852Z" creationid="xccui" creationdate="20190409T195852Z">
        <seg>图2-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-11 illustrates this problem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154903Z" creationid="xccui" creationdate="20190606T015143Z">
        <seg>图2-11说明了这个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152133Z" creationid="xccui" creationdate="20190411T152133Z">
        <seg>图2-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T145254Z" creationid="xccui" creationdate="20190412T145254Z">
        <seg>图2-12，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-13 shows that an event-time window would correctly place events in a window, reflecting the reality of how things happened, even though some events were delayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T024207Z" creationid="xccui" creationdate="20190606T024207Z">
        <seg>如图2-13所示，即便事件有延迟，事件时间窗口也能准确地将事件分配到窗口中，从而反映出真实发生的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150547Z" creationid="xccui" creationdate="20190412T150547Z">
        <seg>图2-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-2 shows a physical dataflow graph for the logical graph of Figure 2-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044348Z" creationid="xccui" creationdate="20190605T233123Z">
        <seg>图2-2展示了图2-1中逻辑图所对应的物理Dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233204Z" creationid="xccui" creationdate="20190401T021435Z">
        <seg>图2-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233614Z" creationid="xccui" creationdate="20190401T142156Z">
        <seg>图2-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011531Z" creationid="xccui" creationdate="20190405T155233Z">
        <seg>图2-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-5 shows a rolling minimum aggregation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011908Z" creationid="xccui" creationdate="20190606T011908Z">
        <seg>图2-5展示了一个求最小值的滚动聚合，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011935Z" creationid="xccui" creationdate="20190406T035853Z">
        <seg>图2-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-6 shows a count-based tumbling window that discretizes the input stream into buckets of four elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013041Z" creationid="xccui" creationdate="20190606T013033Z">
        <seg>图2-6中基于数量的滚动窗口将输入流按每4个元素一组分配到不同的桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013105Z" creationid="xccui" creationdate="20190407T023535Z">
        <seg>图2-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-7 shows a time-based tumbling window that gathers events into buckets and triggers computation every 10 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013100Z" creationid="xccui" creationdate="20190606T013100Z">
        <seg>图2-7中基于时间的滚动窗口将事件汇集到桶中，每10分钟触发一次计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013116Z" creationid="xccui" creationdate="20190407T023601Z">
        <seg>图2-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013309Z" creationid="xccui" creationdate="20190407T024337Z">
        <seg>图2-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-9 shows a session win‐ dow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013816Z" creationid="xccui" creationdate="20190606T013816Z">
        <seg>图2-9展示了一个会话窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 2-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193600Z" creationid="xccui" creationdate="20190409T193600Z">
        <seg>图2-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1 &lt;t0/&gt;visualizes how Flink’s components interact with each other when an applica&lt;t1/&gt;‐&lt;t2/&gt; &lt;t3/&gt;tion is submitted for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024536Z" creationid="xccui" creationdate="20190423T024536Z">
        <seg>图3-1展示了应用提交执行过程中Flink各组件之间的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1 is a high-level sketch to visualize the responsibilities and interactions of the components of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T062545Z" creationid="xccui" creationdate="20190606T143140Z">
        <seg>图3-1仅是一个用于展示各组件职责与交互的高层次框架。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1 shows how Flink’s components interact with each other when an applica‐ tion is submitted for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143119Z" creationid="xccui" creationdate="20190606T143119Z">
        <seg>图3-1展示了应用提交执行过程中Flink各组件之间的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024559Z" creationid="xccui" creationdate="20190423T024553Z">
        <seg>图3-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-10 shows the typical interaction between a task and its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054157Z" creationid="xccui" creationdate="20190607T054157Z">
        <seg>图3-10展示了某个任务和它状态之间的典型交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054241Z" creationid="xccui" creationdate="20190607T054204Z">
        <seg>图3-10，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-11 shows how tasks access operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061822Z" creationid="xccui" creationdate="20190607T061818Z">
        <seg>图3-11展示了任务访问算子状态的过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061850Z" creationid="xccui" creationdate="20190607T061850Z">
        <seg>图3-11，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-12 shows how tasks interact with keyed state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T191856Z">
        <seg>图3-12展示了任务和键值分区状态的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191916Z" creationid="xccui" creationdate="20190607T191916Z">
        <seg>图3-12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-13 shows how keyed state is repartitioned in key groups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190608T060134Z">
        <seg>图3-13展示了键值分区状态通过键值组进行重新分区的过程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-13.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060142Z" creationid="xccui" creationdate="20190608T060142Z">
        <seg>图3-13，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-14 shows the redistribution of operator list state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060932Z" creationid="xccui" creationdate="20190608T060915Z">
        <seg>图3-14展示了算子列表状态的重分配过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-14.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060955Z" creationid="xccui" creationdate="20190608T060955Z">
        <seg>图3-14，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-15 shows how operator union list state is redistributed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061440Z" creationid="xccui" creationdate="20190608T061440Z">
        <seg>图3-15展示了算子联合列表状态的重分配过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-15.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061453Z" creationid="xccui" creationdate="20190608T061444Z">
        <seg>图3-15，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-16 shows the redistribution of operator broadcast state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062216Z" creationid="xccui" creationdate="20190608T062216Z">
        <seg>图3-16展示了算子广播状态的重分配过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-16.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062225Z" creationid="xccui" creationdate="20190608T062224Z">
        <seg>图3-16，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-17 shows a consistent checkpoint of a simple application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224948Z" creationid="xccui" creationdate="20190608T224942Z">
        <seg>图3-17展示了一个简单应用的一致性检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-17.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224957Z" creationid="xccui" creationdate="20190608T224957Z">
        <seg>图3-17，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-18 shows the recovery process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035854Z" creationid="xccui" creationdate="20190609T035854Z">
        <seg>图3-18展示了整个恢复过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-18.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035859Z" creationid="xccui" creationdate="20190609T035859Z">
        <seg>图3-18，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062327Z" creationid="xccui" creationdate="20190609T062327Z">
        <seg>图3-19，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-2 shows the relationships between Task‐ Managers, slots, tasks, and operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144423Z" creationid="xccui" creationdate="20190606T144423Z">
        <seg>图3-2展示了TaskManager、处理槽、任务以及算子之间的关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042935Z" creationid="xccui" creationdate="20190423T042916Z">
        <seg>图3-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-20.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062435Z" creationid="xccui" creationdate="20190609T062435Z">
        <seg>图3-20，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-21 shows the streaming application after both source tasks checkpointed their local state and emit‐ ted checkpoint barriers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155312Z" creationid="xccui" creationdate="20190609T155242Z">
        <seg>图3-21展示了流式应用为数据源任务的本地状态生成检查点并发出检查点分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-21.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155332Z" creationid="xccui" creationdate="20190609T155332Z">
        <seg>图3-21，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T174943Z" creationid="xccui" creationdate="20190609T174943Z">
        <seg>图3-22，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-23.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T191821Z" creationid="xccui" creationdate="20190609T191821Z">
        <seg>图3-23，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-24 shows the application at this point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193413Z" creationid="xccui" creationdate="20190609T193413Z">
        <seg>图3-24展示了此时的应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-24.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193437Z" creationid="xccui" creationdate="20190609T193437Z">
        <seg>图3-24，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-25 shows the final step of the checkpointing algorithm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194328Z" creationid="xccui" creationdate="20190609T194328Z">
        <seg>图3-25展示了检查点算法的最后一步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-25.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194520Z" creationid="xccui" creationdate="20190609T194520Z">
        <seg>图3-25，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-26 shows an application with three operators, each running with two tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214838Z" creationid="xccui" creationdate="20190609T214829Z">
        <seg>图3-26所展示的应用包含了3个算子，每个算子各有两个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-26.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215058Z" creationid="xccui" creationdate="20190609T215058Z">
        <seg>图3-26，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-3 illustrates this design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T194307Z" creationid="xccui" creationdate="20190606T194307Z">
        <seg>图3-3阐明了这一设计。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051909Z" creationid="xccui" creationdate="20190502T051909Z">
        <seg>图3-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-4 shows this architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T200550Z" creationid="xccui" creationdate="20190606T200545Z">
        <seg>图3-4展示了这一架构.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T043815Z" creationid="xccui" creationdate="20190504T043815Z">
        <seg>图3-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152413Z" creationid="esouser" creationdate="20190514T152357Z">
        <seg>图3-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-6 &lt;t0/&gt;depicts how the pipeline is executed with task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152448Z" creationid="esouser" creationdate="20190514T152448Z">
        <seg>图3-6展示了流水线如何在任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-6 depicts how the pipeline is executed with task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203516Z" creationid="xccui" creationdate="20190606T203516Z">
        <seg>图3-6展示了流水线如何在任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153047Z" creationid="esouser" creationdate="20190514T153047Z">
        <seg>图3-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-7 shows the same pipeline executed without task chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T202003Z" creationid="xccui" creationdate="20190606T203922Z">
        <seg>图3-7展示了相同的流水线在非任务链接模式下执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T154741Z" creationid="esouser" creationdate="20190514T154741Z">
        <seg>图3-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042306Z" creationid="xccui" creationdate="20190523T042306Z">
        <seg>图3-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-9 shows how a task with four input partitions and three output partitions receives watermarks, updates its partition watermarks and event-time clock, and emits watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025533Z" creationid="xccui" creationdate="20190607T025519Z">
        <seg>图3-9展示了一个有4个输入分区和3个输出分区的任务在接收到水位线后是如何更新它的分区水位线和事件时间时钟，并将水位线发出的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 3-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025624Z" creationid="xccui" creationdate="20190607T025617Z">
        <seg>图3-9，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 4-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041603Z" creationid="xccui" creationdate="20190611T041603Z">
        <seg>图4-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 4-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041632Z" creationid="xccui" creationdate="20190611T041632Z">
        <seg>图4-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 4-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041648Z" creationid="xccui" creationdate="20190611T041648Z">
        <seg>图4-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-1 shows a map transformation that converts every square into a circle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045343Z" creationid="xccui" creationdate="20190613T045343Z">
        <seg>图5-1所示的map转换会将每个方形输入转换为圆形。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045347Z" creationid="xccui" creationdate="20190613T045347Z">
        <seg>图5-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-2 shows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052259Z" creationid="xccui" creationdate="20190613T052259Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052306Z" creationid="xccui" creationdate="20190613T052306Z">
        <seg>图5-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-3 shows a flatMap operation that differentiates its output based on the color of the incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054323Z" creationid="xccui" creationdate="20190613T054323Z">
        <seg>图5-3展示的flatMap操作会根据输入事件颜色的不同输出不同的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054545Z" creationid="xccui" creationdate="20190613T054545Z">
        <seg>图5-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051113Z" creationid="xccui" creationdate="20190614T051113Z">
        <seg>图5-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-5 shows a union operation that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064219Z" creationid="xccui" creationdate="20190614T064219Z">
        <seg>图5-5展示的union操作会将黑色和白色的事件合并成一条输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064230Z" creationid="xccui" creationdate="20190614T064230Z">
        <seg>图5-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-6 shows a split operator that routes all white events into a separate stream than the rest.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T054125Z" creationid="xccui" creationdate="20190615T054125Z">
        <seg>图5-6所示的split算子会将所有白色事件和其他事件分别发往不同的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T054131Z" creationid="xccui" creationdate="20190615T054131Z">
        <seg>图5-6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-7 illustrates the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043407Z" creationid="xccui" creationdate="20190616T043407Z">
        <seg>图5-7对该分发转换进行了说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 5-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045500Z" creationid="xccui" creationdate="20190616T045500Z">
        <seg>图5-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042158Z" creationid="xccui" creationdate="20190623T042158Z">
        <seg>图6-1，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054747Z" creationid="xccui" creationdate="20190623T054747Z">
        <seg>图6-2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-3 illustrates how elements are assigned to session windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061012Z" creationid="xccui" creationdate="20190623T061012Z">
        <seg>图6-3说明了如何将元素分配到会话窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061016Z" creationid="xccui" creationdate="20190623T061016Z">
        <seg>图6-3，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053506Z" creationid="xccui" creationdate="20190625T053506Z">
        <seg>图6-4，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053955Z" creationid="xccui" creationdate="20190625T053955Z">
        <seg>图6-5，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-6 depicts this case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054306Z" creationid="xccui" creationdate="20190625T054306Z">
        <seg>图6-6描述了该情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030122Z" creationid="xccui" creationdate="20190625T030122Z">
        <seg>图6-6，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-7 shows an interval join of two streams, A and B, that joins an event from A with an event from B if the timestamp of the B event is not less than one hour earlier and not more than 15 minutes later than the timestamp of the A event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T214113Z" creationid="xccui" creationdate="20190627T214113Z">
        <seg>图6-7展示了两条流（A和B）上基于间隔的Join，如果B中事件的时间戳相较于A中事件的时间戳不早于1小时且不晚于15分钟，则会将两个事件Join起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025129Z" creationid="xccui" creationdate="20190628T025129Z">
        <seg>图6-7，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-8 shows how the window join of the DataStream API works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040250Z" creationid="xccui" creationdate="20190628T040250Z">
        <seg>图6-8展示了DataStream API中基于窗口的Join是如何工作的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figure 6-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040255Z" creationid="xccui" creationdate="20190628T040255Z">
        <seg>图6-8，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Figures 4-1 to 4-3 illustrate the import process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041557Z" creationid="xccui" creationdate="20190611T041557Z">
        <seg>图4-1到图4-3展示了导入过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File System Configuration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025511Z" creationid="xccui" creationdate="20190225T025511Z">
        <seg>文件系统配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File System Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025157Z" creationid="xccui" creationdate="20190225T025157Z">
        <seg>文件系统汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File System Source Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025149Z" creationid="xccui" creationdate="20190225T025149Z">
        <seg>文件系统源连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem Configuration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152252Z" creationid="esouser" creationdate="20190603T152252Z">
        <seg>文件系统配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem Sink Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152052Z" creationid="esouser" creationdate="20190603T152052Z">
        <seg>文件系统汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filesystem Source Connector</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152039Z" creationid="esouser" creationdate="20190603T152039Z">
        <seg>文件系统源连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T051132Z" creationid="xccui" creationdate="20190613T051132Z">
        <seg>Filter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Chapter 11 contains resources you can use to ask questions, attend Flink- related events, and learn how Flink is currently being used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162637Z" creationid="esouser" creationdate="20190603T162637Z">
        <seg>最后在第11章，我们提供了一些资源，以方便你提问、参与Flink相关活动和了解Flink的现实应用场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Chapter 11 contains resources you can use to ask questions, attend Flink-related events, and learn what people use Flink for.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T190926Z" creationid="xccui" creationdate="20190225T190148Z">
        <seg>最后在第11章，我们提供了一些资源，以方便你提问、参与Flink相关活动和了解Flink的现实应用场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, by leveraging an event log as input source the complete input of an applica&lt;t0/&gt;‐&lt;t1/&gt; tion is reliably stored and can be deterministically replayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190312T212958Z" creationid="xccui" creationdate="20190312T212817Z">
        <seg>以事件日志作为应用的输入，不但完整可靠，而且还支持精准的数据重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, if the operator has an incremental aggregation function and a full window function, the full window function is applied on the aggregated value and the result is emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054251Z" creationid="xccui" creationdate="20190625T054251Z">
        <seg>最后，如果算子同时拥有一个增量聚合函数和一个全量窗口函数，后者将作用于前者产生的聚合值上，之后便会发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, processing time windows offer a faithful rep&lt;t0/&gt;‐&lt;t1/&gt; resentation of the streams themselves, might also be a desirable property for some use-cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T044817Z" creationid="xccui" creationdate="20190414T044223Z">
        <seg>最后一点，处理时间窗口能够表示数据流自身的真实情况，这可能是某些用例的理想属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, processing-time windows offer a faithful rep‐ resentation of the streams themselves, which might be a desirable property for some use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181009Z" creationid="xccui" creationdate="20190606T031118Z">
        <seg>最后，处理时间窗口能够表示数据流自身的真实情况，这可能会在某些用例中派上用场。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we apply a user-defined function that computes the average temperature on each window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053852Z" creationid="xccui" creationdate="20190612T053852Z">
        <seg>最后我们用了一个用户自定义函数来计算每个窗口的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we briefly discuss the evolution of open source stream processors and help you run a streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063726Z" creationid="esouser" creationdate="20190603T163101Z">
        <seg>最后，我们将简要回顾开源流处理引擎的衍变过程，并帮助你在本地Flink实例上运行一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we briefly discuss the evolution of open source stream processors and help you to run a first streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014510Z" creationid="xccui" creationdate="20190225T223601Z">
        <seg>章节最后，我们会简要回顾开源流处理引擎的衍变，并帮助你在本地Flink实例上运行第一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we explain how Flink’s highly available mode works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T045240Z" creationid="xccui" creationdate="20190606T141208Z">
        <seg>最后，我们将解释Flink高可用模式的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we explain how Flink’s highly-available mode works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033313Z" creationid="xccui" creationdate="20190418T033232Z">
        <seg>最后，我们会解释Flink高可用模式的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we learned why state is important in streaming applications and how to guard it against failures and guarantee correct results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T195048Z" creationid="xccui" creationdate="20190606T040520Z">
        <seg>最后我们了解了状态对流式应用的重要性，以及如何应对故障并确保结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we say a big thank you to all the people at O’Reilly who accompanied us on our two and a half year long journey and helped us to push this project over the fin‐ ish line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063113Z" creationid="xccui" creationdate="20190605T134105Z">
        <seg>最后，我们由衷地感谢O'Reilly的相关工作人员：Alicia Young、Colleen Lobner、Christine Edwards、Katherine Tozer、Marie Beaugureau以及Tim McGovern，感谢你们在这两年半旅途中的陪伴，一起协助我们完成这个项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we show how to bootstrap a Flink Maven project, the starting point for a new application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004304Z" creationid="xccui" creationdate="20190610T040552Z">
        <seg>最后我们会介绍如何创建Flink Maven项目，这通常是任何一个新应用的起点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we show how to configure keyed state as queryable and how to access it from an external application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T034640Z">
        <seg>最后，我们将展示怎样将键值分区状态设置为可查询式的以及如何从外部应用中访问它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we took a look at Apache Flink and the extensive features it offers and showed how to install a local Flink setup and run a first stream processing application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T202148Z" creationid="xccui" creationdate="20190605T125759Z">
        <seg>最后我们简单了解了Apache Flink以及它提供的诸多特性，还展示了如何在本地安装设置Flink并运行第一个流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, we will discuss how to join streams on time and strategies to handle late events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151956Z" creationid="xccui" creationdate="20190619T053439Z">
        <seg>最后我们会讨论如何基于时间对数据流进行Join以及处理延迟事件的策略。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you have seen why state is important in streaming applications and how you can guard it against failures and guarantee correct results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051729Z" creationid="xccui" creationdate="20190416T051720Z">
        <seg>最后你明白了状态对流式应用的重要性，以及如何在故障时保证结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you should stop the local Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045629Z" creationid="xccui" creationdate="20190329T045629Z">
        <seg>最后别忘了停止本地Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you should stop the local Flink cluster:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124426Z" creationid="xccui" creationdate="20190605T124426Z">
        <seg>最后别忘了停止本地Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Find us on Facebook: http://facebook.com/oreilly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210845Z" creationid="esouser" creationdate="20190603T210845Z">
        <seg>Find us on Facebook: http://facebook.com/oreilly</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First Edition</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210730Z" creationid="esouser" creationdate="20190603T210730Z">
        <seg>First Edition</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First of all, it requires two semantically equivalent implementations of the application logic for two separate processing sys&lt;t2/&gt;‐&lt;t3/&gt; tems with different APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T030941Z" creationid="xccui" creationdate="20190327T030811Z">
        <seg>首先，该架构需要在拥有不同API的两套独立处理系统之上实现两次语义相同的应用逻辑；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First of all, it requires two semantically equivalent implementations of the application logic for two separate processing systems with different APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193959Z" creationid="xccui" creationdate="20190605T052927Z">
        <seg>首先，该架构需要在拥有不同API的两套独立处理系统之上实现两套语义相同的应用逻辑；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First research prototypes and com&lt;t0/&gt;‐&lt;t1/&gt; mercial products date back to the late 1990s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T041319Z" creationid="xccui" creationdate="20190319T041302Z">
        <seg>它最初的原型和商业产品可以追溯到上世纪90年代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, a savepoint of a running application is taken and then it is used to restore the state in a starting application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214317Z" creationid="xccui" creationdate="20190609T214237Z">
        <seg>首先为正在运行的应用生成一个保存点，然后在应用启动时用它去初始化状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it needs to restart failed pro&lt;t2/&gt;‐&lt;t3/&gt; cesses and second, it needs to restart the application and recover its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205013Z" creationid="xccui" creationdate="20190428T204413Z">
        <seg>一是需要重启故障进程，二是需要重启应用并恢复其状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it should be clear that there is an optimal latency in the case of no load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T204244Z" creationid="xccui" creationdate="20190402T204244Z">
        <seg>首先需要明确的是，在空负载的情况下延迟会达到最优。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it should be clear that there is optimal latency when there is no load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235030Z" creationid="xccui" creationdate="20190605T235030Z">
        <seg>首先需要明确的是，在空负载的情况下延迟会达到最优。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, let’s discuss the software you need to develop Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T040837Z" creationid="xccui" creationdate="20190610T040837Z">
        <seg>首先我们来讨论一下开发Flink应用所需的软件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, let’s have a look at the data type we will be using to represent sensor readings:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035700Z" creationid="xccui" creationdate="20190612T035700Z">
        <seg>首先来看一下传感器读取数据的数据类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, we will learn how to define time characteristics, timestamps, and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T050417Z" creationid="xccui" creationdate="20190619T050417Z">
        <seg>首先我们将学习如何定义时间特征、时间戳及水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you can extend a function class to explicitly provide the TypeInformation of its return type by implementing the ResultTypeQueryable interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061847Z" creationid="xccui" creationdate="20190617T061847Z">
        <seg>首先你可以通过实现ResultTypeQueryable接口来扩展函数，在其中提供返回类型的TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you can parti&lt;t0/&gt;‐&lt;t1/&gt; tion your input data and have tasks of the same operation execute on the data subsets in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032148Z" creationid="xccui" creationdate="20190401T030434Z">
        <seg>首先，你可以将输入数据分组，让同一操作的多个任务并发执行在不同数据子集上，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you can parti‐ tion your input data and have tasks of the same operation execute on the data subsets in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044627Z" creationid="xccui" creationdate="20190605T233227Z">
        <seg>      首先，你可以将输入数据分组，让同一操作的多个任务并发执行在不同数据子集上，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlatMap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053224Z" creationid="xccui" creationdate="20190613T053224Z">
        <seg>FlatMap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142352Z" creationid="esouser" creationdate="20190603T142352Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink  provides different ways to deal with late records, which are discussed in “Handling Late Data” on page 148.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T042933Z" creationid="xccui" creationdate="20190606T205759Z">
        <seg>为了处理迟到记录，Flink提供了不同的机制，我们将在148页"处理迟到数据"一节讨论它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink DataStream applications process streams of events that are represented as data objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T062416Z" creationid="xccui" creationdate="20190616T062416Z">
        <seg>Flink DataStream应用所处理的事件会表示为数据对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink Web UI</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030126Z" creationid="xccui" creationdate="20190225T030126Z">
        <seg>Flink Web UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink accepts a class as a POJO if it satisfies the following conditions:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T042701Z" creationid="xccui" creationdate="20190617T042701Z">
        <seg>如果一个类满足如下条件，Flink就会将它看做POJO：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink achieves millisecond latencies and is able to process millions of events per second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042644Z" creationid="xccui" creationdate="20190328T042616Z">
        <seg>Flink能够实现毫秒级延迟，同时每秒可处理数百万条事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink allows for updating the application code of jobs and migrating jobs to dif&lt;t0/&gt;‐&lt;t1/&gt; ferent Flink clusters without losing the state of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052335Z" creationid="xccui" creationdate="20190328T052036Z">
        <seg>Flink允许在不丢失应用状态的前提下更新作业的程序代码或进行跨Flink集群的作业迁移。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink also</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211241Z" creationid="xccui" creationdate="20190609T211241Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink also aims to keep its own external dependencies to a minimum and hides most of them (including tran‐ sitive dependencies) from user applications to prevent version conflicts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045122Z" creationid="xccui" creationdate="20190619T045122Z">
        <seg>为了尽可能降低自身的外部依赖，Flink将很多依赖（包括传递依赖）都隐藏起来，对用户应用不可见，以此来避免版本冲突。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink also features a type extraction system that analyzes the input and return types of functions to automatically obtain type information and hence serializers and deserial‐ izers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T064254Z" creationid="xccui" creationdate="20190616T064035Z">
        <seg>此外，Flink中还有一个类型提取系统，它可以通过分析函数的输入、输出类型来自动获取类型信息，继而得到相应的序列化器和反序列化器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink analyzes each type that does not fall into any category and checks to see if it can be identified and handled as a POJO type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T042544Z" creationid="xccui" creationdate="20190617T042544Z">
        <seg>Flink会分析那些不属于任何一类的数据类型，并尝试将它们识别为POJO类型进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink applications are executed in parallel in a distributed environment such as a cluster of machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050849Z" creationid="xccui" creationdate="20190616T050849Z">
        <seg>Flink应用可以在分布式环境中（例如机器集群）并行执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink applications can be deployed in two different styles.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025403Z" creationid="xccui" creationdate="20190423T025315Z">
        <seg>Flink应用可以通过两种模式进行部署。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink applications can be scaled to run on thousands of cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042749Z" creationid="xccui" creationdate="20190328T042749Z">
        <seg>基于Flink的应用可以扩展到数千核心之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink appli‐ cations can be scaled to run on thousands of cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T055912Z" creationid="xccui" creationdate="20190605T055912Z">
        <seg>基于Flink的应用可以扩展到数千核心之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not automatically take a save‐ point, so a user (or external scheduler) has to explicitly trigger its creation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210829Z" creationid="xccui" creationdate="20190609T210829Z">
        <seg>保存点的生成不是由Flink自动完成，而是需要由用户（或外部调度器）显式触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not implement all this functionality by itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T031440Z" creationid="xccui" creationdate="20190418T031424Z">
        <seg>Flink并没有依靠自己实现所有上述功能，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not provide durable, distributed storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032116Z" creationid="xccui" creationdate="20190418T032114Z">
        <seg>Flink没有提供分布式持久化存储，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not provide tooling to restart failed processes when running in a stand-alone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T040150Z" creationid="xccui" creationdate="20190504T035856Z">
        <seg>Flink没有针对独立集群模式提供重启故障进程的工具，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink does not provide tooling to restart failed processes when running in a standalone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195157Z" creationid="xccui" creationdate="20190606T195157Z">
        <seg>Flink没有针对独立集群模式提供重启故障进程的工具，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink encodes timestamps as 16-byte Long values and attaches them as metadata to records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205013Z" creationid="xccui" creationdate="20190606T204939Z">
        <seg>Flink内部将时间戳编码为16字节的Long类型值并将它们以元数据的形式附加在记录之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink encodes timestamps as 16-byte long values and attaches them as metadata to records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040434Z" creationid="xccui" creationdate="20190523T040434Z">
        <seg>Flink内部将时间戳编码为16字节的long类型值并将它们以元数据的形式附加在记录之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink exposes all interfaces for user-defined functions, such as MapFunction, Filter Function, and ProcessFunction, as interfaces or abstract classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T053854Z" creationid="xccui" creationdate="20190618T053724Z">
        <seg>Flink中所有用户自定义函数（例如MapFunction、FilterFunction、ProcessFunction）的接口都是以接口或抽象类的形式对外暴露，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features an optimization technique called task chaining that reduces the over‐ head of local communication under certain conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T200205Z" creationid="xccui" creationdate="20190606T203214Z">
        <seg>Flink采用一种名为任务链接的优化技术来降低某些情况下的本地通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features an optimization technique called task chaining which reduces the over&lt;t0/&gt;‐&lt;t1/&gt; head of local communication under certain conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151913Z" creationid="esouser" creationdate="20190514T151904Z">
        <seg>Flink利用一项名为任务链接（task chaining）的优化技术来降低部分情况下本地通信的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features dedicated operators for time-based stream joins, which are discussed in Chapter 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151910Z" creationid="xccui" creationdate="20190615T044956Z">
        <seg>Flink对基于时间的流式Join设有专用算子，相关内容会在第6章讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features different techniques to reduce the communication costs between tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T192536Z" creationid="esouser" creationdate="20190513T192536Z">
        <seg>Flink采用多种技术来降低任务之间的通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features layered APIs with varying tradeoffs for expressiveness and ease-of-use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T044046Z" creationid="xccui" creationdate="20190328T042847Z">
        <seg>Flink提供的层次化API，在表达能力和易用性方面各有权衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features multiple &lt;t0/&gt;ResourceManager&lt;t1/&gt;s for different environments and resource providers such as YARN, Mesos, Kubernetes, and stand-alone deploy&lt;t2/&gt;‐&lt;t3/&gt; ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T050208Z" creationid="xccui" creationdate="20190418T050003Z">
        <seg>针对不同的环境和资源提供者（例如：YARN、Mesos、Kubernetes或独立部署），Flink提供了不同的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features multiple ResourceManagers for different environments and resource providers such as YARN, Mesos, Kubernetes, and standalone deploy‐ ments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060817Z" creationid="xccui" creationdate="20190606T142057Z">
        <seg>针对不同的环境和资源提供者（resource provider）（如YARN、Mesos、Kubernetes或独立部署），Flink提供了不同的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink features savepoints to maintain applications and their states.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T214017Z" creationid="xccui" creationdate="20190702T212746Z">
        <seg>Flink利用保存点机制来对应用及其状态进行维护，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink for a while without ever needing to worry about TypeInformation for your data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T052704Z" creationid="xccui" creationdate="20190617T052631Z">
        <seg>因此你可以先用上一段时间的Flink而无需担心数据类型的TypeInformation问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink guarantees this by periodically writing a consistent checkpoint of the application state to a remote and durable storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073626Z" creationid="xccui" creationdate="20190305T032707Z">
        <seg>为了实现该特性，Flink会定期将应用状态的一致性检查点（checkpoint）写入远程持久化存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements a credit-based flow control mechanism that works as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202657Z" creationid="xccui" creationdate="20190606T202654Z">
        <seg>Flink实现了一个基于信用值的流量控制机制，它的工作原理如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements a credit-based flow control mechanism which works as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151603Z" creationid="esouser" creationdate="20190513T210738Z">
        <seg>Flink实现了一个基于信用度的流量控制机制，它的工作原理如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements tweaks that can alleviate the performance impact under certain conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195937Z" creationid="xccui" creationdate="20190609T195841Z">
        <seg>Flink实现了一些调整策略，从而可以减轻某些条件下对性能的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink implements watermarks as special records that are received and emitted by operator tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040759Z" creationid="xccui" creationdate="20190529T040724Z">
        <seg>Flink内部将水位线实现为特殊的记录，可以通过算子任务进行接收和发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is a distributed data processing system, and as such, has to deal with failures such as killed processes, failing machines, and interrupted network connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T151730Z" creationid="xccui" creationdate="20190608T062326Z">
        <seg>Flink是一个分布式的数据处理系统，因此必须能够处理一些故障，例如：进程被强制关闭、机器故障以及网络连接中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is a distributed system for stateful parallel data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190417T181954Z" creationid="xccui" creationdate="20190417T181954Z">
        <seg>Flink是一个用于状态化并行流处理的分布式系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is able to run streaming applications 24/7 with very little downtime due to its highly-available setup (no single point of failure), a tight integration with Kubernetes, YARN, and Apache Mesos, fast recovery from failures, and the abil&lt;t0/&gt;‐&lt;t1/&gt; ity to dynamically scale jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052002Z" creationid="xccui" creationdate="20190328T051545Z">
        <seg>Flink支持高可用性配置（无单点失效），和Kubernetes、YARN、Apache Mesos紧密集成，快速故障恢复，动态扩容作业等。基于上述特点，它可以7*24小时运行流式应用，几乎无须停机。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is well integrated with cluster resource managers, such as Apache Mesos, YARN, and Kubernetes, but can also be configured to run as a stand- alone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T044510Z" creationid="xccui" creationdate="20190606T140736Z">
        <seg>Flink和很多集群管理器（cluster resource manager）（如Apache Mesos、YARN及Kubernetes）都能很好地集成；同时它也可以通过配置，作为独立集群来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink is well integrated with cluster resource managers, such as Apache Mesos, YARN, and Kubernetes, but can also be configured to run as a stand-alone cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032041Z" creationid="xccui" creationdate="20190418T032041Z">
        <seg>Flink和很多集群管理器，例如：Apache Mesos、YARN、Kubernetes，都有很好地集成；同时它也可以通过配置以独立集群模式运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink joined the Apache Software Foun&lt;t2/&gt;‐&lt;t3/&gt; dation as an incubating project in April 2014 and became a top-level project in January 2015.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T192355Z" creationid="xccui" creationdate="20190225T192355Z">
        <seg>Flink于2014年4月以孵化项目的形式进入Apache软件基金会，并在次年1月就成为了顶级项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink joined the Apache Software Foun‐ dation as an incubating project in April 2014 and became a top-level project in January 2015.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T045323Z" creationid="esouser" creationdate="20190603T162828Z">
        <seg>Flink于2014年4月以孵化项目的形式进入Apache软件基金会，并在次年一月就成为了顶级项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink maintains one state instance per key value and parti‐ tions all records with the same key to the operator task that maintains the state for this key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191729Z" creationid="xccui" creationdate="20190607T190646Z">
        <seg>Flink为每个键值都维护了一个状态实例，该实例总是会位于那个处理对应键值记录的算子任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink needs to create a suitable serializer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T071403Z" creationid="xccui" creationdate="20190630T071403Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink offers different strategies to handle such late events, and we discuss those later in “Handling Late Data” on page 148.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T053636Z" creationid="xccui" creationdate="20190620T053636Z">
        <seg>Flink为处理此类迟到事件提供了不同的策略，我们稍后会在148页"处理迟到数据"中对它们进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink offers good answers to all of these requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033243Z" creationid="xccui" creationdate="20190319T033237Z">
        <seg>Flink 能够完美满足上述需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink offers three primitives for operator state:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061941Z" creationid="xccui" creationdate="20190607T061925Z">
        <seg>Flink为算子状态提供了3类原语：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink powers large-scale business-critical applications in many companies and enterprises across different industries and around the globe.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T220902Z" creationid="xccui" creationdate="20190225T220902Z">
        <seg>全球各行各业很多公司和企业的大型核心业务应用都是基于Flink完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink powers large-scale, business-critical applications in many companies and enterprises across different industries and around the globe.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063351Z" creationid="esouser" creationdate="20190603T162927Z">
        <seg>全球很多不同行业的公司和企业都在使用Flink支撑其大规模核心业务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink programs are executed lazily.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011017Z" creationid="xccui" creationdate="20190613T010906Z">
        <seg>Flink程序都是通过延迟计算的方式执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides Maven archetypes to generate Maven projects for Java or Scala Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004621Z" creationid="xccui" creationdate="20190612T004239Z">
        <seg>Flink提供了Maven模板来为Java或Scala的Flink应用生成Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides a well-maintained collection of stream sinks that can be used to write data to different systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054203Z" creationid="xccui" creationdate="20190612T054203Z">
        <seg>Flink提供了一组维护良好的流式数据汇，可用来完成上述工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides built-in window assigners for the most common windowing use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T024503Z" creationid="xccui" creationdate="20190623T024503Z">
        <seg>Flink为一些最常见的窗口使用场景提供了内置窗口分配器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides connectors to the most commonly used storage systems such as Apache Kafka, Apache Cassandra, Elasticsearch, JDBC, Kinesis, and (distributed) file systems such as HDFS and S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T045210Z" creationid="xccui" creationdate="20190328T044823Z">
        <seg>Flink提供了一些用于最常见存储系统的连接器，如Apache Kafka、Apache Cassandra、Elasticsearch、JDBC、Kinesis以及（分布式）文件系统（HDFS和S3等）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides different mechanisms to deal with late records which are dis&lt;t8/&gt;‐&lt;t9/&gt; cussed in &lt;t10/&gt;Chapter 6&lt;t11/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035634Z" creationid="xccui" creationdate="20190529T035619Z">
        <seg>为了处理迟到记录，Flink提供了不同的机制，我们将在第6章讨论它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides different primitives for keyed state that determine the type of the value stored for each key in this distributed key-value map.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T192242Z">
        <seg>Flink为键值分区状态提供了不同原语，它们的区别就在于分布式键值映射中每个键对应存储值的类型不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides efficient implementations of Java tuples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T071300Z" creationid="xccui" creationdate="20190616T071153Z">
        <seg>Flink提供了Java元组的高效实现，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides intuitive and easy-to-use primitives for common event-time process&lt;t0/&gt;‐&lt;t1/&gt; ing operations but also exposes expressive APIs to implement more advanced event-time applications with custom operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T034459Z" creationid="xccui" creationdate="20190523T034002Z">
        <seg>Flink不仅针对常见的事件时间操作提供了直观且易用的原语，还支持一些表达能力很强API，允许使用者以自定义算子的方式实现更高级的事件时间处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides intuitive and easy-to-use primitives for common event-time process‐ ing operations but also exposes expressive APIs to implement more advanced event- time applications with custom operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204453Z" creationid="xccui" creationdate="20190606T204427Z">
        <seg>Flink不仅针对常见的事件时间操作提供了直观易用的原语，还支持一些表达能力很强API，允许使用者以自定义算子的方式实现更高级的事件时间处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides more tuning knobs to configure the checkpointing behavior, such as the choice of consistency guarantees (exactly-once or at-least-once), the number of concurrent checkpoints, and a timeout to cancel long-running checkpoints, as well as several state backend–specific options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T211038Z" creationid="xccui" creationdate="20190702T211038Z">
        <seg>Flink还为检查点行为提供了一些其它可供调节的配置选项，例如：一致性保障（精确一次或至少一次）的选择，检查点的并行数量以及用来取消长时间运行的检查点的超时时间，此外还有多个和状态后端相关的选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides multiple interfaces to define stateful functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T035109Z" creationid="xccui" creationdate="20190630T035109Z">
        <seg>Flink为定义状态化函数提供了多种接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides multiple primitives for keyed state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T040825Z">
        <seg>Flink为键值分区状态提供了很多原语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides state backends that manage keyed state as objects stored in in-memory data structures on the JVM heap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190608T052050Z">
        <seg>Flink提供的一类状态后端会把键值分区状态作为对象，以内存数据结构的形式存在JVM堆里面；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides the AssignerWithPunctuatedWatermarks interface for such cases, or when watermarks can be defined based on some other property of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054051Z" creationid="xccui" creationdate="20190620T054023Z">
        <seg>Flink为此类情况或可根据输入元素生成水位线的情况提供了AssignerWithPunctuatedWatermarks接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink provides two utility classes for Java and Scala with static methods to generate a TypeInformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053425Z" creationid="xccui" creationdate="20190617T053425Z">
        <seg>Flink为Java和Scala提供了两个工具类，其中的静态方法可以用来生成TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink pro‐ vides configuration options to improve the efficiency by preregis‐ tering classes to Kryo.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070043Z" creationid="xccui" creationdate="20190616T065724Z">
        <seg>为了提高效率，Flink提供配置选项可以提前将类在Kryo中注册好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink restricts access to timestamps or watermarks through the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T012539Z" creationid="xccui" creationdate="20190607T012506Z">
        <seg>Flink对通过DataStream API访问时间戳和水位线有一些限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink restricts the access to timestamps or watermarks through the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042520Z" creationid="xccui" creationdate="20190529T042453Z">
        <seg>Flink限制通过DataStream API访问时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink serializes all function objects with Java serialization to ship them to the worker processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055202Z" creationid="xccui" creationdate="20190618T055202Z">
        <seg>Flink会利用Java序列化机制将所有函数对象序列化后发送到对应的工作进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports Scala case classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040631Z" creationid="xccui" creationdate="20190617T040631Z">
        <seg>Flink对Scala样例类也提供了相应支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports all common data types that are available in Java and Scala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T064957Z" creationid="xccui" creationdate="20190616T064910Z">
        <seg>Flink支持Java和Scala中所有常见数据类型，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports event-time and processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T041957Z" creationid="xccui" creationdate="20190328T041957Z">
        <seg>Flink同时支持事件时间和处理时间语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports exactly-once state consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042435Z" creationid="xccui" creationdate="20190328T042435Z">
        <seg>Flink提供精确一次的状态一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports four patterns for scaling different types of state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T054918Z" creationid="xccui" creationdate="20190608T054918Z">
        <seg>Flink对不同类型的状态提供了4种扩缩容模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports many data types, which we describe in the next section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051637Z" creationid="xccui" creationdate="20190612T051624Z">
        <seg>Flink支持很多数据类型，我们会在下一节介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports several special-purpose types, such as primitive and object Array types; Java’s ArrayList, HashMap, and Enum types; and Hadoop Writable types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T045914Z" creationid="xccui" creationdate="20190617T045914Z">
        <seg>Flink支持多种特殊用途的类型，例如：原始或对象类型的数组，Java的ArrayList、HashMap及Enum，Hadoop的Writable类型等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink supports such updates by taking a savepoint of a running application, stopping it, and starting a new version of the application from the savepoint.5 However, updat‐ ing an application while preserving its state is only possible for certain application changes—the original application and its new version need to be savepoint compati‐ ble.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035413Z" creationid="xccui" creationdate="20190705T022928Z">
        <seg>Flink可以通过为运行的应用生成保存点，停止该应用，重启新版本等三个步骤来实现此类更新。5 然而这种保留状态的应用更新对应用改动也有一些限制——原始应用和新版本应用的检查点必须兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink treats all states—regardless of built-in or user-defined operators—the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T053301Z" creationid="xccui" creationdate="20190607T053200Z">
        <seg>Flink对所有状态一视同仁，无论是内置的还是用户自定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink uses ZooKeeper for leader election and as a highly available and durable datastore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072949Z" creationid="xccui" creationdate="20190606T150002Z">
        <seg>它在Flink中主要用于"领导"选举以及持久且高可用的数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink uses ZooKeeper for leader election and as a highly-available and durable data store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T045628Z" creationid="xccui" creationdate="20190502T045316Z">
        <seg>它在Flink中用于"领导"选举以及高可用性数据持久化存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink uses the concept of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T063852Z" creationid="xccui" creationdate="20190616T063852Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink will exclude stream partitions produced by idle source functions from the watermark computation of subsequent operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034703Z" creationid="xccui" creationdate="20190607T034613Z">
        <seg>Flink会在后续算子计算水位线的时候把那些来自于空闲源函数的流分区排除在外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink will never evaluate empty windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T035219Z" creationid="xccui" creationdate="20190623T033506Z">
        <seg>Flink永远不会对空窗口执行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FlinkCEP for Complex Event Processing and Pattern Matching</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152541Z" creationid="esouser" creationdate="20190603T152541Z">
        <seg>用于复杂事件处理和模式匹配的FlinkCEP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s Checkpointing Algorithm</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T212839Z" creationid="xccui" creationdate="20190225T022209Z">
        <seg>Flink检查点算法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s DataStream API features two built-in operators to join streams with a temporal condition: the interval join and the window join.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210453Z" creationid="xccui" creationdate="20190627T210453Z">
        <seg>Flink的DataStream API中内置有两个算子可以根据时间条件对数据流进行Join：基于间隔的Join和基于窗口的Join。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s DataStream API is available for Java and Scala.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T015102Z" creationid="xccui" creationdate="20190611T014730Z">
        <seg>Flink的DataStream API支持Java和Scala语言，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s Data‐ Stream API offers the ProcessWindowFunction to perform arbitrary computations on the contents of a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010127Z" creationid="xccui" creationdate="20190624T010127Z">
        <seg>Flink的DataStream API提供的ProcessWindowFunction可以对窗口内容执行任意计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s Java tuples can have up to 25 fields, with each length is implemented as a separate class—Tuple1, Tuple2, up to Tuple25.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T015545Z" creationid="xccui" creationdate="20190616T071356Z">
        <seg>它最多可包含25个字段，每个字段长度都对应一个单独的实现类——Tuple1、Tuple2直到Tuple25。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s batch processing API, the DataSet API, and the runtime are separate from their corresponding stream&lt;t0/&gt;‐&lt;t1/&gt; ing counterparts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060914Z" creationid="xccui" creationdate="20190328T060503Z">
        <seg>虽然Flink用于批处理的DataSet API以及它的运行时环境都独立于对应的流处理部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s built-in window assigners create windows of type TimeWindow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041448Z" creationid="xccui" creationdate="20190623T041416Z">
        <seg>Flink内置窗口分配器所创建的窗口类型为TimeWindow。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s checkpointing algorithm produces consistent distributed checkpoints from streaming applications without stopping the whole application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195749Z" creationid="xccui" creationdate="20190609T195709Z">
        <seg>虽然Flink的检查点算法能够在不停止整个应用的情况下为流式应用生成一致的分布式检查点，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s checkpointing algorithm uses a special type of record called a checkpoint bar‐ rier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060715Z" creationid="xccui" creationdate="20190609T060148Z">
        <seg>Flink的检查点算法中会用到一类名为检查点分隔符（checkpoint barrier）的特殊记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s default configuration for network buffers is sufficient for small to medium-sized setups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045743Z" creationid="xccui" creationdate="20190504T045713Z">
        <seg>Flink默认的网络缓冲区配置足以应对中小型设置场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s default configuration for network buffers is sufficient for small- to medium-sized set‐ ups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193744Z" creationid="xccui" creationdate="20190606T201811Z">
        <seg>Flink默认的网络缓冲区配置足以应对中小型使用场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s design aims to reduce synchronization points.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163613Z" creationid="xccui" creationdate="20190702T163613Z">
        <seg>Flink的设计旨在减少同步点的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s high-availability mode is based on &lt;t0/&gt;Apache ZooKeeper&lt;t1/&gt;, a system for distributed services that require coordination and consensus.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T045126Z" creationid="xccui" creationdate="20190502T045126Z">
        <seg>Flink的高可用模式是基于能够提供分布式协调和共识服务的Apache ZooKeeper系统来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s high-availability mode is based on Apache ZooKeeper, a system for distributed services that require coordination and consensus.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072755Z" creationid="xccui" creationdate="20190606T145941Z">
        <seg>Flink中的高可用模式是基于能够提供分布式协调和共识服务的Apache ZooKeeper来完成的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s recovery algorithm is based on state checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T205400Z" creationid="xccui" creationdate="20190609T205357Z">
        <seg>Flink的故障恢复算法是基于状态的检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s recovery mechanism is based on consistent application checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054558Z" creationid="xccui" creationdate="20190609T054558Z">
        <seg>Flink的故障恢复机制是基于应用的一致性检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s recovery mechanism is based on consistent checkpoints of application state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155305Z" creationid="xccui" creationdate="20190608T154504Z">
        <seg>Flink的故障恢复机制是基于应用状态的一致性检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s relational APIs, SQL and the LINQ-style Table API, are not discussed in this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195721Z" creationid="xccui" creationdate="20190328T044231Z">
        <seg>而Flink的关系型API——SQL及LINQ风格的Table API，并没有在书中过多涉及。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s type extractor leverages reflection and analyzes function signatures and subclass information to derive the correct output type of a user-defined function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T060621Z" creationid="xccui" creationdate="20190617T060529Z">
        <seg>Flink的类型提取器利用反射和分析函数签名及子类信息的方式，从用户自定义函数中提取正确的输出类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flink’s watermark-handling and propagation algorithm ensures operator tasks emit properly aligned timestamped records and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T031249Z" creationid="xccui" creationdate="20190607T031249Z">
        <seg>Flink的水位线处理和传播算法保证了算子任务所发出的记录时间戳和水位线一定会对齐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Follow the authors on Twitter: @fhueske and @vkalavri</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210848Z" creationid="esouser" creationdate="20190603T210848Z">
        <seg>Follow the authors on Twitter: @fhueske and @vkalavri</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Follow us on Twitter: http://twitter.com/oreillymedia</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210846Z" creationid="esouser" creationdate="20190603T210846Z">
        <seg>Follow us on Twitter: http://twitter.com/oreillymedia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T050329Z" creationid="xccui" creationdate="20190617T050329Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Java, the helper class is org.apache.flink.api.common.type info.Types, and it is used as shown in the following examples:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053757Z" creationid="xccui" creationdate="20190617T053555Z">
        <seg>Java中的这个辅助类是org.apache.flink.api.common.typeInfo.Types，它的用法如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a sliding window, you have to specify a window size and a slide interval that defines how frequently a new window is started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055016Z" creationid="xccui" creationdate="20190623T055016Z">
        <seg>对于滑动窗口而言，你需要指定窗口大小以及用于定义新窗口开始频率的滑动间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For almost 40 years, O’Reilly has provided technology and    business training, knowledge, and insight to help companies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210829Z" creationid="esouser" creationdate="20190603T210829Z">
        <seg>For almost 40 years, O’Reilly has provided technology and    business training, knowledge, and insight to help companies</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For applications that require very low latency and can tolerate at-least-once state guarantees, Flink can be configured to process all arriving records during buffer alignment instead of buffering those for which the barrier has already arrived.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T204845Z" creationid="xccui" creationdate="20190609T204517Z">
        <seg>对于那些需要极低延迟且能容忍至少一次状态保障的应用，可以通过配置让Flink在分隔符对齐的过程中不缓存那些已收到分隔符所对应分区的记录，而是直接处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For batch applications, we usually care about the total execution time of a job, or how long it takes for our processing engine to read the input, perform the computation, and write back the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050454Z" creationid="xccui" creationdate="20190401T150338Z">
        <seg>对批处理应用而言，我们通常会关心作业的总执行时间，或者说处理引擎读取输入、执行计算、写回结果共需多长时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each distinct value of the key attribute, Flink maintains one state instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T035553Z" creationid="xccui" creationdate="20190630T035553Z">
        <seg>对于每一个键值，Flink都会维护一个状态实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each event in the input stream, a task is a processing step that performs the fol‐ lowing steps: (1) receives the event, storing it in a local buffer; (2) possibly updates internal state; and (3) produces an output record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T190522Z" creationid="xccui" creationdate="20190606T033527Z">
        <seg>对于输入流中的每个事件，任务都需要执行以下步骤：（1）接收事件并将它们存在本地缓冲区；（2）选择性地更新内部状态；（3）产生输出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each event in the input stream, a task performs the following steps: (1) receive the event, i.e. store it in a local buffer, (2) possibly update internal state, and (3) produce an output record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042612Z" creationid="xccui" creationdate="20190415T042352Z">
        <seg>对于输入流中的每个事件，任务都需要执行以下步骤：（1）接收事件（将它们存在本地缓冲）；（2）有可能更新内部状态；（3）产生输出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each expired timer, the task invokes a call-back function that can perform a computation and emit records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042230Z" creationid="xccui" creationdate="20190529T042140Z">
        <seg>对于每个到期的定时器，调用回调函数，利用它来执行计算和发出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each expired timer, the task invokes a callback function that can perform a computation and emit records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190606T212941Z">
        <seg>对于每个到期的计时器，调用回调函数，利用它来执行计算并发出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each incoming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052406Z" creationid="xccui" creationdate="20190614T052406Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each input event, the processElement() method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T211737Z" creationid="xccui" creationdate="20190704T211737Z">
        <seg>对于每个输入事件，都会调用processElement()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each key and timestamp, exactly one timer can be registered, which means each key can have multiple timers but only one for each timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T064209Z">
        <seg>对于每个键值和时间戳只能注册一个计时器。换言之，每个键值可以有多个计时器，但对应每个时间戳只能有一个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For exam&lt;t0/&gt;‐&lt;t1/&gt; ple, the data of an order processing system can be analyzed to obtain sales growth over time, to identify reasons for delayed shipments, or to predict future sales in order to adjust the inventory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T182744Z" creationid="xccui" creationdate="20190228T182744Z">
        <seg>例如：通过分析订单处理系统中的数据来获知销售增长率、分析运输延迟原因、预测销售量以调整库存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example they need to be normalized, joined or enriched with additional data, or pre-aggregated, i.e., transformations that are also commonly performed by ETL processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T013802Z" creationid="xccui" creationdate="20190314T073857Z">
        <seg>例如：标准化，与其他数据连接或丰富数据，预聚合等一系列在ETL过程中的常见变换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, MapState is backed by a Java HashMap object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221941Z" creationid="xccui" creationdate="20190703T221941Z">
        <seg>例如，MapState的后端其实是Java HashMap对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a MapFunction does</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T043236Z" creationid="xccui" creationdate="20190621T043236Z">
        <seg>例如，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a sink operator that writes the results and updates of a keyed window operator to a key-value store could do this by overriding inaccu‐ rate results with the latest update using upsert writes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T163859Z" creationid="xingcan" creationdate="20190628T163859Z">
        <seg>例如，为了实现此目的，一个用于将键值窗口算子的结果及更新写入键值存储的数据汇算子，可以通过upsert写入模式将之前的非精确结果替换为最近一次更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a time-window operator assigns records to windows according to their associated timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040311Z" creationid="xccui" creationdate="20190523T040311Z">
        <seg>例如，时间窗口算子会根据记录关联的时间戳将其分配到窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a time-window task finalizes a window computa&lt;t0/&gt;‐&lt;t1/&gt; tion and emits the result when the task event-time passes the window’s end boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T041949Z" creationid="xccui" creationdate="20190523T041914Z">
        <seg>例如：基于时间窗口的任务会在其事件时间超过窗口结束边界时确定最终的窗口进行计算并发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a time-window task finalizes a window computa‐ tion and emits the result when the task event-time passes the window’s end boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205223Z" creationid="xccui" creationdate="20190606T205223Z">
        <seg>例如：基于时间窗口的任务会在其事件时间超过窗口结束边界时确定最终的窗口进行计算并发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a window operator can group the events of a stream into windows of 5 minutes and count for each window how many events have been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T033648Z" creationid="xccui" creationdate="20190622T033648Z">
        <seg>举例而言，窗口算子可以将数据流中的事件按照每5分钟的窗口进行分组，并计算每个窗口中接收的事件数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a window operator registers a timer for every active window, which cleans up the window’s state when the event time passes the window’s ending time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190606T211126Z">
        <seg>例如：窗口算子会为每个活动窗口注册一个计时器，它们会在事件时间超过窗口的结束时间时清理窗口状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an assigner with a size of one hour will define windows at 00:00:00, 01:00:00, 02:00:00, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054104Z" creationid="xccui" creationdate="20190623T054104Z">
        <seg>例如，大小为1小时的分配器将会在00:00:00、01:00:00、02:00:00……时间定义窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an average latency value of 10 ms means that events are processed within 10 ms on average.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234026Z" creationid="xccui" creationdate="20190605T234026Z">
        <seg>例如：平均延迟为10毫秒表示平均每条数据会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an average latency value of 10ms means that events&lt;t8/&gt; &lt;t9/&gt;are processed within 10ms on average.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T155133Z" creationid="xccui" creationdate="20190401T154841Z">
        <seg>例如：平均延迟10毫秒表示平均每条数据会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, computing running</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T183351Z" creationid="xccui" creationdate="20190704T183351Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, determining whether a specific event occurs in the input stream can be correctly realized with at-least-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193111Z" creationid="xccui" creationdate="20190416T042315Z">
        <seg>例如：确定某个事件是否在输入流中出现过，就可以利用至少一次保障正确地实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if all users in a team pop 500 bubbles within one minute, they get a level-up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154431Z" creationid="xccui" creationdate="20190411T145904Z">
        <seg>（例如：如果团队所有成员在一分钟内消除了500个泡泡，他们就会提升一级）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are processing a stream of measurements from a set of sensors, you can use a parti‐ tioned operator state to maintain state for each sensor independently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T184007Z" creationid="xccui" creationdate="20190606T032927Z">
        <seg>举例而言，如果你要处理从一组传感器得到的测量值数据流，则可以用分区算子状态（partitioned operator state）来单独维护每个传感器的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are processing a stream of measurements from a set of sensors, you can use partitioned operator state to maintain state for each sensor inde&lt;t3/&gt;‐&lt;t4/&gt; pendently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T034432Z" creationid="xccui" creationdate="20190415T033859Z">
        <seg>举例而言，如果你要处理从一组传感器得到的测量值数据流，则可以用分组算子状态（partitioned operator state）来独立地维持每个传感器的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you are the first customer showing up at the coffee shop right after it opened its doors in the morning, you will be served immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052839Z" creationid="xccui" creationdate="20190605T234700Z">
        <seg>这就如同你是早晨咖啡店开门后的首位顾客，会立即享受服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, information for a product that is offered in a webshop can be stored in a transactional database, a web cache, and a search index.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T070514Z" creationid="xccui" creationdate="20190314T065839Z">
        <seg>例如：网店内某产品的信息可能会同时放到事务型型数据库、网站缓存以及搜索索引中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it can make sense to break a long pipeline of chained tasks or break a chain into two tasks to schedule an expensive function to different slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T201955Z" creationid="esouser" creationdate="20190514T154252Z">
        <seg>举例而言，有时候我们需要对过长任务链接进行切分或者将两个计算量大的函数分配到不同的处理槽中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, most operators for Flink’s SQL support are implemented using process functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T044544Z" creationid="xccui" creationdate="20190621T044544Z">
        <seg>例如，大多数Flink SQL所支持的算子都是利用处理函数实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, once data has been emitted to a sink, it is hard to guarantee result correctness, since the sink might not provide transactions to revert results that have been previously written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050731Z" creationid="xccui" creationdate="20190415T050222Z">
        <seg>举例而言，一旦数据从数据汇中写出，结果正确性将难以保障。原因在于，数据汇可能不提供事务来恢复之前写入的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, sink functions that aim to write data to external systems with exactly-once guarantees must only emit records that were received before a successful checkpoint to ensure the received data will not be recomputed in the case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T200602Z" creationid="xccui" creationdate="20190702T181000Z">
        <seg>例如：数据汇函数为了以精确一次语义将数据写入外部系统，只能发出那些在检查点成功创建前收到的记录。这样做是为了保证在出现故障时不会重复发送收到的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the FileSystem state backend and the RocksDB state backend support asynchronous checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202717Z" creationid="xccui" creationdate="20190609T202658Z">
        <seg>举例而言，文件系统状态后端和RocksDB状态后端支持异步生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the data of an order processing system can be analyzed to obtain sales growth over time, to identify reasons for delayed shipments, or to predict future sales in order to adjust the inventory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T024556Z" creationid="esouser" creationdate="20190603T201909Z">
        <seg>例如：通过分析订单处理系统中的数据来获知销售增长率，通过分析运输延迟原因或预测销售量以调整库存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the default triggers of the pre‐ viously discussed time windows fire when the processing time or the watermark exceed the timestamp of the window’s end boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T182151Z" creationid="xccui" creationdate="20190626T182151Z">
        <seg>对之前讨论的时间窗口而言，其默认触发器会在处理时间或水位线超过了窗口结束边界的时间戳时触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following Java class will be identified as a POJO by Flink:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044720Z" creationid="xccui" creationdate="20190617T044720Z">
        <seg>例如，以下Java类就会被Flink识别为POJO：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to finalize windows when the event-time passes their end boundaries, a time-window task registers a timer for the ending time of each of its active windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041839Z" creationid="xccui" creationdate="20190529T041558Z">
        <seg>例如：为了在事件时间越过结束边界时最终确定窗口，时间窗口任务会根据当前活动窗口的结束时间注册定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, user interactions with a series of news articles one after the other could be considered a session.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025919Z" creationid="xccui" creationdate="20190407T025745Z">
        <seg>例如：用户浏览一连串新闻文章的交互过程可以看作一个会话。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, with RocksDBStateBackend it is more efficient to use MapState[X, Y] instead of ValueState[HashMap[X, Y]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T034135Z" creationid="xccui" creationdate="20190704T034135Z">
        <seg>例如，针对RocksDBStateBackend，使用MapState[X, Y]要比ValueState[HashMap[X, Y]更高效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, writing a program that uses several chunks of code from this book does not require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210818Z" creationid="esouser" creationdate="20190603T210818Z">
        <seg>For example, writing a program that uses several chunks of code from this book does not require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can implement triggering logic to fire when the window receives a certain number of elements, when an ele‐ ment with a specific value is added to the window, or after detecting a pattern on added elements like “two events of the same type within 5 seconds.” A custom trigger can also be used to compute and emit early results from an event-time window, before the watermark reaches the window’s end timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184024Z" creationid="xccui" creationdate="20190626T183807Z">
        <seg>举例而言，你可以在触发器中实现以下触发逻辑：窗口接收到一定数量的元素，含有某个特定值的元素加入窗口，或检测到添加的元素满足某种模式（如5秒内出现了两个相同类型的事件）。自定义触发器还可以用来在水位线到达窗口的结束时间戳以前，为事件时间窗口计算并发出早期结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example: “Stream Processing with Apache Flink by Fabian Hueske and Vasiliki Kalavri (O’Reilly).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210824Z" creationid="esouser" creationdate="20190603T210824Z">
        <seg>For example: “Stream Processing with Apache Flink by Fabian Hueske and Vasiliki Kalavri (O’Reilly).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a time-window operator task attaches the end time of a window as the timestamp to all records emitted by the window computation before it emits the watermark with the timestamp that triggered the computation of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T013912Z" creationid="xccui" creationdate="20190607T013520Z">
        <seg>例如：时间窗口算子任务会在发送触发窗口计算的水位线时间戳之前，为所有经过窗口计算并发出的结果附加窗口的结束时间作为它们的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a window operator collects input records for</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T031720Z" creationid="xccui" creationdate="20190630T031720Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, assume you join two streams with a join operator that is configured with 1-hour tumbling window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T055055Z" creationid="xccui" creationdate="20190628T055055Z">
        <seg>例如，假设你为执行Join操作的算子配置了1小时的滚动窗口，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, event logs like Apache Kafka can provide records from a previous offset of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044504Z" creationid="xccui" creationdate="20190609T044407Z">
        <seg>例如，类似Apache Kafka的事件日志系统就允许从之前的某个偏移读取记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if we are using a dis&lt;t2/&gt;‐&lt;t3/&gt; tributed processing engine, each operator might have several parallel tasks running on different physical machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T003110Z" creationid="xccui" creationdate="20190401T002829Z">
        <seg>例如：当我们使用分布式处理引擎，每个算子可能会在不同物理机器上运行多个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if we are using a distributed processing engine, each operator might have several parallel tasks running on different physical machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044323Z" creationid="xccui" creationdate="20190605T233104Z">
        <seg>例如：当我们使用分布式处理引擎时，每个算子可能会在不同物理机器上运行多个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if we know that the load</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T065829Z" creationid="xccui" creationdate="20190615T065827Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you are receiving meas&lt;t4/&gt;‐&lt;t5/&gt; urements from different sensors, you probably want to group the stream by sensor id before applying a window computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195017Z" creationid="xccui" creationdate="20190409T194251Z">
        <seg>例如，如果你在收集来自不同传感器的测量值，那么可能会想在应用窗口计算前按照传感器id对数据流进行划分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you are receiving measurements from different sensors, you probably want to group the stream by sensor ID before applying a window computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013856Z" creationid="xccui" creationdate="20190606T013849Z">
        <seg>例如，如果你在收集来自不同传感器的测量值，那么可能会想在应用窗口计算前按照传感器ID对数据流进行划分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in a stand-alone setup, i.e., a setup without a resource provider, the ResourceManager can only distribute the slots of available TaskManagers and cannot start new TaskManagers on its own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062146Z" creationid="xccui" creationdate="20190423T025023Z">
        <seg>例如：独立集群设置中没有资源提供者，因此ResourceManager只能分配现有TaskManager中的处理槽而无法自己启动新的TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in a standalone setup—a setup without a resource provider—the ResourceManager can only distribute the slots of available TaskManagers and cannot start new TaskManag‐ ers on its own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T062709Z" creationid="xccui" creationdate="20190606T143258Z">
        <seg>例如：独立集群设置下没有资源提供者，因此ResourceManager只能分配现有TaskManager中的处理槽而无法自己启动新的TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the RocksDB state backend supports incremental checkpoints, which can significantly reduce the checkpointing overhead for very large state sizes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155142Z" creationid="xccui" creationdate="20190608T053953Z">
        <seg>举例而言，RocksDB状态后端支持增量检查点，对于大规模的状态，这会显著降低生成检查点的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you might be interested in measuring how the stream is observed and count events per second in order to detect possible outages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052851Z" creationid="xccui" creationdate="20190414T045116Z">
        <seg>例如，你可能会有兴趣监测数据流的接入情况或通过计算每秒事件数来发现潜在的数据中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you might be interested in observing the stream and counting the number of events per second to detect outages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181051Z" creationid="xccui" creationdate="20190606T031132Z">
        <seg>例如，你可能想观察数据流的接入情况，通过计算每秒事件数来检测数据中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you might want to know how many vehicles cross an intersection every 5 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T044551Z" creationid="xccui" creationdate="20190406T043731Z">
        <seg>例如，你可能想了解某路口每5分钟的车流量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For larger setups, you need to tune the configuration as described in &lt;t2/&gt;Chapter 9&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045859Z" creationid="xccui" creationdate="20190504T045853Z">
        <seg>而对于大型设置场景，需要根据第9章的介绍调节配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For larger setups, you need to tune the configuration as described in “Main Memory and Network Buffers” on page 240.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193803Z" creationid="xccui" creationdate="20190606T201833Z">
        <seg>而对于大型使用场景，需要根据第240页"内存和网络缓冲"一节所介绍的内容调整配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For leader election in highly available setups, Flink depends on Apache ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T044706Z" creationid="xccui" creationdate="20190606T140816Z">
        <seg>它依赖Apache ZooKeeper来完成高可用性设置中的领导选举工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For leader election in highly-available setups, Flink depends on Apache ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032403Z" creationid="xccui" creationdate="20190418T032403Z">
        <seg>Flink依赖Apache ZooKeeper来完成高可用设置中的领导选举过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For local state management, a state backend stores all keyed states and ensures that all accesses are correctly scoped to the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190608T051526Z">
        <seg>对于本地状态管理，状态后端会存储所有键值分区状态并保证能将状态访问范围正确地限制在当前键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For low-level operations on two inputs, the DataStream API also provides the CoProcessFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T024409Z" creationid="xccui" creationdate="20190622T024145Z">
        <seg>针对有两个输入的低层操作，DataStream API还提供了CoProcessFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about our books, courses, conferences, and news, see our web‐ site at http://www.oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210844Z" creationid="esouser" creationdate="20190603T210844Z">
        <seg>For more information about our books, courses, conferences, and news, see our web‐ site at http://www.oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, contact our corporate/institutional sales department: 800-998-9938 or corporate@oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210718Z" creationid="esouser" creationdate="20190603T210718Z">
        <seg>For more information, contact our corporate/institutional sales department: 800-998-9938 or corporate@oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, please visit http://oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210834Z" creationid="esouser" creationdate="20190603T210834Z">
        <seg>For more information, please visit http://oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some operators it can be important to know whether a checkpoint completed or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025955Z" creationid="xccui" creationdate="20190702T171255Z">
        <seg>对一些算子而言，了解检查点的完成情况非常重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some storage systems, Flink provides sink functions that feature exactly-once output, for example, by committing emitted records on checkpoint completion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054217Z" creationid="xccui" creationdate="20190609T053939Z">
        <seg>对于某些存储系统，Flink提供的数据汇函数支持精确一次输出，例如，在检查点完成后才会把写出的记录正式提交。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some use cases it might also be necessary to distinguish between the first result and an update due to a late event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164011Z" creationid="xingcan" creationdate="20190628T164011Z">
        <seg>对大多数用例而言，可能还要对第一次的结果和由于迟到事件产生的更新结果加以区分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For state backends that de/serialize state objects when reading or writing, such as RocksDBStateBackend, the choice of the state primitive (ValueState, ListState, or MapState) can have a major impact on the performance of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T031531Z" creationid="xccui" creationdate="20190704T031531Z">
        <seg>对于那些在读写状态时涉及对象序列化和反序列化的状态后端（如RocksDBStateBackend），状态原语（ValueState、ListState或MapState）的选择将对应用性能产生决定性的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For such advanced applications, a good understanding of Flink’s internal time handling is often helpful and sometimes required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204542Z" creationid="xccui" creationdate="20190523T034809Z">
        <seg>在面对这些高级应用时，充分理解Flink内部事件处理机制通常会有所帮助，有时也是必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For such applications,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010015Z" creationid="xccui" creationdate="20190624T010015Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For such cases, Flink provides the BoundedOutOfOrder nessTimeStampExtractor, which takes the maximum expected lateness as an argu‐ ment:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052854Z" creationid="xccui" creationdate="20190620T052854Z">
        <seg>针对这种情况，Flink提供了BoundedOutOfOrdernessTimeStampExtractor，它接收一个表示最大预期延迟的参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the first input, all records with timestamps larger than the current watermark—the upper bound— are buffered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T031701Z" creationid="xccui" creationdate="20190628T031631Z">
        <seg>对第一个输入而言，所有时间戳大于当前水位线减去间隔上界的数据都会被缓冲起来；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the second input, all records with timestamps larger than the current watermark + the lower bound are buffered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T031913Z" creationid="xccui" creationdate="20190628T031643Z">
        <seg>对第二个输入而言，所有时间戳大于当前水位线加上间隔下界的数据都会被缓冲起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this example, your system needs Java 8 installed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122651Z" creationid="xccui" creationdate="20190605T122651Z">
        <seg>为此你需要先安装Java 8。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this your system needs to have Java 8 installed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T055409Z" creationid="xccui" creationdate="20190328T055216Z">
        <seg>为此你需要先安装Java 8。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, in many cases, you can partition the state by a key and manage the state of each partition independently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T183735Z" creationid="xccui" creationdate="20190415T033542Z">
        <seg>幸运的是，在很多情况下可以把状态按照键值划分，并独立管理每一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Framework style</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143403Z" creationid="xccui" creationdate="20190606T143403Z">
        <seg>框架模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Framework style&lt;t0/&gt;: In this mode, Flink applications are packaged into a JAR file and&lt;t1/&gt; &lt;t2/&gt;submitted by a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030257Z" creationid="xccui" creationdate="20190423T025356Z">
        <seg>框架模式：在本模式下，Flink应用会打包成一个JAR文件并通过客户端提交到运行的服务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Frequent synchronization is a major reason for performance limitations in dis‐ tributed systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T164151Z" creationid="xccui" creationdate="20190702T163542Z">
        <seg>频繁的同步是分布式系统产生性能瓶颈的主要原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From a savepoint-compatibility point of view this means an application can be evolved in three ways:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035308Z" creationid="xccui" creationdate="20190705T035308Z">
        <seg>从保存点兼容性的角度来看，应用可以通过以下三种方式进行更新：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From there, the late events can be processed or emitted using a regular sink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154751Z" creationid="xingcan" creationdate="20190628T154541Z">
        <seg>这样就可以对它们进行后续处理或利用常规的数据汇函数将其写出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FsStateBackend stores the local state on the TaskManager’s JVM heap, just like MemoryStateBackend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T021829Z" creationid="xccui" creationdate="20190704T021829Z">
        <seg>FsStateBackend和MemoryStateBackend一样，将本地状态保存在TaskManager的JVM堆内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Full window functions collect all elements of a window and iterate over the list of all collected elements when they are evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211513Z" creationid="xccui" creationdate="20190623T211046Z">
        <seg>全量窗口函数，它会收集窗口内的所有元素，并在这些元素需要执行计算时对其进行遍历。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Full window functions usually require more space but allow for more complex logic than incremental aggrega‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211518Z" creationid="xccui" creationdate="20190623T211421Z">
        <seg>虽然全量窗口函数通常需要占用更多空间，但它和增量聚合函数相比，支持更复杂的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022917Z" creationid="xccui" creationdate="20190225T022917Z">
        <seg>函数类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>FunctionSnapshotCon text gives access to the unique identifier of the checkpoint and the timestamp when the JobManager initiates the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071501Z" creationid="xccui" creationdate="20190702T071501Z">
        <seg>从FunctionSnapshotContext中，我们可以得到检查点的唯一标识以及JobManager初始化检查点时的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions Must Be Java Serializable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055059Z" creationid="xccui" creationdate="20190618T055059Z">
        <seg>函数必须是Java可序列化的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are called with data objects and emit data objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T062947Z" creationid="xccui" creationdate="20190616T062947Z">
        <seg>函数在调用时会传入数据对象，同时它也可以发出数据对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are not able to read or modify record timestamps and watermarks, except for the &lt;t0/&gt;ProcessFunc&lt;t1/&gt; &lt;t2/&gt;tion &lt;t3/&gt;which can read the timestamp of a currently processed&lt;t4/&gt; &lt;t5/&gt;record, request the current event-time of the operator, and register timers&lt;t6/&gt;4&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T140632Z" creationid="esouser" creationdate="20190603T140632Z">
        <seg>Flink中的普通函数无法读写记录的时间戳或水位线。但有一个例外——ProcessFunction，它可以读取当前正在处理记录的时间戳，请求获取当前算子的事件时间以及注册定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are written by the application programmer and implement custom computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060723Z" creationid="xccui" creationdate="20190606T011456Z">
        <seg>函数由应用开发人员编写，可用来实现某些自定义的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can also be implemented as anonymous classes:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054230Z" creationid="xccui" creationdate="20190618T054230Z">
        <seg>还可以通过匿名类来实现函数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can receive parameters through their constructor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054311Z" creationid="xccui" creationdate="20190618T054311Z">
        <seg>函数可以通过其构造函数接收参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can reuse Java tuples in order to reduce the pressure on the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040423Z" creationid="xccui" creationdate="20190617T040423Z">
        <seg>函数可以重用Java元组以减轻垃圾回收器的压力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions cannot read or modify record time‐ stamps and watermarks, except for the process functions, which  can read the timestamp of a currently processed record, request the current event time of the operator, and register timers.3 None of the functions exposes an API to set the timestamps of emitted records, manipulate the event-time clock of a task, or emit watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190607T012544Z">
        <seg>普通函数无法读写记录的时间戳或水位线，但一系列处理函数除外，它们可以读取当前正在处理记录的时间戳，请求获得当前算子的事件时间以及注册计时器。3所有函数都无法通过API来设置发出记录的时间戳，调整任务的事件时间时钟或发出水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions, such as</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020745Z" creationid="xccui" creationdate="20190613T020745Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fundamentals, Implementation, and Operation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041340Z" creationid="esouser" creationdate="20190603T142422Z">
        <seg>流式应用基础、实现及操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further, it includes methods for accessing partitioned state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033725Z" creationid="xccui" creationdate="20190619T033527Z">
        <seg>另外它还提供了访问分区状态的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, Flink can reset the state of an application to a previous savepoint, making it possible to evolve or rescale an application without losing its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T053639Z" creationid="xccui" creationdate="20190604T052208Z">
        <seg>此外，Flink可以将应用状态重置到之前的某个检查点，从而允许应用在不丢失状态的前提下更新或扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gelly for Graph Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152554Z" creationid="esouser" creationdate="20190603T152554Z">
        <seg>用于图计算的Gelly</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Give your project a name and click Finish</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041704Z" creationid="xccui" creationdate="20190611T041704Z">
        <seg>为项目命名，然后单击Finish</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a Flink setup with four TaskManagers that provide two slots each, a streaming application can be executed with a maximum par&lt;t0/&gt;‐&lt;t1/&gt; allelism of eight.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205754Z" creationid="xccui" creationdate="20190428T205630Z">
        <seg>假设一个Flink设置包含4个TaskManager，每个TaskManager有2个处理槽，那么一个流式应用最多运行以并行度8来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given a Flink setup with four TaskManagers that provide two slots each, a streaming application can be executed with a maximum par‐ allelism of eight.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145448Z" creationid="xccui" creationdate="20190606T145448Z">
        <seg>假设一个Flink设置包含4个TaskManager，每个TaskManager有2个处理槽，那么一个流式应用最多运行以并行度8来运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an application and a compatible savepoint, you can start the application from the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211347Z" creationid="xccui" creationdate="20190609T211347Z">
        <seg>给定一个应用和一个兼容的保存点，可以从该保存点启动应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the unpredictable reality of distributed systems and arbitrary delays that might be caused by external components, there are no categorically cor‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025236Z" creationid="xccui" creationdate="20190606T025236Z">
        <seg>鉴于分布式系统现实的不确定性以及外部组件可能引发任意延迟，这些问题没有绝对正确的答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the unpredictable reality of distributed systems and arbitrary delays that might be caused by external components, there is no categorically correct answer to these questions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T204356Z" creationid="xccui" creationdate="20190412T203922Z">
        <seg>鉴于分布式系统现实的不确定性以及外部组件可能引发任意延迟，这些问题没有绝对正确的答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given two TaskManag&lt;t0/&gt;‐&lt;t1/&gt; ers with two processing slots each, this requirement is fulfilled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T163329Z" creationid="xccui" creationdate="20190423T043703Z">
        <seg>给定两个TaskManager，每个TaskManager内都有两个处理槽，即可满足该需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given two TaskManagers with two processing slots each, this requirement is fulfilled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071124Z" creationid="xccui" creationdate="20190606T144546Z">
        <seg>如果每个TaskManager内有两个处理槽，则给定两个TaskManager即可满足该需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045801Z" creationid="xccui" creationdate="20190616T045801Z">
        <seg>全局</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global state can be used to share</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024915Z" creationid="xccui" creationdate="20190624T024915Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global state refers to the keyed state that is not scoped to any window, while per-window state refers to the window instance that is currently being evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190624T012655Z">
        <seg>其中单个窗口的状态指的是当前正在计算的窗口实例的状态，而全局状态指的是不属于任何一个窗口的键值分区状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go to the Apache Flink webpage &lt;t0/&gt;flink.apache.org&lt;t1/&gt; &lt;t2/&gt;and download the Hadoop-free binary distribution of Apache Flink 1.7.1 for Scala 2.12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T024852Z" creationid="xccui" creationdate="20190329T024852Z">
        <seg>从Apache Flink官网flink.apache.org下载支持Scala 2.12的Apache Flink 1.7.1无Hadoop二进制发行版。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Go to the Apache Flink webpage and download the Hadoop-free binary distribu‐ tion of Apache Flink 1.7.1 for Scala 2.12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201150Z" creationid="xccui" creationdate="20190605T123020Z">
        <seg>从Apache Flink官网flink.apache.org下载支持Scala 2.12的Apache Flink 1.7.1 Hadoop-free二进制发行版。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gravenstein Highway North Sebastopol, CA 95472</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210839Z" creationid="esouser" creationdate="20190603T210839Z">
        <seg>Gravenstein Highway North Sebastopol, CA 95472</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HA Kubernetes Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152240Z" creationid="esouser" creationdate="20190603T152240Z">
        <seg>Kubernetes的HA设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HA Standalone Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152203Z" creationid="esouser" creationdate="20190603T152203Z">
        <seg>独立集群的HA设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HA YARN Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152218Z" creationid="esouser" creationdate="20190603T152218Z">
        <seg>YARN上的HA设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Late Data</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150755Z" creationid="xccui" creationdate="20190225T023322Z">
        <seg>处理迟到数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Late Data | 149</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042128Z" creationid="xccui" creationdate="20190629T042128Z">
        <seg>处理迟到数据 | 149</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Late Data | 151</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042139Z" creationid="xccui" creationdate="20190629T042139Z">
        <seg>处理迟到数据 | 151</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling delayed events is only one of the challenges that you can overcome with event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160251Z" creationid="xccui" creationdate="20190412T151554Z">
        <seg>使用事件时间要克服的挑战之一是如何处理延迟事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having no guaran&lt;t0/&gt;‐&lt;t1/&gt; tees whatsoever sounds like a terrible idea, but it might be fine, if you can live with approximate results and all you care about is providing the lowest latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041743Z" creationid="xccui" creationdate="20190415T184946Z">
        <seg>无论如何，没有保障听上去都不是个好主意。但如果你能接受近似结果并且只关心提供尽可能低的延迟，这种保障可能没多大问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having no guarantees whatsoever sounds like a terrible idea, but it might be fine if you can live with approximate results and all you care about is providing the lowest latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T192756Z" creationid="xccui" creationdate="20190606T034436Z">
        <seg>无论如何，没有保障听上去都像是个馊主意。但如果你能接受近似结果并且一门心思地关注怎样降低延迟，这种保障似乎也可以接受。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hello, Flink!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035709Z" creationid="xccui" creationdate="20190418T035709Z">
        <seg>Hello, Flink!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, FsStateBackend provides in-memory speed for local</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T022632Z" creationid="xccui" creationdate="20190704T022405Z">
        <seg>因此，FsStateBackend既让本地访问拥有了内存的速度，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a Java JDK is required to implement Flink DataStream applications—Java JDK 8 (or higher).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T015629Z" creationid="xccui" creationdate="20190611T014959Z">
        <seg>因此在写DataStream 应用之前需要安装Java JDK 8或更高版本，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a late arriving ele‐ ment will not create a new window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T153917Z" creationid="xingcan" creationdate="20190628T153654Z">
        <seg>因此，迟到元素将不会创建新的窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a single misbehaving task can kill a whole TaskManager process and all tasks that run on it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071442Z" creationid="xccui" creationdate="20190606T144925Z">
        <seg>因此只要有一个任务运行异常，就会终止整个TaskManager进程，导致它上面运行的所有任务都停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a single misbehaving task can kill a whole TaskManager process and all tasks which run on the TaskManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063433Z" creationid="xccui" creationdate="20190424T063420Z">
        <seg>因此只要有一个任务运行异常，就会终止整个TaskManager进程，它上面运行的所有任务都会随之停止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a trigger must clear all of its state in the Trigger.clear() method to prevent</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040852Z" creationid="xccui" creationdate="20190626T040750Z">
        <seg>所以说，为了避免状态泄露，触发器需要在Trigger.clear()方法中清除自身所有状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a typical application consists of multiple states that are distributed across multiple operator tasks that can run on different TaskManager processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214735Z" creationid="xccui" creationdate="20190609T214705Z">
        <seg>因此一个典型的应用会包含多个状态，它们分布在不同TaskManager进程内的算子任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, a window object</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033855Z" creationid="xccui" creationdate="20190626T033855Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, all data that is required to recover from a Job&lt;t2/&gt;‐&lt;t3/&gt; Manager failure is stored in the remote storage and ZooKeeper holds pointers to the storage locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051205Z" creationid="xccui" creationdate="20190502T051143Z">
        <seg>因此所有用于JobManager故障恢复的数据都在远程存储上面，而ZooKeeper持有指向这些存储位置的指针。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, all data that is required to recover from a JobManager failure is stored in the remote storage and ZooKeeper holds pointers to the storage locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073351Z" creationid="xccui" creationdate="20190606T194220Z">
        <seg>因此所有用于JobManager故障恢复的数据都在远程存储上面，而ZooKeeper持有这些存储位置的路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, credit-based flow control is an important building block for Flink to achieve high throughput and low latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T195939Z" creationid="esouser" creationdate="20190514T151545Z">
        <seg>不难看出，基于信用值的流量控制是Flink实现高吞吐低延迟的重要一环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, data transfer between tasks that run on the same TaskManager does not cause network communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194344Z" creationid="xccui" creationdate="20190606T202123Z">
        <seg>这意味着同一个TaskManager内不同任务之间的数据传输不会引起网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it can be useful to run stand-by JobManagers and TaskManagers that can take over the work of failed processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T040555Z" creationid="xccui" creationdate="20190504T040147Z">
        <seg>因此运行一些后备JobManager及TaskManager来接管故障进程的工作会很有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it can be useful to run standby JobManagers and TaskManagers that can take over the work of failed processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T074242Z" creationid="xccui" creationdate="20190606T195220Z">
        <seg>因此有必要运行一些后备JobManager及TaskManager来接管故障进程的工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it is important that their execution does not stop even if an involved process fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072033Z" creationid="xccui" creationdate="20190424T064522Z">
        <seg>因此对于它很重要的一点是即便内部进程发生故障时也不能终止运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it is not difficult to update an application by removing stateful operators or state from an existing operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043616Z" creationid="xccui" creationdate="20190705T043616Z">
        <seg>因此，通过删除状态化算子或其中的状态来更新应用其实并不困难。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it should be ignored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T061338Z" creationid="xccui" creationdate="20190618T061338Z">
        <seg>因此需要将其忽略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it will not be able to evict the state for the key because it might receive another record for the key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T182804Z" creationid="xccui" creationdate="20190704T170508Z">
        <seg>因此它根本无法准确移除某一键值的状态（因为不确定将来是否还有该键值的记录到来）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, its storage must be considered volatile.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053629Z" creationid="xccui" creationdate="20190608T053557Z">
        <seg>它们的存储只能看做是易失的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, keyed state is very similar to a distributed key-value map.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T035948Z">
        <seg>因此，键值分区状态看上去就像一个分布式键值映射（distributed key-value map）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, no events are lost and the state is completely built up from scratch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T191304Z" creationid="xccui" creationdate="20190606T034000Z">
        <seg>所以不会有任何事件丢失，状态也可以完全从最初开始构建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, no network communication is involved for a TaskManager-local connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T192436Z" creationid="esouser" creationdate="20190513T192419Z">
        <seg>因此对于TaskManager本地连接而言无须网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, only the JobManager can determine whether a check‐ point is successful or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T201942Z" creationid="xccui" creationdate="20190702T201832Z">
        <seg>因此，只有JobManager才能对此作出判断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, simply relying on watermarks might not always be a good idea.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025830Z" creationid="xccui" creationdate="20190414T031243Z">
        <seg>因此简单地依赖水位线并不总是可以高枕无忧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, split can also be used to filter or replicate events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053954Z" creationid="xccui" creationdate="20190615T053954Z">
        <seg>因此，split也可以用来过滤或复制事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the callback method has full access to the key’s state and can also clear it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T204118Z" creationid="xccui" creationdate="20190704T204118Z">
        <seg>因此在回调方法内你可以获得当前键值状态的完整访问权限并将其清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the elements of both input streams can be jointly processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T052207Z" creationid="xccui" creationdate="20190615T052207Z">
        <seg>这样一来，就可以联合处理两个输入流的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the identifier of an operator changes when one of its predecessors changes, for example, when an operator is added or removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T025037Z" creationid="xccui" creationdate="20190610T023325Z">
        <seg>这意味着任意一个前置算子的改变（例如：添加或删除某个算子）都会导致该标识发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the total state of an application must fit into</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T020451Z" creationid="xccui" creationdate="20190704T020451Z">
        <seg>因此JobManager的内存需要装得下应用的全部状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, there are basically no serialization and communication costs for pass&lt;t3/&gt;‐&lt;t4/&gt; ing records between functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153042Z" creationid="esouser" creationdate="20190514T153042Z">
        <seg>因此函数之间的记录传输基本上不存在序列化及通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, there are basically no serialization and communication costs for passing records between functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203739Z" creationid="xccui" creationdate="20190606T203739Z">
        <seg>因此函数之间的记录传输基本上不存在序列化及通信开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, they are as powerful as process functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T182328Z" creationid="xccui" creationdate="20190626T182328Z">
        <seg>因此它其实和处理函数一样强大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you can fix bugs in your application logic and reprocess as many events as your streaming source can provide in order to repair your results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212237Z" creationid="xccui" creationdate="20190609T212214Z">
        <seg>这意味着你可以修复应用的一些逻辑bug，然后在数据流来源的支持范围内下尽可能多地重新处理输入事件，以此来修复结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you might need to explicitly provide TypeInformation objects to Flink for some of the data types used in your application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061706Z" creationid="xccui" creationdate="20190617T061243Z">
        <seg>因此对于应用中的部分数据类型，可能需要你向Flink显式提供TypeInformation对象，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you might use</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T052635Z" creationid="xccui" creationdate="20190617T052635Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, you should be aware that you might debug a multithreaded program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T054146Z" creationid="xccui" creationdate="20190611T054146Z">
        <seg>所以你应该有可能要调试多线程程序的觉悟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example that processes a stream of Long values and increments each element:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070614Z" creationid="xccui" creationdate="20190616T070438Z">
        <seg>下面的示例处理一条Long值组成的数据流，对每个元素加一：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here we explain how to do this with a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T021444Z" creationid="xccui" creationdate="20190620T021444Z">
        <seg>此处我们只介绍使用用户自定义函数的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we briefly review some common data exchange strate&lt;t2/&gt;‐&lt;t3/&gt; gies, as shown in &lt;t4/&gt;Figure 2-3&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034906Z" creationid="xccui" creationdate="20190401T034747Z">
        <seg>下面我们结合图2-3来简单回顾一下常见的数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we briefly review some common data exchange strate‐ gies, as shown in Figure 2-3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045024Z" creationid="xccui" creationdate="20190605T233351Z">
        <seg>接下来，我们结合图2-3来简单回顾一下常见的数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we use a Scala case class as the data type that we defined before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051901Z" creationid="xccui" creationdate="20190612T051901Z">
        <seg>在这里我们使用事先定义好的Scala样例类作为数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly Available Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144306Z" creationid="esouser" creationdate="20190603T144306Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly Available Setups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152146Z" creationid="esouser" creationdate="20190603T152146Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Kubernetes Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025452Z" creationid="xccui" creationdate="20190225T025452Z">
        <seg>基于Kubernetes 的高可用设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021800Z" creationid="xccui" creationdate="20190225T021800Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Setups</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025425Z" creationid="xccui" creationdate="20190225T025425Z">
        <seg>高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available Stand-Alone Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025438Z" creationid="xccui" creationdate="20190225T025438Z">
        <seg>基于独立集群的高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Highly-Available YARN Setup</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025441Z" creationid="xccui" creationdate="20190225T025441Z">
        <seg>基于YARN的高可用性设置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How can you ensure that such failures are handled transparently so that your streaming job can continue to run?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185857Z" creationid="xccui" creationdate="20190415T041907Z">
        <seg>如何确保能够透明地处理这些故障，让流式作业得以继续运行？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How exactly the state is stored, accessed, and maintained is determined by a pluggable component</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051428Z" creationid="xccui" creationdate="20190608T051306Z">
        <seg>至于状态具体的存储、访问和维护，则是由一个名为状态后端的可插拔组件决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How exactly the state of a task is copied depends on the implementation of the state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202643Z" creationid="xccui" creationdate="20190609T202643Z">
        <seg>因此任务的状态具体是怎么拷贝的完全取决于状态后端的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to Contact Us</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210835Z" creationid="esouser" creationdate="20190603T210835Z">
        <seg>How to Contact Us</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How&lt;t6/&gt;‐&lt;t7/&gt; ever, too many co-located tasks can also overload a TaskManager and result in bad performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062808Z" creationid="xccui" creationdate="20190424T062808Z">
        <seg>然而，任务过于集中也会使TaskManager负载变高，继而导致性能下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, ProcessWindowFunction’s Context object also offers unique features.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011712Z" creationid="xccui" creationdate="20190624T011712Z">
        <seg>而ProcessWindowFunction的Context对象还提供了一些特有的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, UNIX-based setups enjoy the richest tooling support because this environment is preferred by most Flink developers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T054143Z" creationid="xccui" creationdate="20190610T041004Z">
        <seg>但基于类UNIX系统的设置会享有最丰富的工具支持，因为大多数Flink开发人员都偏爱这类环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a function with keyed state can only access the state of a key if it received a record with that key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T142046Z" creationid="xccui" creationdate="20190704T142046Z">
        <seg>然而，具有键值分区状态的函数只有在收到某键值的记录时才能访问该键值的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, adding a single value to ListState—appending it to the end of the list—is a cheap operation because only the appended value is serialized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T032817Z" creationid="xccui" creationdate="20190704T032817Z">
        <seg>但向ListState中添加一个值（将其附加到列表最后）的操作会相对轻量级一些，因为它只会序列化新添加的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, also with storage systems and execution engines of the Hadoop ecosystem the overall mode of operation of the infrastructure remains basically the same as the traditional data warehouse architec&lt;t2/&gt;‐&lt;t3/&gt; ture, i.e., data is periodically extracted and loaded into to a data store and processed by periodic or ad-hoc queries in a batch fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T040639Z" creationid="xccui" creationdate="20190301T034022Z">
        <seg>虽说如此，但对Hadoop生态中的存储系统和执行引擎而言，其基础工作模式仍和传统数据仓库的架构保持一致，即周期性地将数据提取加载到数据存储系统，随后以批处理的方式执行定期或ad-hoc查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, another implication is that the state of an application is never in a consis‐ tent state except for the logical points in time when a checkpoint is taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T170824Z" creationid="xccui" creationdate="20190702T164144Z">
        <seg>然而这也意味着除了生成检查点的几个逻辑时间点外，应用程序的状态无法做到强一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, applications can freely choose the meaning of the time&lt;t0/&gt;‐&lt;t1/&gt; stamps as long as the timestamps of the stream records are roughly ascending as the stream is advancing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035947Z" creationid="xccui" creationdate="20190523T035924Z">
        <seg>但实际上应用可以自由选择时间戳的含义，只要保证流记录的时间戳会随着数据流的前进大致递增即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, applications can freely choose the meaning of the timestamps as long as the timestamps of the stream records are roughly ascending as the stream is advancing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204846Z" creationid="xccui" creationdate="20190606T204846Z">
        <seg>但实际上应用可以自由选择时间戳的含义，只要保证流记录的时间戳会随着数据流的前进大致递增即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as you start writing more advanced streaming applica‐ tions, you might find yourself needing to implement more complex windowing logic, such as windows that emit early results and update their results if late elements are encountered, or windows that start and end when specific records are received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T050956Z" creationid="xccui" creationdate="20190625T050956Z">
        <seg>然而，当你着手写一些高级的流式应用时，可能会发现自己需要实现更为复杂的窗口逻辑，例如：窗口需要提前发出结果并在之后遇到迟到元素时对结果进行更新，或者窗口需要以特定记录作为开始或结束的边界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, counting how many times a specific event occurs in the input stream might return the wrong result under at-least-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T042923Z" creationid="xccui" creationdate="20190416T042900Z">
        <seg>但如果要计算某个事件在输入流中出现的次数，至少一次保障可能就会返回错误的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, custom operators can have their own interpretation and may, for example, adjust the preci‐ sion to microseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205054Z" creationid="xccui" creationdate="20190606T205029Z">
        <seg>但自定义算子可以有自己的解析机制，例如：将精度调整为微秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, custom operators can have their own interpretation and, for example, adjust the precision to microseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040846Z" creationid="xccui" creationdate="20190523T040820Z">
        <seg>但自定义算子可以有自己的解析机制，例如，将精度调整为微秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, during busy times, customers will have to wait in line and latency will increase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054122Z" creationid="xccui" creationdate="20190402T205216Z">
        <seg>然而，在高峰时段，顾客必须要排队，此时延迟将增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, even with continuous ETL there will always be a certain delay until an event is processed by a query.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032305Z" creationid="xccui" creationdate="20190317T032305Z">
        <seg>但即便使用持续ETL，事件在被查询处理到之前总会有一定延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, even with continuous ETL there will always be a delay until an event is processed by a query.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155201Z" creationid="xccui" creationdate="20190605T043619Z">
        <seg>但即便持续地进行ETL操作，事件在被查询和处理到之前总会有一定延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, event-time applications require additional configuration com‐ pared to applications with processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204315Z" creationid="xccui" creationdate="20190606T204315Z">
        <seg>但和基于处理时间语义的应用相比，基于事件时间的应用需要一些额外的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, event-time applications require some additional configuration compared to applications with processing-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T160953Z" creationid="esouser" creationdate="20190514T160953Z">
        <seg>但和基于处理时间语义的应用相比，基于事件时间的应用需要一些额外的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, guaranteeing exactly-once delivery of results to external systems is very challenging.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T050212Z" creationid="xccui" creationdate="20190415T045640Z">
        <seg>至于保证将结果精确一次地传递到外部系统，则难度很大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in certain situations, such as lambda functions or generic types, it is necessary to explicitly provide type information to make an application work or improve its performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065250Z" creationid="xccui" creationdate="20190616T064538Z">
        <seg>但在某些情况下，例如使用了lambda函数或泛型类型，则必须显式指定类型信息才能启动应用或提高其性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, instead of checkpointing the state to the JobMa‐ nager’s volatile memory, FsStateBackend writes the state to a remote and persis‐ tent file system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T022121Z" creationid="xccui" creationdate="20190704T022121Z">
        <seg>但它不会在创建检查点时将状态存到JobManager的易失内存中，而是会将它们写入远程持久化文件系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it can</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195737Z" creationid="xccui" creationdate="20190609T195737Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it has a few notable drawbacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193935Z" creationid="xccui" creationdate="20190605T052900Z">
        <seg>然而自身却有很多明显的缺点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is limited by the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T022926Z" creationid="xccui" creationdate="20190704T022926Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is possible to disable this safety check as described in “Running and Managing Streaming Appli‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043530Z" creationid="xccui" creationdate="20190705T043509Z">
        <seg>但你可以禁用这一安全检查（相关内容会在第245页"运行和管理流式应用"中介绍）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it relies on the fact that all partitions continuously provide increasing watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T031937Z" creationid="xccui" creationdate="20190607T031937Z">
        <seg>但这依赖于一个事实——所有分区都会持续提供自增的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it requires that all stateful operators of the initial version of an application specify two parameters to ensure the application can be properly maintained in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T012247Z" creationid="xccui" creationdate="20190702T214012Z">
        <seg>但它需要初始版本应用的全部状态化算子都指定好两个参数，才能在将来正常工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it uses the more general AggregateFunction to aggregate values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061036Z" creationid="xccui" creationdate="20190630T060806Z">
        <seg>但它使用了更加一般化的AggregateFunction来聚合内部的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, most real-world applications combine charac&lt;t0/&gt;‐&lt;t1/&gt; teristics of more than one class which again shows the flexibility of this application design pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T072733Z" creationid="xccui" creationdate="20190305T160041Z">
        <seg>而现实中绝大多数应用都同时兼有多种类别模式的特征，这也印证了状态化流处理的灵活性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, once we reach a rate of incoming events such that the system resources are fully used, we will have to start buffering events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T201505Z" creationid="xccui" creationdate="20190401T210044Z">
        <seg>但现实中，一旦事件到达速率过高致使系统没有空闲资源，我们将被迫开始缓冲事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, once we reach a rate of incoming events such that the sys‐ tem resources are fully used, we will have to start buffering events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053028Z" creationid="xccui" creationdate="20190605T234718Z">
        <seg>但现实中，一旦事件到达速率过高致使系统没有空闲资源，系统就会被迫开始缓冲事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, reading and writing data to disk and the over‐ head of de/serializing objects result in lower read and write performance com‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025404Z" creationid="xccui" creationdate="20190704T025404Z">
        <seg>然而，对于磁盘的读写和序列化反序列化对象的开销使得它和在内存中维护状态比起来，读写性能会偏低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, some improvements such as higher throughput and better failure guarantees came at the cost of increasing processing latencies from milliseconds to seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T194316Z" creationid="xccui" creationdate="20190327T035003Z">
        <seg>但它们的部分改进（例如更高的吞吐和更完善的故障处理保障）是以增加处理延迟（从毫秒级到秒级）为代价的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, some operations must collect and buffer records to compute their result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061737Z" creationid="xccui" creationdate="20190406T040646Z">
        <seg>然而，有些操作必须收集并缓冲记录才能计算结果，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, sometimes the type extractor fails or you might want to define your</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053221Z" creationid="xccui" creationdate="20190617T052957Z">
        <seg>但有时候类型提取器会失灵，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, sometimes we need access to all elements of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005942Z" creationid="xccui" creationdate="20190624T005942Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the applications for ReduceFunction are limited and usually restricted to simple aggregations since the input and output type must be the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002147Z" creationid="xccui" creationdate="20190624T002147Z">
        <seg>然而ReduceFunction的应用场景存在一定局限，由于输入、输出类型必须一致，所以通常仅限于一些简单的聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the approach had a few notable drawbacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T015901Z" creationid="xccui" creationdate="20190327T015901Z">
        <seg>但它有很多不足之处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the broadcast state handle that is returned in the processElement()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T051404Z" creationid="xccui" creationdate="20190702T051348Z">
        <seg>但processElement()方法返回的句柄对广播状态是只读的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the growing adoption of stream processing technology in the recent past has been driven to a large extent by the availability of mature open source stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160136Z" creationid="xccui" creationdate="20190605T050109Z">
        <seg>而近期流处理技术的普及在很大程度上还要归功于很多开源界成熟的流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the growing adoption of stream processing technology in the recent past is driven to a large extent by the availability of mature open source stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014756Z" creationid="xccui" creationdate="20190319T041536Z">
        <seg>然而近期流处理技术的普及还要归功于开源界很多成熟的流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the identifier of an operator is deterministically generated based on the identifiers of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T023205Z" creationid="xccui" creationdate="20190610T021226Z">
        <seg>但该标识是根据前置算子的标识按照某种确定规则生成的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the infrastructure remains basically the same as a traditional data ware‐ house architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T064902Z" creationid="esouser" creationdate="20190603T204255Z">
        <seg>然而，这些基础设施所用的架构只是和传统数据仓库大同小异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the reality is that we can never have perfect watermarks because that would mean we are always certain there are no delayed records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031843Z" creationid="xccui" creationdate="20190621T031325Z">
        <seg>但现实中永远不会有完美的水位线，因为总会存在迟到的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the state of a window that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034348Z" creationid="xccui" creationdate="20190625T034215Z">
        <seg>但和执行增量聚合的窗口相比，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the vision of the Flink community is to treat batch processing as a special case of stream processing, i.e., the processing of bounded streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060757Z" creationid="xccui" creationdate="20190328T060625Z">
        <seg>但Flink社区的视角是把批处理看做流处理的一个特例，即处理有界的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the vision of the Flink community is to treat batch processing as a special case of stream processing—the processing of bounded streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122214Z" creationid="xccui" creationdate="20190605T122214Z">
        <seg>但Flink社区的视角是把批处理看做流处理的一个特例，即处理有界的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are a few issues that need to be taken into account in order to be able to recompute and update results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T160700Z" creationid="xingcan" creationdate="20190628T160640Z">
        <seg>如果想重新计算和更新结果，就必需考虑几个问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are a few things to consider when debugging a Flink application in an IDE:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T053805Z" creationid="xccui" creationdate="20190611T053805Z">
        <seg>但在调试时需要注意一下几点：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is also a mode in which the call of the execute() method starts a Job‐ Manager and a TaskManager (by default with as many slots as available CPU threads) as separate threads within the same JVM. Consequently, the whole Flink application is multithreaded and executed within the same JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T052546Z" creationid="xccui" creationdate="20190611T052546Z">
        <seg>但除此之外还有一种执行模式：当execute()方法被调用时，会在同一个JVM中以独立线程的方式启动一个JobManager线程和一个TaskManager（默认的处理槽数等于???CPU可用线程数???）。这样，整个Flink应用会以多线程的方式在同一个JVM进程中执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they do not meet the latency requirements for many of today’s use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T153957Z" creationid="xccui" creationdate="20190604T055430Z">
        <seg>但这对于现如今很多用例场景而言无法满足延迟方面的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they have a very similar feature set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T052107Z" creationid="xccui" creationdate="20190621T052107Z">
        <seg>但是它们的功能都很相似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this has dramatically changed in the last decade.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T051715Z" creationid="xccui" creationdate="20190317T033023Z">
        <seg>然而，这在过去十年里发生了巨大的变化，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, to improve the efficiency of the necessary state transfer between tasks, Flink does not redistribute individual keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T055813Z" creationid="xccui" creationdate="20190608T055302Z">
        <seg>但为了降低状态在不同任务之间迁移的必要成本，Flink不会对单独的键值执行再分配，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, transactional data is often distributed across several disconnected database systems and becomes more valuable when it can be jointly analyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192024Z" creationid="xccui" creationdate="20190228T183532Z">
        <seg>虽然如此，但事务数据通常存储于互不相连的数据库系统之中，如能将它们联结分析必能创造更大价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, transactional data is often distributed across several discon‐ nected database systems and is more valuable when it can be jointly analyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T072143Z" creationid="esouser" creationdate="20190603T201929Z">
        <seg>然而用于存储事务性数据的多个数据库系统通常都是相互隔离的，如能将它们联合分析必然会创造更高的价值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, we have not yet discussed where they originate from.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033616Z" creationid="xccui" creationdate="20190607T033558Z">
        <seg>但一直没涉及它们的来源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, with the growing popularity of Hadoop, companies realized that a lot of valuable data was excluded from their data analytics process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T205940Z" creationid="xccui" creationdate="20190228T203747Z">
        <seg>但随着Hadoop的流行，不少公司开始意识到他们现有的数据分析流程会遗漏很多有价值的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can be quite cer‐ tain all relevant data is available when you perform a computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T040233Z" creationid="xccui" creationdate="20190621T040233Z">
        <seg>但这样的好处是在执行计算时你能确保可以使用全部相关数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can configure the RocksDB state backend to also store the timers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T065154Z">
        <seg>同时你可以配置RocksDB状态后端来存计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you should also know how to create a new Flink project from scratch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004140Z" creationid="xccui" creationdate="20190612T004101Z">
        <seg>但同时你也要掌握如何从头开始创建一个新的Flink项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How‐ ever, efficient and reliable management of state is more challenging.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055302Z" creationid="xccui" creationdate="20190607T055225Z">
        <seg>而难点在于如何高效、可靠地管理状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How‐ ever, since it is typically not possible for an operator to retain all state forever, it needs to purge state at some point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T162447Z" creationid="xingcan" creationdate="20190628T162447Z">
        <seg>然而通常算子无法永久保留所有状态，最终还是需要在某个时间点将其清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How‐ ever, too many colocated tasks can also overload a TaskManager and result in bad performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144821Z" creationid="xccui" creationdate="20190606T144803Z">
        <seg>然而，任务过于集中也会使TaskManager负载变高，继而可能导致性能下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ideally, you would like this latency to remain constant and independent of the rate of the incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052913Z" creationid="xccui" creationdate="20190401T205449Z">
        <seg>理想情况下，你会希望延迟保持平稳，不受事件到来速率的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idempotent Sink Connectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025308Z" creationid="xccui" creationdate="20190225T025308Z">
        <seg>幂等性汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idempotent Writes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152026Z" creationid="esouser" creationdate="20190603T151856Z">
        <seg>幂等性写</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195137Z" creationid="xccui" creationdate="20190626T195137Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a modified application is started from a savepoint, a state in the savepoint can only be mapped to the application if it contains an operator with a corresponding identi‐ fier and state name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023155Z" creationid="xccui" creationdate="20190609T220228Z">
        <seg>如果应用在从保存点启动的时候发生过改动，那么保存点中的状态只有在应用还保留着那些含有对应标识和状态名称的算子时才可以成功映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a source function (temporarily) does not emit anymore watermarks, it can declare itself idle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034450Z" creationid="xccui" creationdate="20190607T034439Z">
        <seg>如果源函数（临时性地）不会再发出水位线，可以把自己声明成空闲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a timestamp assigner is used, any existing timestamps and water‐ marks will be overwritten.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T025618Z" creationid="xccui" creationdate="20190620T025618Z">
        <seg>一旦使用时间戳分配器，已有的时间戳和水位线都将被覆盖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a trigger is applied together with a MergingWindowAssigner, it needs to be able to handle the case when two windows are merged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194900Z" creationid="xccui" creationdate="20190626T194900Z">
        <seg>如果某个触发器和MergingWindowAssigner一起使用，则需要处理两个窗口合并的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a win‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052117Z" creationid="xccui" creationdate="20190625T052117Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an application is updated without removing or changing existing state, it is always savepoint compatible and can be started from a savepoint of an earlier version.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T040244Z" creationid="xccui" creationdate="20190705T040244Z">
        <seg>如果应用在更新时不会删除或改变已有状态，那么它一定是保存点兼容的，并且能够从旧版本的保存点启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an application needs to recover from a failure, all processing-time timers that expired while the application was restarting will fire immediately when the application resumes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T065349Z">
        <seg>如果应用需要从故障中恢复，那么所有在应用重启过程中过期的处理时间计时器会在应用恢复后立即触发，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210742Z" creationid="esouser" creationdate="20190603T210742Z">
        <seg>If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both tasks are located on the same physical machine (which is often ensured by task schedu&lt;t2/&gt;‐&lt;t3/&gt; lers), this exchange strategy avoids network communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T134825Z" creationid="xccui" creationdate="20190401T134633Z">
        <seg>如果两端任务运行在同一物理机器上（通常由任务调度器保障），该交换策略可以避免网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both tasks are located on the same physical machine (which is often ensured by task schedu‐ lers), this exchange strategy avoids network communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233415Z" creationid="xccui" creationdate="20190605T233415Z">
        <seg>如果两端任务运行在同一物理机器上（通常由任务调度器保障），该交换策略可以避免网络通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If events take a long time to travel in the data processing pipeline, we cannot easily ensure high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053856Z" creationid="xccui" creationdate="20190605T234945Z">
        <seg>如果事件在数据处理管道中传输时间太久，我们将难以确保高吞吐；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If events take long to travel in the data processing pipeline, we cannot easily ensure high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T203457Z" creationid="xccui" creationdate="20190402T203213Z">
        <seg>如果事件在数据处理管道中的传输时间太久，我们将难以确保高吞吐；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it fails after it has updated its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033627Z" creationid="xccui" creationdate="20190606T033627Z">
        <seg>如果在更新内部状态后发生故障，系统恢复后是否会重复更新？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it fails after it has updated its internal state, will it update it again after it recovers?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043148Z" creationid="xccui" creationdate="20190415T043141Z">
        <seg>如果在更新内部状态后发生故障，系统恢复后是否会重复更新？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no such timer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060625Z" creationid="xccui" creationdate="20190621T060625Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no such timer exists, the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060716Z">
        <seg>如果该计时器不存在，则方法不会有任何作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one of the TaskManagers fails, the number of available slots drops to six.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205758Z" creationid="xccui" creationdate="20190428T205742Z">
        <seg>如果有一个TaskManager出现故障，则可用处理槽的数量就降到了6个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If state gets lost during a failure, results will be incorrect after recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T184931Z" creationid="xccui" creationdate="20190415T035644Z">
        <seg>如果状态在故障期间丢失，那恢复后的结果就会不正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the JobManager runs remotely, the JobGraph must be shipped together with a JAR file that contains all classes and required dependencies of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T012656Z" creationid="xccui" creationdate="20190613T012656Z">
        <seg>如果是远程JobManager的情况，除了JobGraph之外，还要同时提供包含应用所需全部类和依赖的JAR包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the ResourceManager does not have enough slots to fulfill the JobManager’s request, the ResourceManager can talk to a resource provider to provision containers in which TaskManager processes are started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060937Z" creationid="xccui" creationdate="20190418T050826Z">
        <seg>如果ResourceManager的处理槽数无法满足JobManager的请求，则ResourceManager可以和资源提供者通信，让它们提供额外容器来启动更多TaskManager进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application is not started from a checkpoint or savepoint, the state will be initially empty.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071046Z" creationid="xccui" creationdate="20190702T071046Z">
        <seg>如果应用不是从检查点或保存点启动，那状态就会初始化为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application runs in a local execution environment the parallelism is set to match the number of CPU cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T052859Z" creationid="xccui" creationdate="20190616T052859Z">
        <seg>如果应用是在一个本地执行环境中运行，并行度会设置为CPU的核心数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application was submitted to a Dispatcher or YARN Resource&lt;t5/&gt;‐&lt;t6/&gt; Manager, it will spin up a JobManager, hand over the application, and the Job&lt;t7/&gt;‐&lt;t8/&gt; Manager continues to execute the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030049Z" creationid="xccui" creationdate="20190423T030049Z">
        <seg>如果应用提交到Dispatcher或YARN ResourceManager，它们会启动一个JobManager并将应用转交给它，随后由JobManager负责继续执行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application was submitted to a Dispatcher or YARN ResourceManager, it will spin up a JobManager and hand over the application, and the JobManager will start to execute the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T062914Z" creationid="xccui" creationdate="20190606T143514Z">
        <seg>如果应用提交到Dispatcher或YARN ResourceManager，它们会启动一个JobManager并将应用转交给它，随后由JobManager负责执行该应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application was submitted to a JobManager, it immediately starts to execute the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025910Z" creationid="xccui" creationdate="20190423T025902Z">
        <seg>如果应用提交到JobManager，会立即开始执行；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the barista runs out of milk right before preparing your cappuccino, you will have to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051209Z" creationid="xccui" creationdate="20190605T234059Z">
        <seg>如果咖啡师在给你准备卡布奇诺（译者注：一种需要牛奶和奶泡的咖啡）前刚好把牛奶用光了，那么你必须等他从供应间再拿一些出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the barista runs out of milk right before preparing your cappuccino, you will have to wait until they bring some from the supply room.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T160202Z" creationid="xccui" creationdate="20190401T155651Z">
        <seg>如果咖啡师在给你准备卡布奇诺（译者注：一种需要牛奶和奶泡的咖啡）前刚好把牛奶用光了，则你必须等他从补给室再拿一些出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the command completed successfully, you will find a new target folder in your project folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010337Z" creationid="xccui" creationdate="20190612T010337Z">
        <seg>如果命令成功完成，你会在项目目录里看到一个新的target文件夹。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the data type is a tuple, keys can be defined by simply using the field position of the corresponding tuple element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T033121Z" creationid="xccui" creationdate="20190618T033121Z">
        <seg>针对元组数据类型，可以简单地使用元组相应元素的字段位置来定义键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the event-time clock advances, the task processes all triggered timers and finally broadcasts its new event time to all downstream tasks by emitting a corresponding watermark to all con‐ nected output partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190607T025043Z">
        <seg>如果事件时间时钟向前推动，任务会先处理因此而触发的所有计时器，最后才会把对应的水位线发往所有连接的输出分区，从而实现将事件时间广播到全部下游任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the input is a white square, it outputs the event unmodified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T054414Z" creationid="xccui" creationdate="20190613T054359Z">
        <seg>如果输入是白色方块，则不加改动直接输出；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the key domain is continuously growing—for example, because the key is a unique transaction ID—you have to clean up state for keys that are no longer active to avoid memory problems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T045513Z" creationid="xccui" creationdate="20190614T045513Z">
        <seg>如果键值域会持续增长（例如将唯一的事务ID作为键值），则必须对那些不再活跃的键值进行清理，以避免出现内存问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the method is invoked from a submission cli‐ ent with a connection to a remote cluster, a remote execution environment is returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045413Z" creationid="xccui" creationdate="20190612T045413Z">
        <seg>如果是一个连接远程集群的提交客户端调用了该方法，则会返回一个远程执行环境；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the method returns a nonnull value with a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T050009Z" creationid="xccui" creationdate="20190620T050009Z">
        <seg>如果该方法的返回值非空，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operator is configured just with an incremental aggregation func‐ tion, the current aggregation result is emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053430Z" creationid="xccui" creationdate="20190625T053430Z">
        <seg>如果算子只是配置了一个增量聚合函数，就会发出当前聚合结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operator only has a full window function, the function is applied on all ele‐ ments of the window and the result is emitted as shown in Figure 6-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053951Z" creationid="xccui" creationdate="20190625T053710Z">
        <seg>如果算子只包含一个全量窗口函数，那么该函数将一次性作用于窗口内的所有元素上，之后便会发出结果。该情况如图6-5所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operator’s parallelism is larger than 128, the maximum parallelism is com‐ puted as the minimum of nextPowerOfTwo(parallelism + (parallelism / 2)) and 2^15.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025539Z" creationid="xccui" creationdate="20190703T025539Z">
        <seg>如果算子并行度大于128，那么最大并行度会取nextPowerOfTwo(parallelism + (parallelism / 2))和2^15之中的较小值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the parallelism is less than or equal to 128, the maximum parallelism is 128.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025409Z" creationid="xccui" creationdate="20190703T025409Z">
        <seg>如果并行度小于或等于128，则最大并行度会设置成128；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the sender and receiver tasks run in separate Task&lt;t0/&gt;‐&lt;t1/&gt; Manager processes, they communicate via the network stack of the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042532Z" creationid="xccui" creationdate="20190504T042532Z">
        <seg>如果发送端和接收端的任务运行在不同的TaskManager进程中，就需要利用操作系统的网络栈进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the sender and receiver tasks run in separate TaskManager pro‐ cesses, they communicate via the network stack of the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T191535Z" creationid="xccui" creationdate="20190606T195843Z">
        <seg>如果发送端和接收端的任务运行在不同的TaskManager进程中，它们就要用到操作系统的网络栈进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the slide is larger than the window size, some elements might not be assigned to any window and hence may be dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055510Z" creationid="xccui" creationdate="20190623T055207Z">
        <seg>如果滑动间隔大于大于窗口大小，则一些元素可能不会分配给任何窗口，因此可能会被丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the state backend does not contain state for the given descriptor, the state that is linked to the handle is initialized as empty.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T022350Z" creationid="xccui" creationdate="20190701T022350Z">
        <seg>如果状态后端没包含给定描述符的对应状态，那么就会以空值来初始化句柄链接的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the state of a task instance grows too large, the JVM and all task instances running on it can be killed due to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T222738Z" creationid="xccui" creationdate="20190703T222738Z">
        <seg>如果某个任务实例的状态变得很大，那么它所在的JVM连同所有运行在该JVM之上的任务实例都可能由于OutOfMemoryError而终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the state of an application is continuously increasing, it will at some point grow too large and kill the application unless action is taken to scale the application to more resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T140136Z" creationid="xccui" creationdate="20190704T130702Z">
        <seg>应用状态如果不断增加，总有一天会变得过大并"杀死"应用，除非我们有什么办法能为应用不断扩充资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the system continues to receive data at a higher rate than it can handle, buffers might become unavailable and data might get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T202331Z" creationid="xccui" creationdate="20190402T201609Z">
        <seg>如果系统持续以难以应对的高速率接收数据，缓冲区可能会用尽，继而可能导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the system continues to receive data at a higher rate than it can handle, buf‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053602Z" creationid="xccui" creationdate="20190605T234746Z">
        <seg>如果系统持续以力不能及的高速率接收数据，那么缓冲区可能会用尽，继而可能导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the task fails during the first step, will the event get lost?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043111Z" creationid="xccui" creationdate="20190415T043111Z">
        <seg>如果故障发生在第一步，事件是否会丢失？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the task is restarted due to a failure or from a save‐ point, the state will be initialized from the saved data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071058Z" creationid="xccui" creationdate="20190702T065621Z">
        <seg>如果是重启任务（无论由于故障还是从保存点恢复）的情况，那Flink就会用保存的数据初始化状态；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the window only has an incremetal aggregation function (ReduceFunction or AggregateFunction) the current aggregation result is emit‐ ted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184600Z" creationid="xccui" creationdate="20190626T184537Z">
        <seg>如果窗口只包含一个增量聚合函数（ReduceFunction或AggregateFunction），则直接发出当前聚合结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the window operator has a ProcessWindowFunction, the function is called and the result is emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184543Z" creationid="xccui" creationdate="20190626T184449Z">
        <seg>如果窗口算子配置了ProcessWindowFunction，就会调用该函数并发出结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the window operator is configured with an incremental aggregation function, such as a ReduceFunction or AggregateFunction, the newly added element is immediately aggregated and the result is stored as the contents of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052346Z" creationid="xccui" creationdate="20190625T052346Z">
        <seg>如果为窗口算子配置的是增量聚合函数（如ReduceFunction或AggregateFunction），新加入的元素会立即执行聚合，其结果会存为窗口内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the window oper‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052518Z" creationid="xccui" creationdate="20190625T052518Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are fewer list entries than the new parallelism of an operator, some tasks will start with empty state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060844Z" creationid="xccui" creationdate="20190608T060655Z">
        <seg>如果列表项目的数量小于算子新设置的并发度，部分任务在启动时的状态就可能为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are more parallel subtasks than state objects, some subtasks are started with no state, and the restoreState() method is called with an empty list.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061347Z" creationid="xccui" creationdate="20190701T061347Z">
        <seg>如果并行子任务的数量多于状态对象，那么有些子任务在启动时就会获取不到状态，此时传入restoreState()方法的就会是一个空列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is not possible, for example because the application runs in a stand-alone cluster, the JobManager is not able to restart the application until enough slots become available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210324Z" creationid="xccui" creationdate="20190428T210135Z">
        <seg>若无法完成（例如应用运行在一个独立集群上），JobManager将无法重启应用，直至有足够数量的可用处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is not possible—for example, because the application runs in a standalone cluster—the JobManager can not restart the application until enough slots become available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145517Z" creationid="xccui" creationdate="20190606T145517Z">
        <seg>若无法完成（例如应用运行在一个独立集群上），JobManager将无法重启应用，直至有足够数量的可用处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061843Z" creationid="xccui" creationdate="20190701T061843Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we only consider how much data we receive within one minute, our results will vary and depend on the speed of the network connection or the speed of the processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143249Z" creationid="xccui" creationdate="20190412T142831Z">
        <seg>如果我们仅考虑现实时间一分钟内收到多少数据，那结果可能会随网络连接速度或处理速度而改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we want to reference a person’s ZIP code, we can use a field expression:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050107Z" creationid="xccui" creationdate="20190618T050107Z">
        <seg>如果我们想引用某人的邮政编码，可以使用字段表达式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you add a new stateful operator to the application or a new state to an existing operator, the state will be initialized as empty when the application is started from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T040408Z" creationid="xccui" creationdate="20190705T040408Z">
        <seg>如果你向应用中添加了新的状态化算子或为已有算子增加了状态，那么在应用从保存点启动时，这些状态都会被初始化为空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are familiar with batch data processing APIs, functional programming languages, or SQL you will find the API concepts very easy to grasp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024103Z" creationid="xccui" creationdate="20190613T024059Z">
        <seg>如果你熟悉批处理API、函数式编程语言或SQL，将会发现这里的API概念都很容易掌握。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are interested in learning more about real-world use cases and deployments, check out Apache Flink’s &lt;t0/&gt;Powered By&lt;t1/&gt; &lt;t2/&gt;page and the talk recordings and slide decks of &lt;t3/&gt;Flink For&lt;t4/&gt;‐&lt;t5/&gt; &lt;t6/&gt;ward &lt;t7/&gt;presentations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T155324Z" creationid="xccui" creationdate="20190305T154924Z">
        <seg>如果还想了解更多的用例和部署方案，请查看Apache Flink的Powered By页面或Flink Forward的演讲录像及幻灯片。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are interested in learning more about real-world use cases and deployments, check out Apache Flink’s Powered By page and the talk recordings and slide decks of Flink Forward presentations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T212615Z" creationid="esouser" creationdate="20190603T212449Z">
        <seg>如果想了解更多真实用例和部署方案，请查看Apache Flink的用户页面或Flink Forward的演讲录像及幻灯片。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are running Windows, we recom&lt;t2/&gt;‐&lt;t3/&gt; mend to set up a virtual machine with Linux, Cygwin (a Linux environment for Win&lt;t4/&gt;‐&lt;t5/&gt; dows), or the Windows Subsystem for Linux, which was introduced with Windows 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060249Z" creationid="xccui" creationdate="20190328T055732Z">
        <seg>如果你的系统是Windows，我们建议你配置一个Linux虚拟机，或安装Cygwin（一个Windows下的Linux环境），或设置Linux子系统（Win10中新加的功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are the first customer showing up at the coffee shop right after it opened its doors in the morning, you will be served immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T205517Z" creationid="xccui" creationdate="20190401T205243Z">
        <seg>如果你是早晨咖啡店开门后第一个顾客，将立即得到服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are using the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T065824Z" creationid="xccui" creationdate="20190621T065824Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you cannot express your required join semantics using Flink’s built-in join opera‐ tors, you can implement custom join logic as a CoProcessFunction, BroadcastPro cessFunction, or KeyedBroadcastProcessFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210857Z" creationid="xccui" creationdate="20190627T210857Z">
        <seg>如果Flink内置的Join算子无法表达所需的Join语义，那么你可以通过CoProcessFunction、BroadcastProcessFunction或KeyedBroadcastProcessFunction实现自定义的Join逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you click on that job you will see the data flow and live metrics about the opera&lt;t0/&gt;‐&lt;t1/&gt; tors of the running job similar to the screenshot in &lt;t2/&gt;Figure 1-9&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042154Z" creationid="xccui" creationdate="20190329T041245Z">
        <seg>点击那个作业，你会看到和图1-9中的截图类似的数据流程及运行作业中算子的实时指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not explicitly set unique identifiers to the operators of your stateful applica‐ tion, you will face significant limitations when you have to evolve the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023250Z" creationid="xccui" creationdate="20190703T023053Z">
        <seg>如果你没有为状态化应用的算子显式指定标识，那么在更新应用时就会受到诸多限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210827Z" creationid="esouser" creationdate="20190603T210827Z">
        <seg>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you generate loose watermarks—where the watermarks are far behind the time‐ stamps of the processed records—you increase the latency of the produced results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T034216Z" creationid="xccui" creationdate="20190621T033944Z">
        <seg>如果生成的水位线过于宽松，即水位线远落后于已处理记录的时间戳，那么将导致产生结果的延迟增大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have incremental aggregation logic but also need access to window metadata, you can combine a ReduceFunction or AggregateFunction, which perform incre‐ mental aggregation, with a ProcessWindowFunction, which provides access to more</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T035614Z" creationid="xccui" creationdate="20190625T035513Z">
        <seg>如果是增量聚合逻辑但还需要访问窗口元数据，你可以将ReduceFunction或AggregateFunction和功能更多的ProcessWindowFunction组合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run the application in a local environ‐ ment—or example, from your IDE—on a machine with 8 cores, the source task will run with 8 tasks, the mapper with 16 tasks, and the sink with 2 tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T062232Z" creationid="xccui" creationdate="20190616T062221Z">
        <seg>如果你在一台8核的机器上以本地环境中运行（例如在IDE里），那么数据源将会运行8个任务，map将运行16个任务，数据汇将运行2个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you take a step back and read the introductory example once more, you hopefully have a better idea about what is going on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T044441Z" creationid="xccui" creationdate="20190619T044357Z">
        <seg>如果回头再看一次开篇示例，希望你能对它的行为有一个更好的理解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your application requires keyed state for a moving key domain, it should ensure the state of keys is cleared when it is not needed anymore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T201452Z" creationid="xccui" creationdate="20190704T201452Z">
        <seg>如果你的应用需要用到键值域不断改变的键值分区状态，那么必须要确保能够对那些无用的状态进行清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your function requires a nonserializable object instance, you can either implement it as a rich function and initialize the nonserializ‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055521Z" creationid="xccui" creationdate="20190618T055329Z">
        <seg>如何你有函数需要一个无法序列化的对象实例，可以选择使用富函数在open()方法中将其初始化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your input elements have timestamps that are</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051515Z" creationid="xccui" creationdate="20190620T051433Z">
        <seg>如果你输入元素的时间戳是单调增加的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine that during Christmas holiday season, baristas have to draw a Santa Claus on the cup of each coffee they serve.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T205829Z" creationid="xccui" creationdate="20190402T205727Z">
        <seg>假设正值圣诞假期，咖啡师要在他们端出的每一杯咖啡上面画一个圣诞老人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine that during the Christmas holiday season, baristas have to draw a Santa Claus on the cup of each coffee they serve.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054351Z" creationid="xccui" creationdate="20190605T235108Z">
        <seg>假设现在正值圣诞假期，咖啡师要在他们完成的每杯咖啡的杯子上画一个圣诞老人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implement</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063640Z" creationid="xccui" creationdate="20190701T063640Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implement Your Applications With Evolution in Mind</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T024734Z" creationid="xccui" creationdate="20190705T024319Z">
        <seg>实现应用时须长远考虑</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation of a CoProcessFunction that dynamically filters a stream of sensor readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032022Z" creationid="xccui" creationdate="20190622T032022Z">
        <seg>动态过滤传感器读数流的CoProcessFunction实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation of a ProcessWindowFunction that assigns the window end timestamp to an incrementally computed result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045132Z" creationid="xccui" creationdate="20190625T045132Z">
        <seg>用于将窗口结束时间戳分配到递增计算结果的ProcessWindowFunction实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022910Z" creationid="xccui" creationdate="20190225T022910Z">
        <seg>实现函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Functions | 105</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045347Z" creationid="xccui" creationdate="20190619T045347Z">
        <seg>实现函数 | 105</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Operator List State with the ListCheckpointed Interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T064029Z" creationid="xccui" creationdate="20190225T024556Z">
        <seg>通过ListCheckpointed接口实现算子列表状态（operator list state）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Stateful Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030643Z" creationid="xccui" creationdate="20190225T024522Z">
        <seg>实现状态化函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a Custom Sink Function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025258Z" creationid="xccui" creationdate="20190225T025258Z">
        <seg>实现自定义汇函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a Custom Source Function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025229Z" creationid="xccui" creationdate="20190225T025229Z">
        <seg>实现自定义源函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a FlatMapFunction with a keyed ValueState</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064202Z" creationid="xccui" creationdate="20190630T064202Z">
        <seg>实现带有键值分区ValueState的FlatMapFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing a KeyedBroadcastProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041324Z" creationid="xccui" creationdate="20190702T041324Z">
        <seg>实现KeyedBroadcastProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the Book’s Examples in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054951Z" creationid="esouser" creationdate="20190603T144859Z">
        <seg>在IDE中导入书中示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the book examples repository into IntelliJ</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041629Z" creationid="xccui" creationdate="20190611T041629Z">
        <seg>将书中示例仓库导入IntelliJ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the book’s examples in your IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022322Z" creationid="xccui" creationdate="20190225T022322Z">
        <seg>将书中示例导入你的IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Importing the examples-scala repository into your IDE to experiment with Flink is a good first step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004111Z" creationid="xccui" creationdate="20190612T004022Z">
        <seg>将examples-scala库导入IDE来体验Flink是一个良好的开端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improving on the first generation, the next generation of distributed open source stream processors (2013) provided better failure guarantees and ensured that in case of a failure each input record affects the result exactly once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T194051Z" creationid="xccui" creationdate="20190605T053117Z">
        <seg>和第一代开源分布式流处理引擎相比，第二代引擎（2013年）提供了更加完善的故障处理机制——即便出现故障，也能保证每条记录仅参与一次结果运算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improving on the first generation, the next generation of distributed open source stream processors (2013) provided better failure guarantees and ensured that in case of a failure each record contributes exactly once to the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T034733Z" creationid="xccui" creationdate="20190327T034557Z">
        <seg>和第一代开源分布式流处理引擎相比，第二代引擎（2013年）提供了更加完善的故障处理机制，可以保证在出错的情况下每条记录也仅参与一次结果运算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t0/&gt;Chapter 10&lt;t1/&gt;, we show how to disable task chaining for an application and how to control the chaining behavior of individual opera&lt;t2/&gt;‐&lt;t3/&gt; tors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155735Z" creationid="esouser" creationdate="20190514T155247Z">
        <seg>在第10章中，我们会展示如何对某一应用内禁用任务链接以及如何单独控制每个算子的链接行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t0/&gt;Chapter 2&lt;t1/&gt;, we highlighted the importance of time semantics for stream processing applications and explained the differences between processing-time and event-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155850Z" creationid="esouser" creationdate="20190514T155850Z">
        <seg>在第二章里，我们强调了时间语义对于流处理应用的重要性并解释了处理时间和事件时间的不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t2/&gt;Chapter 9&lt;t3/&gt;, we will discuss how to setup and configure Flink for different environments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025244Z" creationid="xccui" creationdate="20190423T025119Z">
        <seg>在第9章里，我们会讨论如何针对不同环境搭建及配置Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;t2/&gt;Figure 2-2&lt;t3/&gt;, the output of the “Extract hashtags” operator is partitioned by key (the hashtag), so that the count operator tasks can correctly compute the occurrences of each hashtag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135717Z" creationid="xccui" creationdate="20190401T135653Z">
        <seg>图2-2中，"Extract hashtags"算子的输出就是按照键值（主题标签）划分的，因此下游的计数算子可以正确计算出每个主题标签的出现次数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Alice’s game example, the streaming application could operate with two different notions of time, Processing time or Event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143526Z" creationid="xccui" creationdate="20190412T143355Z">
        <seg>在爱丽丝游戏的例子中，流式应用可以使用两个不同概念的时间，即处理时间和事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Alice’s game example, the streaming application could operate with two different notions of time: processing time or event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155450Z" creationid="xccui" creationdate="20190606T023542Z">
        <seg>在爱丽丝游戏的例子中，流式应用可以使用两个不同概念的时间，即处理时间（processing time）和事件时间（event time）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter 1, you learned that streaming applications have different operational requirements than traditional batch programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050310Z" creationid="xccui" creationdate="20190605T233716Z">
        <seg>在第一章，你已经了解到流式应用和传统批处理程序在操作的需求上有所差异，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter 2 we pointed out that most streaming applications are stateful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T042001Z" creationid="xccui" creationdate="20190607T041304Z">
        <seg>在第2章我们指出，大部分的流式应用都是有状态的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter 6, things are going to get even more interesting—we will learn how to enrich our programs with window operators and time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T044618Z" creationid="xccui" creationdate="20190619T044618Z">
        <seg>在第6章，我们将会接触到一些更加有趣的内容——学习如何利用窗口算子和时间语义来进一步丰富我们的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Figure 2-2, the output of the “Extract hashtags” operator is partitioned by the key (the hashtag), so that the count operator tasks can correctly compute the occurrences of each hashtag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233520Z" creationid="xccui" creationdate="20190605T233520Z">
        <seg>图2-2中，"Extract hashtags"算子的输出就是按照键值（主题标签）划分的，因此下游的计数算子可以正确计算出每个主题标签的出现次数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Figure 3-17, Flink took a checkpoint when the input offset was 5, and the sums were 6 and 9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T031758Z" creationid="xccui" creationdate="20190609T031739Z">
        <seg>在图3-17中，Flink会在输入偏移到达5的时候生成一个检查点，此时两个和值分别为6和9。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, keys are not predefined in the input types like in systems that work with key-value pairs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T063113Z" creationid="xccui" creationdate="20190617T062643Z">
        <seg>和某些使用键值对的系统不同，Flink不是在输入类型中提前定义好键值，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, state is always associated with a specific operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055854Z" creationid="xccui" creationdate="20190607T055833Z">
        <seg>在Flink中，状态都是和特定算子相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, such a state is called a broadcast state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T203707Z" creationid="xccui" creationdate="20190701T203626Z">
        <seg>在Flink中，这种状态称为广播状态（broadcast state），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, watermarks are implemented as special records holding a timestamp as a Long value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205301Z" creationid="xccui" creationdate="20190606T205232Z">
        <seg>在Flink中，水位线是利用一些包含Long值时间戳的特殊记录来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink, watermarks are implemented as special records holding a timestamp long value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042055Z" creationid="xccui" creationdate="20190523T042038Z">
        <seg>在Flink中，水位线是利用一些包含时间戳long值的特殊记录来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Flink’s design it is the responsibility of the state backend to perform a checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202614Z" creationid="xccui" creationdate="20190609T202559Z">
        <seg>按照Flink的设计，是由状态后端负责生成检查点，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a batch processing scenario, all these questions are answered because a batch job can be simply restarted from the beginning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T191246Z" creationid="xccui" creationdate="20190606T033840Z">
        <seg>在批处理场景下，上面提到的都不算问题。由于批处理任务可以轻易"从头再来"，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a batch processing scenario, you can solve all these problems easily since all the input data is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044030Z" creationid="xccui" creationdate="20190415T044017Z">
        <seg>在批处理场景下，由于可以得到所有输入数据，上述问题都能轻松解决。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a real-word streaming architecture however, it is common to have several connected components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045315Z" creationid="xccui" creationdate="20190416T045214Z">
        <seg>但在现实世界的流处理架构中，有多个连接组件是很稀松平常的事儿。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a real-world streaming application however, there will be at least one source and one sink apart from the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194630Z" creationid="xccui" creationdate="20190606T035056Z">
        <seg>在实际流处理应用中，除了流处理引擎也至少还要有一个数据来源组件和一个数据终点组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a true streaming model, events can be processed as soon as they arrive in the system and latency more closely reflects the actual work that has to performed on each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195212Z" creationid="xccui" creationdate="20190401T194838Z">
        <seg>在该模型中，事件一到达系统就可以进行处理，延迟会更真实地反映出每个事件都要经历的实际执行工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a true stream‐ ing model, events can be processed as soon as they arrive in the system and latency more closely reflects the actual work that has to be performed on each event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052022Z" creationid="xccui" creationdate="20190605T234331Z">
        <seg>在真正的流模型中，事件一到达系统就可以进行处理，延迟会更加真实地反映出每个事件都要经历的实际处理工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to built-in operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T032021Z" creationid="xccui" creationdate="20190630T032021Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to joining two streams, it is also possible to cogroup two streams on a window by starting the operator definition with coGroup() instead of join().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T053729Z" creationid="xccui" creationdate="20190628T053610Z">
        <seg>除了对窗口中的两条流进行Join，还可以对它们进行Cogroup。只需将算子定义开始位置的join()改为coGroup()即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to keeping state around, the downstream operators or external systems that follow an operator, which updates previously emitted results, need to be able to handle these updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T163101Z" creationid="xingcan" creationdate="20190628T163101Z">
        <seg>除了在算子中保持状态，受结果更新影响下游算子或外部系统还得能够处理这些更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to record timestamps, a Flink event-time application must also provide watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040914Z" creationid="xccui" creationdate="20190523T040914Z">
        <seg>除了记录的时间戳，Flink基于事件时间的应用还必须提供水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the WindowAssigner interface there is also the MergingWindowAssigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045234Z" creationid="xccui" creationdate="20190626T045234Z">
        <seg>除了WindowAssigner接口外，还有一个继承自它的MergingWindowAssigner接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the system properties discussed so far, such as failure tolerance, perfor&lt;t0/&gt;‐&lt;t1/&gt; mance, and result accuracy, stream processors also continuously added new opera&lt;t2/&gt;‐&lt;t3/&gt; tional features.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T140909Z" creationid="xccui" creationdate="20190327T135929Z">
        <seg>除了已经讨论过的如：容错、性能、结果精确性等系统属性，流处理引擎还在不断添加新的操作功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the system properties discussed so far, such as failure tolerance, perfor‐ mance, and result accuracy, stream processors have also continuously added new operational features such as highly available setups, tight integration with resource managers, such as YARN or Kubernetes, and the ability to dynamically scale stream‐ ing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195108Z" creationid="xccui" creationdate="20190605T053708Z">
        <seg>除了已经讨论过的容错、性能及结果精确性等系统属性，流处理引擎还在不断添加新的操纵功能（operational feature），例如：高可用设置，和资源管理器（YARN、Kubernetes等）的紧密集成以及支持流式应用动态扩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to these features, Flink is a very developer-friendly framework due to its easy-to-use APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T200442Z" creationid="xccui" creationdate="20190328T052954Z">
        <seg>除了上述特性，Flink还是一个对开发者非常友好的框架，这得益于它十分易用的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to time-based windows, Flink also supports count- based windows—windows that group a fixed number of elements in the order in which they arrive at the window operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T035632Z" creationid="xccui" creationdate="20190623T035632Z">
        <seg>Flink除了支持基于时间的窗口，还支持基于数量的窗口。后者会按照元素到达窗口算子的顺序以固定数量对其进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, both context objects also provide access to the event-time timestamp, the current watermark, the current processing time, and the side outputs, similar to the context objects of other process functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T053527Z" creationid="xccui" creationdate="20190702T053527Z">
        <seg>此外，和其他处理函数的上下文对象类似，这两个上下文对象也支持访问状态时间戳、当前水位线、当前处理时间以及副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, program&lt;t0/&gt;‐&lt;t1/&gt; ming APIs evolved from rather low-level operator interfaces to high-level APIs with more built-in primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T035008Z" creationid="xccui" creationdate="20190327T034928Z">
        <seg>此外，编程API也从低层基于算子的接口进化为拥有更多内置操作原语的高层API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, program‐ ming APIs evolved from rather low-level operator interfaces to high-level APIs with more built-in primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T062918Z" creationid="xccui" creationdate="20190605T053242Z">
        <seg>此外，编程API也从底层基于算子的接口进化为拥有更多内置操作原语的高层API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the JobManager writes a pointer to the storage location into ZooKeeper’s data store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051712Z" creationid="xccui" creationdate="20190502T045820Z">
        <seg>此外，它还会将存储位置的指针写入ZooKeeper的数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the JobManager writes a pointer to the storage location into ZooKeeper’s datastore.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073253Z" creationid="xccui" creationdate="20190606T150105Z">
        <seg>此外，JobManager还会将存储位置的路径地址写入ZooKeeper的数据存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the RocksDB state backend also features incremental checkpointing, which reduces the amount of data to transfer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203905Z" creationid="xccui" creationdate="20190609T203841Z">
        <seg>除此之外，RocksDB状态后端还支持增量生成检查点，这可以降低需要传输的数据量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the method getRuntimeContext() provides access to the function’s Run timeContext.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033317Z" creationid="xccui" creationdate="20190619T033317Z">
        <seg>此外，可以利用getRuntimeContext()方法访问函数的RuntimeContext。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, there is a service running that accepts the Flink application and ensures it is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143501Z" creationid="xccui" creationdate="20190606T143501Z">
        <seg>无论哪种情况，运行的服务都会接收Flink应用并确保其执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In batch processing you first need to gather the events in batches and only then you are able to process them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T193255Z" creationid="xccui" creationdate="20190401T193141Z">
        <seg>在批处理中，你先要批量收集事件，然后才能处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In batch processing, you first need to gather the events in batches and only then can you pro‐ cess them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234259Z" creationid="xccui" creationdate="20190605T234259Z">
        <seg>在批处理中，你先要批量收集事件，然后才能处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, Flink links the newly registered state handle object to the existing state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T021819Z" creationid="xccui" creationdate="20190701T021819Z">
        <seg>无论哪种情况，Flink都会将新注册的状态句柄对象链接到已有状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, Flink recovers a stateful streaming application by restoring its state from a previous checkpoint and resetting the read position on the event log.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155036Z" creationid="esouser" creationdate="20190603T211702Z">
        <seg>一旦出现故障，Flink会利用之前的检查点恢复状态并重置事件日志的读取指针，以此来使状态化流处理应用恢复正常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, Flink restores a stateful streaming application by recovering its state from a previously taken checkpoint and resets the read position on the event log.The application will replay (and fast forward) the input events from the event log until it reaches the tail of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T144620Z" creationid="xccui" creationdate="20190305T062150Z">
        <seg>一旦计算失败，Flink会利用之前的checkpoint恢复状态和重置事件日志的读取指针，以此来使状态化流处理应用恢复正常。随后应用会从事件日志中读取并（快速）重放输入事件，直到数据流末尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a failure, Flink uses the latest check‐ point  to  consistently  restore  the  application’s   state   and   restarts   the   processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035819Z" creationid="xccui" creationdate="20190609T033338Z">
        <seg>一旦发生故障，Flink会利用最新的检查点为应用恢复一致性的状态并重启进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a fail‐ ure, these records will be processed again, which means the checkpoint provides at- least-once instead of exactly-once consistency guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T205249Z" creationid="xccui" creationdate="20190609T205203Z">
        <seg>一旦出现故障，这些记录会被重复处理，而这意味着检查点只能提供至少一次而非精确一次的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a shuffle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045224Z" creationid="xccui" creationdate="20190504T044946Z">
        <seg>在shuffle或broadcast连接的情况下，每个发送任务都需要针对每个接收任务提供一个缓冲区，因此所需的缓冲区数量是相关算子并发度的平方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of a shuffle connection pattern, each sender task needs to be able to send data to each receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T043112Z" creationid="xccui" creationdate="20190504T043112Z">
        <seg>在shuffle连接模式下，每个发送端的任务都需要能够向每个接受任务发送数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In combination with exactly-once failure semantics, systems of this generation are the first open source stream processors capable of computing consistent and accurate results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053340Z" creationid="xccui" creationdate="20190605T053340Z">
        <seg>结合精确一次故障恢复语义，这一代系统才称得上第一批能够计算精确、一致结果的开源流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In combination with exactly-once failure semantics, systems of this generation are the first open source stream processors that are capable of computing consistent and accurate results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T051821Z" creationid="xccui" creationdate="20190327T050854Z">
        <seg>结合精确一次故障恢复语义，这一代系统才称得上第一批能够计算精确、一致结果的开源流处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to batch processors that guarantee accurate results, the first open source stream processors traded result accuracy for much better latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T044942Z" creationid="xccui" creationdate="20190322T043015Z">
        <seg>和提供精确结果的批处理引擎相比，第一代开源流处理引擎通过牺牲结果的准确度换取更低的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to executing a Flink program by sending it to a remote JobManager, the program is executed in a single JVM. Therefore, certain issues, such as class‐ loading issues, cannot be properly debugged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T054526Z" creationid="xccui" creationdate="20190611T054526Z">
        <seg>和将Flink程序发送到远程JobManager执行相比，将程序放在单个JVM进程中执行可能会导致某些问题（例如类加载）无法正确调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to the AssignerWithPeriodicWatermarks function, this function can—but does not need to—extract a watermark from each record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040244Z" creationid="xccui" creationdate="20190607T040224Z">
        <seg>和AssignerWithPeriodicWatermarks函数不同，这个函数不会强制你从每条记录中都提取一个时间戳（虽然这样也行）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to the ReduceFunction, the intermediate data type and the output type do not depend on the input type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005140Z" creationid="xccui" creationdate="20190624T005140Z">
        <seg>和ReduceFunction不同的是中间数据类型以及结果类型不再依赖输入类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to their Scala counterparts, Flink’s Java tuples are mutable, so the val‐ ues of fields can be reassigned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040328Z" creationid="xccui" creationdate="20190617T040328Z">
        <seg>和Scala不同的是，Java元组是可变的，因此可以为其字段重新赋值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, a stream consumed from a socket cannot be reset because sockets discard data once it has been consumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044947Z" creationid="xccui" creationdate="20190609T044943Z">
        <seg>相反，如果数据流来是从套接字消费而来则无法重置，因为套接字会在数据被取走后将它们丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, a stream processor that runs a stateful streaming application takes care of all processing steps, including event ingestion, continuous computation including state maintenance, and updating the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014657Z" creationid="xccui" creationdate="20190317T063132Z">
        <seg>相较之下，运行状态化流处理应用的流处理引擎会负责事件获取、维护状态的持续计算、更新结果等所有处理步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, a stream pro‐ cessor that runs a stateful streaming application takes care of all these processing steps, including event ingestion, continuous computation including state mainte‐ nance, and updating the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155810Z" creationid="xccui" creationdate="20190605T044848Z">
        <seg>相比之下，运行状态化流处理应用的流处理引擎会负责事件获取、维护状态的持续计算以及更新结果等所有处理步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, event-time semantics yield reproducible and consis&lt;t2/&gt;‐&lt;t3/&gt; tent results which is a hard requirement for many stream processing use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T160831Z" creationid="esouser" creationdate="20190514T160831Z">
        <seg>而事件时间语义恰恰相反，它会生成可重现、一致性的结果，这也是很多流处理场景中的刚性需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, event-time semantics yield reprodu‐ cible and consistent results, which is a hard requirement for many stream processing use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204307Z" creationid="xccui" creationdate="20190606T204233Z">
        <seg>相反，事件时间语义会生成可重现且一致性的结果，这也是很多流处理场景中的刚性需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, in continuously running streaming jobs, state is durable across events and we can expose it as a first-class citi‐ zen in the programming model.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182441Z" creationid="xccui" creationdate="20190606T032132Z">
        <seg>反之，在持续运行的流式作业中，每次处理事件所用到的状态都是持久化的，我们完全可以将其作为编程模型中的一等公民。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, stateful operators may main‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235838Z" creationid="xccui" creationdate="20190605T235838Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, traditional batch processing latencies typically range from a few minutes to several hours.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T193105Z" creationid="xccui" creationdate="20190401T193105Z">
        <seg>相反，传统批处理的延迟可能从几分钟到几小时不等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In con‐ trast to batch processors, the first open source stream processors traded result accu‐ racy for better latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051716Z" creationid="xccui" creationdate="20190605T051623Z">
        <seg>和批处理引擎相比，第一代开源流处理引擎通过牺牲结果的准确度来换取低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In data streaming, latency is measured in units of time, such as milliseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051003Z" creationid="xccui" creationdate="20190401T154502Z">
        <seg>在流处理中，延迟是以时间片（例如毫秒）为单位测量的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, there is a ser&lt;t3/&gt;‐&lt;t4/&gt; vice running that accepts the Flink application and ensures it is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025733Z" creationid="xccui" creationdate="20190423T025658Z">
        <seg>无论哪种情况，运行的服务都会接收Flink应用并确保其执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, exactly-once guarantees mean that our application will provide the correct result, as if a failure never happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045641Z" creationid="xccui" creationdate="20190416T044057Z">
        <seg>本质上，精确一次保障意味着应用总会提供正确的结果，就如同故障从未发生过一般。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, exactly-once guarantees mean that our application will provide the correct result, as though a failure never happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034827Z" creationid="xccui" creationdate="20190606T034827Z">
        <seg>本质上，精确一次保障意味着应用总会提供正确的结果，就如同故障从未发生过一般。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, the rescale partitioning strategy offers a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043856Z" creationid="xccui" creationdate="20190616T043856Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, watermarks pro&lt;t0/&gt;‐&lt;t1/&gt; vide a logical clock which informs the system about the current event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205344Z" creationid="xccui" creationdate="20190412T205344Z">
        <seg>本质上，水位线提供了一个逻辑时钟，通知系统当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, watermarks provide a logical clock that informs the system about the current event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T161005Z" creationid="xccui" creationdate="20190606T025413Z">
        <seg>本质上，水位线提供了一个逻辑时钟，用来通知系统当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, if you want to compute anything interesting in a streaming application, even a simple count, you need to maintain state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064507Z" creationid="xccui" creationdate="20190409T204144Z">
        <seg>实际上，如果你想在流式应用中计算任何有意思的东西（即便是简单的计数），都需要维护状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it is difficult to find</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T040711Z" creationid="xccui" creationdate="20190301T035808Z">
        <seg>事实上，很难从现实世界找到那种瞬间就生成完整数据集的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it is difficult to find examples of finite, complete datasets that are generated all at once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T030309Z" creationid="esouser" creationdate="20190603T204824Z">
        <seg>事实上，现实世界中很难找到那种瞬间就生成完整数据集的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, most nontrivial operations need to memorize records or par‐ tial results because data is streamed and arrives over time.1 Many of Flink’s built-in DataStream operators, sources, and sinks are stateful and buffer records or maintain partial results or metadata.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T031240Z" creationid="xccui" creationdate="20190630T030651Z">
        <seg>事实上，由于数据会随时间以流式到来，但凡稍复杂点的操作大部分都需要对数据本身或中间结果进行记录。1很多Flink内置的DataStream算子、数据源以及数据汇都是状态化的，它们需要对数据记录进行缓冲或者对中间结果或元数据进行维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, that is what you achieve by exploiting parallelism in a stream processing pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T212158Z" creationid="xccui" creationdate="20190402T212052Z">
        <seg>事实上这就是在流处理管道中利用并行性实现的效果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, that’s what happens when you exploit parallelism in a stream processing pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235716Z" creationid="xccui" creationdate="20190605T235716Z">
        <seg>事实上这就是在流处理管道中利用并行性实现的效果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, the flatMap transformation is a gener‐ alization of filter and map and can be used to implement both those operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053755Z" creationid="xccui" creationdate="20190613T053755Z">
        <seg>事实上，flatMap转换可以看做是filter和map的泛化，能够实现它们二者的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, this has been a common implementation choice before the rise of modern stream processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053346Z" creationid="xccui" creationdate="20190414T053223Z">
        <seg>事实上，在现代流处理引擎兴起之前，状态就是一个常见的实现选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, you would like your stream processor to not only continue processing in the case of task failures, but also provide correctness guarantees about the result and operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T190419Z" creationid="xccui" creationdate="20190606T033501Z">
        <seg>事实上，你不仅需要流处理引擎在出现任务故障时可以继续运行，还需要它能保证结果和算子状态的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, you would like your stream processor to not only continue the processing in the case of task failures, but also provide correctness guarantees about the result and operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042203Z" creationid="xccui" creationdate="20190415T042023Z">
        <seg>事实上，你不仅需要流处理引擎在任务故障时可以继续运行，还需要它保证结果和算子状态的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, all data maintained by a task and used to compute the results of a function belong to the state of the task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T053933Z" creationid="xccui" creationdate="20190607T053933Z">
        <seg>通常意义上，所函数里所有需要任务去维护和用来计算结果的数据都属于任务的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, if example code is offered with this book, you may use it in your programs and documentation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210816Z" creationid="esouser" creationdate="20190603T210816Z">
        <seg>In general, if example code is offered with this book, you may use it in your programs and documentation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, it is a good idea to define the parallelism of your operators relative to the default parallelism of the environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T053829Z" creationid="xccui" creationdate="20190616T053603Z">
        <seg>一般情况下，最好将算子并行度设置为随环境默认并行度变化的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, using processing time for window operations results in nondeterministic results</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T065815Z" creationid="xccui" creationdate="20190619T065807Z">
        <seg>通常情况下，在窗口算子中使用处理时间会导致不确定的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In long-running, streaming jobs, each of these tasks can fail at any time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185813Z" creationid="xccui" creationdate="20190415T041755Z">
        <seg>对于长期运行的流式作业而言，每个任务都随时有可能出现故障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many cases, a function does not know if a record will be the last one for a key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T182628Z" creationid="xccui" creationdate="20190704T142252Z">
        <seg>很多情况下，函数不会知道某条记录是否是该键值所对应的最后一条。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many real-world applications, the system does not have enough knowledge to per&lt;t0/&gt;‐&lt;t1/&gt; fectly determine watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T211450Z" creationid="xccui" creationdate="20190412T211024Z">
        <seg>在很多现实应用中，系统必须知道足够多的信息才能完美地设置水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many real-world applications, the system does not have enough knowledge to per‐ fectly determine watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T161917Z" creationid="xccui" creationdate="20190606T025733Z">
        <seg>在很多现实应用中，系统无法得知足够多的信息来完美地确定水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, Flink can automatically infer types and generate the correct TypeInfor mation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T055139Z" creationid="xccui" creationdate="20190617T055139Z">
        <seg>大多数情况下，Flink可以自动推断类型并生成正确的TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most real-world applications, the expectation is that events should not get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034559Z" creationid="xccui" creationdate="20190606T034519Z">
        <seg>对大多数现实应用而言，用户期望是不丢事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most real-world applications, the minimum requirement is that events do not get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041926Z" creationid="xccui" creationdate="20190416T041813Z">
        <seg>对大多数现实应用而言，最低要求是不丢失事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to achieve better state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062306Z" creationid="xccui" creationdate="20190701T062306Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to achieve deterministic transformations on ConnectedStreams, connect() can be combined with keyBy() or broadcast().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045948Z" creationid="xccui" creationdate="20190615T045948Z">
        <seg>为了在ConnectedStreams上实现确定性的转换，connect()可以与keyBy()和broadcast()结合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to be able to delete the currently registered timer, its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T212811Z" creationid="xccui" creationdate="20190704T212811Z">
        <seg>为了删除当前已经注册的计时器，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to clean up all state when a window is deleted, the clear() method of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194446Z" creationid="xccui" creationdate="20190626T194350Z">
        <seg>为了在删除窗口时彻底清理状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to do this efficiently, Flink requires detailed knowledge of the types of data the application processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T063647Z" creationid="xccui" creationdate="20190616T063647Z">
        <seg>为了提高上述过程的效率，Flink需要详细了解应用处理的数据类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to enable a smooth pipelined data exchange, a TaskManager must be able to provide enough buf&lt;t2/&gt;‐&lt;t3/&gt; fers to serve all outgoing and incoming connections concurrently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044648Z" creationid="xccui" creationdate="20190504T044648Z">
        <seg>为了使流水线式的数据交换平滑进行，TaskManager必须提供足够多的缓冲区来同时服务全部进出连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to enable a smooth pipe‐ lined data exchange, a TaskManager must be able to provide enough buffers to serve all outgoing and incoming connections concurrently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193207Z" creationid="xccui" creationdate="20190606T201341Z">
        <seg>为了使流水线式的数据交换平滑进行，TaskManager必须提供足够多的缓冲区来同时服务所有进出连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to ensure at-least-once result correctness, you need to have a mechanism to replay events, either from the source or from some buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T043259Z" creationid="xccui" creationdate="20190416T042957Z">
        <seg>为了确保至少一次结果的正确，需要一些机制从源头或缓冲中重放事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to ensure at-least-once result correctness, you need to have a way to replay events—either from the source or from some buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193640Z" creationid="xccui" creationdate="20190606T034644Z">
        <seg>为了确保至少一次结果语义的正确性，需要想办法从源头或缓冲区中重放事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to evaluate such operations effi&lt;t4/&gt;‐&lt;t5/&gt; ciently on unbounded streams, you need to limit the amount of data these operations maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041628Z" creationid="xccui" creationdate="20190406T041619Z">
        <seg>为了在无限数据流上高效地执行这些操作，必须限制操作所维持的数据量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to evaluate such operations efficiently on unbounded streams, you need to limit the amount of data these operations maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061921Z" creationid="xccui" creationdate="20190606T012044Z">
        <seg>为了在无限数据流上高效地执行这些操作，必须对操作所维持的数据量加以限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to execute a dataflow program, its logical graph is converted into a physical dataflow graph, which includes details about how the computation is going to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T003156Z" creationid="xccui" creationdate="20190401T002442Z">
        <seg>为了执行dataflow程序，需要将逻辑图转化为物理dataflow图，它们包含了计算执行的细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to execute a dataflow program, its logical graph is converted into a physical dataflow graph, which specifies in detail how the program is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044306Z" creationid="xccui" creationdate="20190605T233054Z">
        <seg>为了执行Dataflow程序，需要将逻辑图转化为物理Dataflow图，后者指定了程序的执行细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to increase or decrease the parallelism of a function with operator state, the operator state needs to be redistributed to a larger or smaller number of task instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T055222Z" creationid="xccui" creationdate="20190701T055222Z">
        <seg>为了达到该目的，Flink需要将算子状态重新分配到更多或更少的任务实例上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to keep the data of the data warehouse up-to-date, ETL processes need to run periodically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192243Z" creationid="xccui" creationdate="20190228T191319Z">
        <seg>同时为了保证数据仓库中数据的实效，ETL流程需要定期重复执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to make Flink’s runtime aware of the state of an operator, the operator needs to register its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055945Z" creationid="xccui" creationdate="20190607T055945Z">
        <seg>为了让Flink的运行层知道算子有哪些状态，算子需要自己注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to populate a data ware&lt;t2/&gt;‐&lt;t3/&gt; house, the data managed by the transactional database systems needs to be copied to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T191750Z" creationid="xccui" creationdate="20190228T184446Z">
        <seg>为了填充它，需要将事务型数据库系统中的数据拷贝过去，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to populate a data warehouse, the data managed by the transac‐ tional database systems needs to be copied to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T202712Z" creationid="esouser" creationdate="20190603T202712Z">
        <seg>为了填充数据仓库，需要将事务型数据库系统中的数据拷贝过去，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to prevent increasing resource consumption of an application over time, it is important that the size of the operator state be controlled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T135741Z" creationid="xccui" creationdate="20190704T135607Z">
        <seg>为了防止应用资源随时间而耗尽，关键要控制算子状态大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to provide a concise window operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T024653Z" creationid="xccui" creationdate="20190626T015035Z">
        <seg>为了使窗口算子的API保持简洁，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to provide fault tolerance for an application, the JobManager initiates checkpoints at regular intervals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204550Z" creationid="xccui" creationdate="20190702T204550Z">
        <seg>为了支持应用容错，JobManager会以固定间隔开始创建检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to read</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T023659Z" creationid="xccui" creationdate="20190704T023659Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to satisfy the requirements for task chaining, two or more operators must be configured with the same parallelism and be connected by local forward channels.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152052Z" creationid="esouser" creationdate="20190514T152010Z">
        <seg>为了满足任务链接的条件，多个算子必须有相同的并发度且通过本地转发通道连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to satisfy the requirements for task chaining, two or more operators must be configured with the same parallelism and connected by local forward channels.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203321Z" creationid="xccui" creationdate="20190606T203255Z">
        <seg>任务链接的前提条件是，多个算子必须有相同的并发度且通过本地转发通道连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to use processing time, replace TimeCharacteristic.EventTime with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T073049Z" creationid="xccui" creationdate="20190619T073049Z">
        <seg>如果需要使用处理时间，请将TimeCharacteristic.EventTime替换为TimeCharacteristic.ProcessingTime。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, events can be simply dropped and nothing is done to ensure result correctness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034357Z" creationid="xccui" creationdate="20190606T034357Z">
        <seg>换句话说，事件可以随意丢弃，没有任何机制来保证结果的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, events can be simply dropped and there is no mechanism to ensure result correctness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T184510Z" creationid="xccui" creationdate="20190415T184441Z">
        <seg>换句话说，事件可以随意丢弃，没有任何机制来保证结果的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our discussion about event-time windows so far, we have overlooked one very important aspect: &lt;t0/&gt;how do we decide when to trigger an event-time window&lt;t1/&gt;?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T160625Z" creationid="xccui" creationdate="20190412T160108Z">
        <seg>在到目前为止有关事件时间窗口的讨论中，我们一直忽略了一个非常重要的方面：如何决定触发事件时间窗口的时间？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our discussion about event-time windows so far, we have overlooked one very important aspect: how do we decide when to trigger an event-time window?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025229Z" creationid="xccui" creationdate="20190606T025229Z">
        <seg>在到目前为止有关事件时间窗口的讨论中，我们一直忽略了一个非常重要的方面：如何决定触发事件时间窗口的时间？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, the result is a DataStream[SensorReading] record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054549Z" creationid="xccui" creationdate="20190612T054549Z">
        <seg>在所给示例中，结果是DataStream[SensorReading]中的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we define the AverageSensorReadings object and include most of the application logic inside main().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043342Z" creationid="xccui" creationdate="20190612T043342Z">
        <seg>在示例中，我们定义了AverageSensorReadings对象，并将大部分应用逻辑都放到了main()方法里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we first apply a map() transformation that converts the temperature of each sensor reading to Celsius.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053231Z" creationid="xccui" creationdate="20190612T053231Z">
        <seg>在示例中，我们首先利用map()转换将每个传感器读取的温度都转换为摄氏度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we retrieve the execution environment by calling the static getExecutionEnvironment() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045057Z" creationid="xccui" creationdate="20190612T045057Z">
        <seg>在示例中，我们通过调用静态的getExecutionEnvironment()方法来获取执行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example, we use:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051434Z" creationid="xccui" creationdate="20190612T051404Z">
        <seg>在示例中，我们通过：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In parallel windows, each partition applies the window policies independently of other partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T195229Z" creationid="xccui" creationdate="20190409T194934Z">
        <seg>并行窗口中，每个数据分区都会都会各自应用独立于其他分区的窗口策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In parallel windows, each partition applies the win‐ dow policies independently of other partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014028Z" creationid="xccui" creationdate="20190606T013916Z">
        <seg>并行窗口中，每个数据分区所应用的窗口策略都相互独立。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular the following features let it stand out:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042143Z" creationid="xccui" creationdate="20190328T041315Z">
        <seg>尤其是以下功能使其在同类系统中脱颖而出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the following features make Flink stand out:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054030Z" creationid="xccui" creationdate="20190605T054030Z">
        <seg>尤其是以下功能使其在同类系统中脱颖而出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, we explain Flink’s distributed architecture, show how Flink handles time and state in streaming applications, and discuss its fault tolerance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T054253Z" creationid="xccui" creationdate="20190416T054235Z">
        <seg>我们将重点解释Flink的分布式架构，展示它如何在流式应用中处理时间和状态并讨论它的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, we explain Flink’s distributed architecture, show how it handles time and state in streaming applications, and discuss its fault- tolerance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T043016Z" creationid="xccui" creationdate="20190606T140115Z">
        <seg>我们会重点解释Flink的分布式架构，展示它如何在流式应用中处理时间和状态，并讨论它的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice though you might want to partition a stream into multiple logical streams and define &lt;t2/&gt;parallel&lt;t3/&gt; windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193928Z" creationid="xccui" creationdate="20190409T193840Z">
        <seg>但在实际应用中，你可能会想将数据流划分为多条逻辑流并定义一些并行窗口（parallel window）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, you need to make an educated guess and use heuristics to generate watermarks in your applica‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T033656Z" creationid="xccui" creationdate="20190621T031744Z">
        <seg>实际操作时，你需要一些有依据的猜测并使用启发式方法为你的应用生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In principle, save‐ points are created using the same algorithm as checkpoints and hence are basically checkpoints with some additional metadata.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210719Z" creationid="xccui" creationdate="20190609T210541Z">
        <seg>原则上，保存点的生成算法和检查点完全一样，因此可以把保存点看做包含一些额外元数据的检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In principle, state can be stored and accessed in many different places including pro&lt;t0/&gt;‐&lt;t1/&gt; gram variables, local files, or embedded or external databases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T031704Z" creationid="xccui" creationdate="20190305T031345Z">
        <seg>原则上，可以在很多不同的位置存储并访问状态，例如：应用程序变量、本地文件、嵌入式或外部数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In principle, state can be stored and accessed in many different places including pro‐ gram variables, local files, or embedded or external databases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T031625Z" creationid="esouser" creationdate="20190603T205858Z">
        <seg>原则上，需要在应用中访问的状态有多种可选的存储位置，例如：程序变量、本地文件、嵌入式或外部数据库等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In streaming systems you usually want to ensure that your system can handle the maximum expected rate of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052415Z" creationid="xccui" creationdate="20190401T203251Z">
        <seg>在流处理系统中，你通常希望系统有能力应对以最大期望速率到来的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a case, a function with keyed state would accumulate state for more and more</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T141436Z" creationid="xccui" creationdate="20190704T141354Z">
        <seg>此时，具有键值分区状态的函数就会积累越来越多的键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such a case, a job is executed repeatedly over batches of incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053531Z" creationid="xccui" creationdate="20190414T053446Z">
        <seg>在以往的场景中，作业会在批量传入的事件上重复执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such applications, we would like to group together events that origin from the same period of user activity or &lt;t5/&gt;session&lt;t6/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025410Z" creationid="xccui" creationdate="20190407T025207Z">
        <seg>在该应用中我们要把事件按照用户的同一活动或会话来源进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such applications, we would like to group together events that originate from the same period of user activity or session.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013602Z" creationid="xccui" creationdate="20190606T013602Z">
        <seg>在该应用中我们要把事件按照用户的同一活动或会话来源进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, you need to generate a TypeInformation for a specific data type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053326Z" creationid="xccui" creationdate="20190617T053326Z">
        <seg>这些情况下，你就需要为特定数据类型生成TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, it is recom‐ mended to not use timers excessively, to avoid long checkpointing times.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T070042Z">
        <seg>在这种情况下，建议不要使用太多计时器，以避免检查点生成时间太久。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the DataStream API this is done by providing a ProcessWindowFunction as a sec‐ ond parameter to the reduce() or aggregate() methods as shown in the following code:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040327Z" creationid="xccui" creationdate="20190625T040327Z">
        <seg>如以下代码所示，在DataStream API中，实现该过程的途径是将ProcessWindowFunction作为reduce()或aggregate()方法的第二个参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the DataStream API, the execution environment of an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044948Z" creationid="xccui" creationdate="20190612T044948Z">
        <seg>在DataStream API中，执行环境用StreamExecutionEnvironment表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Data‐ Stream API, you can use the time characteristic to tell Flink how to define time when you are creating windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T055236Z" creationid="xccui" creationdate="20190619T055236Z">
        <seg>在DataStream API中，你可以使用时间特性告诉Flink在创建窗口时如何定义时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Java DataStream API, you can also use the returns() method to explicitly specify the return type of an operator when defining the dataflow as shown in the fol‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062203Z" creationid="xccui" creationdate="20190617T062203Z">
        <seg>你还可以像下面这样，在定义dataflow时使用Java DataStream API中的returns()方法来显式指定某算子的返回类型：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Scala API, Flink uses Scala compiler macros that generate TypeInformation objects for all data types at compile time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054714Z" creationid="xccui" creationdate="20190617T054714Z">
        <seg>在Scala API中，Flink利用Scala编译器的宏功能在编译时为所有数据类型生成TypeInformation对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the beginning of this chapter, you saw how you can model streaming programs as dataflow graphs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185224Z" creationid="xccui" creationdate="20190415T041033Z">
        <seg>在本章开头，你学到了如何将流处理程序建模成Dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of a mobile game, consequences can be as bad as Alice and her team getting disappointed and never playing again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155144Z" creationid="xccui" creationdate="20190411T153935Z">
        <seg>在这个手游例子中，后果可能非常糟糕，以至于爱丽丝和她团队的其他玩家失望透顶，再也不想碰这个游戏。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of downscaling, the surplus tasks are simply canceled since state is already replicated and will not be lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062154Z" creationid="xccui" creationdate="20190608T061946Z">
        <seg>在缩容的情况下，由于状态经过复制不会丢失，我们可以简单地停掉多出的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the coffee shop example, you will probably see this happening right after lunch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053151Z" creationid="xccui" creationdate="20190401T210715Z">
        <seg>在咖啡店的例子中，你很有可能在午餐后见到这种情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of an event- time window operator, an event is late if it arrives at the operator and the window assigner maps it to a window that has already been computed because the operator’s watermark passed the end timestamp of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T152848Z" creationid="xingcan" creationdate="20190628T152848Z">
        <seg>在事件时间窗口算子的环境下，如果事件到达算子时，窗口分配器为其分配的窗口已经因为算子水位线超过了它的结束时间而计算完毕，那么该事件就被认为是迟到的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of stream processing, one disadvantage of buffering is that it adds latency because records are collected in a buffer instead of being immediately shipped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194650Z" creationid="esouser" creationdate="20190513T210715Z">
        <seg>在流处理环境下，缓冲的一个明显缺点是会增加延迟，因为记录首先要收集到缓冲区中而不会立即发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, MyAssigner can either be of type AssignerWithPeriodicWater marks or AssignerWithPunctuatedWatermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044801Z" creationid="xccui" creationdate="20190620T044801Z">
        <seg>在上面的例子中，MyAssigner既可以是AssignerWithPeriodicWatermarks，也可以是AssignerWithPunctuatedWatermarks.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the stream is keyed by language and the result is a continuously updated list of words per language:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062219Z" creationid="xccui" creationdate="20190614T062107Z">
        <seg>在下面的示例中，数据流会以语言字段（译者注：第1个字段）为键值进行分区，最终输出结果是针对每种语言产生一个不断更新的单词列表：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following example, the source operator will be executed with the default parallel‐ ism of the environment, the map transformation has double as many tasks as the source, and the sink operation will always be executed by two parallel tasks:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061542Z" creationid="xccui" creationdate="20190616T061542Z">
        <seg>下面的示例中，数据源算子会以环境默认并行度执行，map转换的任务数是数据源的两倍，数据汇操作固定以两个并行任务执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following example, we implement a FilterFunction that filters for strings that contain the word "flink":</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T053958Z" creationid="xccui" creationdate="20190618T053958Z">
        <seg>下面的例子中，我们实现了一个FilterFunction，用来过滤出所有包含"flink"一词的字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, we briefly discuss credit-based flow control and task chain&lt;t0/&gt;‐&lt;t1/&gt; ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T205548Z" creationid="esouser" creationdate="20190513T192619Z">
        <seg>在接下来的几节，我们简要讨论一下基于信任度的流量控制以及任务链接（task chaining）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, we briefly discuss credit-based flow control and task chain‐ ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194425Z" creationid="xccui" creationdate="20190606T202141Z">
        <seg>在接下来的几节，我们简要讨论一下基于信用值（credit-based）的流量控制以及任务链接（task chaining）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, we discuss the lifecycle of windows and introduce the inter‐ faces to define custom window assigners, triggers, and evictors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T030123Z" creationid="xccui" creationdate="20190626T030123Z">
        <seg>下面几节我们将讨论窗口的生命周期并介绍用于自定义分配器、触发器以及移除器的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, we discuss these three cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035945Z" creationid="xccui" creationdate="20190705T035945Z">
        <seg>接下来的几节我们就来详细讨论一下这三种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following we describe how to set these parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015318Z" creationid="xccui" creationdate="20190703T013429Z">
        <seg>下面我们来介绍如何设置它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following we present three classes of applications that are commonly implemented using stateful stream processing, 1) event-driven applications, 2) data pipeline applications, and 3) data analytics applications and give examples of real-world applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T153749Z" creationid="xccui" creationdate="20190305T153717Z">
        <seg>接下来我们结合例子，介绍三类常见的状态化流处理应用：1）事件驱动型应用；2）数据管道应用；3）数据分析应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following we will describe how Flink internally implements and handles timestamps and water&lt;t4/&gt;‐&lt;t5/&gt; marks to support streaming applications with event-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035243Z" creationid="xccui" creationdate="20190523T035101Z">
        <seg>接下面我们会介绍Flink内部如何实现和处理时间戳及水位线以支持事件时间语义的流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, the KeySelector function returns the maximum of the tuple fields as the key:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052138Z" creationid="xccui" creationdate="20190618T052138Z">
        <seg>下面的示例中，KeySelector函数会返回元组中最大的字段作为键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we briefly describe the contents and style of each chapter, so you can directly jump to the part that interests you most.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T163452Z" creationid="xccui" creationdate="20190225T163433Z">
        <seg>接下来我们简要介绍一下每个章节的内容和特点，以便于你直接跳到最感兴趣的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we briefly describe the contents of each chapter, so you can directly jump to those chapters that interest you most.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041630Z" creationid="esouser" creationdate="20190603T153658Z">
        <seg>接下来我们会简要介绍一下每个章节的内容，便于你直接跳到最感兴趣的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we define a case class Person with two fields: name and age.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040740Z" creationid="xccui" creationdate="20190617T040740Z">
        <seg>下方我们定义了一个样例类Person，它有两个字段：name和age。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we describe how Flink internally implements and handles timestamps and watermarks to support streaming applications with event-time semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204715Z" creationid="xccui" creationdate="20190606T204617Z">
        <seg>接下面我们会介绍Flink内部如何实现和处理时间戳及水位线以支持事件时间语义的流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we describe how to obtain the code examples we use here, how to import them into IntelliJ, how to run an example application, and how to debug it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T035134Z" creationid="xccui" creationdate="20190611T035122Z">
        <seg>下文我们会介绍如何获取书中用到的代码，如何将它们导入IntelliJ以及如何运行和调试它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we describe in detail how a task emits watermarks to multiple output tasks and how it advances its event-time clock from the watermarks it receives from its input tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T024024Z" creationid="xccui" creationdate="20190607T015241Z">
        <seg>下面我们将详细介绍一个任务如何将水位线发送至多个输出任务以及它从多个输入任务获取水位线后如何推动事件时间时钟前进。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we discuss different methods to reference fields and define keys on data types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T064316Z" creationid="xccui" creationdate="20190617T064316Z">
        <seg>接下来我们将讨论基于数据类型定义引用字段和键值的几种方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we discuss the DataStream API transformations that process multiple input streams or emit multiple output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T063511Z" creationid="xccui" creationdate="20190614T063511Z">
        <seg>接下来我们就开始讨论那些能同时处理多条输入流或产生多条结果流的DataStream API转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we discuss these options in detail and show how they are applied for process functions and window operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T153228Z" creationid="xingcan" creationdate="20190628T153228Z">
        <seg>下面我们将详细讨论这些选项，看一看它们如何用于处理函数和窗口算子中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we explain how applications can be evolved while preserving savepoint compatibility.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="xccui" creationdate="20190705T023232Z">
        <seg>接下来我们将介绍如何在保持检查点兼容的前提下更新应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we explain how this algorithm works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060033Z" creationid="xccui" creationdate="20190609T060033Z">
        <seg>接下来我们解释一下这个算法的工作原理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we explain this step in detail for IntelliJ.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041041Z" creationid="xccui" creationdate="20190611T040830Z">
        <seg>下文我们会以IntelliJ为例对该步骤进行详细解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we present three classes of applications that are commonly implemented using stateful stream processing: (1) event-driven applications, (2) data pipeline applications, and (3) data analytics applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T212222Z" creationid="esouser" creationdate="20190603T212154Z">
        <seg>接下来我们介绍三类常见的状态化流处理应用：1）事件驱动型应用；2）数据管道应用；3）数据分析应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we show the different built-in window assigners of the DataStream API and how to use them to define window operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041952Z" creationid="xccui" creationdate="20190623T041952Z">
        <seg>接下来我们将对DataStream API中的多种内置窗口分配器以及如何用它们来定义窗口算子进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we will guide you through the process of starting a local cluster and executing a streaming application to give you a first look at Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T065047Z" creationid="xccui" creationdate="20190605T122436Z">
        <seg>为了让你对Flink有一个初步印象，接下来我们将一步步指导你启动本地集群并运行一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following, we will use a keyBy transformation to convert a DataStream into a KeyedStream and keyed transformations such as rolling aggrega‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050213Z" creationid="xccui" creationdate="20190614T050124Z">
        <seg>下面我们将使用keyBy转换将一个DataStream转化为KeyedStream，然后对它进行滚动聚合以及reduce。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the introductory example of this chapter, we defined the following case class:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051654Z" creationid="xccui" creationdate="20190618T042328Z">
        <seg>在本章的开篇示例中，我们定义了如下样例类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the library mode, there is no Flink ser&lt;t0/&gt;‐&lt;t1/&gt; vice continuously running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041017Z" creationid="xccui" creationdate="20190423T040707Z">
        <seg>而在库模式中，Flink服务不是一直运行，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the library style, there is no Flink service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144231Z" creationid="xccui" creationdate="20190606T144151Z">
        <seg>而在库模式中，Flink不是作为服务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the mobile gaming case for example, it is practically impossible to know for how long a user might remain disconnected; they could be going through a tunnel, boarding a plane, or never playing again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T030410Z" creationid="xccui" creationdate="20190414T030248Z">
        <seg>以手游场景为例，现实中根本无法得知用户离线多久，他们可能正在过隧道，可能正在上飞机，也可能直接退坑不玩了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the mobile gaming example, it is practically impossi‐ ble to know how long a user might remain disconnected; they could be going through a tunnel, boarding a plane, or never playing again.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T161937Z" creationid="xccui" creationdate="20190606T025740Z">
        <seg>以手游场景为例，现实中根本无法得知用户会离线多久。他们可能正在过隧道，可能正在上飞机，也可能直接退坑不玩了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the next section, we discuss task failures and result guarantees in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033049Z" creationid="xccui" creationdate="20190606T033021Z">
        <seg>在下一节，我们会讨论有关任务故障和结果保障的详情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the next section, you will learn about task failures and result guarantees in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035719Z" creationid="xccui" creationdate="20190415T035232Z">
        <seg>在下一节，你将了解任务故障和结果保障的详细信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the past, analyzing data with a few hours or even days delay was often</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032918Z" creationid="xccui" creationdate="20190317T032601Z">
        <seg>在过去，由于对最新结果或见解的快速反应并不会产生显著优势，因此人们完全可以接受分析数据存在几小时甚至几天的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the preceding code, elements are allowed to be late up to 10 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T053005Z" creationid="xccui" creationdate="20190620T053005Z">
        <seg>以上代码中，元素最多允许延迟10秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the preceding example, you instruct the program to emit watermarks every 5 sec‐ onds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045838Z" creationid="xccui" creationdate="20190620T045838Z">
        <seg>在上方示例中，你指示程序每隔5秒发出一次水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the previous chapter, you saw how streaming applications have different opera&lt;t0/&gt;‐&lt;t1/&gt; tional requirements from traditional batch programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150245Z" creationid="xccui" creationdate="20190401T150006Z">
        <seg>在上一章，你已经了解了流式应用在操作需求方面和传统批处理程序有所不同，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the remainder of the chapter we focus on keyed windows only.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041511Z" creationid="xccui" creationdate="20190622T041511Z">
        <seg>在本章剩余部分，我们将只关注键值分区窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this book, we are going to see how Flink actually implements these concepts and how you can use its DataStream API to write applications that use all of the features we have introduced so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T195509Z" creationid="xccui" creationdate="20190606T041244Z">
        <seg>在本书的剩余部分，我们会介绍Flink是如何实现这些概念的，以及怎样利用它的DataStream API来编写一些涵盖了目前为止所讲特性的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this book, we are going to see how Flink actually implements these concepts and how you can use its DataStream APIs to write applications that use all of the features that we have introduced so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052330Z" creationid="xccui" creationdate="20190416T051935Z">
        <seg>在本书的其余部分，我们会介绍Flink是如何实现这些概念的，以及怎样利用它的DataStream API来编写那些涵盖目前所介绍的所有特性的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, we are going to look deeper into the concepts of time and state guarantees under failures in data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T205822Z" creationid="xccui" creationdate="20190409T205616Z">
        <seg>在本章剩余部分，我们将深入研究流处理发生故障时的时间和状态保障相关概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, we are going to look deeper into the concepts of time and state guarantees under failures in data stream process‐ ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064752Z" creationid="xccui" creationdate="20190606T014614Z">
        <seg>在本章剩余部分，我们将深入研究流处理中的时间以及在发生故障时和状态保障相关概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, when we talk about “result guarantees” we mean the consistency of the internal state of the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034209Z" creationid="xccui" creationdate="20190606T034209Z">
        <seg>在本章剩余部分，当提到"结果保障"，我们指的是流处理引擎内部状态的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the rest of this chapter, when we talk about “result guarantees” we refer to the consistency of the internal state of the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T045234Z" creationid="xccui" creationdate="20190415T044920Z">
        <seg>在本章剩余部分，当提到"结果保障"，我们指的是流处理引擎内部状态的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the streaming world, however, dealing with failures is not a trivial problem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044227Z" creationid="xccui" creationdate="20190415T044227Z">
        <seg>然而在流式场景中，处理故障就没那么容易了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the streaming world, however, dealing with fail‐ ures is not a trivial problem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034123Z" creationid="xccui" creationdate="20190606T034123Z">
        <seg>然而在流式场景中，处理故障就没那么容易了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the very simple case, there will be at least one source and one sink apart from the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045446Z" creationid="xccui" creationdate="20190416T045403Z">
        <seg>即便是最简单的情形，除了流处理引擎也至少要有一个数据源和一个数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the worst case, you will locate the event more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193329Z" creationid="xccui" creationdate="20190416T042615Z">
        <seg>它最坏的情况也无非就是多几次定位到目标事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this architecture the event log acts as a source of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T060836Z" creationid="xccui" creationdate="20190305T060746Z">
        <seg>在该架构下，事件日志扮演了真实数据源的角色，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this architecture the event log persists the input events and can replay them in deterministic order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T032438Z" creationid="esouser" creationdate="20190603T211452Z">
        <seg>在该架构下，事件日志系统可以持久化输入事件并以确定的顺序将其重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, any custom states of the triggers also need to be merged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194925Z" creationid="xccui" creationdate="20190626T194925Z">
        <seg>在该情况下所有触发器的自定义状态同样需要合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, late events might arrive after the watermark, and we should provide some code to handle them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025649Z" creationid="xccui" creationdate="20190606T025649Z">
        <seg>该情况下，延迟事件可能会在水位线之后到来，我们必须额外加一些代码来处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, late&lt;t2/&gt; &lt;t3/&gt;events might arrive after the watermark and we should provide some code to handle them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210653Z" creationid="xccui" creationdate="20190412T210653Z">
        <seg>该情况下，延迟事件可能会在水位线之后到来，我们必须额外加一些代码来处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the dependencies are loaded into the classpath when Flink processes are started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041732Z" creationid="xccui" creationdate="20190619T041732Z">
        <seg>这样在Flink进程启动时就会将依赖加载到classpath中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the positions are provided as a list, one after the other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T040655Z" creationid="xccui" creationdate="20190618T033756Z">
        <seg>只需将所有位置以列表的形式逐一提供即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, you can ach&lt;t2/&gt;‐&lt;t3/&gt; ieve exactly-once semantics with at-least-once guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050315Z" creationid="xccui" creationdate="20190416T050315Z">
        <seg>该情况下，你可以利用至少一次保障去实现精确一次的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, you can achieve exactly-once semantics with at-least-once guar‐ antees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194838Z" creationid="xccui" creationdate="20190606T035403Z">
        <seg>该情况下，你可以用至少一次保障来实现精确一次的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we discuss why stateful stream processing is becoming so popular and assess its potential.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T222743Z" creationid="xccui" creationdate="20190225T222138Z">
        <seg>本章我们将讨论为何状态化流处理会变得流行，并进一步评估它的发展潜力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we discussed Flink’s high-level architecture and the internals of its net‐ working stack, event-time processing mode, state management, and failure recovery mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T031909Z" creationid="xccui" creationdate="20190610T030858Z">
        <seg>本章我们主要讨论了Flink的高层次设计架构以及内部的网络栈、事件时间处理模式、状态管理以及故障恢复机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we give a high-level introduc&lt;t0/&gt;‐&lt;t1/&gt; tion to Flink’s architecture and describe how Flink addresses the aspects of stream processing that we discussed before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T054045Z" creationid="xccui" creationdate="20190416T053847Z">
        <seg>本章中我们将从一个较高的层次来讲解Flink的架构，并介绍Flink是如何解决之前讨论的流处理相关问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we introduced the basics of Flink’s DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T043534Z" creationid="xccui" creationdate="20190619T043534Z">
        <seg>本章我们介绍了Flink DataStream API的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter you learned how to implement streaming applications that operate on time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041419Z" creationid="xccui" creationdate="20190629T041419Z">
        <seg>在本章中，你学到了如何实现对时间进行操作的流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter you learned how to set up an environment to develop and debug Flink DataStream applications and how to generate a Maven project using Flink’s Maven archetype.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010845Z" creationid="xccui" creationdate="20190612T010845Z">
        <seg>本章你学到了如何设置一个用于开发和调试Flink DataStream应用的环境，以及如何使用Flink的Maven模板生成Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we discuss why stateful stream processing is becoming so popular and assess its poten‐ tial.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063642Z" creationid="esouser" creationdate="20190603T163008Z">
        <seg>本章我们会讨论为何状态化流处理会变得如此流行，并进一步评估其发展潜力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we give a high-level introduction to Flink’s architecture and describe how Flink addresses the aspects of stream processing we discussed earlier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T042917Z" creationid="xccui" creationdate="20190606T140002Z">
        <seg>本章我们将从一个较高的层次来讲解Flink的架构，并介绍它如何解决我们之前讨论的流处理相关问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we introduced stateful stream processing, discussed its use cases, and had a first look at Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124639Z" creationid="xccui" creationdate="20190605T124639Z">
        <seg>本章我们介绍了状态化流处理，讨论了它的几个用例并对Apache Flink进行了初步介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, we will cover DataStream API methods for time handling and time- based operators, like windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T050036Z" creationid="xccui" creationdate="20190619T050036Z">
        <seg>本章我们将介绍DataStream API中用于处理时间和方法以及基于时间的算子，例如窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you have learned the fundamental concepts and ideas of data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051435Z" creationid="xccui" creationdate="20190416T050432Z">
        <seg>本章中你主要学习了数据流处理的基本概念和思想。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you learned the fundamentals of data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194856Z" creationid="xccui" creationdate="20190606T035408Z">
        <seg>本章主要教给你数据流处理相关的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you will enter the streaming world for good and you will get the necessary background for the rest of this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T053424Z" creationid="xccui" creationdate="20190329T053246Z">
        <seg>在本章中，你将踏入流处理的世界并从中获得本书其余部分所需的背景知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you will enter the streaming world for good.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T042452Z" creationid="xccui" creationdate="20190605T224655Z">
        <seg>本章将正式引领你踏入流处理的世界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter, you will learn how to set up an environment to develop, run, and debug Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012943Z" creationid="xccui" creationdate="20190610T040115Z">
        <seg>本章你将学到如何搭建一个用于开发、运行和调试Flink应用的环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example the tuple input stream is keyed by the first field and the rolling sum is computed on the second field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054950Z" creationid="xccui" creationdate="20190614T054950Z">
        <seg>该示例中，输入流的元组按照第1个字段进行分区，然后滚动计算第2个字段的总和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, after reading the stream, we first apply a filter transformation and then call the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044508Z" creationid="xccui" creationdate="20190620T044508Z">
        <seg>在这个例子中，我们首先使用了一个过滤转换，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this mode, Flink applications are packaged into a JAR file and submitted by a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143428Z" creationid="xccui" creationdate="20190606T143415Z">
        <seg>在该模式下，Flink应用会打包成一个JAR文件，通过客户端提交到运行的服务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this mode, the Flink application is bundled in an application-specific con‐ tainer image, such as a Docker image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143707Z" creationid="xccui" creationdate="20190606T143646Z">
        <seg>在该模式下，Flink应用会绑定到一个特定应用的容器映像（如Docker映像）中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this scenario, a stateful function receives records with keys that are only active for a cer‐ tain period of time and are never received after that.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T141245Z" creationid="xccui" creationdate="20190704T141006Z">
        <seg>在该场景下，有状态函数所接收记录的键值只有一段特定时间的活跃期，此后就再也不会收到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this scenario, you want to know if there has been an accident in a certain location within the last few minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043257Z" creationid="xccui" creationdate="20190406T043238Z">
        <seg>在该场景下，你想知道在最近几分钟内某个特定位置有没有发生交通事故。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section we describe the different components that a Flink setup consists of and discuss their responsibilities and how they interact with each other to execute an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033253Z" creationid="xccui" creationdate="20190418T032751Z">
        <seg>在本节，我们将首先介绍Flink设置中的不同组件，讨论它们的职责以及在运行应用时如何交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section we give an overview of the basic transformations of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T012954Z" creationid="xccui" creationdate="20190613T012853Z">
        <seg>本节我们将对DataStream API中的基本转换做一个概览。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070259Z" creationid="xccui" creationdate="20190615T070259Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe both operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210559Z" creationid="xccui" creationdate="20190627T210559Z">
        <seg>本节我们会对两个算子进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe how Flink initializes the state of an application started from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214403Z" creationid="xccui" creationdate="20190609T214356Z">
        <seg>本节我们会介绍Flink在从保存点启动时如何去初始化应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe the different components of a Flink setup and how they interact with each other to execute an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T045129Z" creationid="xccui" creationdate="20190606T140844Z">
        <seg>本节我们将介绍搭建Flink时所涉及的不同组件并讨论它们在应用运行时的交互过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe the most common streaming operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235815Z" creationid="xccui" creationdate="20190402T213018Z">
        <seg>在本节中，我们来介绍最常见的流式操作，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we describe the semantics of common window types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T050438Z" creationid="xccui" creationdate="20190406T050413Z">
        <seg>本节我们会介绍常见窗口类型的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss aspects that need to be taken into account to ensure robust execution behavior and consistent performance of long- running applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T213613Z" creationid="xccui" creationdate="20190703T211557Z">
        <seg>本节我们将重点讨论几个方面，它们可以为长期运行应用的健壮执行及一致性能提供保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss both types and how they manage and process data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T023126Z" creationid="esouser" creationdate="20190603T194239Z">
        <seg>在本节中，我们将讨论这两类处理模型以及它们如何管理和处理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss how operators process watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040632Z" creationid="xccui" creationdate="20190529T040632Z">
        <seg>在本节中，我们讨论算子如何处理水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss the different types of functions that can be applied on a window to perform aggregations or arbitrary computations on the window’s con‐ tents.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211733Z" creationid="xccui" creationdate="20190623T211733Z">
        <seg>本节我们将讨论一些可应用于窗口上的不同函数，它们可以对窗口内容执行聚合或任意计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss the different types of states Flink supports.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T053356Z" creationid="xccui" creationdate="20190607T053343Z">
        <seg>本节我们会对Flink支持的不同类别的状态加以讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss the lifecycle of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032353Z" creationid="xccui" creationdate="20190626T032353Z">
        <seg>本节我们将讨论窗口的生命周期，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss the types supported by Flink, how to create type informa‐ tion for a data type, and how to help Flink’s type system with hints if it cannot auto‐ matically infer the return type of a function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T064849Z" creationid="xccui" creationdate="20190616T064849Z">
        <seg>本节我们会讨论Flink支持的类型，如何为数据类型创建类型信息，以及当Flink无法自动推断函数的返回类型时如何以提示的方式帮助类型系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss window operations, which provide such a mech&lt;t6/&gt;‐&lt;t7/&gt; anism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041719Z" creationid="xccui" creationdate="20190406T041719Z">
        <seg>在本章中，我们以窗口操作为例讨论这个机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we discuss window operations, which pro‐ vide this service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T062107Z" creationid="xccui" creationdate="20190606T012050Z">
        <seg>在本节中，我们将讨论提供了此项功能的窗口操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we explain the different ways in which you can define and para‐ metrize functions in the DataStream API in more detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T053322Z" creationid="xccui" creationdate="20190618T052914Z">
        <seg>本节我们会对在DataStream API中定义和参数化函数的各种方式进行一个更加详细的解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we introduce time semantics and describe the different notions of time in streaming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T152542Z" creationid="xccui" creationdate="20190409T205917Z">
        <seg>本节我们将介绍流式场景中时间语义和不同的时间概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we present Flink’s checkpointing and recovery mechanism to guaran‐ tee exactly-once state consistency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154954Z" creationid="xccui" creationdate="20190608T153948Z">
        <seg>本节我们会介绍Flink的检查点以及故障恢复机制，看一下它们如何提供精确一次的状态一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we show how functions with keyed and operator state are implemented.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T035207Z">
        <seg>本节我们将展示如何实现带有键值分区状态和算子状态的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we show you how to define window operators, present the built- in window types of the DataStream API, discuss the functions that can be applied on a window, and finally explain how to define custom windowing logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T034040Z" creationid="xccui" creationdate="20190622T034040Z">
        <seg>本节我们将向你展示如何定义窗口算子，介绍DataStream API的内置窗口类型，讨论可用于窗口的函数并说明如何自定义窗口逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we will see how to use watermarks to configure event-time window behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160859Z" creationid="xccui" creationdate="20190606T025254Z">
        <seg>在本节中，我们将了解如何利用水位线来设定事件时间窗口的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, we will see how we can use the concept of &lt;t2/&gt;watermarks &lt;t3/&gt;to configure event-time window behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T204619Z" creationid="xccui" creationdate="20190412T204508Z">
        <seg>在本节中，我们来看一下如何利用水位线概念来设定事件窗口的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, you are going to learn how to process infinite streams in parallel, using the dataflow programming paradigm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045834Z" creationid="xccui" creationdate="20190605T233704Z">
        <seg>本节你将学到如何利用Dataflow编程范式并行处理无限数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, you are going to learn the concepts of processing infinite streams in parallel, using the dataflow programming paradigm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T145933Z" creationid="xccui" creationdate="20190401T143350Z">
        <seg>本节中你将学到用dataflow编程范式去并行处理无限数据流的相关概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section, you will learn how Flink restarts failed processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072142Z" creationid="xccui" creationdate="20190428T205043Z">
        <seg>本节你将学到Flink如何重启故障进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this situation, the JobManager will ask the ResourceManager to provide</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210310Z" creationid="xccui" creationdate="20190428T205838Z">
        <seg>这时候JobManager就会向ResourceManager申请更多的处理槽，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this situation, the JobManager will ask the ResourceManager to provide more processing slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145522Z" creationid="xccui" creationdate="20190606T145500Z">
        <seg>这时候JobManager就会向ResourceManager申请更多的处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Checkpoints, Savepoints, and State Recovery”, we explained Flink’s mechanism to create consistent checkpoints of a stateful application, a snapshot of the state of all built-in and user-defined stateful functions at a point in time when all operators pro‐ cessed all events up to a specific position in the application’s input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204418Z" creationid="xccui" creationdate="20190702T204418Z">
        <seg>在"检查点、保存点即状态恢复"一节，我们解释了Flink为状态化应用创建一致性检查点的机制——在所有算子都处理到应用输入流的某一特定位置时，为全部内置或用户定义的有状态函数基于该时间点创建一个状态快照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Controlling Task Chaining” on page 261, we show how to disable task chaining for an application and how to control the chaining behavior of individual operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T202250Z" creationid="xccui" creationdate="20190606T204112Z">
        <seg>在第261页的"控制任务链接"一节，我们会展示如何针对某一应用禁用任务链接以及如何单独控制单个算子的链接行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Controlling Task Scheduling” on page 260 we discuss how to con‐ trol the scheduling of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144841Z" creationid="xccui" creationdate="20190606T144841Z">
        <seg>我们将在260页"控制任务调度"一节讨论如何控制任务调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Deployment Modes” on page 221, we will dis‐ cuss how to set up and configure Flink for different environments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143345Z" creationid="xccui" creationdate="20190606T143345Z">
        <seg>在第221页"部署模式"一节，我们会讨论如何针对不同环境搭建及配置Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Emitting to Side Outputs” on page 119, we present the side-output feature of the process functions, which can emit multiple streams of different types from a function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064512Z" creationid="xccui" creationdate="20190615T064512Z">
        <seg>在119页"发送至副输出"一节，我们会介绍针对处理函数的副输出功能，它可以从函数中发出多条类型不同的数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Savepoints”, we explained that each state in a savepoint can be addressed by a composite identifier consisting of a unique operator identifier and the state name declared by the state descriptor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T023759Z" creationid="xccui" creationdate="20190705T023759Z">
        <seg>在"保存点"一节，我们说明了保存点中的每个状态都可以利用一个复合标识进行定位，该标识包含了一个唯一算子标识和一个由状态描述符声明的状态名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “State Backends” on page 55, we explained that Flink maintains application state in a state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T213538Z" creationid="xccui" creationdate="20190703T213538Z">
        <seg>在第55页"状态后端"一节，我们介绍了Flink使用状态后端来维护应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “State Management” on page 53, we discussed that Flink supports three types of operator state: list state, list union state, and broadcast state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T035936Z" creationid="xccui" creationdate="20190701T035832Z">
        <seg>在53页"状态管理"一节，我们讨论了Flink支持的三种算子状态：列表状态、联合列表状态以及广播状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “State Management”, we explained that functions can have two types of state, keyed state and operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T035002Z">
        <seg>在"状态管理"一节，我们提到了函数允许有两种类型的状态——键值分区状态和算子状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In “Time Semantics” on page 27, we highlighted the importance of time semantics for stream processing applications and explained the differences between processing time and event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204156Z" creationid="xccui" creationdate="20190606T204144Z">
        <seg>在第27页的"时间语义"一节，我们强调了时间语义对于流处理应用的重要性并解释了处理时间和事件时间的不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Including External and Flink Dependencies</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022940Z" creationid="xccui" creationdate="20190225T022940Z">
        <seg>导入外部和Flink依赖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Including External and Flink Dependencies | 107</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035424Z" creationid="xccui" creationdate="20190619T035424Z">
        <seg>导入外部和Flink依赖 | 107</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incorporating a signifi‐ cant amount of example code from this book into your product’s documentation does require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210821Z" creationid="esouser" creationdate="20190603T210821Z">
        <seg>Incorporating a signifi‐ cant amount of example code from this book into your product’s documentation does require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incremental aggregation and ProcessWindowFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034430Z" creationid="xccui" creationdate="20190625T034430Z">
        <seg>增量聚合与ProcessWindowFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Incremental aggregation functions are directly applied when an element is added to a window and hold and update a single value as window state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211052Z" creationid="xccui" creationdate="20190623T210654Z">
        <seg>增量聚合函数，它的应用场景是窗口内以状态形式存储某个值且需要根据每个加入窗口的元素对该值进行更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Index.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031120Z" creationid="xccui" creationdate="20190418T040551Z">
        <seg>索引</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexer: Judith McConville</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210722Z" creationid="esouser" creationdate="20190603T210722Z">
        <seg>Indexer: Judith McConville</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indicates new terms, URLs, email addresses, filenames, and file extensions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210801Z" creationid="esouser" creationdate="20190603T210801Z">
        <seg>Indicates new terms, URLs, email addresses, filenames, and file extensions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ingesting, transforming, and inserting data with low latency is another common use case for stateful stream processing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154504Z" creationid="xccui" creationdate="20190317T013857Z">
        <seg>状态化流处理应用的另一个日常用例是以低延迟的方式获取、转换并插入数据，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ingestion time does not offer much practical value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071917Z" creationid="xccui" creationdate="20190619T071917Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IngestionTime</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071453Z" creationid="xccui" creationdate="20190619T071453Z">
        <seg>IngestionTime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inspect the web dashboard.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201421Z" creationid="xccui" creationdate="20190329T040028Z">
        <seg>检查一下Web UI，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead a common approach is to write all changes into an event log that serves as source of truth.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T072031Z" creationid="xccui" creationdate="20190314T071923Z">
        <seg>一种常见的替代方法是把所有改动写入事件日志系统中，并以它为事实来源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead it takes advantage of distributed file systems like HDFS or object stores such as S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032244Z" creationid="xccui" creationdate="20190418T032212Z">
        <seg>而是利用了现有的分布式文件系统（如：HDFS）或对象存储（如：S3）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of adding new states to an application, you might also want to adjust an appli‐ cation by removing state—either by removing a complete stateful operator or just a state from a function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T042812Z" creationid="xccui" creationdate="20190705T042812Z">
        <seg>除了向应用中添加状态，你可能还想在修改应用的同时从中删除一些状态。这些删除操作所针对的可以是一个完整的状态化算子，也可以是函数中的某个状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of dropping or redirecting late events, another strategy is to recompute an incomplete result and emit an update.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T160522Z" creationid="xingcan" creationdate="20190628T160522Z">
        <seg>除了将迟到事件丢弃或重定向外，另一种策略是对不完整的结果进行重新计算并发出更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of inserting all data into a relational database system, significant amounts of data, such as, log files, social media, or web click logs, are written into Hadoop’s distributed file system (HDFS) or other bulk data stores, like Apache HBase, which provide massive storage capacity at small cost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T032702Z" creationid="xccui" creationdate="20190301T030218Z">
        <seg>海量日志文件、社交媒体、网页点击日志等数据已不再使用关系数据库系统存储，而是会写入Hadoop分布式文件系统（HDFS）或其他诸如Apache HBase的批量数据存储系统。这些系统以低廉的成本提供庞大的存储容量，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of inserting all data into a relational data‐ base system, significant amounts of data, such as log files, social media, or web click logs, are written into Hadoop’s distributed filesystem (HDFS), S3, or other bulk data‐ stores, like Apache HBase, which provide massive storage capacity at a small cost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T065204Z" creationid="esouser" creationdate="20190603T203758Z">
        <seg>海量日志文件、社交媒体、网页点击日志等数据已不再使用关系数据库系统存储，而是会写入Hadoop分布式文件系统（HDFS）、S3或其他诸如Apache HBase的批量数据存储系统。这些系统以低廉的成本提供庞大的存储容量，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of running analytical queries directly on the transactional databases, a com&lt;t0/&gt;‐&lt;t1/&gt; mon component in IT systems is a data warehouse.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192036Z" creationid="xccui" creationdate="20190228T184103Z">
        <seg>IT系统中一般会选用的数据仓库，而非事务型数据库来执行分析类查询。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of running analytical queries directly on the transactional databases, the data is typically replicated to a data warehouse, a dedicated datastore for analytical query workloads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T064724Z" creationid="esouser" creationdate="20190603T202102Z">
        <seg>对于分析类查询，我们通常不会直接在事务型数据库上执行，而是将数据复制到一个专门用来处理分析类查询工作的数据仓库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of waiting to be periodically trig&lt;t0/&gt;‐&lt;t1/&gt; gered, a streaming analytics application continuously ingests streams of events and maintains an updating result by incorporating the latest events with low latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062449Z" creationid="xccui" creationdate="20190317T055651Z">
        <seg>流式分析应用不再需要等待周期性地触发。相反，它们会一直获取事件流，以极低的延迟整合最新事件，从而可以维护不断更新的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of waiting to be periodically triggered, a streaming analytics application con‐ tinuously ingests streams of events and updates its result by incorporating the latest events with low latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155248Z" creationid="xccui" creationdate="20190605T043757Z">
        <seg>流式分析应用不再需要等待周期性地触发。相反，它会持续获取事件流，以极低的延迟整合最新事件，从而可以不断更新结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink implements checkpointing based on the Chandy–Lamport algorithm for distributed snapshots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T055721Z" creationid="xccui" creationdate="20190609T055529Z">
        <seg>而Flink的检查点是基于Chandy-Lamport分布式快照算法来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink is bundled as a library together with the application in a container image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T063806Z" creationid="xccui" creationdate="20190423T040832Z">
        <seg>而是以库的形式绑定在应用所在的容器映像中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink organizes keys in so-called key groups.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T055556Z" creationid="xccui" creationdate="20190608T055448Z">
        <seg>而是会把所有键值分为不同的键值组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Flink uses a lightweight snapshotting mechanism to achieve exactly-once result guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194239Z" creationid="xccui" creationdate="20190416T045008Z">
        <seg>Flink采用了轻量级检查点机制来实现精确一次结果保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, a 95th-percentile latency value of 10ms means that 95% of events are processed within 10ms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T155314Z" creationid="xccui" creationdate="20190401T155221Z">
        <seg>而第95百分位延迟在10毫秒意味着95%的事件会在10毫秒内处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, a method is called as soon as an event has arrived via the corre‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T043711Z" creationid="xccui" creationdate="20190615T043711Z">
        <seg>一旦对应流中有事件到来，就需要调用相应的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, all stateful operators must control the size of their state and have to ensure it is not infinitely growing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T140020Z" creationid="xccui" creationdate="20190704T140020Z">
        <seg>所有状态化算子都要控制自身状态大小，确保他们不会无限制增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, functions implement operator state as regular member variables and interact with the state backend via callback functions of the ListCheckpointed interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T040529Z" creationid="xccui" creationdate="20190701T040529Z">
        <seg>而需要将算子状态实现为成员变量并通过接口提供的回调函数和状态后端进行交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it focuses on its core function - distributed data stream processing - and leverages existing cluster infra&lt;t0/&gt;‐&lt;t1/&gt; structure and services.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T031834Z" creationid="xccui" creationdate="20190418T031709Z">
        <seg>而是在已有集群基础设施和服务之上专注于它的核心功能——分布式数据流处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it focuses on its core function—distributed data stream processing—and leverages existing cluster infra‐ structure and services.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140707Z" creationid="xccui" creationdate="20190606T140707Z">
        <seg>而是在已有集群基础设施和服务之上专注于它的核心功能——分布式数据流处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it is crucial that the stream processing system provides some mechanism to deal with events that might arrive after the watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T032537Z" creationid="xccui" creationdate="20190414T031709Z">
        <seg>而流处理系统至关重要的一点是能提供一些机制来处理那些可能晚于流水线的落后事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it is crucial that the stream pro‐ cessing system provide some mechanism to deal with events that might arrive after the watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T162223Z" creationid="xccui" creationdate="20190606T030316Z">
        <seg>而流处理系统很关键的一点是能提供某些机制来处理那些可能晚于水位线的落后事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it takes advantage of distributed filesystems like HDFS or object stores such as S3.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T140811Z" creationid="xccui" creationdate="20190606T140758Z">
        <seg>而是利用了现有的分布式文件系统（如HDFS）或对象存储（如S3）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, keys are defined as functions over the input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T063908Z" creationid="xccui" creationdate="20190617T062909Z">
        <seg>而是它定义为输入数据上的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, streaming applications must provide results for incoming data &lt;t0/&gt;as fast as possible&lt;t1/&gt; while being able to handle high &lt;t2/&gt;ingest rates&lt;t3/&gt; of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151236Z" creationid="xccui" creationdate="20190401T150934Z">
        <seg>取而代之的是，流式应用必须尽可能快地针对到来数据计算结果，且需要应对较高的事件接入速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, streaming applications must provide results for incoming data as fast as possible while being able to handle high ingest rates of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233757Z" creationid="xccui" creationdate="20190605T233757Z">
        <seg>取而代之的是，流式应用需要针对到来数据尽可能快地计算结果，同时还要应对很高的事件接入速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the API calls construct an execution plan in the execution environment, which consists of the stream sources created from the environment and all transformations that were tran‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011810Z" creationid="xccui" creationdate="20190613T011810Z">
        <seg>事实上，它们只会在执行环境中构建一个执行计划，其中包含了从环境创建的流式数据源以及应用于这些数据源之上的一系列转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the SessionWindows assigner initially maps each incoming element into its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T062146Z" creationid="xccui" creationdate="20190623T062005Z">
        <seg>事实上，SessionWindows分配器会将每个到来的元素映射到一个它自己的窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the context of the KeyedBroadcastProcessFunction.processBroad castElement() method provides a method applyToKeyed State(StateDescriptor,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054747Z" creationid="xccui" creationdate="20190702T054435Z">
        <seg>作为替代，该方法的上下文提供了一个applyToKeyedState(StateDescriptor, KeyedStateFunction)方法，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the operator continues to maintain the complete window for the allowed lateness period.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164709Z" creationid="xingcan" creationdate="20190628T164559Z">
        <seg>而是会将窗口继续保留该延迟容忍度的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, time-based DataStream operator tasks configure the time‐ stamps of emitted records to ensure they are properly aligned with the emitted watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T013338Z" creationid="xccui" creationdate="20190607T013124Z">
        <seg>为发出记录设置时间的工作是由基于时间的DataStream算子任务来完成，这样才能确保时间戳和发出的水位线对齐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, we need a window operation that assigns events belonging to the same session in the same bucket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013758Z" creationid="xccui" creationdate="20190409T192442Z">
        <seg>而我们需要一个窗口操作，能将属于同一会话的事件分配到相同桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, what really defines the amount of events in one minute is the time of the data itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143725Z" creationid="xccui" creationdate="20190412T143109Z">
        <seg>而事实上每分钟收到事件数目的是由数据本身的时间来定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you can implement the necessary logic using the building blocks of record timestamps, watermarks, and timers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041248Z" creationid="xccui" creationdate="20190629T041248Z">
        <seg>虽说如此，你仍可以利用记录时间戳、水位线和定时器等功能来实现必要的迟到数据处理逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integration with Hadoop Components</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025502Z" creationid="xccui" creationdate="20190225T025502Z">
        <seg>集成Hadoop组件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Rebecca Demarest</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210725Z" creationid="esouser" creationdate="20190603T210725Z">
        <seg>Interior Designer: David Futato Cover Designer: Karen Montgomery Illustrator: Rebecca Demarest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, Flink needs to be able to handle these objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T063149Z" creationid="xccui" creationdate="20190616T063048Z">
        <seg>因此Flink在内部需要对这些数据对象进行一些处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internally, a window that is evaluated by ProcessWindowFunction stores all assigned events in a ListState.1 By collecting all events and providing access to window meta‐ data and other features, ProcessWindowFunction can address many more use cases than ReduceFunction or AggregateFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034118Z" creationid="xccui" creationdate="20190625T034118Z">
        <seg>在系统内部，由ProcessWindowFunction处理的窗口会将所有已分配的事件存储在ListState中。1通过将所有事件收集起来且提供对于窗口元数据及其他一些特性的访问和使用，ProcessWindowFunction的应用场景比ReduceFunction和AggregateFunction更加广泛。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interval Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151640Z" creationid="esouser" creationdate="20190603T150359Z">
        <seg>基于间隔的Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Dataflow Programming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143756Z" creationid="esouser" creationdate="20190603T143543Z">
        <seg>Dataflow编程介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Dataflow Programming | 19</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041328Z" creationid="xccui" creationdate="20190606T041328Z">
        <seg>Dataflow编程介绍 | 19</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191716Z" creationid="xccui" creationdate="20190225T191716Z">
        <seg>状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to Stateful Stream Processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014519Z" creationid="xccui" creationdate="20190225T014519Z">
        <seg>状态化流处理介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction to dataflow programming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014938Z" creationid="xccui" creationdate="20190225T014938Z">
        <seg>dataflow模型介绍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inversely, very conservative water&lt;t0/&gt;‐&lt;t1/&gt; marks increase processing latency but improve result completeness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040618Z" creationid="xccui" creationdate="20190529T040556Z">
        <seg>相反，非常宽松的水位线会增加处理延迟，但同时结果的完整性也会有所提升。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inversely, very conservative water‐ marks increase processing latency but improve result completeness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T210205Z" creationid="xccui" creationdate="20190606T210205Z">
        <seg>相反，非常宽松的水位线会增加处理延迟，但同时结果的完整性也会有所提升。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also gives you a brief look at what it is like to run your first streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031427Z" creationid="esouser" creationdate="20190603T155806Z">
        <seg>此外还简要介绍了如何在本地Flink实例上运行你的第一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also gives you a brief taste of what it is like to run a your first streaming application on a local Flink instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T164237Z" creationid="xccui" creationdate="20190225T164237Z">
        <seg>此外还简要介绍了如何在本地Flink实例上运行你的第一个流处理应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also needs to provide a default trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042147Z" creationid="xccui" creationdate="20190626T042141Z">
        <seg>它还需要一个默认触发器，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also shows how to use Flink’s queryable state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162155Z" creationid="esouser" creationdate="20190603T162155Z">
        <seg>同时本章还会展示如何使用Flink的可查询式状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also supports connecting a keyed and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210037Z" creationid="xccui" creationdate="20190615T053018Z">
        <seg>它不仅支持联结一个按键值分好区的流和一个广播流，还能将广播后的事件存到一个托管状态中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It applies a ReduceFunction on a KeyedStream, which combines each incoming event with the current reduced value, and produces a DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040642Z" creationid="xccui" creationdate="20190614T061430Z">
        <seg>它将一个ReduceFunction作用在一个KeyedStream上，每个到来事件都会和reduce结果进行一次组合，从而产生一个新的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used to generate watermarks that are encoded in special input records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040000Z" creationid="xccui" creationdate="20190607T035846Z">
        <seg>它可用于需要根据特殊输入记录生成水位线的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can remove elements from a window before or after the window function is evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201531Z" creationid="xccui" creationdate="20190626T201531Z">
        <seg>它可以用于在窗口执行计算前或后从窗口中删除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of 11 chapters that hopefully tell a coherent story.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152645Z" creationid="esouser" creationdate="20190603T152631Z">
        <seg>它总共包含了11个章节，我们希望通过这些章节讲述一个完整的故事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of 11 chapters which hopefully tell a coherent story.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T042123Z" creationid="xccui" creationdate="20190225T042123Z">
        <seg>它包含了11个章节，我们希望通过这些章节讲述一个完整的故事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of three operators that are all configured for a task parallelism of two and are connected with local forward connec&lt;t2/&gt;‐&lt;t3/&gt; tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152332Z" creationid="esouser" creationdate="20190514T152332Z">
        <seg>它包含了3个算子，每个算子的任务并发度都为2且通过本地转发方式连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of three operators that are all configured for a task parallelism of two and connected with local forward connec‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203412Z" creationid="xccui" creationdate="20190606T203412Z">
        <seg>它包含了3个算子，每个算子的任务并发度都为2且通过本地转发方式连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It defines the checkAndGetNextWatermark() method, which is called for each event right after extractTimestamp().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054250Z" creationid="xccui" creationdate="20190620T054250Z">
        <seg>该接口中的checkAndGetNextWatermark()方法会在针对每个事件的extractTimestamp()方法后立即调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It defines the map() method that trans‐ forms an input event into exactly one output event:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050318Z" creationid="xccui" creationdate="20190613T050318Z">
        <seg>它定义的map()方法将每个输入事件转换为一个输出事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It determines how much the operator’s process‐ ing effort can be distributed and also how much data it can process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051522Z" creationid="xccui" creationdate="20190616T051504Z">
        <seg>它决定了算子处理的并行化程度和能够处理的数据规模。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It discusses Flink’s approach to end-to-end application consistency and how to implement custom connectors to ingest data from and emit data to external systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T062703Z" creationid="esouser" creationdate="20190603T162455Z">
        <seg>其中会讨论Flink中解决端到端应用一致性的方案以及如何实现自定义连接器来读写外部系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It discusses distributed architecture, time and state handling in streaming applications, and Flink’s fault toler&lt;t0/&gt;‐&lt;t1/&gt; ance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T165047Z" creationid="xccui" creationdate="20190225T165047Z">
        <seg>其中讨论了分布式架构、流式应用中的时间和状态处理问题、Flink的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It discusses dis‐ tributed architecture, time and state handling in streaming applications, and Flink’s fault-tolerance mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031452Z" creationid="esouser" creationdate="20190603T160106Z">
        <seg>其中讨论了分布式架构、流式应用中的时间和状态处理问题以及Flink的容错机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It divides an input stream into two or more output streams of the same type as the input stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053847Z" creationid="xccui" creationdate="20190615T053847Z">
        <seg>它将输入流分割成两条或多条类型和输入流相同的输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It efficiently runs such applica&lt;t0/&gt;‐&lt;t1/&gt; tions at large scale in a fault-tolerant manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T215719Z" creationid="xccui" creationdate="20190225T192215Z">
        <seg>且支持在容错的前提下高效运行大规模的此类应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It efficiently runs such applica‐ tions at large scale in a fault-tolerant manner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T051514Z" creationid="esouser" creationdate="20190603T162716Z">
        <seg>并且支持在容错的前提下高效、大规模地运行此类应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It emits one record for each window consisting of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030449Z" creationid="xccui" creationdate="20190625T030449Z">
        <seg>每个窗口都会发出一条记录，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It exposes methods to retrieve the window boundaries, to check whether windows intersect, and to merge overlapping windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041758Z" creationid="xccui" creationdate="20190623T041758Z">
        <seg>它对外提供了获取窗口边界、检查窗口是否相交以及合并重叠窗口等方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It gives access to the timestamp and the key of the current record and to a TimerService.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T054048Z" creationid="xccui" creationdate="20190621T054048Z">
        <seg>通过它可以访问时间戳、当前记录的键值以及TimerService。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has a public constructor without any arguments—a default constructor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T042929Z" creationid="xccui" creationdate="20190617T042929Z">
        <seg>有一个公有的无参默认构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a hybrid of EventTime and ProcessingTime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071542Z" creationid="xccui" creationdate="20190619T071529Z">
        <seg>其实是EventTime和ProcessingTime的混合体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a public class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T042846Z" creationid="xccui" creationdate="20190617T042846Z">
        <seg>是一个公有类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054227Z" creationid="xccui" creationdate="20190612T054227Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to configure an application to retain its last checkpoint when it is canceled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211232Z" creationid="xccui" creationdate="20190609T211232Z">
        <seg>可以通过配置让应用在取消的时候保留最近一次检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to explicitly create local or remote execution environments as fol‐ lows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045513Z" creationid="xccui" creationdate="20190612T045513Z">
        <seg>同时也可以像下面那样显式地创建一个本地或远程执行环境：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to nest expressions on mixed types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050346Z" creationid="xccui" creationdate="20190618T050242Z">
        <seg>还能够以混合类型嵌套表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to specify a custom trigger and evictor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T053227Z" creationid="xccui" creationdate="20190628T053227Z">
        <seg>同时你也可以自定义触发器或移除器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is best practice to assign timestamps and generate watermarks as close to the sour‐ ces as possible or even within the SourceFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T031544Z" creationid="xccui" creationdate="20190620T031544Z">
        <seg>最佳做法就是在尽可能靠近数据源的地方甚至在SourceFunction内部，分配时间戳和生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is called once per task before a transformation method like filter or map is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T061044Z" creationid="xccui" creationdate="20190618T061044Z">
        <seg>它在每个任务调用正式的转换方法（例如filter或map）前调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is common that companies store the same data in multiple different systems to improve the performance of data accesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T061210Z" creationid="xccui" creationdate="20190604T053931Z">
        <seg>公司为了提高数据访问性能把相同数据存储到多个系统中已然稀松平常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is crucial to understand how to deliver accu‐ rate and deterministic results under such conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014411Z" creationid="xccui" creationdate="20190606T014330Z">
        <seg>了解如何在这种情况下提供精准、确定的结果就变得至关重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is crucial to understand how you can deliver accurate and deterministic results under such conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T201950Z" creationid="xccui" creationdate="20190409T201839Z">
        <seg>了解如何在这种情况下提供精准、确定的结果就变得至关重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that a window is created when the first element is assigned to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T035201Z" creationid="xccui" creationdate="20190623T033439Z">
        <seg>请注意，窗口会随着首次为其分配元素而创建，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that sometimes you can</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050336Z" creationid="xccui" creationdate="20190416T050038Z">
        <seg>注意，有时候可以通过弱保障实现强语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that sometimes you can get stronger semantics with weaker guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194759Z" creationid="xccui" creationdate="20190606T035348Z">
        <seg>注意，有时候你可以通过弱保障来实现强语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to note that the rate of processing depends on the rate of arrival; low throughput does not necessarily indicate bad performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052350Z" creationid="xccui" creationdate="20190401T200707Z">
        <seg>但要注意，处理速率取决于数据到来速率，因此吞吐低不一定意味着性能差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to understand that the initial design of an applica‐ tion determines if and how it can be modified later on in a savepoint-compatible way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T024907Z" creationid="xccui" creationdate="20190705T024630Z">
        <seg>请谨记，应用的初始设计决定了它日后能否，或以何种方式进行保存点兼容的修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to clean up state in a timer callback method, since these methods are not called after a window is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194739Z" creationid="xccui" creationdate="20190626T194739Z">
        <seg>由于在删除窗口后不会调用计时器回调方法，因此无法在其中清理状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to combine multiple rolling aggregation methods—only a single roll‐ ing aggregate can be computed at a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054053Z" creationid="xccui" creationdate="20190614T054037Z">
        <seg>注意，无法将多个滚动聚合方法组合使用，每次只能计算一个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to control the order in which the methods of a CoMapFunction or CoFlatMapFunction are called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T043751Z" creationid="xccui" creationdate="20190615T043633Z">
        <seg>CoMapFunction和CoFlatMapFunction内方法的调用顺序无法控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to start an application from a previously taken savepoint if the identi‐ fiers or the maximum parallelism of operators were changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015224Z" creationid="xccui" creationdate="20190703T014722Z">
        <seg>如果算子的标识或最大并行度发生了变化，则无法从之前生成的保存点启动应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not pos‐ sible to remove individual elements from ListState, but the list can be updated by calling ListState.update(values: java.util.List[T]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T055537Z" creationid="xccui" creationdate="20190630T054329Z">
        <seg>虽然ListState不支持单个元素的删除，但你可以调用ListState.update(values: java.util.List[T])来更新整个列表，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is often necessary to fix a bug or to evolve the business logic of a long-running stateful streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T214053Z" creationid="xccui" creationdate="20190704T214053Z">
        <seg>很多时候我们需要对一个长时间运行的状态化流式应用进行Bug修复或业务逻辑调整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is pos‐ sible that a task misses the notification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T202947Z" creationid="xccui" creationdate="20190702T202947Z">
        <seg>所以说任务可能会错过一些通知。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is required by any non-trivial computa&lt;t0/&gt;‐&lt;t1/&gt; tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T051626Z" creationid="xccui" creationdate="20190414T050639Z">
        <seg>任何稍麻烦点的计算都用得到它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is required by any nontrivial computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181230Z" creationid="xccui" creationdate="20190606T031411Z">
        <seg>任何一个稍复杂的计算都要用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It passes each incoming event to a user-defined mapper</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050421Z" creationid="xccui" creationdate="20190613T042926Z">
        <seg>该转换将每个到来的事件传给一个用户自定义的映射器，后者针对每个输入只会返回一个（可能是不同类型的）输出事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides accurate stream processing with high throughput and low latency at scale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195227Z" creationid="xccui" creationdate="20190328T041119Z">
        <seg>它支持精确的流处理，能同时满足各种规模下对高吞吐和低延迟的要求，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides hooks to register and maintain keyed state and operator state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T063401Z" creationid="xccui" creationdate="20190702T060057Z">
        <seg>它为键值分区状态和算子状态分别提供了用于注册及维护的钩子函数（hook），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides the system with the necessary information it needs to generate serialiazers and comparators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T050322Z" creationid="xccui" creationdate="20190617T050322Z">
        <seg>它为系统生成序列化器和比较器提供了必要的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It remembers the rules in an operator state in order to apply them to all events of the event stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T203350Z" creationid="xccui" creationdate="20190701T203350Z">
        <seg>它会将规则存为算子状态然后将它们应用到事件流中的全部事件上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It requests processing slots from the ResourceManager to continue executing the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190503T192045Z" creationid="xccui" creationdate="20190503T192045Z">
        <seg>向ResourceManager申请处理槽来继续执行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It requests the storage locations from ZooKeeper to fetch the JobGraph, the JAR file, and the state handles of the last checkpoint of the application from the remote storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073917Z" creationid="xccui" creationdate="20190503T192017Z">
        <seg>向ZooKeeper请求存储位置，以获取JobGraph、JAR文件及应用最新检查点在远程存储的状态句柄。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It restarts the application and resets the state of all its tasks to the last completed checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T190616Z" creationid="xccui" creationdate="20190503T192125Z">
        <seg>重启应用并利用最近一次检查点重置任务状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should be noted that joining windowed streams can have unex‐ pected semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T054846Z" creationid="xccui" creationdate="20190628T054846Z">
        <seg>注意，对划分窗口后的数据流进行Join可能会产生始料未及的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should only be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045111Z" creationid="xccui" creationdate="20190626T045111Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It starts the same application with the same configuration on the same cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211715Z" creationid="xccui" creationdate="20190609T211715Z">
        <seg>它会在完全相同的集群上以完全相同的配置运行完全相同的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then starts to consume and process all data that was processed between the checkpoint and the failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T053306Z" creationid="xccui" creationdate="20190609T051830Z">
        <seg>随后应用就会开始重新消费并处理那些从之前检查点完成开始到发生系统故障之间已经处理过的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will help you to understand Flink’s internals and to reason about the performance and behavior of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T054615Z" creationid="xccui" creationdate="20190416T054457Z">
        <seg>这将帮助你理解Flink的内部原理，评估流式应用的性能及行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will help you to understand Flink’s internals and to reason about the perfor‐ mance and behavior of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T043728Z" creationid="xccui" creationdate="20190606T140523Z">
        <seg>这将帮助你在理解Flink内部原理的同时，评估流式应用的性能及行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will show that a single Task Manager (Flink’s worker processes) is connected and that a single Task Slot (resource units provided by a Task Manager) is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035532Z" creationid="xccui" creationdate="20190329T035513Z">
        <seg>它表示已经连接上一个Task Manager（Flink的工作进程），且有一个可用的Task Slot（Task Manager所提供的资源单元）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will show that a single TaskManager (Flink’s worker processes) is connected and that a single task slot (resource units provided by a TaskManager) is available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123338Z" creationid="xccui" creationdate="20190605T123258Z">
        <seg>它表示已经连接上一个TaskManager（Flink的工作进程），且有一个可用的任务槽（TaskManager所提供的资源单元）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Italic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210800Z" creationid="esouser" creationdate="20190603T210800Z">
        <seg>Italic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its built-in operators interpret the Long value as a Unix timestamp with millisecond pre‐ cision—the number of milliseconds since 1970-01-01-00:00:00.000.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205018Z" creationid="xccui" creationdate="20190606T204948Z">
        <seg>它的内置算子会将这个Long类型值解析为毫秒精度的Unix时间戳（自1970-01-01-00:00:00.000以来的毫秒数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its built-in operators interpret the long value as a Unix timestamp with millisecond precision, i.e., the number of milliseconds since 1970-01-01-00:00:00.000.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040728Z" creationid="xccui" creationdate="20190523T040511Z">
        <seg>它的内置算子会将这个long类型值解析为毫秒精度的Unix时间戳（自1970-01-01-00:00:00.000以来的毫秒数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its default trigger is the NeverTrigger that, as the name suggests, never fires.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044404Z" creationid="xccui" creationdate="20190626T044404Z">
        <seg>它默认的触发器是NeverTrigger，顾名思义，该触发器永远不会触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its goal is to introduce the funda&lt;t0/&gt;‐&lt;t1/&gt; mental concepts of stream processing and discuss the requirements of stream pro&lt;t2/&gt;‐&lt;t3/&gt; cessing frameworks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T053802Z" creationid="xccui" creationdate="20190329T053732Z">
        <seg>其目的在于介绍流处理的基础概念，讨论流处理框架的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Java and Classloading</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025533Z" creationid="xccui" creationdate="20190225T025533Z">
        <seg>Java和类加载</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Java and Scala tuples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065007Z" creationid="xccui" creationdate="20190616T065007Z">
        <seg>Java和Scala元组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Job has been submitted with JobID cfde9dbe315ce162444c475a08cf93d9</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040020Z" creationid="xccui" creationdate="20190329T040020Z">
        <seg>Job has been submitted with JobID cfde9dbe315ce162444c475a08cf93d9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JobManager failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T222247Z" creationid="xccui" creationdate="20190428T222247Z">
        <seg>JobManager故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>JobManager initiates a checkpoint by sending a message to all sources</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T063013Z" creationid="xccui" creationdate="20190608T063329Z">
        <seg>JobManager通过向所有数据源发送消息来启动检查点生成流程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joining Streams on Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151633Z" creationid="xccui" creationdate="20190225T023252Z">
        <seg>基于时间的双流Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joining Streams on Time | 145</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042118Z" creationid="xccui" creationdate="20190629T042118Z">
        <seg>基于时间的双流Join | 145</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joining two windowed streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T035947Z" creationid="xccui" creationdate="20190628T035947Z">
        <seg>对划分窗口后的两条流进行Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Joint processing of two streams usually requires that events of both streams are deter‐ ministically routed based on some condition to be processed by the same parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151857Z" creationid="xccui" creationdate="20190615T044638Z">
        <seg>对双流进行Join的情况常常需要两条流中的事件基于某些条件进行确定性路由，以便能够发往算子的同一并行实例上处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like many DataStream applications, the source, sink, and opera‐ tors of the program are assembled in the main() method of the AverageSensorRead ings class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042849Z" creationid="xccui" creationdate="20190611T042751Z">
        <seg>和大多数DataStream应用一样，该程序的数据源、数据汇以及其他算子都是在（AverageSensorReadings类的）main()方法中组装的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEY key, Context ctx, Iterable&lt;IN&gt; vals, Collector&lt;OUT&gt; out) throws Exception;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010520Z" creationid="xccui" creationdate="20190624T010520Z">
        <seg>KEY key, Context ctx, Iterable&lt;IN&gt; vals, Collector&lt;OUT&gt; out) throws Exception;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Selectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145630Z" creationid="esouser" creationdate="20190603T145630Z">
        <seg>键值选择器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keyed State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041649Z" creationid="xccui" creationdate="20190418T035556Z">
        <seg>键值分区状态（Keyed State）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keyed state can only be used by functions that are applied on a KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T040154Z">
        <seg>键值分区状态只能用于作用在KeyedStream上面的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keyed state is maintained and accessed with respect to a key defined in the records of an operator’s input stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T185829Z">
        <seg>键值分区状态是按照算子输入记录所定义的键值来进行维护或访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedProcessFunction holds the timestamps of all timers in a priority queue on the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T064250Z">
        <seg>默认情况下，KeyedProcessFunction会将全部计时器的时间戳放到堆中的一个优先队列里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStateFunction to the value of each key in the keyed state ref‐ erenced by the StateDescriptor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T055151Z" creationid="xccui" creationdate="20190702T054650Z">
        <seg>可以对StateDescriptor所引用的键值分区状态内每个键值所对应的状态值应用KeyedStateFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStateFunction)  to   apply  a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054819Z" creationid="xccui" creationdate="20190702T054819Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStream Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022735Z" creationid="xccui" creationdate="20190225T022735Z">
        <seg>基于KeyedStream的转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStream transformations are transformations that are applied to events in the context of a key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024555Z" creationid="xccui" creationdate="20190613T024408Z">
        <seg>KeyedStream转换是作用于同一键值上下文内事件的转换；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KeyedStream, which is a DataStream that has been logically partitioned into disjoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044002Z" creationid="xccui" creationdate="20190614T044002Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Kubernetes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040325Z" creationid="xccui" creationdate="20190418T040325Z">
        <seg>Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lambda Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022924Z" creationid="xccui" creationdate="20190225T022924Z">
        <seg>Lambda函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lambda functions are avail‐ able for Scala and Java and offer a simple and concise way to implement application logic when no advanced operations such as accessing state and configuration are required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055802Z" creationid="xccui" creationdate="20190618T055802Z">
        <seg>lambda函数可用于Scala或Java，它在不需要进行高级操作（例如访问状态或配置）的情况下提供了一种简洁明了的方式来实现应用逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last but not least, Flink is also a full-fledged batch processor.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195932Z" creationid="xccui" creationdate="20190605T121712Z">
        <seg>最后要强调的一点：Flink同时也是一个成熟的批处理引擎。1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last but not least, Flink is also a full-fledged batch processor&lt;t0/&gt;1&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T052128Z" creationid="xccui" creationdate="20190328T052128Z">
        <seg>最后要强调的一点，Flink同时也是一个成熟的批处理引擎。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Late events arrive at an operator after a computation to which they should have con‐ tributed was completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T160649Z" creationid="xingcan" creationdate="20190628T160255Z">
        <seg>迟到事件抵达算子后，它们本应参与贡献的计算可能已经执行完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Late events can also be redirected into another DataStream using the side-output fea‐ ture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154745Z" creationid="xingcan" creationdate="20190628T154212Z">
        <seg>我们还能利用副输出将迟到事件重定向到另一个DataStream，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Late events can be redirected into a separate stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T152958Z" creationid="xingcan" creationdate="20190628T152958Z">
        <seg>可以将迟到事件重定向到单独的数据流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Late events can be simply dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T153015Z" creationid="xingcan" creationdate="20190628T152931Z">
        <seg>可以简单地将其丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151529Z" creationid="xccui" creationdate="20190401T151529Z">
        <seg>延迟</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency Versus Throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234912Z" creationid="xccui" creationdate="20190605T234912Z">
        <seg>延迟 vs. 吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency and Throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143930Z" creationid="esouser" creationdate="20190603T143930Z">
        <seg>延迟和吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency and throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015312Z" creationid="xccui" creationdate="20190225T015312Z">
        <seg>延迟和吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency indicates how long it takes for an event to be processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151602Z" creationid="xccui" creationdate="20190401T151602Z">
        <seg>延迟表示处理一个事件所需的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Latency vs. throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T202243Z" creationid="xccui" creationdate="20190402T202238Z">
        <seg>延迟 vs. 吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Layered APIs with varying tradeoffs for expressiveness and ease of use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195445Z" creationid="xccui" creationdate="20190605T055937Z">
        <seg>层次化的API在表达能力和易用性方面各有权衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let us revisit the coffee shop example to clarify how latency and throughput affect each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210220Z" creationid="xccui" creationdate="20190402T204057Z">
        <seg>我们再通过咖啡店的示例来解释一下延迟和吞吐如何相互影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s assume you want to compute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T153428Z" creationid="xccui" creationdate="20190606T014646Z">
        <seg>假如你想持续计算结果，比如每分钟计算一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s assume you want to compute results continuously, for example every one minute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T144504Z" creationid="xccui" creationdate="20190409T211020Z">
        <seg>假设你想持续计算结果，比如每分钟计算一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s look at each type category.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070104Z" creationid="xccui" creationdate="20190616T070104Z">
        <seg>我们分别来看一下每种类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s now explain in more detail how a task emits watermarks and updates its event- time clock when receiving a new watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T014349Z" creationid="xccui" creationdate="20190607T014310Z">
        <seg>接下来我们详细解释一下当任务接收到一个新的水位线之后，将如何发送水位线以及更新其内部事件时间时钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s revisit the coffee shop example to clarify how latency and throughput affect each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053948Z" creationid="xccui" creationdate="20190605T235018Z">
        <seg>我们再通过咖啡店的例子来解释一下延迟和吞吐如何相互影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let’s start with a simple example to get a first impression of what it is like to write streaming applications with the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035305Z" creationid="xccui" creationdate="20190612T035028Z">
        <seg>让我们从一个简单的示例开始，来感受使用DataStream API编写流式应用的第一印象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Library style</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143638Z" creationid="xccui" creationdate="20190606T143638Z">
        <seg>库模式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Library style&lt;t0/&gt;: In this mode, the Flink application is bundled in an application-specific container image, such as a Docker image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030252Z" creationid="xccui" creationdate="20190423T030236Z">
        <seg>库模式：在该模式下，Flink应用会绑定到一个应用相关的容器映像中（如Docker映像）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184138Z" creationid="xccui" creationdate="20190607T184048Z">
        <seg>列表状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List.fill(10 - mod)(new java.lang.Long(div))).asJava</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062853Z" creationid="xccui" creationdate="20190701T062853Z">
        <seg>List.fill(10 - mod)(new java.lang.Long(div))).asJava</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ListCheckpointed Interface Uses Java Serialization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063556Z" creationid="xccui" creationdate="20190701T062935Z">
        <seg>ListCheckpointed接口使用了Java序列化机制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ListState[T] holds a list of elements of type T. New elements can be appended to the list by calling ListState.add(value: T) or ListState.addAll(values: java.util.List[T]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T054342Z" creationid="xccui" creationdate="20190630T053549Z">
        <seg>ListState[T]用于保存类型为T的元素列表。你可以调用ListState.add(value: T)或ListState.addAll(values: java.util.List[T])将新元素附加到列表中,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ListState[X] has an advantage over Value State[List[X]] if elements are frequently appended to the list and the elements of the list are less frequently accessed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T034541Z" creationid="xccui" creationdate="20190704T034541Z">
        <seg>如果经常要在列表后面添加元素且列表元素的访问频率很低，那么ListState[X]会比ValueState[List[X]]更有优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local state access provides very good performance compared to reading and writing queries against remote datastores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T034032Z" creationid="xccui" creationdate="20190604T023347Z">
        <seg>访问本地状态的性能要比读写远程数据存储系统更好；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local state accesses, i.e., reading from or writing to memory or local disk, provide very good performance compared to read and write queries against remote data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190312T212225Z" creationid="xccui" creationdate="20190308T074008Z">
        <seg>只需要访问本地状态。和查询远程数据存储系统相比，读写本地内存或磁盘性能会更好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking again at the HighTempCounter function in Example 7-4, we see that each par‐ allel instance of the operator exposes its state as a list with a single entry.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061533Z" creationid="xccui" creationdate="20190701T061533Z">
        <seg>回顾一下示例7-4中的HighTempCounter函数，每个算子并行实例所提供的状态列表都只包含了一个项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking at the example, you might wonder why operator state is handled as a list of state objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T054512Z" creationid="xccui" creationdate="20190701T054512Z">
        <seg>看完上述例子，你可能会奇怪为什么要讲算子状态作为状态对象列表来处理？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Low latency is a key characteristic of stream processing and it enables what we call &lt;t2/&gt;real-time&lt;t3/&gt; applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T192514Z" creationid="xccui" creationdate="20190401T191707Z">
        <seg>低延迟是流处理的一个关键特性，它滋生了所谓的实时应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Low latency is a key characteristic of stream processing and it enables what we call real-time applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051538Z" creationid="xccui" creationdate="20190605T234240Z">
        <seg>低延迟是流处理的一个关键特性，它滋生出了所谓的实时应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Main Memory and Network Buffers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025555Z" creationid="xccui" creationdate="20190225T025555Z">
        <seg>内存和网络缓冲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make sure that “Import project from external model” and “Maven” are selected and click Next.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041318Z" creationid="xccui" creationdate="20190611T041318Z">
        <seg>确保勾上"Import project from external model"以及"Maven"两个选项，然后点击Next。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Managing Applications with the Command-Line Client</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025929Z" creationid="xccui" creationdate="20190225T025929Z">
        <seg>通过命令行客户端管理应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Managing Applications with the REST API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025932Z" creationid="xccui" creationdate="20190225T025932Z">
        <seg>通过REST API管理应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many applications ingest multiple streams that need to be jointly processed or split a stream in order to apply different logic to different substreams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T205623Z" creationid="xccui" creationdate="20190614T063301Z">
        <seg>很多应用需要将多条输入流联合起来处理，或将一条流分割成多条子流以便应用不同的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many changes will not be possible if the original version was not designed with updates in mind.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T025211Z" creationid="xccui" creationdate="20190705T025211Z">
        <seg>如果原始版本在设计时没有考虑到日后的更新，则很难对其进行较大改动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators continuously read and update some kind of state such as records collected in a window, reading positions of an input source, or custom, application-specific operator states like machine learning models.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T053106Z" creationid="xccui" creationdate="20190607T052753Z">
        <seg>很多算子会持续读取并更新某些状态，例如：窗口内收集的记录，输入源的读取位置或是一些定制的，诸如机器学习模型之类的特定应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many people show up at the same time and have to wait in line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053206Z" creationid="xccui" creationdate="20190605T234727Z">
        <seg>店内突然间涌入大量顾客，点单的人排起了长队。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many people show up at the same time and you have to wait in line to place your order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T211059Z" creationid="xccui" creationdate="20190401T211059Z">
        <seg>突然间涌入大量顾客，你必须排队点单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many problems originate from incompatibili‐ ties among different versions of the same library that are pulled in from different connectors or directly from the user application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041008Z" creationid="xccui" creationdate="20190619T041008Z">
        <seg>连接器或用户程序使用的类库一多就容易出现使用了同一库的多个版本，很多问题都是源于这些版本之间相互不兼容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T044721Z" creationid="xccui" creationdate="20190613T044721Z">
        <seg>Map</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Map state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T220307Z" creationid="xccui" creationdate="20190607T220057Z">
        <seg>映射状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MapFunction in  the  following,  are  defined  as  classes  that  implement  a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020939Z" creationid="xccui" creationdate="20190613T020742Z">
        <seg>函数可以被定义为实现了某个特定转换接口的类，例如下面的MapFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MapState of RocksDBStateBackend</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T033040Z" creationid="xccui" creationdate="20190704T033040Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MapState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221602Z" creationid="xccui" creationdate="20190703T221602Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MapState[K, V] holds a map of keys and values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T055646Z" creationid="xccui" creationdate="20190630T055646Z">
        <seg>MapState[K, V]用于保存一组键到值的映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MemoryStateBackend stores state as regular objects on the heap of the TaskMan‐ ager JVM process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221848Z" creationid="xccui" creationdate="20190703T221848Z">
        <seg>MemoryStateBackend将状态以常规对象的方式存储在TaskManager JVM进程的堆里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Merging of windows is discussed in more detail in the next section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T050333Z" creationid="xccui" creationdate="20190626T050333Z">
        <seg>有关窗口合并的内容会在下一节详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metric System</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030134Z" creationid="xccui" creationdate="20190225T030134Z">
        <seg>指标系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metzger, Sebastian Schelter, Shaoxuan Wang, Shuyi Chen, Stefan Richter, Stephan Ewen, Theodore Vasiloudis, Thomas Weise, Till Rohrmann, Timo Walther, Tzu-Li (Gordon) Tai, Ufuk Celebi, Xiaogang Shi, Xiaowei Jiang, Xingcan Cui.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T025914Z" creationid="xccui" creationdate="20190605T132801Z">
        <seg>Metzger、Sebastian Schelter、Shaoxuan Wang（王绍翾）、Shuyi Chen（陈舒毅）、Stefan Richter、Stephan Ewen、Theodore Vasiloudis、Thomas Weise、 Till Rohrmann、Timo Walther、Tzu-Li (Gordon) Tai（戴资力）、Ufuk Celebi、Xiaogang Shi（施晓罡）、Xiaowei Jiang（蒋晓伟）、Xingcan Cui（崔星灿）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Microservices and all required software and services are typically bundled and deployed in independent containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172622Z" creationid="xccui" creationdate="20190228T172041Z">
        <seg>通常，微服务连同必须的软件及服务会打包部署到独立的容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Microservices are designed as small, self-contained, and independent applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T172159Z" creationid="xccui" creationdate="20190227T042155Z">
        <seg>微服务由很多微型、完备、独立的应用组成，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Microser‐ vices and all the required software and services are typically bundled and deployed in independent containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T024114Z" creationid="esouser" creationdate="20190603T201022Z">
        <seg>通常情况下，微服务会和所有必须的软件及服务一起打包部署到独立的容器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Millisecond latencies while processing millions of events per second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195359Z" creationid="xccui" creationdate="20190605T055840Z">
        <seg>在每秒处理数百万条事件的同时保持毫秒级延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modern stream processors, like Apache Flink, can offer latencies as low as a few milliseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T193037Z" creationid="xccui" creationdate="20190401T192945Z">
        <seg>像Apache Flink这样的现代流处理引擎可以提供低至几毫秒的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modified applica‐ tions can also be used to run A/B tests or what-if scenarios with different busi‐ ness logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212424Z" creationid="xccui" creationdate="20190609T212336Z">
        <seg>应用修改还可用于A/B测试或需要不同业务逻辑的假想场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying the State of an Operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024933Z" creationid="xccui" creationdate="20190225T024924Z">
        <seg>改变算子的状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying the state of an existing operator by changing the state primitive or data type of the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035834Z" creationid="xccui" creationdate="20190705T035834Z">
        <seg>通过改变状态原语或数据类型来修改已有算子的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring Flink Clusters and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030117Z" creationid="xccui" creationdate="20190225T030117Z">
        <seg>监控Flink集群及应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring Latency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030141Z" creationid="xccui" creationdate="20190225T030141Z">
        <seg>延迟监控</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring the quality of cellphone networks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045418Z" creationid="xccui" creationdate="20190605T045418Z">
        <seg>手机网络质量监控</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Monitoring the quality of cellphone networks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033619Z" creationid="xccui" creationdate="20190319T033357Z">
        <seg>手机网络质量监控，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More complex applications are built by connecting several microservices with each other that only communicate over stand&lt;t2/&gt;‐&lt;t3/&gt; ardized interfaces such as RESTful HTTP connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190227T233910Z" creationid="xccui" creationdate="20190227T233910Z">
        <seg>通过将多个微服务相互连接可以构建出更加复杂的应用，而微服务之间只通过标准化接口（如RESTful HTTP连接）进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More complex applica‐ tions are built by connecting several microservices with each other that only commu‐ nicate over standardized interfaces such as RESTful HTTP connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151017Z" creationid="esouser" creationdate="20190603T200705Z">
        <seg>通过将多个微服务相互连接可以构建出更加复杂的应用，而微服务间只会通过标准化接口（如RESTful HTTP连接）进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover the state size typically increases because the application needs to buffer more data until it can perform a computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T034347Z" creationid="xccui" creationdate="20190621T034203Z">
        <seg>此外，由于应用需要在计算之前缓冲更多的数据，所以通常会导致状态大小也随之增加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, Flink provides Maven archetypes to bootstrap new Flink Maven projects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004357Z" creationid="xccui" creationdate="20190611T020723Z">
        <seg>此外，Flink还提供了Maven模板（Maven archetypes）来创建新的Flink Maven项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, Kryo does not provide a good migration path to evolve data types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070032Z" creationid="xccui" creationdate="20190616T070032Z">
        <seg>此外，对于数据类型演变的情况，Kryo没有提供很好的迁移路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, even though events were not lost, they could be processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051608Z" creationid="xccui" creationdate="20190605T051608Z">
        <seg>此外，虽然数据在出错时不会丢失，但可能会被处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, even though events would not be lost in case of a failure, they could be processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T042844Z" creationid="xccui" creationdate="20190322T042844Z">
        <seg>此外，虽然数据在出错时不会丢失，但可能会被处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, exactly-once state consistency and the ability to scale an application are fundamental requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T064049Z" creationid="xccui" creationdate="20190314T062307Z">
        <seg>此外，作为基本需求，系统要提供精确一次的状态一致性保障和应用扩容能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, in some cases Flink might not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061122Z" creationid="xccui" creationdate="20190617T061122Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, in the case of a failure, a stateless operator can be simply restarted and continue processing from where it left off.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T055150Z" creationid="xccui" creationdate="20190405T040033Z">
        <seg>此外，如果发生故障，无状态的算子可以很容易地重启，并从中断处继续工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it is an effective mecha&lt;t0/&gt;‐&lt;t1/&gt; nism to distribute network resources in case of skewed data distributions because credit is granted depending on the size of the senders’ backlog.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151301Z" creationid="esouser" creationdate="20190514T151123Z">
        <seg>此外，授予信用度是依据发送端的积压量来完成，因此该机制还会在出现数据倾斜时有效地分配网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it is an effective mechanism to distribute network resources in the case of skewed data distributions because credit is granted based on the size of the senders’ backlog.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T200120Z" creationid="xccui" creationdate="20190606T203116Z">
        <seg>此外，信用值的授予是根据各发送端的数据积压量来完成的，因此该机制还能在出现数据倾斜（data skew）时有效地分配网络资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it is often required to transform the data into a common format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T183803Z" creationid="xccui" creationdate="20190228T183803Z">
        <seg>此外，我们经常需要将数据转换为某种通用格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, it provides type information for Scala’s Either, Option, and Try types, and Flink’s Java version of the Either type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T050116Z" creationid="xccui" creationdate="20190617T050116Z">
        <seg>此外，它还为Scala的Either、Option、Try类型以及Flink内部Java版本的Either类型提供了相应的类型信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, most Flink applications depend on one or more of Flink’s connectors to ingest data from or emit data to external sys‐ tems, like Apache Kafka, filesystems, or Apache Cassandra.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035050Z" creationid="xccui" creationdate="20190619T035050Z">
        <seg>此外，大多数Flink应用都会依赖一个或多个Flink的连接器来读写外部系统（例如：Apache Kafka、文件系统或Apache Cassandra）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, process functions feature side outputs to emit records to multiple output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T043918Z" creationid="xccui" creationdate="20190621T043918Z">
        <seg>此外，处理函数的副输出功能还允许将记录发送到多个输出流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, results were still dependent on timing and order of arriving events, i.e., the results did not depend solely on the data but also on exter&lt;t2/&gt;‐&lt;t3/&gt; nal conditions such as the hardware utilization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T050519Z" creationid="xccui" creationdate="20190327T050502Z">
        <seg>此外，结果仍然依赖于到来事件的时间和顺序，换言之，结果的生成不仅依赖于数据本身，还和外部条件（如：硬件使用率）有关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, results were still dependent on timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T194319Z" creationid="xccui" creationdate="20190605T053311Z">
        <seg>并且其处理结果仍依赖于事件到来的时间和顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the Context can emit records to side outputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T054138Z" creationid="xccui" creationdate="20190621T054138Z">
        <seg>此外，Context还支持将结果发送到副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the method has a Context parameter similar to other process methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011223Z" creationid="xccui" creationdate="20190624T011223Z">
        <seg>此外，该方法和其他处理方法一样都有一个Context参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the state of a window operator with an AggregateFunction also consists of a single value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T003406Z" creationid="xccui" creationdate="20190624T003406Z">
        <seg>此外，使用了AggregateFunction的窗口算子，其状态也只有一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the stream processor can recover from failures with exactly-once state consistency guarantees and can adjust the compute resources of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045057Z" creationid="xccui" creationdate="20190605T044916Z">
        <seg>此外，它还能以精确一次的状态一致性保障进行故障恢复，调节应用计算资源等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the stream processor is respon&lt;t0/&gt;‐&lt;t1/&gt; sible to recover from failures with exactly-once state consistency guarantees and should be capable of adjusting the parallelism of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033138Z" creationid="xccui" creationdate="20190317T063754Z">
        <seg>此外，它还要负责以精确一次的状态一致性保障进行故障恢复，调节应用并发度等工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the union operator does not perform duplication elimina‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064716Z" creationid="xccui" creationdate="20190614T064619Z">
        <seg>此外，union算子不会对数据进行去重，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, they can cause issues if they are used without a custom trigger that discards incomplete and stale windows at some point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041329Z" creationid="xccui" creationdate="20190623T041329Z">
        <seg>此外，如果没有为其自定义触发器来丢弃某些时候出现的不完整或过期的窗口，还会导致一些问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, this approach can suffer from garbage collec‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T020047Z" creationid="xccui" creationdate="20190703T222830Z">
        <seg>此外，该方法可能由于堆中放置了过多常驻内存的对象（long-lived object）而引发垃圾回收停顿（garbage collection pause）问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, users of open source software request or contribute new features that are missing to support their use</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T041404Z" creationid="xccui" creationdate="20190319T054608Z">
        <seg>此外，开源软件用户如果发现某些功能无法满足用例需求，都会向开源社区汇报或亲自操刀上阵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More‐ over, exactly-once state consistency and the ability to scale an application are funda‐ mental requirements for event-driven applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T074758Z" creationid="xccui" creationdate="20190604T053625Z">
        <seg>此外，作为基本需求，系统要提供精确一次（exactly-once）的状态一致性保障和针对应用的可伸缩性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More‐ over, in combination with the CheckpointListener interface, the snapshotState() method can be used to consistently write data to external datastores by synchronizing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T072346Z" creationid="xccui" creationdate="20190702T071818Z">
        <seg>此外，该方法还可以协同CheckpointListener接口，以和Flink检查点同步的方式将数据持续写入外部数据存储中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More‐ over, the data often needs to be transformed into a common format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T072352Z" creationid="esouser" creationdate="20190603T202046Z">
        <seg>此外，开发人员经常需要将这些数据转换为某种通用格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most DataStream API methods accept lambda functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055552Z" creationid="xccui" creationdate="20190618T055552Z">
        <seg>大多数DataStream API的方法都接收lambda函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most commonly, this is done in a static</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043215Z" creationid="xccui" creationdate="20190612T043110Z">
        <seg>大多数情况下，这些工作都会在静态的main方法中完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most function interfaces are designed as SAM (single abstract method) interfaces and they can be implemented as Java 8 lambda functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T022250Z" creationid="xccui" creationdate="20190613T022250Z">
        <seg>大多数函数接口都被设计为SAM（单一抽象方法）形式的，因此可以通过Java 8的labmda函数实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most operators of the DataStream API have a single output—they produce one result stream with a specific data type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T013130Z" creationid="xccui" creationdate="20190622T013130Z">
        <seg>大多数DataStream API的算子都只有一个输出，即只能生成一条某种数据类型的结果流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most stream transformations are based on user-defined functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T014153Z" creationid="xccui" creationdate="20190613T014153Z">
        <seg>大多数流式转换都是基于用户自定义函数来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most streaming applications require that failures not affect the correctness of the computed results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T203714Z" creationid="xccui" creationdate="20190702T203714Z">
        <seg>它们中的大多数都要求故障不会对计算结果的正确性产生影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-Stream Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022743Z" creationid="xccui" creationdate="20190225T022743Z">
        <seg>基于多流的转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple companies have built streaming analytics services based on Flink’s SQL support both for internal use or to publicly offer them to paying customers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T041142Z" creationid="xccui" creationdate="20190319T040751Z">
        <seg>很多公司基于此构建了流式分析服务，供内部或外界付费用户使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multistream Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024730Z" creationid="esouser" creationdate="20190603T145126Z">
        <seg>多流转换</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multistream transformations merge multiple streams into one stream or split one stream into multiple streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024606Z" creationid="xccui" creationdate="20190613T024521Z">
        <seg>多流转换会将多条数据流合并为一条或将一条数据流拆分成多条；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MyAssigner().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044601Z" creationid="xccui" creationdate="20190620T044601Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nat&lt;t4/&gt;‐&lt;t5/&gt; urally, if a system can perform operations faster, it can perform more operations at the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211939Z" creationid="xccui" creationdate="20190402T211902Z">
        <seg>显然，系统执行操作越快，相同时间内执行的操作数量就会越多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naturally, if a system can perform operations faster, it can perform more operations in the same amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235710Z" creationid="xccui" creationdate="20190605T235634Z">
        <seg>显然，系统执行操作越快，相同时间内执行的操作数目就会越多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Navigate to File -&gt; New -&gt; Project from Existing Sources, select the book examples folder examples-scala, and click OK.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041215Z" creationid="xccui" creationdate="20190611T041215Z">
        <seg>依次找到File -&gt; New -&gt; Project from Existing Sources，选择书中示例文件夹examples-scala，点击OK。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested fields in POJOs and tuples are selected by denoting the nesting level with a "." (period character).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T045900Z" creationid="xccui" creationdate="20190618T045900Z">
        <seg>如需选择POJO和元组中嵌套字段，可以利用"." (英文句号)来区分嵌套级别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New distributed stream processing projects are continuously entering the open source stage and are challenging the state-of-the-art with new features and capabilities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T054015Z" creationid="xccui" creationdate="20190319T054015Z">
        <seg>新的分布式流处理项目不断涌入开源领域，依靠其新特性和新功能向旧有的领先技术发起挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New distributed stream processing projects are continu‐ ously entering the open source stage and are challenging the state of the art with new features and capabilities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160505Z" creationid="xccui" creationdate="20190605T050557Z">
        <seg>新的分布式流处理项目不断涌入开源领域，依靠其新的功能特性能向旧有的先进技术发起挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next,  we  use env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045810Z" creationid="xccui" creationdate="20190612T045706Z">
        <seg>接下来我们通过env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, let’s run one of the book example applications in your IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042102Z" creationid="xccui" creationdate="20190611T042102Z">
        <seg>下一步让我们尝试在IDE里运行书中的一个示例程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we define a timeWindow() transfor‐ mation, which groups the sensor readings of each sensor ID partition into tumbling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053740Z" creationid="xccui" creationdate="20190612T053715Z">
        <seg>接下来我们通过timeWindow()转换，在每个传感器ID分区都将读数划分为5秒一次的滚动窗口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we describe the semantics of common window types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012953Z" creationid="xccui" creationdate="20190606T012936Z">
        <seg>接下来我们将介绍常见窗口类型的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we introduce application designs based on stateful stream processing that exhibit many interesting characteristics and benefits over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T223624Z" creationid="xccui" creationdate="20190225T222612Z">
        <seg>接下来，我们会介绍基于状态化流处理的应用方法。和传统方法相比，它有很多有趣的特性和优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we introduce application designs based on stateful stream pro‐ cessing that exhibit many interesting characteristics and benefits over traditional approaches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T022934Z" creationid="esouser" creationdate="20190603T163031Z">
        <seg>其次，我们会介绍基于状态化流处理的应用设计。和传统设计相比，它有很多有趣的特性和优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we review the types of guarantees offered by modern stream processors and some mechanisms that systems implement to achieve those guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044532Z" creationid="xccui" creationdate="20190415T044532Z">
        <seg>接下来我们回顾一下现代流处理引擎所提供的不同种类的结果保障以及它们相应的实现机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we review the types of guarantees offered by modern stream processors and some of the mechanisms systems imple‐ ment to achieve those guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034141Z" creationid="xccui" creationdate="20190606T034141Z">
        <seg>接下来我们回顾一下现代流处理引擎所提供的不同种类的结果保障以及它们相应的实现机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we will get to use Flink’s window API, which provides built-in implementations of the most common window types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T053031Z" creationid="xccui" creationdate="20190619T053031Z">
        <seg>接下面我们会讲到Flink的窗口API，它针对几个最为常用的窗口类型都提供了内置实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we will guide you through the process of starting a local cluster and executing a first streaming application in order to give you a first impression of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T054710Z" creationid="xccui" creationdate="20190328T054710Z">
        <seg>接下来为了帮你获得Flink的第一印象，我们将一步步指导你启动本地集群并运行第一个流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, you have looked into the requirements of processing infinite streams in parallel and you have realized the importance of latency and throughput for stream applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051449Z" creationid="xccui" creationdate="20190416T050633Z">
        <seg>接下来你了解了并行处理无限流的需求并意识到了延迟和吞吐对于流式应用的重要性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, you learned the requirements of pro‐ cessing infinite streams in parallel and saw the importance of latency and throughput for stream applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194946Z" creationid="xccui" creationdate="20190606T040339Z">
        <seg>接下来，你学习了的并行处理无限流的需求，了解了延迟和吞吐对于流式应用的重要性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No action is taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184403Z" creationid="xccui" creationdate="20190626T184403Z">
        <seg>什么都不做。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No matter if water&lt;t2/&gt;‐&lt;t3/&gt; marks are user-defined or automatically generated, tracking global progress in a dis&lt;t4/&gt;‐&lt;t5/&gt; tributed system might be problematic in the presence of straggler tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T031322Z" creationid="xccui" creationdate="20190414T030615Z">
        <seg>无论水位线是由用户定义还是自动生成，只要存在落后的任务，追踪分布式系统中的全局进度就可能出现问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No matter if watermarks are user defined or automatically generated, tracking global progress in a distributed system might be problematic in the presence of straggler tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T162042Z" creationid="xccui" creationdate="20190606T025748Z">
        <seg>无论水位线是由用户定义还是自动生成，只要存在"拖后腿"的任务，追踪分布式系统中的全局进度就可能出现问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nodes represent operators and edges denote data dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T001302Z" creationid="xccui" creationdate="20190401T001240Z">
        <seg>其中节点表示算子，边表示数据依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nodes represent tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021810Z" creationid="xccui" creationdate="20190401T021708Z">
        <seg>每个节点表示一个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-chained task execution with dedicated threads and data transport via buffer channels and serialization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155047Z" creationid="esouser" creationdate="20190514T155047Z">
        <seg>使用特定线程执行非链接任务，利用缓冲通道及序列化进行数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonchained task execution with dedicated threads and data transport via</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T202204Z" creationid="xccui" creationdate="20190606T204033Z">
        <seg>利用专用线程执行非链接任务并通过缓冲通道及序列化进行数据传输</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>None of the functions exposes an API to set the time&lt;t8/&gt;‐&lt;t9/&gt; stamps of emitted records, manipulate the event-time clock of a task, or emit watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T140736Z" creationid="esouser" creationdate="20190603T140736Z">
        <seg>但函数没有暴露相应的API来设置发出记录的时间戳，调整任务的事件时间时钟或发出水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonkeyed windows (also called all-windows in the DataStream API) behave exactly the same, except that they collect all data and are not evaluated in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041635Z" creationid="xccui" creationdate="20190622T041635Z">
        <seg>非键值分区窗口（在DataStream API中也称为全量窗口）的行为与之完全相同，只是它们会收集全量数据且不支持并行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all stream processors are equally well-suited to run event-driven applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T150915Z" creationid="xccui" creationdate="20190604T052517Z">
        <seg>并不是所有的流处理引擎都同等适合来运行事件驱动型应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note shipping records in buffers does imply that Flink’s processing model is based on micro-batches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042016Z" creationid="xccui" creationdate="20190504T042016Z">
        <seg>但注意，从缓冲区中传输记录并不意味着Flink的处理模型是基于微批次的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink does not guarantee that the notifyCheckpointCom plete() method is called for each completed checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T202900Z" creationid="xccui" creationdate="20190702T202900Z">
        <seg>注意，Flink不保证对每个完成的检查点都会调用notifyCheckpointComplete()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink does not implement this naive mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224835Z" creationid="xccui" creationdate="20190608T224543Z">
        <seg>但值得一提的是Flink没有实现这种朴素策略，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink uses TCP connec&lt;t0/&gt;‐&lt;t1/&gt; tions, thus these requirements are guaranteed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043546Z" creationid="xccui" creationdate="20190415T043439Z">
        <seg>由于Flink使用的是TCP连接，这些需求都能得以保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Flink uses TCP connec‐ tions, and thus these requirements are guaranteed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T190915Z" creationid="xccui" creationdate="20190606T033713Z">
        <seg>由于Flink使用的是TCP连接，上述需求都能满足。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that an explicitly specified trigger overrides the existing trig‐ ger and does not complement it—the window will only be evalu‐ ated based on the trigger that was last defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T025932Z" creationid="xccui" creationdate="20190626T025707Z">
        <seg>需要注意的是，显式指定的触发器会覆盖已有的触发器而非对其进行补充，这意味着窗口仅会基于最新定义的触发器执行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that both bounds may be negative.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T031942Z" creationid="xccui" creationdate="20190628T031942Z">
        <seg>注意，两侧边界值都有可能为负。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that changing the input data type of built-in stateful opera‐ tors, such as window aggregation, time-based joins, or asyncronous functions, often modifies the type of their internal state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T041430Z" creationid="xccui" creationdate="20190705T041430Z">
        <seg>注意，改变内置状态化算子（例如窗口聚合，基于时间的Join或异步函数）的输入数据类型通常都使它们内部状态的类型发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that guaranteeing the consistency of an application’s state is not the same a guarantee‐ ing consistency of its output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T191638Z" creationid="xccui" creationdate="20190606T034216Z">
        <seg>请注意，保证应用状态的一致性和保证输出的一致性并不是一回事儿。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that keyBy() is different from the distribution transforma‐ tions discussed in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070343Z" creationid="xccui" creationdate="20190615T070343Z">
        <seg>注意，keyBy()和本节介绍的分发转换不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that mergable triggers may only use state primitives that can be automatically merged—ListState, ReduceState, or Aggrega tingState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195502Z" creationid="xccui" creationdate="20190626T195502Z">
        <seg>注意，可合并的触发器只能使用那些可以自动合并的状态原语——ListState，ReduceState或AggregatingState。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that shipping records in buffers does imply that Flink’s pro‐ cessing model is based on microbatches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T191414Z" creationid="xccui" creationdate="20190606T195722Z">
        <seg>请注意，将记录放入缓冲区并不意味着Flink的处理模型就是基于微批次的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that stateful transformations and keyed aggregates have to be used with care.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044921Z" creationid="xccui" creationdate="20190614T044921Z">
        <seg>请注意，在使用状态化转换和基于键值的聚合时要格外小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that stream pro&lt;t0/&gt;‐&lt;t1/&gt; cessors can normally only guarantee result correctness for state that lives inside the stream processor itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T045425Z" creationid="xccui" creationdate="20190415T045308Z">
        <seg>注意，流处理引擎通常只能保障其自身内部状态结果的正确性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T032826Z" creationid="xccui" creationdate="20190619T032826Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the ListCheckpointed interface is implemented in Java and expects a java.util.List instead of a Scala native list.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T054346Z" creationid="xccui" creationdate="20190701T054346Z">
        <seg>请注意，ListCheckpointed接口是用Java实现的，所以它内部使用的是java.util.List而非Scala原生列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the application and the savepoint must be compatible—the application must be able to load the state of the savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212525Z" creationid="xccui" creationdate="20190609T212448Z">
        <seg>需要注意的是，应用和保存点必须相互兼容，只有这样应用才能加载保存点内的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the choice of a streaming sink affects the end-to-end con‐ sistency of an application, whether the result of the application is provided with at-least once or exactly-once semantics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005523Z" creationid="xccui" creationdate="20190613T005523Z">
        <seg>注意，无论应用结果是至少一次语义还是精确一次语义，流式数据汇的选择都将影响应用端到端的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the keys of both streams should</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151936Z" creationid="xccui" creationdate="20190615T050826Z">
        <seg>注意，就像SQL查询中Join的谓词一样，两条流中的键值类型需要是同一类实体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the savepoint does not contain information about opera‐ tor tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215650Z" creationid="xccui" creationdate="20190609T215650Z">
        <seg>注意，保存点没有包含算子任务的相关信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the trigger uses custom state, which is cleaned up using the clear() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201046Z" creationid="xccui" creationdate="20190626T201046Z">
        <seg>注意，该触发器用到了自定义状态并在clear()方法中对其进行了清理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T062507Z" creationid="xccui" creationdate="20190621T062507Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that to be able to efficiently combine the current state with an event and produce a single value, the aggregation function must be associative and commuta&lt;t0/&gt;‐&lt;t1/&gt; tive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035418Z" creationid="xccui" creationdate="20190406T035032Z">
        <seg>注意，为了更有效地合并事件和当前状态、生成单个结果，聚合函数必须是可结合（associative）及可交换（commutative）的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that to be able to efficiently combine the current state with an event and produce a single value, the aggregation function must be associative and commuta‐ tive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061404Z" creationid="xccui" creationdate="20190606T011827Z">
        <seg>注意，为了更有效地合并事件和当前状态并生成单个结果，聚合函数必须是可结合（associative）及可交换（commutative）的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you can customize a window operator by providing a custom trigger or evictor and declaring strategies to deal with late elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T042128Z" creationid="xccui" creationdate="20190622T041859Z">
        <seg>你可以通过提供自定义触发器或移除器以及声明迟到元素处理策略的方式来自定义窗口算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you should avoid using Kryo if possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065518Z" creationid="xccui" creationdate="20190616T065518Z">
        <seg>注意，如果可能请尽量避免使用Kryo。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you should design such an operator with efficient state access patterns and effective state cleanup strategies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T211309Z" creationid="xccui" creationdate="20190627T211309Z">
        <seg>注意，你设计的算子需要拥有高效的状态访问模式及有效的状态清理策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you should not access keyed state from the processBroadcastEle ment() method of KeyedBroadcastProcessFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054919Z" creationid="xccui" creationdate="20190702T053934Z">
        <seg>注意，由于广播输入一侧没有指定键值，状态后端无法访问键值分区的状态值，所以你不能从KeyedBroadcastProcessFunction的processBroadcastElement()方法中访问键值分区状态，强行这么做会使状态后端抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: you can also build the JAR file yourself by following the steps on the repo&lt;t0/&gt;‐&lt;t1/&gt; sitory’s README file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035840Z" creationid="xccui" creationdate="20190329T035802Z">
        <seg>注意：你也可以根据代码库中README文件的指示自行构建JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now let’s quickly discuss what is happening under the hood.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043738Z" creationid="xccui" creationdate="20190611T043738Z">
        <seg>接下来我们快速讨论一下内部发生的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now open your IDE and import the Maven project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040711Z" creationid="xccui" creationdate="20190611T040711Z">
        <seg>现在就可以打开你的IDE，把Maven项目导进去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that we have all that knowledge, it’s time to get our hands dirty and start devel‐ oping Flink applications!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T034012Z" creationid="xccui" creationdate="20190610T033449Z">
        <seg>既然我们已经掌握了这么多理论知识，是时候撸起袖子着手开发Flink应用了！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that you are familiar with the basics of dataflow programming, it’s time to see how these concepts apply to processing data streams in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045530Z" creationid="xccui" creationdate="20190605T233630Z">
        <seg>现在你已经对Dataflow编程的基础有所了解，接下来我们看一下如何将这些概念应用到并行数据流处理中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that you have become familiar with the basics of dataflow programming, it’s time to see how these concepts apply to processing data streams in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142729Z" creationid="xccui" creationdate="20190401T142257Z">
        <seg>现在你已经对dataflow编程的基础有所了解，接下来我们看一下这些概念如何应用于并行数据流处理中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>OUT getResult(ACC accumulator);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T004737Z" creationid="xccui" creationdate="20190624T004737Z">
        <seg>OUT getResult(ACC accumulator);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Obviously, the periodic nature of the ETL jobs and reporting queries induce a consid&lt;t0/&gt;‐&lt;t1/&gt; erable latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T031411Z" creationid="xccui" creationdate="20190317T031021Z">
        <seg>就是ETL作业和报告查询的周期性会导致相当高的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course there is much more to learn about stream pro&lt;t0/&gt;‐&lt;t1/&gt; cessing with Apache Flink and that’s what this book is about.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041854Z" creationid="xccui" creationdate="20190328T062511Z">
        <seg>当然，关于用Apache Flink进行流处理要学习的知识还有很多，这也正是本书要介绍的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, none of this matters if your system cannot guard state against failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T203538Z" creationid="xccui" creationdate="20190409T203538Z">
        <seg>当然，如果你的系统无法在故障时保护状态，那一切都是空谈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, there is much more to learn about stream processing with Apache Flink and that’s what this book is about.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124522Z" creationid="xccui" creationdate="20190605T124522Z">
        <seg>当然，关于用Apache Flink进行流处理要学习的知识还有很多，这也正是本书要介绍的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, you can still use processing-time windows and timers if you choose the EventTime time characteristic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190619T073009Z">
        <seg>当然，即便选择EventTime时间特性，仍然可以使用处理时间窗口和计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often are features of these newcomers being adop&lt;t0/&gt;‐&lt;t1/&gt; ted by more stream processors of earlier generations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014815Z" creationid="xccui" creationdate="20190319T055501Z">
        <seg>而这些新特性往往会被更多上一代的流处理引擎所采用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, a database system serves multiple applications that sometimes access the same databases or tables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T195827Z" creationid="esouser" creationdate="20190603T195556Z">
        <seg>很多时候，多个应用会共享同一个数据库系统，有时候还会访问相同的数据库或表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, these include frequently used libraries, such as Apache Commons or Google’s Guava.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T040525Z" creationid="xccui" creationdate="20190619T040525Z">
        <seg>这些依赖通常包括一些诸如Apache Commons或Google Guava等常用库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often, this data was either unstruc&lt;t0/&gt;‐&lt;t1/&gt; tured, i.e., not strictly following a relational schema, or too voluminous to be cost-effectively stored in a relational database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T210826Z" creationid="xccui" creationdate="20190228T210612Z">
        <seg>这些数据通常是非结构化（即无法严格匹配关系模式）的，或因数量庞大无法经济高效地存放于关系型数据库系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Oftentimes there is a need to initialize a function before it processes the first record or to retrieve information about the context in which it is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060108Z" creationid="xccui" creationdate="20190618T060108Z">
        <seg>很多时候我们需要在函数处理第一条记录之前进行一些初始化工作或是取得有关执行它的上下文信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the contrary, in continuously running stream&lt;t4/&gt;‐&lt;t5/&gt; ing jobs, state is durable across events and we can expose it as a first-class citizen in the programming model.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053122Z" creationid="xccui" creationdate="20190414T054354Z">
        <seg>反之，在持续运行的流式作业中，每次处理事件状态都是持久化的，我们完全可以将其作为编程模型中的一等公民。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the contrary, stateful operators may maintain information about the events they have received before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T040228Z" creationid="xccui" creationdate="20190405T040212Z">
        <seg>相反，状态化算子可能会维护之前接收的事件信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the left hand side you see a JobGraph - the non-parallel representation of an application - consisting of five operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043357Z" creationid="xccui" creationdate="20190423T043236Z">
        <seg>左侧的JobGraph（非并行化的应用表示）包含了5个算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the left-hand side of Figure 3-2 you see a JobGraph—the nonparallel representa‐ tion of an application—consisting of five operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144523Z" creationid="xccui" creationdate="20190606T144451Z">
        <seg>左侧的JobGraph（应用的非并行化表示）包含了5个算子，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, event time guarantees deterministic results and allows you to deal with events that are late or even out of order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031344Z" creationid="xccui" creationdate="20190606T031309Z">
        <seg>事件时间则与之相反，能保证结果的准确性，并允许你处理延迟甚至无序的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, event time guarantees deterministic results and allows you to deal with events that are late or even out-of-order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050333Z" creationid="xccui" creationdate="20190414T045924Z">
        <seg>与之相对的事件时间能保证确定的结果，并允许你处理延迟甚至无序的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if watermarks are too relaxed, you have high confidence but you might unnecessarily increase processing latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T161536Z" creationid="xccui" creationdate="20190606T025703Z">
        <seg>反之，如果水位线过于宽松，虽然可信度得以保证，但可能会无谓地增加处理延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if watermarks are too slow to arrive, you have high confi&lt;t4/&gt;‐&lt;t5/&gt; dence but you might unnecessarily increase processing latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210859Z" creationid="xccui" creationdate="20190412T210722Z">
        <seg>反之，如果水位线到来的太晚，虽然可信度得到了保证，但可能会无谓地增加处理延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if you generate very tight watermarks—watermarks that might be larger than the timestamps of some later records—time-based computations might be performed before all relevant data has arrived.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T040435Z" creationid="xccui" creationdate="20190621T040435Z">
        <seg>反之，如果生成的水位线过于紧密，即水位线可能大于部分后来数据的时间戳，那么计算可能会在所有相关数据到齐之前就已触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, knowing about all accidents that have ever happened might not be so interesting in this case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043532Z" creationid="xccui" creationdate="20190406T043454Z">
        <seg>此时，我们可能对该位置发生过的所有事故并不感兴趣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a job is scheduled for execution on the next batch, it cannot access the state of the pre&lt;t2/&gt;‐&lt;t3/&gt; vious job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053824Z" creationid="xccui" creationdate="20190414T053811Z">
        <seg>一旦作业调度到下个批次上执行，它将无法访问之前的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a job is scheduled for execution on the next batch, it cannot access the state of the previous job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182213Z" creationid="xccui" creationdate="20190606T032116Z">
        <seg>一旦某个作业被调度到下个批次上执行，它将无法访问之前的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a sender receives a credit notification, it ships as many buffers as it was granted and the size of its backlog, i.e., the number of network buffers that are filled and ready to be shipped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T151649Z" creationid="esouser" creationdate="20190513T211245Z">
        <seg>一旦发送端收到信用通知，就会在信用度范围内传输尽可能多的缓冲，并附带积压量（已经填满准备传输的缓冲数目）大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a sender receives a credit notification, it ships as many buffers as it was granted and the size of its backlog—the number of network buffers that are filled and ready to be shipped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T195048Z" creationid="xccui" creationdate="20190606T202839Z">
        <seg>一旦发送端收到信用通知，就会在信用值所限定的范围内尽可能多地传输缓冲数据，并会附带上积压量（已经填满准备传输的网络缓冲数目）大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a watermark has been received, operators are signaled that all timestamps for a certain time interval have been observed and either trigger computation or order received events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T161323Z" creationid="xccui" creationdate="20190412T205922Z">
        <seg>算子一旦收到某个水位线，就相当于接到信号：某个特定时间区间的时间戳已经到齐，可以触发窗口计算或对接收的数据进行排序了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once all barriers for a checkpoint have arrived, the operator checkpoints the state, which might now also include modifications caused by records that would usually belong to the next checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T205131Z" creationid="xccui" creationdate="20190609T204938Z">
        <seg>待所有的检查点分隔符都到达以后，算子才将状态存入检查点，这时候状态可能会包含一些由本应出现在下一次检查点的记录所导致的改动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once all checkpoint barriers have been emitted, the task starts to process the buffered records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193035Z" creationid="xccui" creationdate="20190609T193035Z">
        <seg>任务在发出所有的检查点分隔符后就会开始处理缓冲的记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once all tasks are up and running, the pro‐ gram starts to produce its results, which should look similar to the following lines:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043424Z" creationid="xccui" creationdate="20190611T043424Z">
        <seg>一旦所有任务启动起来并开始运行，程序就会开始生成类似下面这样的结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once an application is submitted for execution, it starts a JobManager and hands the application over.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061658Z" creationid="xccui" creationdate="20190606T142857Z">
        <seg>一旦某个应用提交执行，Dispatcher会启动一个JobManager并将应用转交给它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once data has been emitted to a sink, it is difficult to guarantee result correctness, unless the sink system supports transactions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T191921Z" creationid="xccui" creationdate="20190606T034308Z">
        <seg>一旦数据从数据汇中写出，除非目标系统支持事务，否则结果的正确性将难以保证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it received enough TaskManager slots, it distributes the tasks of the ExecutionGraph to the TaskManagers that execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T061952Z" creationid="xccui" creationdate="20190418T035042Z">
        <seg>一旦它收到了足够的TaskManager处理槽，就会将ExecutionGraph中的任务分发给TaskManager来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it receives an application, it starts a JobMan&lt;t4/&gt;‐&lt;t5/&gt; ager and hands the application over.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T053136Z" creationid="xccui" creationdate="20190418T053058Z">
        <seg>一旦接收了某个应用，Dispatcher会启动一个JobManager并将应用交付给它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it receives enough Task‐ Manager slots, it distributes the tasks of the ExecutionGraph to the TaskManag‐ ers that execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060207Z" creationid="xccui" creationdate="20190606T141755Z">
        <seg>一旦它收到了足够数量的TaskManager处理槽（slot），就会将ExecutionGraph中的任务分发给TaskManager来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once that timer fires, the onTimer() method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T213456Z" creationid="xccui" creationdate="20190704T213456Z">
        <seg>一旦该计时器触发，就会调用onTimer()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the data has been imported into the data warehouse it can be queried and ana&lt;t0/&gt;‐&lt;t1/&gt; lyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192252Z" creationid="xccui" creationdate="20190228T191418Z">
        <seg>一旦数据导入数据仓库，就能对它们做查询分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the data has been imported into the data warehouse it can be queried and ana‐ lyzed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T064853Z" creationid="esouser" creationdate="20190603T203005Z">
        <seg>一旦数据导入数据仓库，我们就能对它们做查询分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the execution environment has been configured, it is time to do some actual work and start processing streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T050957Z" creationid="xccui" creationdate="20190612T050957Z">
        <seg>在执行环境配置完后，就可以进行一些实质性的工作，正式开始处理数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the sender task completes, the data is sent as a batch over a temporary TCP connection to the receiver</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045623Z" creationid="xccui" creationdate="20190504T045549Z">
        <seg>一旦发送端任务完成，所有数据会经由一个到接收端的临时TCP连接，以批量形式发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the sender task completes, the data is sent as a batch over a temporary TCP connection to the receiver.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193024Z" creationid="xccui" creationdate="20190606T200629Z">
        <seg>一旦发送端任务完成，所有数据会经由一个到接收端的临时TCP连接批量发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the state for a certain result has been purged, the result cannot be updated anymore and late events can only be dropped or redirected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T162637Z" creationid="xingcan" creationdate="20190628T162637Z">
        <seg>一旦清除了针对特定结果的状态，这些结果就再也无法更新，而迟到事件也只能被丢弃或重定向。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once we have a DataStream, we can apply a transformation on it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052239Z" creationid="xccui" creationdate="20190612T052239Z">
        <seg>一旦得到了DataStream，我们就可以对它进行转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you change operator identifiers or the maximum parallelism, you cannot start an application from a savepoint but have to start it from scratch without any state initialization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023237Z" creationid="xccui" creationdate="20190703T015126Z">
        <seg>一旦你修改了算子标识或最大并行度则无法从保存点启动应用，只能选择抛弃状态从头开始运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once your coffee is ready, the barista calls your name and you can pick up your coffee from the bench.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T153941Z" creationid="xccui" creationdate="20190401T152947Z">
        <seg>咖啡制作完成后，店员会叫你的名字，你来从吧台取走咖啡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once your coffee is ready, the barista calls your name and you can pick up your coffee from the counter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050857Z" creationid="xccui" creationdate="20190605T233910Z">
        <seg>咖啡制作完成后，咖啡师会叫你的名字，你来从吧台取走咖啡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One appli&lt;t0/&gt;‐&lt;t1/&gt; cation emits its output to an event log and another application consumes the events that the other application emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152727Z" creationid="xccui" creationdate="20190307T152727Z">
        <seg>即上游应用将结果写入事件日志供下游应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One application emits its output to an event log and another application consumes the events the other appli‐ cation emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214038Z" creationid="esouser" creationdate="20190603T214015Z">
        <seg>上游应用将结果写入事件日志供下游应用消费使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One example for such an assigner is the EventTimeSessionWindows assigner we discussed before, which works by creating a new window for each arriving element and merging overlapping win‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045808Z" creationid="xccui" creationdate="20190626T045703Z">
        <seg>一个例子就是我们之前讨论过的EventTimeSessionWindows分配器，它需要为每个到来的元素创建一个新的窗口并在之后合并那些重叠的窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of Flink’s most valued and unique features are savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210433Z" creationid="xccui" creationdate="20190609T210433Z">
        <seg>Flink最具价值和最独特的功能之一是保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the most interesting applications of save‐ points we have seen in the wild is continuously migrating a streaming application to the datacenter that provides the lowest instance prices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214038Z" creationid="xccui" creationdate="20190609T213849Z">
        <seg>我们在生态中见到保存点最有意思的应用之一是不断将流式应用迁移到实例价格最低的数据中心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One operator (OP-1) has a single operator state (OS-1) and another operator (OP-2) has two keyed states (KS-1 and KS-2).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190609T214916Z">
        <seg>其中一个算子（OP-1）有一个算子状态（OS-1），另一个算子（OP-2）有两个键值分区状态（KS-1和KS-2）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One restriction of the split transformation is that all outgoing streams are of the same type as the input type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064224Z" creationid="xccui" creationdate="20190615T064224Z">
        <seg>split转换的一个限制是所有输出流的类型必须和输入流相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way you can lower latency is by hiring a more skilled barista, i.e. one that prepares coffees faster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210823Z" creationid="xccui" creationdate="20190402T210744Z">
        <seg>一种降低延迟的方法是雇佣更娴熟的咖啡师，他们制作咖啡会更快一些。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Online editions are also available for most titles (http://oreilly.com).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210717Z" creationid="esouser" creationdate="20190603T210717Z">
        <seg>Online editions are also available for most titles (http://oreilly.com).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Online gaming is a simple scenario showing how operator semantics should depend on the time when events actually happen and not the time when the application receives the events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155048Z" creationid="xccui" creationdate="20190411T153601Z">
        <seg>在线游戏这个简单场景展示了算子语义应该依赖事件实际发生时间而非应用收到事件的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only Use Kryo as a Fallback Solution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065453Z" creationid="xccui" creationdate="20190616T065453Z">
        <seg>仅将Kryo作为后备方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only Use Rolling Aggregations on Bounded Key Domains</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062710Z" creationid="xccui" creationdate="20190614T060917Z">
        <seg>只对有限键值域使用滚动聚合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only Use Rolling Reduce on Bounded Key Domains</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062659Z" creationid="xccui" creationdate="20190614T062659Z">
        <seg>只对有限键值域使用滚动reduce操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the split operator allows splitting a stream into multiple streams of the same type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T013746Z" creationid="xccui" creationdate="20190622T013746Z">
        <seg>只有split算子可以将一条数据流拆分成多条类型相同的流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only when execute() is called does the system trig‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011948Z" creationid="xccui" creationdate="20190613T011858Z">
        <seg>只有在调用execute()方法时，系统才会触发程序执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open Flink’s Web UI by entering the URL http://localhost:8081 in your browser.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123232Z" creationid="xccui" creationdate="20190605T123228Z">
        <seg>在浏览器中输入URL http://localhost:8081，打开Flink Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open Flink’s Web UI on by entering the URL &lt;t0/&gt;http://localhost:8081&lt;t1/&gt; &lt;t2/&gt;in your browser.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035037Z" creationid="xccui" creationdate="20190329T025509Z">
        <seg>在你浏览器中输入URL http://localhost:8081，打开Flink Web UI。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open a terminal and run the following Git command to clone the examples-scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040102Z" creationid="xccui" creationdate="20190611T035954Z">
        <seg>打开终端运行以下Git命令将examples-scala库克隆到你的机器上1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open a terminal and run the following command to create a Flink Maven Quickstart Scala project as a starting point for your Flink application:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004808Z" creationid="xccui" creationdate="20190612T004808Z">
        <seg>打开终端运行以下命令来创建Flink Maven Quickstart Scala项目，并以它为基础开发Flink应用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source communities are constantly improving the capabilities of their projects and are pushing the technical boundaries of stream pro‐ cessing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T192800Z" creationid="xccui" creationdate="20190605T050637Z">
        <seg>开源社区通过不断增强它们项目的功能在流处理领域开疆拓土。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source software is a major driver of this trend, mainly due to two reasons.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T052426Z" creationid="xccui" creationdate="20190319T051721Z">
        <seg>开源软件之所以能够主导这一趋势，主要有两方面原因：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source software is a major driver of this trend, mainly due to two reasons:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050320Z" creationid="xccui" creationdate="20190605T050320Z">
        <seg>开源软件之所以能够主导这一趋势，主要有两方面原因：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source stream processing software is a commodity that everybody can eval&lt;t0/&gt;‐&lt;t1/&gt; uate and use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T052828Z" creationid="xccui" creationdate="20190319T052828Z">
        <seg>开源流处理软件作为一件商品，所有人都可以评估和使用它；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source stream processing software is a commodity that everybody can eval‐ uate and use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160213Z" creationid="xccui" creationdate="20190605T050444Z">
        <seg>开源流处理软件作为一类商品，允许任何人评估和使用。</seg>
      </tuv>
    </tu>
    <tu>
      <note>TODO</note>
      <tuv lang="EN-US">
        <seg>Operating Flink and Streaming Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T033147Z" creationid="xccui" creationdate="20190225T025708Z">
        <seg>操纵Flink和流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operation of a window join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T040307Z" creationid="xccui" creationdate="20190628T040307Z">
        <seg>基于窗口的Join操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations based on event time are predictable and their results are deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160049Z" creationid="xccui" creationdate="20190606T024302Z">
        <seg>基于事件时间的操作是可预测的，其结果具有确定性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations based on event-time are predictable and their results deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150811Z" creationid="xccui" creationdate="20190412T150811Z">
        <seg>基于事件时间的操作是可预测的，它们的结果非常确定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations can be either &lt;t0/&gt;stateless&lt;t1/&gt; or &lt;t2/&gt;stateful&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T213151Z" creationid="xccui" creationdate="20190402T213141Z">
        <seg>这些操作既可以是无状态（stateless）的，也可以是有状态（stateful）的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations can be either stateless or stateful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235803Z" creationid="xccui" creationdate="20190605T235803Z">
        <seg>这些操作既可以是无状态（stateless）的，也可以是有状态（stateful）的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations on Data Streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T143937Z" creationid="esouser" creationdate="20190603T143937Z">
        <seg>数据流上的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operations on data streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015445Z" creationid="xccui" creationdate="20190225T015445Z">
        <seg>数据流上的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022048Z" creationid="xccui" creationdate="20190225T022048Z">
        <seg>算子状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator Unique Identifiers and Maximum Parallelism Are Baked into Savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015232Z" creationid="xccui" creationdate="20190703T013808Z">
        <seg>算子唯一标识和最大并行度会被固化到保存点中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state cannot be accessed by another task of the same or a different operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061752Z" creationid="xccui" creationdate="20190607T061413Z">
        <seg>算子状态不能通过其他任务访问，无论该任务是否来自相同算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state in streaming jobs is very valuable and should be guarded against fail&lt;t0/&gt;‐&lt;t1/&gt; ures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T035634Z" creationid="xccui" creationdate="20190415T035334Z">
        <seg>流式作业中的算子状态十分宝贵，因此需要在故障时予以保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state in streaming jobs is very valuable and should be guarded against fail‐ ures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T184230Z" creationid="xccui" creationdate="20190606T033054Z">
        <seg>在流式作业中，算子的状态十分重要，因此需要在故障时予以保护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state is managed per parallel instance of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T035653Z" creationid="xccui" creationdate="20190701T035251Z">
        <seg>算子状态的维护是按照每个算子并行实例来分配的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator state is scoped to an operator task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T060735Z" creationid="xccui" creationdate="20190607T060228Z">
        <seg>算子状态的作用域是某个算子任务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators A and C are sources and operator E is a sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043400Z" creationid="xccui" creationdate="20190423T043347Z">
        <seg>其中算子A和C是数据源，算子E是数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators C and E have a parallelism of two.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043448Z" creationid="xccui" creationdate="20190423T043412Z">
        <seg>算子C和E的并行度为2，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators are executed in parallel by one or more operator tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T214539Z" creationid="xccui" creationdate="20190609T214539Z">
        <seg>算子会在一个或多个任务上并行执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators are the basic functional units of a dataflow application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T224831Z" creationid="xccui" creationdate="20190331T214759Z">
        <seg>算子是Dataflow程序的基本功能单元，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators can accept multiple inputs and produce multiple output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060919Z" creationid="xccui" creationdate="20190405T155812Z">
        <seg>算子既可以同时接收多个输入流或产生多条输出流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that implement data ingestion logic are called &lt;t4/&gt;data sources&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152036Z" creationid="xccui" creationdate="20190405T152036Z">
        <seg>实现数据接入操作逻辑的算子称为数据源（data source）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that implement data ingestion logic are called data sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T005820Z" creationid="xccui" creationdate="20190606T005820Z">
        <seg>实现数据接入操作逻辑的算子称为数据源（data source）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that need to be notified about completed check‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T202324Z" creationid="xccui" creationdate="20190702T202152Z">
        <seg>需要感知检查点创建成功的算子可以实现CheckpointListener接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that perform data egress are called &lt;t8/&gt;data sinks&lt;t9/&gt; and exam&lt;t10/&gt;‐&lt;t11/&gt; ples include files, databases, message queues, and monitoring interfaces.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152733Z" creationid="xccui" creationdate="20190405T152512Z">
        <seg>负责数据输出的算子称为数据汇（data sink），其写入的目标包括文件、数据库、消息队列、监控接口等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that perform data egress are called data sinks and examples include files, databases, message queues, and monitoring interfaces.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060316Z" creationid="xccui" creationdate="20190606T010159Z">
        <seg>负责数据输出的算子称为数据汇（data sink），其写入的目标可以是文件、数据库、消息队列以及监控接口等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with keyed state are scaled by repartitioning keys to fewer or more tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190608T055151Z">
        <seg>带有键值分区状态的算子在扩缩容时会根据新的任务数量对键值重新分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with operator broadcast state are scaled up by copying the state to new tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061609Z" creationid="xccui" creationdate="20190608T061609Z">
        <seg>带有算子广播状态的算子在扩缩容时会把状态拷贝到全部新任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with operator list state are scaled by redistributing the list entries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T060331Z" creationid="xccui" creationdate="20190608T060308Z">
        <seg>带有算子列表状态的算子在扩缩容时会重新分配列表中的项目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with operator union list state are scaled by broadcasting the full list of state entries to each task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T063527Z" creationid="xccui" creationdate="20190608T061211Z">
        <seg>带有算子联合列表状态（operator union list state）的算子会在扩缩容时把状态列表的全部条目广播到全部任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators without input ports are called data sources and opera&lt;t4/&gt;‐&lt;t5/&gt; tors without output ports are called data sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190331T223800Z" creationid="xccui" creationdate="20190331T223724Z">
        <seg>没有输入口的算子称为数据源，没有输出口的算子称为数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators without input ports are called data sources and opera‐ tors without output ports are called data sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T043806Z" creationid="xccui" creationdate="20190605T224919Z">
        <seg>没有输入端的算子称为数据源，没有输出端的算子称为数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators, Tasks, and Processing Slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042938Z" creationid="xccui" creationdate="20190423T042938Z">
        <seg>算子、任务以及处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators, tasks, and processing slots</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144442Z" creationid="xccui" creationdate="20190606T144442Z">
        <seg>算子、任务以及处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Option is not defined if the state has not been initialized yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T034548Z" creationid="xccui" creationdate="20190701T034548Z">
        <seg>如果状态尚未初始化则Option为None。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionally output the result to one or more data sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044352Z" creationid="xccui" creationdate="20190612T044352Z">
        <seg>选择性地将结果输出到一个或多个数据汇中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T184156Z" creationid="xccui" creationdate="20190704T184156Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other features include support to upgrade application code or migrate a job to a different cluster or a new version of the stream processor without losing the current state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="xccui" creationdate="20190605T053913Z">
        <seg>此外还有一些新的特性，例如：支持应用代码更新，在不丢失当前状态的前提下将作业迁移至一个新的集群或新版本的流处理引擎等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other features include support to upgrade application code or migrating a job to a different cluster or a new version of the stream processor without losing the current state of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T140840Z" creationid="xccui" creationdate="20190327T140804Z">
        <seg>还有一些特性包括支持应用代码升级，在不丢失当前状态的前提下将作业迁移至一个新的集群或新版本的流处理引擎等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Others more interested in writing Flink code right away might want to read the practical chapters first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041613Z" creationid="esouser" creationdate="20190603T153223Z">
        <seg>或者如果你迫不及待地想开始编写Flink代码，也可以先阅读实践章节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, it returns a local environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045422Z" creationid="xccui" creationdate="20190612T045422Z">
        <seg>否则会返回一个本地环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the operator would have to store the complete stream history.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061442Z" creationid="xccui" creationdate="20190406T035454Z">
        <seg>否则算子就需要存储整个流的历史记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the window operator will accu‐ mulate more and more state over time and your application will probably fail at some</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194322Z" creationid="xccui" creationdate="20190626T194322Z">
        <seg>否则窗口算子的状态会越积越多，最终可能导致你的应用在某个时间出现故障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our code exam‐ ples use Scala for conciseness, but the Java API is mostly analogous (exceptions or special cases will be pointed out).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T034526Z" creationid="xccui" creationdate="20190612T034526Z">
        <seg>出于简洁考虑，我们的示例代码还会选用Scala版本，但绝大多数的Java API都是类似的（如果有异常或特殊情况会指出）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our example application ingests a stream of temperature meas‐ urements from multiple sensors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035537Z" creationid="xccui" creationdate="20190612T035520Z">
        <seg>我们的示例应用会从多个传感器中获取温度测量数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our unique network of experts and innovators share their knowledge and expertise through books, articles, conferences, and our online learning platform.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210831Z" creationid="esouser" creationdate="20190603T210831Z">
        <seg>Our unique network of experts and innovators share their knowledge and expertise through books, articles, conferences, and our online learning platform.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Output the Result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145109Z" creationid="esouser" creationdate="20190603T145109Z">
        <seg>输出结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Output the result</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022624Z" creationid="xccui" creationdate="20190225T022624Z">
        <seg>输出结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Over the years the collection and usage of data has grown consistently, and compa‐ nies have designed and built infrastructures to manage that data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T051818Z" creationid="esouser" creationdate="20190603T193927Z">
        <seg>随着数据采集和使用量的不断增长，很多公司都设计并构建了各种基础架构来管理数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Source-Generated Timestamps and Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T025549Z" creationid="xccui" creationdate="20190620T025549Z">
        <seg>覆盖数据源生成的时间戳和水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly Media, Inc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210837Z" creationid="esouser" creationdate="20190603T210837Z">
        <seg>O’Reilly Media, Inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly Online Learning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210828Z" creationid="esouser" creationdate="20190603T210828Z">
        <seg>O’Reilly Online Learning</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly books may be purchased for educational, business, or sales promotional use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210716Z" creationid="esouser" creationdate="20190603T210716Z">
        <seg>O’Reilly books may be purchased for educational, business, or sales promotional use.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>O’Reilly’s online learning platform gives you on-demand access to live training courses, in- depth learning paths, interactive coding environments, and a vast collection of text</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210832Z" creationid="esouser" creationdate="20190603T210832Z">
        <seg>O’Reilly’s online learning platform gives you on-demand access to live training courses, in- depth learning paths, interactive coding environments, and a vast collection of text</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POJO or case class fields are selected by their field name like in the above example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T042758Z" creationid="xccui" creationdate="20190618T042758Z">
        <seg>POJO或样例类的字段也可以像上面那样根据字段名称进行选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POJOs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T064539Z" creationid="xccui" creationdate="20190617T064539Z">
        <seg>POJO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>POJOs, including classes generated by Apache Avro</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065115Z" creationid="xccui" creationdate="20190616T065115Z">
        <seg>POJO（包括Apache Avro生成的类）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PURGE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184625Z" creationid="xccui" creationdate="20190626T184625Z">
        <seg>PURGE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pairs of joined events are passed into a ProcessJoinFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025950Z" creationid="xccui" creationdate="20190628T025950Z">
        <seg>Join成功的事件对会发送给ProcessJoinFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parallelization gets complicated, since results depend on both the state and incoming events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T183657Z" creationid="xccui" creationdate="20190606T032919Z">
        <seg>由于结果需要同时依赖状态和到来的事件，所以状态并行化会变得异常复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Partitioning transformations correspond to the data exchange strategies we intro‐ duced in “Data Exchange Strategies” on page 19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T065003Z" creationid="xccui" creationdate="20190615T064707Z">
        <seg>各类分区转换对应我们在第19页"数据交换策略"一节中介绍的多种数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pattern detection or complex event processing (CEP), e.g., for fraud detection in credit card transactions, and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190315T012134Z" creationid="xccui" creationdate="20190307T151505Z">
        <seg>模式识别或复杂事件处理（CEP）（例如：根据信用卡交易记录进行反欺诈），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pattern detection or complex event processing (e.g., for fraud detection in credit card transactions)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055445Z" creationid="esouser" creationdate="20190603T213624Z">
        <seg>模式识别或复杂事件处理（例如：根据信用卡交易记录进行欺诈识别）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pause the ingestion of all input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223558Z" creationid="xccui" creationdate="20190608T223429Z">
        <seg>暂停接收所有输入流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Per-window state is useful to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T023819Z" creationid="xccui" creationdate="20190624T023819Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performace Implications of Checkpointing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155008Z" creationid="esouser" creationdate="20190603T144627Z">
        <seg>检查点对性能的影响</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performance and Robustness of Stateful Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024730Z" creationid="xccui" creationdate="20190225T024730Z">
        <seg>状态化应用的性能及鲁棒性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Periodic assigner: The DataStream API provides a user-defined function called AssignerWithPeriodicWatermarks that extracts a timestamp from each record and is periodically queried for the current watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T035640Z" creationid="xccui" creationdate="20190607T034945Z">
        <seg>周期分配器：DataStream API提供了一个名为AssignerWithPeriodicWatermarks的用户自定义函数，它可以用来从每条记录提取时间戳并周期性地响应获取当前水位线的查询请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Persistent event logs write all events to durable storage, so that they can be replayed if a task fails.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193704Z" creationid="xccui" creationdate="20190416T043348Z">
        <seg>持久化事件日志会将所有事件写入永久存储，这样在任务故障时就可以重放它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Person("Adam", 17),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041131Z" creationid="xccui" creationdate="20190617T041131Z">
        <seg>Person("Adam", 17),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Person("Sarah", 23))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041140Z" creationid="xccui" creationdate="20190617T041140Z">
        <seg>Person("Sarah", 23))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Playing online mobile games in the subway.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152158Z" creationid="xccui" creationdate="20190411T152153Z">
        <seg>地铁上玩在线手游。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please address comments and questions concerning this book to the publisher:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210836Z" creationid="esouser" creationdate="20190603T210836Z">
        <seg>Please address comments and questions concerning this book to the publisher:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note that &lt;t0/&gt;Figure 3-1&lt;t1/&gt; is a high-level sketch to visualize the responsibilities and interactions of the components.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024651Z" creationid="xccui" creationdate="20190423T024651Z">
        <seg>注意，图3-1仅仅从一个较高层次上展示了各组件的职责与交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Policies can be based on time (e.g. events received in the last 5 seconds), on count (e.g. the last 100 events), or on a data property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T050402Z" creationid="xccui" creationdate="20190406T050241Z">
        <seg>决策可以基于时间（例如：最近5秒钟接收的事件）、数量（例如：最新100个事件）或其他数据属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Policies can be based on time (e.g., events received in the last five seconds), on count (e.g., the last one hundred events), or on a data property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063250Z" creationid="xccui" creationdate="20190606T012927Z">
        <seg>策略的指定可以基于时间（例如：最近5秒钟接收的事件）、数量（例如：最新100个事件）或其他数据属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preaggregation and Evictors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203511Z" creationid="xccui" creationdate="20190627T203511Z">
        <seg>预聚合与移除器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T040256Z" creationid="xccui" creationdate="20190225T040256Z">
        <seg>序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface | xi</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130342Z" creationid="xccui" creationdate="20190605T130342Z">
        <seg>序言 | xi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface | xiii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130355Z" creationid="xccui" creationdate="20190605T130355Z">
        <seg>序言 | xiii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T013841Z" creationid="xccui" creationdate="20190225T013841Z">
        <seg>序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preventing Leaking State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024832Z" creationid="xccui" creationdate="20190225T024832Z">
        <seg>防止状态泄露</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Previously in this chapter, we described the common architecture for data analytics pipelines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T025235Z" creationid="xccui" creationdate="20190317T025021Z">
        <seg>本章前面已经介绍了数据分析管道的通用架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primitives</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T071237Z" creationid="xccui" creationdate="20190615T071237Z">
        <seg>原始类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printed in the United States of America.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210713Z" creationid="esouser" creationdate="20190603T210713Z">
        <seg>Printed in the United States of America.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145830Z" creationid="xccui" creationdate="20190418T035908Z">
        <seg>处理函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process Functions | 117</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041911Z" creationid="xccui" creationdate="20190629T041911Z">
        <seg>处理函数 | 117</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process Functions | 121</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041946Z" creationid="xccui" creationdate="20190629T041946Z">
        <seg>处理函数 | 121</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process functions are com‐ monly used to build event-driven applications and to implement custom logic for which predefined windows and transformations might not be suitable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T044500Z" creationid="xccui" creationdate="20190621T044500Z">
        <seg>处理函数常被用于构建事件驱动型应用或实现一些内置窗口及转换可能不太适合的自定义逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process functions are discussed in more detail in Chapter 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025612Z" creationid="xccui" creationdate="20190607T025612Z">
        <seg>我们会在第6章详细讨论处理函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process functions can also be implemented to support late data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T040440Z" creationid="xccui" creationdate="20190629T034857Z">
        <seg>我们同样可以在处理函数中应对数据迟到的情况，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process functions can emit a record to one or more side outputs via the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T015113Z" creationid="xccui" creationdate="20190622T015113Z">
        <seg>处理函数可以利用Context对象将记录发送至一个或多个副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ProcessWindowFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005621Z" creationid="xccui" creationdate="20190624T005621Z">
        <seg>ProcessWindowFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ProcessWindowFunction is a very powerful window function, but you need to use it with caution since it typically holds more data in state than incrementally aggregating</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034846Z" creationid="xccui" creationdate="20190625T034829Z">
        <seg>ProcessWindowFunction是一个功能十分强大的窗口函数，但你在用它的时候需要小心，因为它和增量聚合函数比起来通常需要在状态中保存更多数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ProcessWindowFunction[(String, Double, Double), MinMaxTemp, String, TimeWindow] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045138Z" creationid="xccui" creationdate="20190625T045138Z">
        <seg>ProcessWindowFunction[(String, Double, Double), MinMaxTemp, String, TimeWindow] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Streams in Parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T054741Z" creationid="esouser" creationdate="20190603T143915Z">
        <seg>并行流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Streams in Parallel | 21</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041420Z" creationid="xccui" creationdate="20190606T041420Z">
        <seg>并行数据流处理 | 21</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144150Z" creationid="esouser" creationdate="20190603T144150Z">
        <seg>处理时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Time Versus Event Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144227Z" creationid="esouser" creationdate="20190603T144227Z">
        <seg>处理时间 vs. 事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing streams in parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015430Z" creationid="xccui" creationdate="20190225T015047Z">
        <seg>并行数据流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020340Z" creationid="xccui" creationdate="20190225T020340Z">
        <seg>处理时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time is the time of the local clock on the machine where the operator pro&lt;t0/&gt;‐&lt;t1/&gt; cessing the stream is being executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T144610Z" creationid="xccui" creationdate="20190412T143933Z">
        <seg>处理时间是当前流处理算子所在机器上的本地时钟时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time is the time of the local clock on the machine where the operator pro‐ cessing the stream is being executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T023826Z" creationid="xccui" creationdate="20190606T023826Z">
        <seg>处理时间是当前流处理算子所在机器上的本地时钟时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time vs. event time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020419Z" creationid="xccui" creationdate="20190225T020419Z">
        <seg>处理时间 vs. 事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing- time windows trigger based on machine time and include whatever elements happen to have arrived at the operator until that point in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T065433Z" creationid="xccui" creationdate="20190619T065139Z">
        <seg>处理时间窗口基于机器时间触发，它涵盖了触发时间点之前所有到达算子的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time can be applicable for applications with very low latency requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T042414Z" creationid="xccui" creationdate="20190328T042346Z">
        <seg>处理时间能够用在具有极低延迟需求的应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time semantics can be used for applications with very low latency requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T054156Z" creationid="xccui" creationdate="20190605T054156Z">
        <seg>处理时间语义能够用在具有极低延迟需求的应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time timers fire immediately after the registering method returns.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T070456Z">
        <seg>处理时间的计时器会在注册方法返回后立即触发，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time windows introduce the lowest latency possi&lt;t6/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043855Z" creationid="xccui" creationdate="20190414T041008Z">
        <seg>它能够将延迟降至最低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing-time windows introduce the lowest latency possi‐ ble.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180444Z" creationid="xccui" creationdate="20190606T030730Z">
        <seg>处理时间窗口能够将延迟降至最低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ProcessingTime</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T064851Z" creationid="xccui" creationdate="20190619T064851Z">
        <seg>ProcessingTime</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provided Connectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030757Z" creationid="xccui" creationdate="20190225T025117Z">
        <seg>内置连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing exactly-once guarantees requires at-least-once guarantees, and thus a data replay mechanism is again necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034836Z" creationid="xccui" creationdate="20190606T034836Z">
        <seg>提供精确一次保障是以至少一次保障为前提，因此同样需要数据重放机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing exactly-once guarantees requires at-least-once guarantees, thus a data replay mechanism is again necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044408Z" creationid="xccui" creationdate="20190416T044337Z">
        <seg>提供精确一次保障是以至少一次保障为前提，因此同样需要数据重放机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210715Z" creationid="esouser" creationdate="20190603T210715Z">
        <seg>Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Punctuated assigner: AssignerWithPunctuatedWatermarks is another user- defined function that extracts a timestamp from each record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T035811Z" creationid="xccui" creationdate="20190607T035758Z">
        <seg>定点分配器：另一个支持从记录中提取时间戳的用户自定义函数叫做AssignerWithPunctuatedWatermarks。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Queryable State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T151202Z" creationid="xccui" creationdate="20190225T024940Z">
        <seg>可查询式状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Querying State from External Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025041Z" creationid="xccui" creationdate="20190225T025041Z">
        <seg>从外部系统查询状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Quite often the logic that needs to be applied on a window can be expressed as an incremental aggregation, but it also needs access to window metadata or state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T035301Z" creationid="xccui" creationdate="20190625T035301Z">
        <seg>其实很多时候需要应用于窗口的逻辑都可以表示为增量聚合，只不过还需要访问窗口元数据或状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Random</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043113Z" creationid="xccui" creationdate="20190614T064954Z">
        <seg>随机</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read an Input Stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145047Z" creationid="esouser" creationdate="20190603T145047Z">
        <seg>读取输入流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read an input stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022556Z" creationid="xccui" creationdate="20190225T022556Z">
        <seg>读取输入流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read one or more streams from data sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043536Z" creationid="xccui" creationdate="20190612T043536Z">
        <seg>从数据源中读取一条或多条流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading from and Writing to External Systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025053Z" creationid="xccui" creationdate="20190225T025053Z">
        <seg>读写外部系统</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-World Streaming Use-Cases and Deployments</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T212518Z" creationid="esouser" creationdate="20190603T212425Z">
        <seg>真实的流处理用例及部署方案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-time recommendations (e.g., for recommending products while customers browse a retailer’s website)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055440Z" creationid="esouser" creationdate="20190603T213611Z">
        <seg>实时推荐（例如：在客户浏览商家页面的同时进行产品推荐）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-time recommendations, e.g., for recommending products while customers browse on a retailer’s website,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T151655Z" creationid="xccui" creationdate="20190307T025808Z">
        <seg>实时推荐（例如：在客户浏览商家页面的同时进行产品推荐），</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-world sys&lt;t2/&gt;‐&lt;t3/&gt; tems, networks, and communication channels are far from perfect, thus streaming data can often be delayed or arrive out-of-order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T201230Z" creationid="xccui" creationdate="20190409T201230Z">
        <seg>真实世界的系统、网络、通信信道充斥缺陷，因此流数据通常都会有所延迟或以乱序到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Real-world systems, net‐ works, and communication channels are far from perfect, and streaming data can often be delayed or arrive out of order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064149Z" creationid="xccui" creationdate="20190606T014251Z">
        <seg>现实世界的系统、网络及通信信道往往充斥缺陷，因此流数据通常都会有所延迟或者以乱序到达。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rebalance and rescale transformations Broadcast</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045642Z" creationid="xccui" creationdate="20190616T045642Z">
        <seg>随机和重调转换 广播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receiving Notifications About Completed Checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155015Z" creationid="esouser" creationdate="20190603T151120Z">
        <seg>接收检查点完成通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receiving Notifications about Completed Checkpoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024630Z" creationid="xccui" creationdate="20190225T024630Z">
        <seg>接收Checkpoint完成通知</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records can be emitted together with an associated timestamp, and watermarks can be emitted at any point in time as special records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034317Z" creationid="xccui" creationdate="20190607T034317Z">
        <seg>每个发出的记录都可以附加一个时间戳，水位线可以作为一个车特殊记录在任何时间点发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records that are produced by a function are separately handed over to the next function with  a simple method call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T203657Z" creationid="xccui" creationdate="20190606T203657Z">
        <seg>函数生成的记录只需通过简单的方法调用就可以分别发往各自的下游函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records that are produced by a function are separately handed over to the next function with a simple method call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152951Z" creationid="esouser" creationdate="20190514T152951Z">
        <seg>函数生成的记录只需通过简单的方法调用就可以分别发往各自的下游函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records that arrive on partitions that forwarded a barrier already cannot be processed and are buf‐ fered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162650Z" creationid="xccui" creationdate="20190609T162559Z">
        <seg>对于已经提供分隔符的分区，它们新到来的记录会被缓冲起来，不能处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recovering an application from a checkpoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T035923Z" creationid="xccui" creationdate="20190609T035923Z">
        <seg>从检查点恢复应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recovery from a Consistent Checkpoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154850Z" creationid="xccui" creationdate="20190225T022157Z">
        <seg>从一致性检查点中恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redirecting Late Events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150750Z" creationid="xccui" creationdate="20190225T023448Z">
        <seg>重定向迟到事件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reduce</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061233Z" creationid="xccui" creationdate="20190614T061233Z">
        <seg>Reduce</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReduceFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211922Z" creationid="xccui" creationdate="20190623T211922Z">
        <seg>ReduceFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReduceFunction and AggregateFunction are incremental aggregation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211000Z" creationid="xccui" creationdate="20190623T211000Z">
        <seg>ReduceFunction和AggregateFunction就属于增量聚合函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReduceFunction and AggregateFunction are incrementally applied on events that are assigned to a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005741Z" creationid="xccui" creationdate="20190624T005741Z">
        <seg>ReduceFunction和AggregateFunction都是递增地应用于分配到窗口的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReduceFunction defines the reduce() method, which takes two input events and returns an event of the same type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061856Z" creationid="xccui" creationdate="20190614T061856Z">
        <seg>其中定义的reduce()方法每次接收两个输入事件，产生一个类型相同的输出事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReduceFunction or AggregateFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033307Z" creationid="xccui" creationdate="20190626T033307Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReducingState[T] offers the same methods as ListState[T] (except for addAll() and update()), but instead of appending values to a list, Reducing State.add(value: T) immediately aggregates value using a ReduceFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T060310Z" creationid="xccui" creationdate="20190630T060310Z">
        <seg>ReducingState[T]提供了和ListState[T]相同的方法（除了addAll()和update()），但它的State.add(value: T)方法会立即返回一个使用ReduceFunction聚合后的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refer to “Implementing Stateful Functions” on page 154, which discusses stateful functions in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T045701Z" creationid="xccui" creationdate="20190614T045650Z">
        <seg>有关状态化函数的详细信息请参阅第154页"实现状态化函数"一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of whether you keyBy() ConnectedStreams or you connect() two Keyed Streams, the connect() transformation will route all events from both streams with the same key to the same operator instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050651Z" creationid="xccui" creationdate="20190615T050651Z">
        <seg>无论你是对ConnectedStreams执行keyBy()还是对两个已经按键值分好区的数据流执行connect()，connect()转换都会将两个数据流中具有相同键值的事件发往同一个算子实例上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removing State from an Application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024915Z" creationid="xccui" creationdate="20190225T024915Z">
        <seg>从应用中删除状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removing a state from the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035722Z" creationid="xccui" creationdate="20190705T035722Z">
        <seg>从应用中移除某个状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Represents state as a list of entries as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184420Z" creationid="xccui" creationdate="20190607T184334Z">
        <seg>同样是将状态看做一个条目列表，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Represents state as a list of entries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184410Z" creationid="xccui" creationdate="20190607T184245Z">
        <seg>将状态表看做一个条目列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reprocessing all input to reproduce lost state in the case of failures would be both very expensive and time-consuming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T040947Z" creationid="xccui" creationdate="20190415T040923Z">
        <seg>通过重新处理所有输入来重建故障时丢失的状态，不仅代价高，而且非常耗时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reprocessing all input to reproduce lost state in the case of fail‐ ures would be both very expensive and time-consuming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185116Z" creationid="xccui" creationdate="20190606T033139Z">
        <seg>通过重新处理所有输入来重建故障期间丢失的状态，不仅代价高，而且还很耗时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required Software</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022254Z" creationid="xccui" creationdate="20190225T022254Z">
        <seg>所需软件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requirements also differ when it comes to evaluating performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050222Z" creationid="xccui" creationdate="20190401T150306Z">
        <seg>而这些需求差异还体现在性能评测方面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rescale</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043443Z" creationid="xccui" creationdate="20190616T043443Z">
        <seg>重调</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reset the states of all stateful tasks to the latest checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040226Z" creationid="xccui" creationdate="20190609T040149Z">
        <seg>利用最新的检查点重置任务状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resettable Source Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025236Z" creationid="xccui" creationdate="20190225T025236Z">
        <seg>可重置的源函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restart strategies are discussed in more detail in Chapter 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T150158Z" creationid="xccui" creationdate="20190606T150158Z">
        <seg>重启策略会在第10章详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restart strategies will be discussed in more detail in Chapter 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051610Z" creationid="xccui" creationdate="20190502T051440Z">
        <seg>重启策略会在第10章详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restart the whole application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040129Z" creationid="xccui" creationdate="20190609T040129Z">
        <seg>重启整个应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restoring the state of an application is described in a later section of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205243Z" creationid="xccui" creationdate="20190428T205226Z">
        <seg>恢复应用状态将会在本章的稍后一节进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restoring the state of an application is described in “Recovery from a Con‐ sistent Checkpoint” on page 60.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072238Z" creationid="xccui" creationdate="20190606T145348Z">
        <seg>而恢复应用状态则会在第60页"从一致性检查点恢复"一节进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Result Guarantees</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144259Z" creationid="esouser" creationdate="20190603T144259Z">
        <seg>结果保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Result guarantees</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021628Z" creationid="xccui" creationdate="20190225T021628Z">
        <seg>结果保障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resume the ingestion of all streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224318Z" creationid="xccui" creationdate="20190608T224238Z">
        <seg>恢复所有数据流的接收。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resume the processing of all tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T040646Z" creationid="xccui" creationdate="20190609T040646Z">
        <seg>恢复所有任务的处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revision History for the First Edition</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210732Z" creationid="esouser" creationdate="20190603T210732Z">
        <seg>Revision History for the First Edition</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revisiting the coffee shop example, if the shop is open from 7 a.m. to 7 p.m. and it serves 600 customers in one day, then its average throughput would be 50 customers per hour.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234402Z" creationid="xccui" creationdate="20190605T234402Z">
        <seg>回到刚刚咖啡店的例子，如果它的营业时间是早7点到晚7点，并且一天服务了600名顾客，那么它的平均吞吐是每小时50人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revisiting the coffee shop example, if the shop is open from 7am to 7pm and it serves 600 customers in one day, then its average throughput would be 50 customers per hour.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195720Z" creationid="xccui" creationdate="20190401T195656Z">
        <seg>回到刚刚咖啡店的例子，如果它的营业时间是早7点到晚7点，并且一天服务了600名顾客，那么它的平均吞吐是每小时50人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rich Functions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022929Z" creationid="xccui" creationdate="20190225T022929Z">
        <seg>富函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rich functions can be parameterized just like regular function classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060523Z" creationid="xccui" creationdate="20190618T060523Z">
        <seg>富函数可以像普通函数类一样接收参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RocksDB is an embedded key-value store that persists data to the local disk.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T023628Z" creationid="xccui" creationdate="20190704T023628Z">
        <seg>RocksDB是一个嵌入式键值存储（key-value store），它可以将数据保存到本地磁盘上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RocksDB state backend with incremental checkpoints and storing the timers on the heap (default setting), they are checkpointed synchronously.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T065821Z">
        <seg>如果你在使用开启了增量检查点模式RocksDB状态后端，且将计时器存储在堆内（默认设置），计时器写入检查点的过程就会是同步的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RocksDBStateBackend stores all state into local RocksDB instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T023459Z" creationid="xccui" creationdate="20190704T023459Z">
        <seg>RocksDBStateBackend会把全部状态存到本地RocksDB实例中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rolling aggregation transformations are applied on a KeyedStream and produce a DataStream of aggregates, such as sum, minimum, and maximum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052018Z" creationid="xccui" creationdate="20190614T052018Z">
        <seg>滚动聚合转换作用于KeyedStream上，生成包含聚合结果（例如求和、最小值、最大值等）的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rolling aggregations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T160158Z" creationid="xccui" creationdate="20190405T160158Z">
        <seg>滚动聚合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Round-Robin</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031352Z" creationid="xccui" creationdate="20190615T071053Z">
        <seg>轮流</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run Flink Applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144911Z" creationid="esouser" creationdate="20190603T144911Z">
        <seg>在IDE中运行Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run Flink applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022339Z" creationid="xccui" creationdate="20190225T022339Z">
        <seg>在IDE中运行Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run and Debug Flink Applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144840Z" creationid="esouser" creationdate="20190603T144840Z">
        <seg>在IDE中运行和调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run and Debug Flink Applications in an IDE | 73</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012826Z" creationid="xccui" creationdate="20190612T012826Z">
        <seg>在IDE中执行和调试Flink程序 | 73</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run and debug Flink applications in an IDE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022308Z" creationid="xccui" creationdate="20190225T022308Z">
        <seg>在IDE中执行和调试Flink程序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the example on your local cluster by specifying the applications entry class and the JAR file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T035936Z" creationid="xccui" creationdate="20190329T035919Z">
        <seg>通过指定应用的入口类和JAR文件，在你的本地集群上运行示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the example on your local cluster by specifying the application’s entry class and JAR file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201345Z" creationid="xccui" creationdate="20190605T123600Z">
        <seg>通过指定应用的入口类和JAR文件，在你本地集群上运行示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running Your First Flink Application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T211803Z" creationid="esouser" creationdate="20190603T143056Z">
        <seg>运行首个Flink应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running and Managing Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025908Z" creationid="xccui" creationdate="20190225T025908Z">
        <seg>运行并管理流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144644Z" creationid="xccui" creationdate="20190418T035333Z">
        <seg>保存点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Save‐ point state can only be restored to an operator of a started application if their identifi‐ ers are identical.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T022647Z" creationid="xccui" creationdate="20190703T022647Z">
        <seg>只有当目标应用的算子标识和保存点中的算子标识相同时，状态才能恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scala DataStream API shortcut for a FlatMap with a keyed ValueState</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023016Z" creationid="xccui" creationdate="20190701T023016Z">
        <seg>利用Scala DataStream API简写只有一个键值分区ValueState的FlatMap。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scala case classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065042Z" creationid="xccui" creationdate="20190616T065042Z">
        <seg>Scala样例类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalable stream processing technology is rapidly maturing and evolving due to the efforts of many open source communities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160226Z" creationid="xccui" creationdate="20190319T053253Z">
        <seg>得益于众多开源社区的努力，可伸缩的流处理技术能够迅速发展和成熟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling Stateful Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T032530Z" creationid="xccui" creationdate="20190225T022106Z">
        <seg>状态化算子扩缩容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with keyed state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190608T060217Z">
        <seg>算子扩缩容时键值分区状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with operator broadcast state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T062304Z" creationid="xccui" creationdate="20190607T060257Z">
        <seg>算子扩缩容时算子广播状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with operator list state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061028Z" creationid="xccui" creationdate="20190608T061028Z">
        <seg>算子扩缩容时算子列表状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling an operator with operator union list state out and in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061516Z" creationid="xccui" creationdate="20190608T061516Z">
        <seg>算子扩缩容时算子联合列表状态的调整</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling and fault tolerance are handled by the stream processor, and by leveraging an event log as the input source the complete input of an application is reliably stored and can be deterministi‐ cally replayed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T034218Z" creationid="xccui" creationdate="20190604T043856Z">
        <seg>伸缩和容错交由流处理引擎完成；以事件日志作为应用的输入，不但完整可靠，而且还支持精准的数据重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scaling and fault-tolerance do not need special consideration because these aspects are handled by the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014605Z" creationid="xccui" creationdate="20190312T212356Z">
        <seg>无须考虑伸缩性和容错性。这些都交给流处理引擎处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scheduling tasks as slices to slots has the advantage that many tasks are co-located on the TaskManager which means that they can efficiently exchange data within the the same process and without accessing the network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062846Z" creationid="xccui" creationdate="20190424T061942Z">
        <seg>将任务以切片的形式调度至处理槽中有一个好处：TaskManager中的多个任务可以在同一进程内高效地执行数据交换而无须访问网络。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scheduling tasks as slices to slots has the advantage that many tasks are colocated on the TaskManager, which means they can efficiently exchange data within the the same process and without accessing the network.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144717Z" creationid="xccui" creationdate="20190606T144717Z">
        <seg>将任务以切片的形式调度至处理槽中有一个好处：TaskManager中的多个任务可以在同一进程内高效地执行数据交换而无须访问网络。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing a running job</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201519Z" creationid="xccui" creationdate="20190605T123752Z">
        <seg>展示运行作业的Apache Flink Web UI截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing a running job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041702Z" creationid="xccui" creationdate="20190329T041546Z">
        <seg>展示运行作业的Apache Flink Web仪表盘截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing the overview</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201430Z" creationid="xccui" creationdate="20190605T123350Z">
        <seg>Apache Flink Web UI概览页面截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Screenshot of Apache Flink’s web dashboard showing the overview.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041649Z" creationid="xccui" creationdate="20190329T035553Z">
        <seg>展示概览的Apache Flink Web仪表盘截图</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Search for the AverageSensorReadings class and open it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042128Z" creationid="xccui" creationdate="20190611T042128Z">
        <seg>找到AverageSensorReadings类，打开它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sebastopol</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210641Z" creationid="esouser" creationdate="20190603T210641Z">
        <seg>Sebastopol</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, the latest results computed by the stream processor are not accurate but only approximated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T030945Z" creationid="xccui" creationdate="20190327T030820Z">
        <seg>其次，流处理引擎计算的最新结果仅仅是不精确的近似结果；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, the results compu‐ ted by the stream processor are only approximate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053042Z" creationid="xccui" creationdate="20190605T052957Z">
        <seg>其次，流处理引擎计算的结果只是近似的；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, you can have tasks from different operators performing computations on the same or different data in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034118Z" creationid="xccui" creationdate="20190401T031957Z">
        <seg>再者，你可以让不同算子的任务（基于相同或不同的数据）并行计算，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025635Z" creationid="xccui" creationdate="20190225T025635Z">
        <seg>安全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Chapter 3 for details on how operator list union state is distributed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071938Z" creationid="xccui" creationdate="20190702T071938Z">
        <seg>有关算子列表状态在实例上进行分配的详细信息请参阅第3章。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Chapter 8 for details on keyed state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190615T052230Z">
        <seg>有关键值分区状态的详细信息请参阅第8章。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See http://oreilly.com/catalog/errata.csp?isbn=9781491974292 for release details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210735Z" creationid="esouser" creationdate="20190603T210735Z">
        <seg>See http://oreilly.com/catalog/errata.csp?isbn=9781491974292 for release details.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Select the Maven project to import</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041645Z" creationid="xccui" creationdate="20190611T041645Z">
        <seg>选择要导入的Maven项目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Selling or distributing a CD-ROM of examples from O’Reilly books does require permission.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210819Z" creationid="esouser" creationdate="20190603T210819Z">
        <seg>Selling or distributing a CD-ROM of examples from O’Reilly books does require permission.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sending individual records over a network connection is inefficient and causes signif&lt;t0/&gt;‐&lt;t1/&gt; icant overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190513T210046Z" creationid="esouser" creationdate="20190513T210046Z">
        <seg>通过网络连接逐条发送记录不但低效，还会导致很多额外开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sending individual records over a network connection is inefficient and causes signif‐ icant overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T202509Z" creationid="xccui" creationdate="20190606T202509Z">
        <seg>通过网络连接逐条发送记录不但低效，还会导致很多额外开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading contains the sensor ID, a timestamp denoting when the measurement was taken, and the measured temperature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052008Z" creationid="xccui" creationdate="20190612T052008Z">
        <seg>每一条SensorReading数据都包括传感器ID，表示测试时间的时间戳以及测量的温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(r.id, r.timestamp, celsius)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042303Z" creationid="xccui" creationdate="20190612T042303Z">
        <seg>SensorReading(r.id, r.timestamp, celsius)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041720Z" creationid="xccui" creationdate="20190329T041720Z">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259) SensorReading(sensor_6,1547718199000,15.402984393403084) SensorReading(sensor_7,1547718199000,6.720945201171228) SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123937Z" creationid="xccui" creationdate="20190605T123937Z">
        <seg>SensorReading(sensor_1,1547718199000,35.80018327300259) SensorReading(sensor_6,1547718199000,15.402984393403084) SensorReading(sensor_7,1547718199000,6.720945201171228) SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041735Z" creationid="xccui" creationdate="20190329T041735Z">
        <seg>SensorReading(sensor_10,1547718199000,38.101067604893444)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_6,1547718199000,15.402984393403084)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041723Z" creationid="xccui" creationdate="20190329T041723Z">
        <seg>SensorReading(sensor_6,1547718199000,15.402984393403084)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading(sensor_7,1547718199000,6.720945201171228)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T041731Z" creationid="xccui" creationdate="20190329T041731Z">
        <seg>SensorReading(sensor_7,1547718199000,6.720945201171228)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SensorReading, (String, Long, Int, String), String, TimeWindow] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T033945Z" creationid="xccui" creationdate="20190629T033945Z">
        <seg>SensorReading, (String, Long, Int, String), String, TimeWindow] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session &lt;t0/&gt;windows are useful in a common real-world scenario where neither&lt;t1/&gt; &lt;t2/&gt;tumbling nor sliding windows can be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024942Z" creationid="xccui" creationdate="20190407T024730Z">
        <seg>会话窗口在一类常见的真实场景下非常有用，该场景中既不适合用滚动窗口也不适合用滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013824Z" creationid="xccui" creationdate="20190606T013824Z">
        <seg>会话窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193607Z" creationid="xccui" creationdate="20190409T193607Z">
        <seg>会话窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060219Z" creationid="xccui" creationdate="20190623T060219Z">
        <seg>会话窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows are useful in common real-world scenarios where neither tum‐ bling nor sliding windows can be applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063724Z" creationid="xccui" creationdate="20190606T013410Z">
        <seg>会话窗口（session window）在一些常见的真实场景中非常有用，这些场景既不适合用滚动窗口也不适合用滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows group events in session based on a &lt;t11/&gt;session gap&lt;t12/&gt; value that defines the time of inactivity to consider a session closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T193417Z" creationid="xccui" creationdate="20190409T192834Z">
        <seg>会话窗口根据会话间隔（session gap）将事件分为不同的会话，该间隔值定义了会话在关闭前的非活动时间长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session windows group events in sessions based on a session gap value that defines the time of inactivity to consider a session closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013807Z" creationid="xccui" creationdate="20190606T013807Z">
        <seg>会话窗口根据会话间隔（session gap）将事件分为不同的会话，该间隔值定义了会话在关闭前的非活动时间长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sessions are com‐ prised of a series of events happening in adjacent times followed by a period of inactivity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013650Z" creationid="xccui" creationdate="20190606T013650Z">
        <seg>会话由发生在相邻时间内的一系列事件外加一段非活动时间组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sessions com&lt;t7/&gt;‐&lt;t8/&gt; prise of a series of events happening in adjacent times followed by a period of inactivity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T025627Z" creationid="xccui" creationdate="20190407T025430Z">
        <seg>会话由发生在相邻时间内的一系列事件外加一段非活动时间组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set Up the Execution Environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044650Z" creationid="esouser" creationdate="20190603T145031Z">
        <seg>设置执行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set up the Execution Environment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022537Z" creationid="xccui" creationdate="20190225T022537Z">
        <seg>设置运行环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set up the execution environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044657Z" creationid="xccui" creationdate="20190612T043506Z">
        <seg>设置执行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Flink Up for Streaming Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025346Z" creationid="xccui" creationdate="20190225T025346Z">
        <seg>配置Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up Flink for Streaming Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152129Z" creationid="esouser" creationdate="20190603T152129Z">
        <seg>配置Flink运行流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up a Development Environment for</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T142736Z" creationid="xccui" creationdate="20190606T042846Z">
        <seg>设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up a Development Environment for Apache Flink | 71</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012812Z" creationid="xccui" creationdate="20190612T012812Z">
        <seg>设置Apache Flink开发环境 | 71</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up a Development Environment for Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T142736Z" creationid="esouser" creationdate="20190603T144822Z">
        <seg>设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting a unique identifier for an operator</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024124Z" creationid="xccui" creationdate="20190703T024124Z">
        <seg>为算子设置唯一标识</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the Parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050657Z" creationid="esouser" creationdate="20190603T145135Z">
        <seg>设置并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the maximum parallelism of operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025050Z" creationid="xccui" creationdate="20190703T025015Z">
        <seg>设置算子的最大并行度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022755Z" creationid="xccui" creationdate="20190225T022755Z">
        <seg>设置并发度</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the time characteristic to EventTime enables timestamp and watermark handling, and as a result, event-time operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T072909Z" creationid="xccui" creationdate="20190619T072909Z">
        <seg>将时间特性设置为EventTime后就可以对时间戳和水印进行处理，从而实现事件时间操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the time characteristic to event time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T072602Z" creationid="xccui" creationdate="20190619T072515Z">
        <seg>将时间特性设为事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting up a development environment for Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022243Z" creationid="xccui" creationdate="20190225T022243Z">
        <seg>设置Apache Flink开发环境</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shows text that should be replaced with user-supplied values or by values deter‐ mined by context.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210808Z" creationid="esouser" creationdate="20190603T210808Z">
        <seg>Shows text that should be replaced with user-supplied values or by values deter‐ mined by context.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Side outputs are a feature of process functions to emit multiple streams from a function with possibly different types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T014947Z" creationid="xccui" creationdate="20190622T014308Z">
        <seg>而处理函数提供的副输出功能允许从同一函数发出多条数据流，且它们的类型可以不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to ReduceFunction, AggregateFunction is also incrementally applied to the elements that are applied to a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002618Z" creationid="xccui" creationdate="20190624T002618Z">
        <seg>和ReduceFunction类似，AggregateFunction也会以递增方式应用于窗口内的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to a CoFlatMapFunction, a CoProcessFunction offers a transformation method for each input, processElement1() and processElement2().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T030632Z" creationid="xccui" creationdate="20190622T030504Z">
        <seg>和ComFlatMapFunction类似，CoProcessFunction也提供了一对作用于每个输入的转换方法——processFunction1()和processFunction2()。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the ProcessFunction, both methods are called with a Context object that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T030809Z" creationid="xccui" creationdate="20190622T030518Z">
        <seg>它们和ProcessFunction中的方法一样，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to watermarks, checkpoint barriers are broadcasted to all connected parallel tasks to ensure that each task receives a barrier from each of its input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T160224Z" creationid="xccui" creationdate="20190609T160142Z">
        <seg>和水位线类似，检查点分隔符总是以广播形式发送，从而可以确保每个任务能从它们的每个输入都收到一个分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to watermarks, checkpoint barriers are injected by source operators into the regular stream of records and cannot overtake or be passed by other records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060724Z" creationid="xccui" creationdate="20190609T060328Z">
        <seg>和水位线类似，这些检查点分隔符会通过数据源算子注入到普通的记录流中，它们在流中的位置无法提前或延后。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, consider an operator that raises an alert when it detects a “high temperature” event followed by a “smoke” event within 10 minutes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181858Z" creationid="xccui" creationdate="20190414T052537Z">
        <seg>类似地，假设还有一个算子，会在每次检测到"高温"事件且在随后10分钟内出现"烟雾"事件时报警。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if a system’s capacity is small, events will be buffered and have to wait before they get processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T203907Z" creationid="xccui" creationdate="20190402T203453Z">
        <seg>同样，如果系统性能不足，事件很容易堆积缓冲，必须等待一段时间才能处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple value conversions, splitting of records, or filtering of records are examples of common basic functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T025233Z" creationid="xccui" creationdate="20190613T025145Z">
        <seg>常见的基本函数示例有：简单的值转换，记录拆分或过滤等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since  the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054220Z" creationid="xccui" creationdate="20190702T054220Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is a distributed system, the JobManager and TaskManagers typically run as separate JVM processes on different machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T051402Z" creationid="xccui" creationdate="20190611T051402Z">
        <seg>由于Flink是一个分布式系统，JobManager和TaskManager通常会在不同机器上作为独立的JVM进程运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is a distributed system, the local state needs to be protected against failures to avoid data loss in case of application or machine failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T073210Z" creationid="esouser" creationdate="20190603T210018Z">
        <seg>由于采用的是分布式架构，Flink需要对本地状态予以保护，以避免因应用或机器故障导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is a distributed system, the local state needs to be protected against failures to avoid data loss in case of application or machine failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T032404Z" creationid="xccui" creationdate="20190305T032238Z">
        <seg>而由于是分布式的，Flink需要保护本地状态，以防因应用或机器故障导致数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is implemented in Java and Scala, all components run on Java Virtual Machines (JVMs).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141455Z" creationid="xccui" creationdate="20190606T141316Z">
        <seg>由于Flink本身是用Java和Scala实现的，因此所有组件都基于Java虚拟机（JVM）运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Flink is implemented in Java and Scala, all components run on a Java Virtual Machine (JVM).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033634Z" creationid="xccui" creationdate="20190418T033634Z">
        <seg>由于Flink本身是用Java和Scala实现的，因此所有组件都运行在Java虚拟机（JVM）之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Kryo is a general-purpose serializer it is usually not very efficient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065540Z" creationid="xccui" creationdate="20190616T065540Z">
        <seg>由于Kryo是一个通用序列化器，因此通常效率不高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since StateBackend is a public interface, it is also possible to implement a custom state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025522Z" creationid="xccui" creationdate="20190704T025522Z">
        <seg>由于StateBackend接口是公开的，所以你也可以实现自定义的状态后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since check‐ points are synchronized with function invocations, multiple state updates do not pro‐ vide any benefits but can cause additional serialization overhead when updating state several times in a single function call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T035120Z" creationid="xccui" creationdate="20190704T035120Z">
        <seg>由于检查点需要和函数调用同步，所以在单个函数内调用多次更新状态没有任何好处，反而会带来额外的序列化开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since each parallel instance of the function must hold all rules in its operator state, the rules stream needs to be broadcasted to ensure each instance of the function receives all rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T203601Z" creationid="xccui" creationdate="20190701T203601Z">
        <seg>由于函数的所有并行实例都需要在算子状态中保存全部规则，所以规则流需要以广播形式发送，以便每个实例都能收到全部规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since elements are typically ingested in parallel, any operation that causes Flink to redistribute elements across parallel</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T031359Z" creationid="xccui" creationdate="20190620T031159Z">
        <seg>由于元素的读取过程通常都是并行的，一切引起Flink跨并行数据流分区进行重新分发的操作（例如改变并行度，keyBy()或显式重新分发）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it has to iterate over all elements, it can only be used if no</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014717Z" creationid="xccui" creationdate="20190626T014717Z">
        <seg>由于需要遍历所有元素，移除器只有在未指定增量聚合函数的时候才能使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since its beginning, Flink has a very active and continuously growing community of users and contributors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T220449Z" creationid="xccui" creationdate="20190225T220008Z">
        <seg>Flink自创建伊始就拥有一个活跃、不断发展的用户及贡献者群体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since its beginning, Flink has had a very active and continuously grow‐ ing community of users and contributors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T162841Z" creationid="esouser" creationdate="20190603T162841Z">
        <seg>Flink自创建伊始就拥有一个活跃、不断发展的用户及贡献者群体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since its memory is volatile, the state is lost in case of a JobManager failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T021715Z" creationid="xccui" creationdate="20190704T020651Z">
        <seg>因为内存具有易失性，所以一旦JobManager出现故障，状态就会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since multiple applications might work on the same data representation or share the same infrastructure, changing the schema of a table or scaling a database system requires careful planning and a lot of effort.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200046Z" creationid="esouser" creationdate="20190603T200017Z">
        <seg>一旦多个应用基于相同的数据表示或共享架构，那么更改表模式或对数据库系统扩容必将劳心费力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since our KeyedProcessFunction always updates the registered timer by deleting the current timer and registering a new one, only a single timer is registered per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T213431Z" creationid="xccui" creationdate="20190704T213431Z">
        <seg>由于KeyedProcessFunction总是在注册新计时器之前将已有的计时器删除，所以每个键值在同一时间最多只会有一个注册的计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since savepoints are such a powerful feature, many users periodically create save‐ points to be able to go back in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213645Z" creationid="xccui" creationdate="20190609T213645Z">
        <seg>保存点的功能如此强大，很多用户都会周期性地创建保存点，以便能即时"回到过去"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since state can become quite large and checkpointing requires writing the data over the network to a remote storage system, taking a checkpoint can easily take several seconds to minutes—much too long for latency-sensitive applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202510Z" creationid="xccui" creationdate="20190609T200126Z">
        <seg>由于状态可能会很大，而且生成检查点需要把这些数据通过网络写入远程存储系统，该过程可能持续数秒，甚至数分钟，这对于一些延迟敏感的应用而言时间过久。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since state manage‐ ment is always custom and manually done in process functions, Flink does not pro‐ vide a built-in API to support late data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041037Z" creationid="xccui" creationdate="20190629T035942Z">
        <seg>但由于处理函数内部的状态管理都是通过手工自定义来完成的，所以Flink没有在其中内置和迟到数据处理相关的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming appli&lt;t2/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150756Z" creationid="xccui" creationdate="20190401T150551Z">
        <seg>但由于流式应用会一直执行且输入可能是无限的，因此在数据流处理中没有总执行时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming applications are often required to run 24/7 with minimum downtime, many stream processors added features such as highly-available setups, tight integration with resource managers, such as YARN or Mesos, and the ability to dynamically scale streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T140537Z" creationid="xccui" creationdate="20190327T140011Z">
        <seg>由于流式应用经常需要近7*24小时不间断运行，很多流处理引擎会添加像高可用设置、与资源管理器（YARN、Mesos等）紧密集成、动态扩展流式应用等特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming appli‐ cations run continuously and the input is potentially unbounded, there is no notion of total execution time in data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050547Z" creationid="xccui" creationdate="20190605T233740Z">
        <seg>但由于流式应用会持续执行且输入可能是无限的，所以在数据流处理中没有总执行时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since streaming operators process potentially unbounded data, caution should be taken to not allow internal state to grow indefinitely.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182956Z" creationid="xccui" creationdate="20190414T054737Z">
        <seg>由于流式算子处理的都是潜在无穷无尽的数据，因此必须小心避免内部状态无限增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since tasks maintain their state locally, Flink has to ensure that this state is not lost and remains consistent in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T152710Z" creationid="xccui" creationdate="20190608T152636Z">
        <seg>由于每个任务会把状态维护在本地，Flink要保证发生故障时状态不丢不错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the aggregation is performed by the ReduceFunction, the ProcessWindowFunction only needs to append the window end timestamp to the incrementally computed result as shown in Example 6-14.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045016Z" creationid="xccui" creationdate="20190625T045016Z">
        <seg>由于聚合逻辑是由ReduceFunction执行的，ProcessWindowFunction只需要像示例6-14那样，将窗口的结束时间戳加到递增计算结果后面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the events of both streams are mapped into the same windows, triggers and evictors behave exactly as in regular window operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T053412Z" creationid="xccui" creationdate="20190628T053412Z">
        <seg>由于两条流中的事件会被映射到相同的窗口中，因此该过程中的触发器和移除器与常规窗口算子中的完全相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the handling of state directly affects the semantics of an operator, Flink cannot automati‐ cally clean up state and free storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T135936Z" creationid="xccui" creationdate="20190704T135936Z">
        <seg>由于状态的处理会直接影响算子语义，所以Flink无法通过自动清理状态来释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the length of a session is not defined beforehand but depends on the actual data, tumbling and sliding win&lt;t9/&gt;‐&lt;t10/&gt; dows cannot be applied in this scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T192212Z" creationid="xccui" creationdate="20190407T030004Z">
        <seg>由于会话长度并非预先定义好，而是和实际数据有关，因此无论是滚动还是滑动窗口都无法用于该场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the length of a session is not defined beforehand but depends on the actual data, tumbling and sliding win‐ dows cannot be applied in this scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013707Z" creationid="xccui" creationdate="20190606T013707Z">
        <seg>由于会话长度并非预先定义好，而是和实际数据有关，因此无论是滚动还是滑动窗口都无法用于该场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the logic for splitting and merging</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T060037Z" creationid="xccui" creationdate="20190701T060037Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the maximum operator parallelism is four, the application requires at least four available processing slots to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043551Z" creationid="xccui" creationdate="20190423T043528Z">
        <seg>由于算子最大并行度是4，因此应用若要执行则至少需要4个处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the pur‐ pose of checkpoints is to ensure an application can be restarted in case of a failure, they are deleted when an application is explicitly canceled.4 However, consistent snap‐ shots of the state of an application can be used for many more things than just failure recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210342Z" creationid="xccui" creationdate="20190609T205625Z">
        <seg>检查点的目的是保证应用可以在出现故障的时候顺利重启，因此当应用被显式取消后，检查点也会随之删除4。但应用状态的一致性快照除了故障恢复外，还有很多其他用途。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the start and the end of a session window depend on the received elements, a window assigner cannot immediately assign all the elements to the correct window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061801Z" creationid="xccui" creationdate="20190623T061801Z">
        <seg>由于会话窗口的起始和结束都取决于接收的元素，因此窗口分配器无法实时将所有元素分配到正确的窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since they depend on the ingestion order, count-based windows are not deter‐ ministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T040009Z" creationid="xccui" creationdate="20190623T035800Z">
        <seg>由于要依赖元素的到达顺序，基于数量的窗口具有不确定性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since this state is never cleaned up, you should only apply a rolling aggregations operator on a stream with a bounded key domain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061231Z" creationid="xccui" creationdate="20190614T061231Z">
        <seg>由于这些状态不会被自动清理，所以只能在键值域有限的流上使用滚动聚合算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since this state is never cleaned up, you should only apply a rolling reduce operator on a stream with a bounded key domain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062950Z" creationid="xccui" creationdate="20190614T062950Z">
        <seg>由于这些状态不会被自动清理，所以只能在键值域有限的流上使用滚动reduce算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since we are using a simple nonmergable ValueState, the trigger is not mer‐ gable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201301Z" creationid="xccui" creationdate="20190626T201301Z">
        <seg>由于我们使用了简单的不可合并状态ValueState，所以无法对触发器进行合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you are running a streaming application, it will continue to run until you cancel it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045509Z" creationid="xccui" creationdate="20190329T045426Z">
        <seg>由于运行的是流式应用，因此它会一直运行下去，直到你手动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you are running a streaming application, the application will continue to run until you cancel it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124357Z" creationid="xccui" creationdate="20190605T124127Z">
        <seg>由于应用是流式的，它会一直运行下去，直到你手动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since you do not take into consideration late events and out-of-order events, a window simply needs to buffer up events and immediately trigger computation once the specified time length is reached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180546Z" creationid="xccui" creationdate="20190414T041209Z">
        <seg>由于无需考虑迟到或乱序的事件，窗口只需简单地缓冲事件，然后在达到特定时间后立即触发窗口计算即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since, multiple applications might work on the same data representation or share the same infrastructure, changing the schema of a table or scaling a database system requires careful planning and a lot of effort.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T185223Z" creationid="xccui" creationdate="20190226T164028Z">
        <seg>一旦多个应用基于相同的数据表示或共享架构，那么更改表模式或对数据库系统扩容必将费心费力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sinks acknowledge the reception of a checkpoint barrier to the JobManager and a checkpoint is complete when all tasks have acknowledged the successful check‐ pointing of their state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195511Z" creationid="xccui" creationdate="20190609T194625Z">
        <seg>数据汇任务向JobManager确认收到检查点分隔符，在所有任务成功将自身状态存入检查点后整个应用的检查点才算完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding &lt;t0/&gt;windows assign events into overlapping buckets of fixed size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024655Z" creationid="xccui" creationdate="20190407T023648Z">
        <seg>滑动窗口（sliding window）将事件分配到大小固定且相互重叠的桶中，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding count-based window with a length of 4 events and a slide of 3 events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024429Z" creationid="xccui" creationdate="20190407T024415Z">
        <seg>长度为4个事件滑动间隔为3个事件的基于数量的滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding count-based window with a length of four events and a slide of three events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013350Z" creationid="xccui" creationdate="20190606T013314Z">
        <seg>长度为4个事件滑动间隔为3个事件的基于数量的滑动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054549Z" creationid="xccui" creationdate="20190623T054549Z">
        <seg>滑动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sliding windows assign events into overlapping buckets of fixed size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063526Z" creationid="xccui" creationdate="20190606T013132Z">
        <seg>滑动窗口（sliding window）将事件分配到大小固定且（允许）相互重叠的桶中，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far we have discussed how to generate watermarks using a TimestampAssigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T055235Z" creationid="xccui" creationdate="20190620T055210Z">
        <seg>目前为止，我们已经讨论过如何使用TimestampAssigner生成水位线，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far we have explained what timestamps and watermarks are and how they are internally handled by Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034622Z" creationid="xccui" creationdate="20190607T033537Z">
        <seg>至今为止，我们已经解释了时间戳和水位线的含义以及它们在Flink内部的处理逻辑，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, you have seen how stream processing addresses limitations of traditional batch processing and how it enables new applications and architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T052148Z" creationid="xccui" creationdate="20190329T050348Z">
        <seg>至此，你已经了解过流式应用如何突破传统批处理的局限以及它如何支持新的应用和架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, you have seen how stream processing addresses some of the limitations of tra‐ ditional batch processing and how it enables new applications and architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T195929Z" creationid="xccui" creationdate="20190605T224637Z">
        <seg>至此，你不但已经见过流式应用是如何突破传统批处理的一些局限以及它如何支持新的应用和架构，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, can you get both low latency and high throughput or is this a hopeless endeavor?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054529Z" creationid="xccui" creationdate="20190605T235232Z">
        <seg>既然这样，可以通过某种方式同时获得低延迟和高吞吐吗？还是说这根本不切实际？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some applications also leverage Flink’s domain-specific libraries, such as the Table API, SQL, or the CEP library.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035212Z" creationid="xccui" creationdate="20190619T035212Z">
        <seg>还有一些应用需要用到Flink一些特定领域的库（例如：Table API、SQL或CEP库）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the first research proto‐ types and commercial products date back to the late 1990s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T160105Z" creationid="xccui" creationdate="20190605T045832Z">
        <seg>一些最初的研究原型和商业产品甚至可以追溯到上世纪90年代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the transformations you saw in the previous section require a key specifica‐ tion or field reference on the input stream type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062440Z" creationid="xccui" creationdate="20190617T062440Z">
        <seg>你在上一节中看到的部分转换需要基于输入流的类型指定键值或引用字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some special types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065127Z" creationid="xccui" creationdate="20190616T065127Z">
        <seg>一些特殊类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some transformations can produce a new DataStream, pos‐ sibly of a different type, while other transformations do not modify the records of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052746Z" creationid="xccui" creationdate="20190612T052453Z">
        <seg>有些会生成一个新的DataStream（类型可能不同）；而另外的一些不会修改DataStream中的记录，仅会通过分区或分组的方式将其重新组织。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes it is necessary or desirable to control the partitioning strategies at the application level or define custom partitioners.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T065406Z" creationid="xccui" creationdate="20190615T065406Z">
        <seg>某些时候，我们有必要或希望能够在应用级别控制这些分区策略或者自定义分区器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes the input stream contains special tuples or markers that indicate the stream’s progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T053858Z" creationid="xccui" creationdate="20190620T053858Z">
        <seg>有时候输入流中会包含一些用于指示系统进度的特殊元组或标记。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, though, the necessary information cannot be extracted (e.g., because of Java erasing generic type information).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061027Z" creationid="xccui" creationdate="20190617T061027Z">
        <seg>但有时候一些必要的信息可能无法提取（例如：由于Java会擦出泛型信息）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Source Functions, Timestamps, and Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152108Z" creationid="xccui" creationdate="20190225T025249Z">
        <seg>源函数、时间戳及水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Source functions are discussed in more detail in “Implementing a Custom Source Function” on page 202.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034915Z" creationid="xccui" creationdate="20190607T034915Z">
        <seg>我们会在第202页"实现自定义源函数"一节详细讨论源函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sources checkpoint their state and emit a checkpoint barrier</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155352Z" creationid="xccui" creationdate="20190609T155352Z">
        <seg>数据源为状态生成检查点并发出检查点分隔符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special thanks go to our fellow Flink committers: Alan Gates, Aljoscha Krettek, Andra Lungu, ChengXiang Li, Chesnay Schepler, Chiwan Park, Daniel Warneke, Dawid Wysakowicz, Gary Yao, Greg Hogan, Gyula Fóra, Henry Saputra, Jamie Grier, Jark Wu, Jincheng Sun, Konstantinos Kloudas, Kostas Tzoumas, Kurt Young, Márton Balassi, Matthias J. Sax, Maximilian Michels, Nico Kruber, Paris Carbone, Robert</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T143900Z" creationid="xccui" creationdate="20190605T132711Z">
        <seg>特别感谢Flink社区的Committer们：Alan Gates、Aljoscha Krettek、Andra Lungu、ChengXiang Li（李呈祥）、Chesnay Schepler、Chiwan Park、 Daniel Warneke、Dawid Wysakowicz、Gary Yao、Greg Hogan、Gyula Fóra、Henry Saputra、Jamie Grier、Jark Wu（伍翀）、Jincheng Sun（孙金城）、 Konstantinos Kloudas、Kostas Tzoumas、Kurt Young（杨克特）、Márton Balassi、Matthias J. Sax、Maximilian Michels、Nico Kruber、Paris Carbone、Robert</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, we explain how to define and interact with different types of state in user-defined func‐ tions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T033930Z" creationid="xccui" creationdate="20190630T033819Z">
        <seg>具体而言，我们将解释如何在用户自定义函数中定义不同类型的状态并与之交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying Unique Operator Identifiers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024703Z" creationid="xccui" creationdate="20190225T024703Z">
        <seg>指定算子唯一标识</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Split a tuple stream into a stream with large numbers and a stream with small numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T062047Z" creationid="xccui" creationdate="20190615T062047Z">
        <seg>将元组流拆分成一条大数字流和一条小数字流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Split and select</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210029Z" creationid="xccui" creationdate="20190615T052247Z">
        <seg>Split和Select</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Split is the inverse transformation to the union transformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T054002Z" creationid="xccui" creationdate="20190615T053736Z">
        <seg>split转换是union转换的逆操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Split operator list state for better distribution during rescaling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062645Z" creationid="xccui" creationdate="20190701T062645Z">
        <seg>将算子列表状态拆分，从而在扩缩容时实现更佳的分布</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stand-Alone Cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025413Z" creationid="xccui" creationdate="20190225T025413Z">
        <seg>独立集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standalone Cluster</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152136Z" creationid="esouser" creationdate="20190603T152136Z">
        <seg>独立集群</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Start a local Flink cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025029Z" creationid="xccui" creationdate="20190329T025015Z">
        <seg>启动本地Flink集群。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Start a local Flink cluster:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123053Z" creationid="xccui" creationdate="20190605T123051Z">
        <seg>启动本地Flink集群：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting an application from a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213449Z" creationid="xccui" creationdate="20190609T213449Z">
        <seg>从保存点启动应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting an application from a savepoint allows you to do much more.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211859Z" creationid="xccui" creationdate="20190609T211810Z">
        <seg>而将应用从某个保存点启动还能让你做更多事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025408Z" creationid="xccui" creationdate="20190329T025102Z">
        <seg>Starting cluster.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting execution of program</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040009Z" creationid="xccui" creationdate="20190329T040009Z">
        <seg>Starting execution of program</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting standalonesession daemon on host xxx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025401Z" creationid="xccui" creationdate="20190329T025401Z">
        <seg>Starting standalonesession daemon on host xxx.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting taskexecutor daemon on host xxx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T025415Z" creationid="xccui" creationdate="20190329T025415Z">
        <seg>Starting taskexecutor daemon on host xxx.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State Backends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022056Z" creationid="xccui" creationdate="20190225T022056Z">
        <seg>状态后端</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State Management</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022008Z" creationid="xccui" creationdate="20190225T022008Z">
        <seg>状态管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State Management | 53</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032642Z" creationid="xccui" creationdate="20190610T032642Z">
        <seg>状态管理 | 53</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State and Consistency Models</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144240Z" creationid="esouser" creationdate="20190603T144240Z">
        <seg>状态和一致性模型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State and Consistency Models | 33</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041500Z" creationid="xccui" creationdate="20190606T041500Z">
        <seg>状态和一致性模型 | 33</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State and consistency models</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T020429Z" creationid="xccui" creationdate="20190225T020429Z">
        <seg>状态和一致性模型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State backends differ in how state is checkpointed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T155129Z" creationid="xccui" creationdate="20190608T053842Z">
        <seg>不同的状态后端生成状态检查点的方式也有所差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State checkpointing is important because Flink is a distributed system and state is only locally maintained.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162333Z" creationid="xccui" creationdate="20190608T053330Z">
        <seg>因为Flink是一个分布式系统但只在本地维护状态，因此状态检查点就显得极其重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State is ubiquitous in data processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050647Z" creationid="xccui" creationdate="20190414T050539Z">
        <seg>状态在数据处理中无处不在，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State management</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032900Z" creationid="xccui" creationdate="20190606T032900Z">
        <seg>状态管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State management&lt;t0/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055905Z" creationid="xccui" creationdate="20190414T055905Z">
        <seg>状态管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State partitioning</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032915Z" creationid="xccui" creationdate="20190606T032915Z">
        <seg>状态划分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State partitioning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T033332Z" creationid="xccui" creationdate="20190415T033332Z">
        <seg>状态划分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State primitives expose the structure of the state to Flink and enable more efficient state accesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T223623Z" creationid="xccui" creationdate="20190607T222211Z">
        <seg>通过这些状态原语可以为Flink状态指定不同的结构，从而实现更加高效的状态访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032954Z" creationid="xccui" creationdate="20190606T032954Z">
        <seg>状态恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State recovery.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T034727Z" creationid="xccui" creationdate="20190415T034727Z">
        <seg>状态恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State, state consistency, and Flink’s checkpointing mechanism will be discussed in more detail in the following chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T033014Z" creationid="xccui" creationdate="20190305T033014Z">
        <seg>我们会在接下来的章节详细讨论状态、状态一致性以及Flink的checkpointing机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>State, state consistency, and Flink’s checkpointing mech‐ anism will be discussed in more detail in the following chapters, but, for now, Figure 1-4 shows a stateful streaming Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T032022Z" creationid="esouser" creationdate="20190603T210107Z">
        <seg>图1-4简单展示了Flink的状态化流式应用。有关状态、状态一致性以及Flink的检查点机制会在接下来的章节详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Operators and Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042412Z" creationid="xccui" creationdate="20190629T042412Z">
        <seg>状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Operators and Applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023527Z" creationid="xccui" creationdate="20190225T023519Z">
        <seg>状态化算子和应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014544Z" creationid="xccui" creationdate="20190225T014544Z">
        <seg>状态化流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful Stream Processing | 5</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130813Z" creationid="xccui" creationdate="20190605T130813Z">
        <seg>状态化流处理 | 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful operators and user functions are common building blocks of stream process‐ ing applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T030655Z" creationid="xccui" creationdate="20190629T042647Z">
        <seg>状态化算子及有状态的用户函数都是流处理应用中的常见组成部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful operators use both incom&lt;t2/&gt;‐&lt;t3/&gt; ing events and internal state to compute their output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T051928Z" creationid="xccui" creationdate="20190414T051928Z">
        <seg>状态化算子同时利用到来的事件和内部状态来计算输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful operators use both incoming events and internal state to compute their output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181422Z" creationid="xccui" creationdate="20190606T031507Z">
        <seg>状态化算子同时使用传入的事件和内部状态来计算输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing applications are more challenging to parallelize and oper&lt;t4/&gt;‐&lt;t5/&gt; ate in a fault tolerant manner because state needs to be efficiently partitioned and reli&lt;t6/&gt;‐&lt;t7/&gt; ably recovered in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151433Z" creationid="xccui" creationdate="20190405T040600Z">
        <seg>状态化流处理应用在并行化和容错方面会麻烦很多，因为需要对状态进行高效划分并且在出错时需进行可靠的故障恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing applications are more challenging to parallelize and oper‐ ate in a fault-tolerant manner because state needs to be efficiently partitioned and reliably recovered in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T055329Z" creationid="xccui" creationdate="20190606T005043Z">
        <seg>状态化流处理应用在并行化和容错方面会更具挑战性，因为它们需要对状态进行高效划分并且在出错时需进行可靠的故障恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing applications often ingest their incoming events from an event log.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T034141Z" creationid="xccui" creationdate="20190305T034141Z">
        <seg>状态化流处理应用通常会从事件日志中读取事件记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing has implications on many aspects of a stream processor such as failure recovery and memory management as well as the maintenance of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T032544Z" creationid="xccui" creationdate="20190630T032323Z">
        <seg>状态化流处理会在故障恢复、内存管理以及流式应用的维护等很多方面对流处理引擎产生影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing in Flink is discussed in detail in “Implementing Stateful Functions” on</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033814Z" creationid="xccui" creationdate="20190619T033814Z">
        <seg>有关Flink中状态化流处理的内容会在154页"实现状态化函数"一节详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing is an application design pattern for processing unbounded streams of events and is applicable to many different use cases in the IT infrastructure of a com&lt;t0/&gt;‐&lt;t1/&gt; pany.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T034013Z" creationid="xccui" creationdate="20190301T202026Z">
        <seg>作为一类面向无限事件流的应用设计模式，状态化流处理可用于公司IT基础设施中的很多用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful stream processing is an application design pattern for processing unbounded streams of events and is applicable to many different use cases in the IT infrastructure of a company.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T030537Z" creationid="esouser" creationdate="20190603T204846Z">
        <seg>作为一类面向无限事件流的应用设计模式，状态化流处理适用于公司IT基础设施中的很多用例场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateful transformations that are applied on a KeyedStream read from and write to state in the context of the currently processed event’s key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044300Z" creationid="xccui" creationdate="20190614T044151Z">
        <seg>作用于KeyedStream的状态化转换可以对当前处理事件键值所对应上下文中的状态进行读写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateless operations are easy to parallelize, since events can be processed independently of each other and of their arriving order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T055130Z" creationid="xccui" creationdate="20190405T035840Z">
        <seg>由于事件处理互不影响且与事件到来的时间无关，无状态的操作很容易并行化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stateless operations do not maintain any internal state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T035709Z" creationid="xccui" creationdate="20190405T035709Z">
        <seg>无状态的操作不会维持内部状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stores a key-value map per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T221802Z" creationid="xccui" creationdate="20190607T220156Z">
        <seg>每个键对应存储一个键值映射，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stores a list of values per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T220018Z" creationid="xccui" creationdate="20190607T215922Z">
        <seg>每个键对应存储一个值的列表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stores a single value of arbitrary type per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T215753Z" creationid="xccui" creationdate="20190607T215707Z">
        <seg>每个键对应存储一个任意类型的值，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream API program essentially boils down to combining such transformations to create a dataflow graph that implements the application logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T013754Z" creationid="xccui" creationdate="20190613T013744Z">
        <seg>完成一个DataStream API程序在本质上可以归结为：通过组合不同的转换来创建一个满足应用逻辑的dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream API transformations we have seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T043218Z" creationid="xccui" creationdate="20190621T043218Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing Fundamentals</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T050207Z" creationid="xccui" creationdate="20190329T050207Z">
        <seg>流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing Fundamentals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014755Z" creationid="xccui" creationdate="20190225T014755Z">
        <seg>流处理基础</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing with Apache</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T050752Z" creationid="esouser" creationdate="20190603T142341Z">
        <seg>基于Apache Flink的流处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing with Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210705Z" creationid="esouser" creationdate="20190603T210656Z">
        <seg>Stream Processing with Apache Flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream Processing with Apache Flink, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210737Z" creationid="esouser" creationdate="20190603T210737Z">
        <seg>Stream Processing with Apache Flink, the cover image, and related trade dress are trademarks of O’Reilly Media, Inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing engines usually provide a set of built-in operations to ingest, trans&lt;t0/&gt;‐&lt;t1/&gt; form, and output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T212650Z" creationid="xccui" creationdate="20190402T212535Z">
        <seg>流处理引擎通常会提供一系列内置操作来实现数据流的获取、转换以及输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing engines usually provide a set of built-in operations to ingest, trans‐ form, and output streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235741Z" creationid="xccui" creationdate="20190605T235741Z">
        <seg>流处理引擎通常会提供一系列内置操作来实现数据流的获取、转换以及输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing technology is becoming more and more popular with companies big and small because it provides superior solutions for many established use cases such as data analytics, ETL, and transactional applications, but also facilitates novel applications, software architectures, and business opportunities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T051811Z" creationid="esouser" creationdate="20190603T162936Z">
        <seg>流处理技术正受到越来越多不同规模公司的青睐，这是因为它不仅可以为很多现有场景提供更优的解决方案（例如数据分析、ETL以及事务性应用），而且可以催生很多新颖的应用、软件架构以及商业机会。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processing technology is being rapidly adopted by companies and enterprises of any size because it provides superior solutions for many established use cases but also facilitates novel applications, software architectures, and business opportunities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T222030Z" creationid="xccui" creationdate="20190225T221738Z">
        <seg>而流处理技术本身也迅速在各种规模的公司和企业中普及，这是因为它不仅可以为现有用例提供更优的解决方案，更可催生很多新颖的应用、软件架构以及商业机会。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processors like Flink also support event-time pro‐ cessing to produce correct and deterministic results and the ability to process large amounts of data in little time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155904Z" creationid="xccui" creationdate="20190605T045138Z">
        <seg>诸如Flink之类的流处理引擎还需要支持事件时间处理，从而可以生成精准、确定的结果，并具备在短时间内处理大量数据的能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processors of this generation made the lambda archi&lt;t2/&gt;‐&lt;t3/&gt; tecture obsolete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T135152Z" creationid="xccui" creationdate="20190327T135031Z">
        <seg>这使得Lambda架构彻底沦为历史。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream processors of this generation made the lambda architecture obsolete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053621Z" creationid="xccui" creationdate="20190605T053616Z">
        <seg>这使得Lambda架构彻底沦为历史。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream&lt;t2/&gt;‐&lt;t3/&gt; ing jobs run for long periods of time, thus state might be collected over several days or even months.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T040818Z" creationid="xccui" creationdate="20190415T040248Z">
        <seg>流式作业会运行较长时间，因此状态可能是数天甚至数月才收集而来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamExecutionEnvironment and it takes the following values:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T065200Z" creationid="xccui" creationdate="20190619T055332Z">
        <seg>时间特性是StreamExecutionEnvironment的属性，它可以接收以下值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>StreamExecutionEnvironment as shown in Example 7-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204734Z" creationid="xccui" creationdate="20190702T204734Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming Analytics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014658Z" creationid="xccui" creationdate="20190225T014658Z">
        <seg>流式分析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming analytics applications are commonly used for:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T045410Z" creationid="xccui" creationdate="20190605T045410Z">
        <seg>流式分析应用常用于：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming application with two stateful sources, two stateful tasks, and two stateless sinks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062410Z" creationid="xccui" creationdate="20190609T062410Z">
        <seg>拥有两个状态化数据源、两个状态化任务以及两个无状态数据汇的流式应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications are often designed to run continuously for months or years.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T130113Z" creationid="xccui" creationdate="20190704T035535Z">
        <seg>流式应用经常会被设计成需要长年累月地连续运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications are supposed to run continuously and must recover from fail‐ ures, such as failing machines or processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T203614Z" creationid="xccui" creationdate="20190702T203549Z">
        <seg>连续运行的流式应用需要具备从故障（例如机器或进程故障）中恢复的能力，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications are typically designed to run 24/7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071805Z" creationid="xccui" creationdate="20190424T064357Z">
        <seg>流式应用通常都会设计成7×24小时运行，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications need to exchange data in a pipelined fashion, i.e., each pair of TaskManagers maintains a permanent TCP connection to exchange data&lt;t2/&gt;3&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T042859Z" creationid="xccui" creationdate="20190504T042843Z">
        <seg>流式应用需要以流水线方式交换数据，即每对TaskManager之间都维护一个永久的TCP连接来交换数据3。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications need to exchange data in a pipelined fashion—each pair of TaskManag‐ ers maintains a permanent TCP connection to exchange data.2 With a shuffle connec‐ tion pattern, each sender task needs to be able to send data to each receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T192058Z" creationid="xccui" creationdate="20190606T195847Z">
        <seg>流式应用需要以流水线方式交换数据，因此每对TaskManager之间都要维护一个永久的TCP连接来执行数据交换2。在Shuffle连接模式下，每个发送端任务都需要向任意一个接收任务传输数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming applications usually emit their results to some external system, such as Apache Kafka, a filesystem, or a database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054057Z" creationid="xccui" creationdate="20190612T054057Z">
        <seg>流式应用通常都会把结果发送到某些外部系统，例如Apache Kafka，文件系统或数据库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming systems define their behavior in the pres&lt;t0/&gt;‐&lt;t1/&gt; ence of failures by offering result guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044432Z" creationid="xccui" creationdate="20190415T044326Z">
        <seg>流处理系统通过不同的结果保障来定义故障时的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Streaming systems define their behavior in the presence of failures by offering result guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034128Z" creationid="xccui" creationdate="20190606T034128Z">
        <seg>流处理系统通过不同的结果保障来定义故障时的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stream‐ ing jobs run for long periods of time, and thus state might be collected over several days or even months.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185018Z" creationid="xccui" creationdate="20190606T033124Z">
        <seg>流式作业通常会运行较长时间，因此状态可能是经过数天甚至数月才收集得到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sub&lt;t0/&gt;‐&lt;t1/&gt; sets of an organization’s data are stored in multiple of these systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T040827Z" creationid="xccui" creationdate="20190314T065729Z">
        <seg>一些机构的数据可能会同时存储在多个系统里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequent transformations pro‐ cess the elements of all input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064047Z" creationid="xccui" creationdate="20190614T064047Z">
        <seg>这样后续的转换操作就可以对所有输入流中的元素进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently, it merges all windows with overlapping ranges.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T062316Z" creationid="xccui" creationdate="20190623T062316Z">
        <seg>随后分配器会合并所有范围存在重叠的窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequently, the task updates its event-time clock to be the minimum of all partition watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T024721Z" creationid="xccui" creationdate="20190607T024706Z">
        <seg>随后，任务会把事件时间时钟调整为所有分区水位线中最小的那个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055728Z" creationid="xccui" creationdate="20190414T055139Z">
        <seg>摘要可能是一个计数值，一个累加和，至今所见事件的抽样，一个窗口缓冲，或是只保留了那些运行应用感兴趣属性的某种自定义数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a summary can be a count, a sum, a sample of the events seen so far, a window buffer, or a custom data structure that preserves some property of interest to the running application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T183345Z" creationid="xccui" creationdate="20190606T032633Z">
        <seg>这种摘要可能是一个数量值，一个累加值，一个对至今为止全部事件的抽样，一个窗口缓冲或是一个保留了应用运行过程中某些有价值信息的自定义数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such records are called late records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035418Z" creationid="xccui" creationdate="20190529T035345Z">
        <seg>我们称此类记录为迟到记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021634Z" creationid="xccui" creationdate="20190225T021634Z">
        <seg>总结</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary | 15</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130843Z" creationid="xccui" creationdate="20190605T130843Z">
        <seg>总结 | 15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary | 69</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032814Z" creationid="xccui" creationdate="20190610T032814Z">
        <seg>总结 | 69</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary | 77</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T012750Z" creationid="xccui" creationdate="20190612T012750Z">
        <seg>总结 | 77</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supplemental material (code examples in Java and Scala) is available for download at</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210813Z" creationid="esouser" creationdate="20190603T210813Z">
        <seg>Supplemental material (code examples in Java and Scala) is available for download at</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supported Data Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022807Z" creationid="xccui" creationdate="20190225T022807Z">
        <seg>支持的数据类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021655Z" creationid="xccui" creationdate="20190225T021655Z">
        <seg>系统架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Architecture | 39</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032542Z" creationid="xccui" creationdate="20190610T032542Z">
        <seg>系统架构 | 39</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>System Configuration</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025523Z" creationid="xccui" creationdate="20190225T025523Z">
        <seg>系统配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>T element, long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190004Z" creationid="xccui" creationdate="20190626T190004Z">
        <seg>T element, long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table API and SQL for Relational Analysis</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152519Z" creationid="esouser" creationdate="20190603T152515Z">
        <seg>用于关系型分析的Table API及SQL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table of Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T013833Z" creationid="xccui" creationdate="20190225T013833Z">
        <seg>目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take a checkpoint by copying the state of each task to a remote, persistent stor‐ age.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224051Z" creationid="xccui" creationdate="20190608T224031Z">
        <seg>将所有任务的状态拷贝到远程持久化存储，生成检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take for example a rolling aggregation operator that outputs the current sum of all the events it has seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T052032Z" creationid="xccui" creationdate="20190414T052003Z">
        <seg>以某个滚动聚合算子为例，它会输出至今所有看到的事件之和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Take, for example, a rolling aggregation operator that outputs the current sum of all the events it has seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181616Z" creationid="xccui" creationdate="20190606T031517Z">
        <seg>以某个滚动聚合算子为例，假设它会输出至今为止所见到的全部事件之和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taking a savepoint from an application and restoring an application from a savepoint</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215136Z" creationid="xccui" creationdate="20190609T215136Z">
        <seg>为应用生成保存点和从保存点恢复应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task Chaining</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021822Z" creationid="xccui" creationdate="20190225T021822Z">
        <seg>任务链接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task Execution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021752Z" creationid="xccui" creationdate="20190225T021752Z">
        <seg>任务执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task Failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144251Z" creationid="esouser" creationdate="20190603T144251Z">
        <seg>任务故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task chaining can significantly reduce the communication costs between local tasks, but there are also cases when it makes sense to execute a pipeline without chaining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T201858Z" creationid="xccui" creationdate="20190606T203900Z">
        <seg>虽然任务链接可以有效地降低本地任务之间的通信开销，但有的流水线应用反而不需要启用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task chaining can significantly reduce the communication costs between local tasks, however there are also cases when it makes sense to execute a pipeline without chain&lt;t0/&gt;‐&lt;t1/&gt; ing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T154339Z" creationid="esouser" creationdate="20190514T154032Z">
        <seg>虽然任务链接可以有效地降低本地任务之间的通信开销，但并不意味着所有的流水线执行都要启用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task chaining is enabled by default in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155143Z" creationid="esouser" creationdate="20190514T155137Z">
        <seg>Flink在默认情况下会开启任务链接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Task failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T204829Z" creationid="xccui" creationdate="20190225T020501Z">
        <seg>任务故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManager failures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205310Z" creationid="xccui" creationdate="20190428T205310Z">
        <seg>TaskManager故障</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManagers &lt;t0/&gt;are the worker processes of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T051341Z" creationid="xccui" creationdate="20190418T051341Z">
        <seg>TaskManager是Flink的工作进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TaskManagers are the worker processes of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061010Z" creationid="xccui" creationdate="20190606T142307Z">
        <seg>TaskManager是Flink的工作进程（worker process）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks can register timers at the timer service to perform a computa&lt;t2/&gt;‐&lt;t3/&gt; tion at a specific point in time in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041504Z" creationid="xccui" creationdate="20190529T041236Z">
        <seg>这些定时器可由任务在时间服务内注册，并在将来的某个时间点执行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks can register timers at the timer service to perform a computa‐ tion at a specific point in time in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190606T210249Z">
        <seg>这些计时器可由任务在时间服务内注册，并在将来的某个时间点执行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks checkpoint their state once all barriers have been received, then they forward the checkpoint barrier</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T192452Z" creationid="xccui" creationdate="20190609T191948Z">
        <seg>任务在收到全部分隔符后将状态存入检查点，然后向下游转发检查点分隔符</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks continue regular processing after the checkpoint barrier is forwarded</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193707Z" creationid="xccui" creationdate="20190609T193606Z">
        <seg>任务在转发检查点分隔符后继续进行常规处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks have an internal time service that maintains timers and is activated when a water&lt;t0/&gt;‐&lt;t1/&gt; mark is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041324Z" creationid="xccui" creationdate="20190529T040840Z">
        <seg>任务的内部时间服务（time service）会维护定时器（timer），并在接收到水位线时激活。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks have an internal time service that maintains timers and is activated when a water‐ mark is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190606T210238Z">
        <seg>任务的内部时间服务（time service）会维护计时器（timer），并在接收到水位线时激活。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks of time-based opera&lt;t2/&gt;‐&lt;t3/&gt; tors collect and process records with possibly unordered timestamps and finalize a computation when their event-time clock, which is advanced by received watermarks, indicates that no more records with relevant timestamps have to be expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035025Z" creationid="xccui" creationdate="20190529T034137Z">
        <seg>对基于时间算子的任务而言，其收集和处理的记录可能会包含乱序的时间戳。只有当它们的事件时间时钟（由接收的水位线驱动）指示不必再等那些包含相关时间戳的记录时，才会最终触发计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks of time-based opera‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205539Z" creationid="xccui" creationdate="20190606T205539Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks wait to receive a barrier on each input partition; records from input streams for which a barrier already arrived are buffered; all other records are regularly processed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T193637Z" creationid="xccui" creationdate="20190609T175039Z">
        <seg>任务等待接收所有输入分区的分隔符，来自已接收分隔符输入分区的记录会被缓存，其他记录则按常规处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks with keyed state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T191928Z">
        <seg>带有键值分区状态的任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks with operator state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T061908Z" creationid="xccui" creationdate="20190607T061908Z">
        <seg>带有算子状态的任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thank you, Adam Kawa, Aljoscha Krettek, Kenneth Knowles, Lea Giordano, Matthias J. Sax, Stephan Ewen, Ted Malaska, and Tyler Akidau.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T161943Z" creationid="xccui" creationdate="20190608T161943Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thank you, Alicia Young, Colleen Lobner, Christine Edwards, Katherine Tozer, Marie Beaugureau, and Tim McGovern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T162030Z" creationid="xccui" creationdate="20190605T134127Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is because the number of tasks might change when an application is started with different parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215733Z" creationid="xccui" creationdate="20190609T215724Z">
        <seg>这是因为任务数目可能会随着应用启动时所指定的并发数而改变。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, after recovery, it should know whether an event update has already been reflected on the state or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045657Z" creationid="xccui" creationdate="20190416T044436Z">
        <seg>即在故障恢复后，引擎需要知道某个事件对应的更新是否已经反映到状态上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, how long do we have to wait before we can be certain that we have received all events that happened before a certain point of time?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160704Z" creationid="xccui" creationdate="20190412T161649Z">
        <seg>换言之，我们需要等多久才能确定已经收到了所有发生在某个特定时间点之前的事件？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the API calls that create stream sources and transformations do not immediately trigger any data processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011133Z" creationid="xccui" creationdate="20190613T011133Z">
        <seg>也就是说，那些创建数据源和转换操作的API调用不会立即触发任何数据处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the processing of an event does not depend on any events seen in the past and no history is kept.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T055045Z" creationid="xccui" creationdate="20190405T035802Z">
        <seg>即处理事件时无需依赖过去看到的事件，也不保存历史数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, throughput tells us how many events the system can process per time unit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195507Z" creationid="xccui" creationdate="20190401T195445Z">
        <seg>它告诉我们系统每单位时间可以处理多少事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, we are concerned with what the application code sees as state value after recovering from a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T191604Z" creationid="xccui" creationdate="20190415T045129Z">
        <seg>也就是说，我们关注故障恢复后应用代码能够看到的状态值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you are primarily concerned with determining the &lt;t0/&gt;peak&lt;t1/&gt; throughput, i.e. the perfor&lt;t2/&gt;‐&lt;t3/&gt; mance limit when your system is at its maximum load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T205829Z" creationid="xccui" creationdate="20190401T203852Z">
        <seg>换言之，首要关注点是确定峰值吞吐，即系统满负载时的性能上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you are primarily concerned with determining the peak throughput—the perfor‐ mance limit when your system is at its maximum load.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052457Z" creationid="xccui" creationdate="20190605T234550Z">
        <seg>换言之，首要的关注点是确定峰值吞吐，即系统满负载时的性能上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you can re-play a stream and analyze historic data as if events are happening in real-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T154822Z" creationid="xccui" creationdate="20190412T154656Z">
        <seg>这意味着你可以通过重放数据流来分析历史数据，就如同它们是实时产生的一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you can replay a stream and analyze historic data as if events are happening in real time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025105Z" creationid="xccui" creationdate="20190606T025105Z">
        <seg>这意味着你可以通过重放数据流来分析历史数据，就如同它们是实时产生的一样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, you will get the fastest service if you are the only customer in the coffee shop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054048Z" creationid="xccui" creationdate="20190402T204424Z">
        <seg>也就是说，如果咖啡店只有你一名顾客，你将获得最快的服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means each parallel instance of the function is responsible for a subrange of the key domain and maintains the corresponding state instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T035827Z" creationid="xccui" creationdate="20190630T035827Z">
        <seg>这意味着每个函数的并行实例都会负责键值域的一部分并维护相应的状态实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That’s it!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041710Z" creationid="xccui" creationdate="20190611T041710Z">
        <seg>就这么简单！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That’s it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T022452Z" creationid="xccui" creationdate="20190328T061659Z">
        <seg>就这么简单，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203027Z" creationid="esouser" creationdate="20190603T203027Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;Dispatcher&lt;t1/&gt; runs across job executions and provides a REST interface to sub&lt;t2/&gt;‐&lt;t3/&gt; mit applications for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T053228Z" creationid="xccui" creationdate="20190418T052650Z">
        <seg>Dispatcher会跨多个作业运行，它提供了一个REST接口来提交要执行的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;JobManager&lt;t1/&gt; is the master process that controls the execution of a single application, i.e., each application is controlled by a different JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033838Z" creationid="xccui" creationdate="20190418T033838Z">
        <seg>JobManager作为主进程，控制着单个应用的执行。换句话说，每个应用都由一个不同的JobManager掌控。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;broadcast&lt;t1/&gt; strategy sends every data item to all parallel tasks of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135817Z" creationid="xccui" creationdate="20190401T134909Z">
        <seg> 广播策略（broadcast strategy）会把数据项发往下游算子的全部并发任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;forward&lt;t1/&gt; strategy sends data from a task to a receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135823Z" creationid="xccui" creationdate="20190401T134033Z">
        <seg>转发策略（forward strategy）在发送端任务和接收端任务之间进行一对一的数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;key-based&lt;t1/&gt; strategy partitions data by a key attribute and guarantees that data items having the same key will be processed by the same task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T135841Z" creationid="xccui" creationdate="20190401T135059Z">
        <seg>基于键值的策略（key-based strategy）根据某一键值属性将数据分成多份并保证键值相同的数据项一定会交由同一个任务处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;t0/&gt;random&lt;t1/&gt; strategy uniformly distributes data items to operator tasks in order to evenly distribute the load across computing tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T140101Z" creationid="xccui" creationdate="20190401T135738Z">
        <seg>随机策略（random strategy）为了实现计算任务的负载均衡，会将数据均匀分配至算子的所有任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Apache Software Foundation alone is the home of more than a dozen projects related to stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050546Z" creationid="xccui" creationdate="20190605T050546Z">
        <seg>仅Apache软件基金会一家就有十多个和流处理相关的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Apache Software Foundation alone is the home of more than a dozen projects that are related to stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T053503Z" creationid="xccui" creationdate="20190319T053503Z">
        <seg>仅Apache软件基金会一家就有十多个和流处理相关的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Architecture of Apache Flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053550Z" creationid="xccui" creationdate="20190416T053550Z">
        <seg>Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Architecture of Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T021648Z" creationid="xccui" creationdate="20190225T021648Z">
        <seg>Apache Flink架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The BroadcastProcessFunction and KeyedBroadcastProcess Function differ from each other as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T053632Z" creationid="xccui" creationdate="20190702T053632Z">
        <seg>BroadcastProcessFunction和KeyedBroadcastProcessFunction本身也有所不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CheckpointedFunction interface defines two methods, initializeState() and snapshotState(), which work similar to the methods of the ListCheckpointed interface for operator list state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T063959Z" creationid="xccui" creationdate="20190702T063959Z">
        <seg>CheckpointedFunction接口定义了两个方法——initializeState()和snapshotState()，它们的工作模式和算子列表状态中ListCheckpointed接口的方法类似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CheckpointedFunction interface is the lowest-level interface to specify stateful functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T055816Z" creationid="xccui" creationdate="20190702T055816Z">
        <seg>CheckpointedFunction是用于指定有状态函数的最低级别接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CoProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023132Z" creationid="xccui" creationdate="20190225T023132Z">
        <seg>CoProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CoProcessFunction also provides an onTimer() callback method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031242Z" creationid="xccui" creationdate="20190622T031242Z">
        <seg>CoProcessFunction还提供了onTimer()回调方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ConnectedStreams object provides map() and flatMap() methods that expect a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T041020Z" creationid="xccui" creationdate="20190615T041010Z">
        <seg>ConnectedStreams对象提供了map()和flatMap()方法，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Context object is what makes a process function special.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T054155Z" creationid="xccui" creationdate="20190621T054010Z">
        <seg>Context对象是让处理函数与众不同的原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Context object of the ProcessWindowFunction gives access to the metadata of the window, the current pro‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011411Z" creationid="xccui" creationdate="20190624T011304Z">
        <seg>ProcessWindowFunction的Context对象可以用于访问窗口的元数据，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataSet API for Batch Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152457Z" creationid="esouser" creationdate="20190603T152457Z">
        <seg>用于批处理的DataSet API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API (v1.7)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014854Z" creationid="xccui" creationdate="20190612T014854Z">
        <seg>DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API (v1.7) | 79</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045132Z" creationid="xccui" creationdate="20190619T045132Z">
        <seg>DataStream API （1.7版本） | 79</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API (v1.7).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022444Z" creationid="xccui" creationdate="20190225T022435Z">
        <seg>DataStream API （1.7版本）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API exposes interfaces and methods to define custom window oper‐ ators by allowing you to implement your own assigners, triggers, and evictors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T051229Z" creationid="xccui" creationdate="20190625T051229Z">
        <seg>DataStream API对外暴露了自定义窗口算子的接口和方法，你可以实现自己的分配器、触发器以及移除器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API features the abstraction of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044525Z" creationid="xccui" creationdate="20190614T043951Z">
        <seg>作为一种特殊的DataStream，DataStream API中的KeyedStream抽象可以从逻辑上将事件按照键值分配到多条独立的子流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API of Flink 1.7 features the WindowFunction interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010353Z" creationid="xccui" creationdate="20190624T010232Z">
        <seg>Flink 1.7版本的DataStream API还提供了WindowFunction接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides a family of low-level transformations, the process functions, which can also access record timestamps and watermarks and register timers that trigger at a specific time in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T043822Z">
        <seg>DataStream API提供了一组相对低级的转换——处理函数。除了基本功能，它们还可以访问记录的时间戳和水位线，并注册一些在将来某个特定时间触发的计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides built-in methods for the most common window oper‐ ations as well as a very flexible windowing mechanism to define custom windowing logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T033836Z" creationid="xccui" creationdate="20190622T033836Z">
        <seg>DataStream API针对一些最常见窗口操作都提供了内置方法，此外还提供了一些非常灵活的窗口机制来自定义窗口逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides different options for how to handle late events:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T152913Z" creationid="xingcan" creationdate="20190628T152913Z">
        <seg>DataStream API提供了不同的选项来应对迟到事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides event-time and processing-time assigners, as well as shortcut methods, and a time interval offset can be set as the third parameter to the window assigner:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060021Z" creationid="xccui" creationdate="20190623T055947Z">
        <seg>DataStream API提供了针对事件时间和处理时间的分配器以及相关的简写方法。你可以将时间间隔偏移设为窗口分配器的第三个参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides implementations for two common cases of timestamp assigners with periodic watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051417Z" creationid="xccui" creationdate="20190620T051417Z">
        <seg>DataStream API内置了两个针对常见情况的周期性水位线时间戳分配器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides rich functions that expose more functionality than the regular functions discussed until now.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060242Z" creationid="xccui" creationdate="20190618T060242Z">
        <seg>DataStream API提供了一类富函数，它和我们之前见到的普通函数相比可以对外提供更多功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides the TimestampAssigner interface to extract time‐ stamps from elements after they have been ingested into the streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T025925Z" creationid="xccui" creationdate="20190620T025925Z">
        <seg>DataStream API提供了TimestampAssigner接口，用于从已读入流式应用的元素中提取时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides the connect transformation to support such use cases.1 The DataStream.connect() method receives a DataStream and returns a Connected Streams object, which represents the two connected streams:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210127Z" creationid="xccui" creationdate="20190615T040600Z">
        <seg>DataStream API提供的connect转换可以用来完成该用例。1 DataStream.connect()方法接收一个DataStream并返回一个ConnectedStream对象，该对象表示两个联结起来（connected）的流：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides the following rolling aggregation methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052557Z" creationid="xccui" creationdate="20190614T052557Z">
        <seg>DataStream API提供了以下滚动聚合方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream API provides transformations for the most common data transfor‐ mation operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T023051Z" creationid="xccui" creationdate="20190613T023051Z">
        <seg>DataStream API为一些最常见的数据转换操作都提供了对应的转换抽象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream.split()  method  returns  a  SplitStream,  which  provides  a select() method to select one or more streams from the SplitStream by specify‐ ing the output names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061408Z" creationid="xccui" creationdate="20190615T061408Z">
        <seg>DataStream.split()方法会返回一个SplitStream对象，它提供的select()方法可以让我们通过指定输出名称的方式从SplitStream中选择一条或多条流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream.split() method receives an OutputSelector that defines how stream elements are assigned to named outputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T054406Z" creationid="xccui" creationdate="20190615T054406Z">
        <seg>DataStream.split()方法接收一个OutputSelector，它用来定义如何将数据流的元素分配到不同的命名输出中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataStream.union() method merges two or more DataStreams of the same type and produces a new DataStream of the same type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040651Z" creationid="xccui" creationdate="20190614T063938Z">
        <seg>DataStream.union()方法可以合并两条或多条类型相同的DataStream，并生成一个新的类型不变的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Datastream API provides two assigners—TumblingEventTimeWindows and Tum blingProcessingTimeWindows—for tumbling event-time and processing-time win‐ dows, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042428Z" creationid="xccui" creationdate="20190623T042428Z">
        <seg>DataStream API针对事件时间和处理时间的滚动窗口分别提供了对应的分配器——TumblingEventTimeWindows和TumblingProcessingTimeWindows。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Dispatcher runs across job executions and provides a REST interface to sub‐ mit applications for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061537Z" creationid="xccui" creationdate="20190606T142757Z">
        <seg>Dispatcher会跨多个作业运行，它提供了一个REST接口来让我们提交需要执行的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Evictor interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201543Z" creationid="xccui" creationdate="20190627T201543Z">
        <seg>移除器接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Evictor is an optional component in Flink’s windowing mechanism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201644Z" creationid="xccui" creationdate="20190626T201345Z">
        <seg>Evictor是Flink窗口机制中的一个可选组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Evolution of Open Source Stream Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014710Z" creationid="xccui" creationdate="20190225T014710Z">
        <seg>开源流处理的衍变</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Evolution of Open Source Stream Processing | 11</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130824Z" creationid="xccui" creationdate="20190605T130824Z">
        <seg>开源流处理的衍变 | 11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The FilterFunction interface is typed to the type of the input stream and defines the filter() method that is called with an input event and returns a boolean:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052914Z" creationid="xccui" creationdate="20190613T052914Z">
        <seg>FilterFunction接口的类型为输入流的类型，它的filter()方法会接收一个输入事件，返回一个布尔值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Flink Maven archetypes we introduced in “Bootstrap a Flink Maven Project” on page 76 generate Maven projects that are configured to produce application-fat JARs that include all required dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T043037Z" creationid="xccui" creationdate="20190619T043037Z">
        <seg>我们在第76页"创建Flink Maven项目"中介绍了利用Flink Maven模板生成Maven项目，其中就加入了生成包含全部所需依赖的胖JAR的配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The GlobalWindows Assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044253Z" creationid="xccui" creationdate="20190626T044253Z">
        <seg>GlobalWindows分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The GlobalWindows assigner maps all elements to the same global window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044319Z" creationid="xccui" creationdate="20190626T044319Z">
        <seg>GlobalWindows分配器会将所有元素映射到同一个全局窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Interval Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023305Z" creationid="xccui" creationdate="20190225T023305Z">
        <seg>The Interval Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Iterable parameter of the ProcessWindowFunc tion.process() method will only provide a single value, the incrementally aggrega‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040022Z" creationid="xccui" creationdate="20190625T040022Z">
        <seg>这样传递给ProcessWindowFunction.process()方法的Iterable参数内将只有一个值，即增量聚合的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JAR file of a dependency can be added to the ./lib folder of a Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041644Z" creationid="xccui" creationdate="20190619T041644Z">
        <seg>可以将依赖的JAR包放到设置Flink的./lib目录中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager can then assign tasks to the slots to execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061320Z" creationid="xccui" creationdate="20190606T142633Z">
        <seg>之后，JobManager就可以向处理槽中分配任务来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager can then assigns tasks to the slots to execute them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062133Z" creationid="xccui" creationdate="20190418T051927Z">
        <seg>随后，JobManager就可以向处理槽中分配任务来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager con&lt;t4/&gt;‐&lt;t5/&gt; verts the JobGraph into a physical dataflow graph called the ExecutionGraph, which consists of tasks that can be executed in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T034733Z" creationid="xccui" creationdate="20190418T034656Z">
        <seg>JobManager将JobGraph转化成名为ExecutionGraph的物理dataflow图，该图包含了那些可以并行执行的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager controls the execution of a streaming application and keeps metadata  about its execution, such as pointers to completed checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072616Z" creationid="xccui" creationdate="20190606T145722Z">
        <seg>它用于控制流式应用执行以及保存该过程中的元数据（如已完成检查点的指针？？）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager controls the execution of a streaming application and keeps metadata about its execution, such as pointers to completed checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T043258Z" creationid="xccui" creationdate="20190502T042809Z">
        <seg>它用于控制流式应用执行以及保存该过程中的元数据（例如用于完成checkpoint的指针）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager converts the JobGraph into a physical dataflow graph called the ExecutionGraph, which consists of tasks that can be executed in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141728Z" creationid="xccui" creationdate="20190606T141717Z">
        <seg>JobManager将JobGraph转化成名为ExecutionGraph的物理Dataflow图，该图包含了那些可以并行执行的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager is the master process that controls the execution of a single application—each application is controlled by a different JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141515Z" creationid="xccui" creationdate="20190606T141505Z">
        <seg>作为主进程，JobManager控制着单个应用的执行。换句话说，每个应用都由一个不同的JobManager掌控。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager receives an application for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T034042Z" creationid="xccui" creationdate="20190418T033907Z">
        <seg>JobManager可以接收用于执行的应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager records the check‐ point of an application as completed once it has received a checkpoint acknowledge‐ ment from all tasks of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194311Z" creationid="xccui" creationdate="20190609T194259Z">
        <seg>JobManager在接收到所有应用任务返回的检查点确认消息后，就会将此次检查点标记为完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager requests the necessary resources (TaskManager slots) to execute the tasks from the ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060159Z" creationid="xccui" creationdate="20190418T034828Z">
        <seg>JobManager从ResourceManager申请执行任务的必要资源（TaskManager处理槽）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The JobManager spans the JobGraph into an ExecutionGraph and assigns the tasks to the four avail&lt;t2/&gt;‐&lt;t3/&gt; able slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T163951Z" creationid="xccui" creationdate="20190423T163315Z">
        <seg>JobManager将JobGraph转成ExecutionGraph并将任务分配到4个空闲槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Job‐ Manager receives an application for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T055934Z" creationid="xccui" creationdate="20190606T141542Z">
        <seg>JobManager可以接收要执行的应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Job‐ Manager spans the JobGraph into an ExecutionGraph and assigns the tasks to the four available slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T071244Z" creationid="xccui" creationdate="20190606T144553Z">
        <seg>JobManager将JobGraph"展开成"ExecutionGraph并把任务分配到4个空闲处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The KeyedProcessFunction is a very versatile function and can be applied to a Keyed Stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053015Z" creationid="xccui" creationdate="20190621T052943Z">
        <seg>KeyedProcessFunction作用于KeyedStream之上，它的用法非常灵活。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lambda architecture aimed to improve the high result latency of the original batch analytics architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T015919Z" creationid="xccui" creationdate="20190322T054026Z">
        <seg>Lambda架构旨在改善原始批量分析架构中结果的高延迟问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lambda architecture augments the traditional periodic batch processing archi&lt;t0/&gt;‐&lt;t1/&gt; tecture with a Speed Layer that is powered by a low-latency stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032853Z" creationid="xccui" creationdate="20190322T043932Z">
        <seg>Lambda架构在传统周期性批处理架构的基础上添加了一个由低延迟流处理引擎所驱动的"提速层"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lambda architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T043711Z" creationid="xccui" creationdate="20190322T043711Z">
        <seg>Lambda架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ListCheckpointed interface does not work with state handles like Val ueState or ListState, which are registered at the state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T040235Z" creationid="xccui" creationdate="20190701T040223Z">
        <seg>该接口不像ValueState或ListState状态句柄那样直接在状态后端注册，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ListCheckpointed interface uses Java serialization to serialize and deserialize the list of state objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063049Z" creationid="xccui" creationdate="20190701T063049Z">
        <seg>ListCheckpointed接口使用Java序列化机制来对状态对象进行序列化和反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ListState implementation of RocksDBStateBackend deseri‐ alizes all list entries before constructing Iterable to read the values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T032212Z" creationid="xccui" creationdate="20190704T032212Z">
        <seg>在构造用于数据访问的Iterable对象之前，RocksDBStateBackend的ListState需要将它所有的列表条目反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The MapFunction is typed to the types of the input and output events and can be specified using the MapFunction interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052743Z" creationid="xccui" creationdate="20190613T050021Z">
        <seg>MapFunction的两个类型分别为输入和输出事件类型，可以通过MapFunction接口来指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The MergingWindowAssigner is used for win‐ dow operators that need to merge existing windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045834Z" creationid="xccui" creationdate="20190626T045356Z">
        <seg>MergingWindowAssigner可用于需要对已有窗口进行合并的窗口算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The OnTimerContext provides the same serv‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T055416Z" creationid="xccui" creationdate="20190621T055144Z">
        <seg>OnTimerContext能够提供和processElement()方法中的Context对象相同的服务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The OutputSelector defines the select() method that is called for each input event and returns a java.lang.Itera ble[String].</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T060646Z" creationid="xccui" creationdate="20190615T054416Z">
        <seg>OutputSelector中定义的select()方法会在每个输入事件到来时被调用，随即返回一个java.lang.Iterable[String]对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The O’Reilly logo is a registered trademark of O’Reilly Media, Inc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210736Z" creationid="esouser" creationdate="20190603T210736Z">
        <seg>The O’Reilly logo is a registered trademark of O’Reilly Media, Inc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ProcessWindowFunction is a full window function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211521Z" creationid="xccui" creationdate="20190623T211454Z">
        <seg>ProcessWindowFunction就是一个全量窗口函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST interface enables the dispatcher to serve as an HTTP entry point to clusters that are behind a firewall.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T053416Z" creationid="xccui" creationdate="20190418T053359Z">
        <seg>REST接口允许Dispatcher作为防火墙后集群的一个HTTP入口点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The REST interface enables the dispatcher to serve as an HTTP entry point to clusters that are behind a fire‐ wall.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061813Z" creationid="xccui" creationdate="20190606T142920Z">
        <seg>REST接口使得Dispatcher可以作为防火墙后集群的一个HTTP入口点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ReduceFunction was introduced in “KeyedStream Transformations” on page 87 when discussing running aggregations on keyed streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T214033Z" creationid="xccui" creationdate="20190623T214033Z">
        <seg>我们已经在第87页"基于KeyedStream的转换"一节讨论键值分区流上的运行聚合时介绍过ReduceFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Resour&lt;t4/&gt;‐&lt;t5/&gt; ceManager also takes care of terminating idle TaskManagers to free compute resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T051307Z" creationid="xccui" creationdate="20190418T051307Z">
        <seg>同时，ResourceManager还负责终止空闲的TaskManager以释放计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ResourceManager also takes care of terminating idle TaskManagers to free com‐ pute resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142256Z" creationid="xccui" creationdate="20190606T142256Z">
        <seg>同时，ResourceManager还负责终止空闲的TaskManager以释放计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ResourceManager is responsible for managing TaskManager slots, Flink’s unit of processing resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062008Z" creationid="xccui" creationdate="20190418T050109Z">
        <seg>ResourceManager负责管理Flink的处理资源单元——TaskManager处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Rest of the Flink Ecosystem</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152428Z" creationid="esouser" creationdate="20190603T152428Z">
        <seg>Flink生态的其他组成部分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RocksDBStateBackend also checkpoints the state to a remote and persistent file system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T024037Z" creationid="xccui" creationdate="20190704T024037Z">
        <seg>RocksDBStateBackend同样会将状态以检查点形式写入远程持久化文件系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RuntimeContext can be used to retrieve information such as the function’s parallelism, its subtask index, and the name of the task that executes the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033617Z" creationid="xccui" creationdate="20190619T033451Z">
        <seg>从RuntimeContext能够获取一些信息，例如函数的并行度，它所在的子任务编号以及执行函数的任务名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Scala DataStream API also has built-in support for lambda functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T022408Z" creationid="xccui" creationdate="20190613T022402Z">
        <seg>Scala DataStream API同样内置了对lambda函数的支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Scala DataStream API offers syntactic shortcuts to define map and flatMap func‐ tions with a single ValueState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T022541Z" creationid="xccui" creationdate="20190701T022541Z">
        <seg>Scala DataStream API为只有单个ValueState的map和flatMap函数提供了简便写法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Scala DataStream API uses regular Scala tuples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070731Z" creationid="xccui" creationdate="20190616T070721Z">
        <seg>Scala DataStream API使用常规Scala元组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The StateDe scriptor is specific to the state primitive and includes the name of the state and the data types of the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T065447Z" creationid="xccui" creationdate="20190630T065447Z">
        <seg>每个状态原语都有自己特定的StateDescriptor，它其中包含了状态名称和类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The StreamExecutionEnvironment provides methods to create stream sources that ingest data streams into the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051229Z" creationid="xccui" creationdate="20190612T051229Z">
        <seg>StreamExecutionEnvironment提供了一些创建流式数据源的方法，可以将数据流读取到应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The String values that are returned for a record specify the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T060916Z" creationid="xccui" creationdate="20190615T060916Z">
        <seg>针对某记录所返回的一系列String值指定了该记录需要被发往哪些输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TaskMan&lt;t0/&gt;‐&lt;t1/&gt; agers take care of shipping data from sending tasks to receiving tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041011Z" creationid="xccui" creationdate="20190504T040910Z">
        <seg>TaskManager负载将数据从发送任务传输至接收任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TaskMan‐ agers take care of shipping data from sending tasks to receiving tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195332Z" creationid="xccui" creationdate="20190606T195324Z">
        <seg>TaskManager负责将数据从发送任务传输至接收任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TimerService and Timers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023114Z" creationid="xccui" creationdate="20190225T023114Z">
        <seg>TimerService和定时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TimerService of the Context and OnTimerContext objects offers the following methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T055620Z" creationid="xccui" creationdate="20190621T055620Z">
        <seg>Context和OnTimerContext对象中的TimerService提供了以下方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Trigger interface features a call‐ back method that is invoked when windows are merged to merge state that is associ‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T050617Z" creationid="xccui" creationdate="20190626T050313Z">
        <seg>Trigger接口有一个回调方法，会在对目标窗口的相关状态进行合并时被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Window Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023309Z" creationid="xccui" creationdate="20190225T023309Z">
        <seg>The Window Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The WindowAssigner determines for each arriving element to which windows it is assigned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041002Z" creationid="xccui" creationdate="20190626T041002Z">
        <seg>WindowAssigner用于决定将到来的元素分配给哪些窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The WindowAssigner returns zero, one, or multiple window objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033551Z" creationid="xccui" creationdate="20190626T033551Z">
        <seg>WindowAssigner会返回零个、一个或多个窗口对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The accumulator maintains a running sum and count and the getResult() method computes the average value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005407Z" creationid="xccui" creationdate="20190624T005407Z">
        <seg>其累加器负责维护不断变化的总和及数量，getResult()方法用来计算平均值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The advantages of applying ReduceFunction on a window are the constant and small state size per window and the simple function interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T001857Z" creationid="xccui" creationdate="20190624T001857Z">
        <seg>在窗口上应用ReduceFunction的优点是只需为每个窗口维护一个常数级别的小状态，此外函数的接口也很简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The algorithm does not pause the complete application but decouples checkpointing from processing, so that some tasks continue processing while others persist their state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T060010Z" creationid="xccui" creationdate="20190609T055752Z">
        <seg>该算法不会暂停整个应用，而是把生成检查点的过程和处理过程分离，这样在部分任务持久化状态的过程中，其他任务还可以继续执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The appli&lt;t0/&gt;‐&lt;t1/&gt; cation we are going to run converts and aggregates randomly generated temperature sensor readings by time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T055143Z" creationid="xccui" creationdate="20190328T054951Z">
        <seg>该应用会读取随机生成的温度传感器数值，并按时间对它们执行转换和聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application consists of a so- called JobGraph, a logical dataflow graph (see “Introduction to Dataflow Programming”), and a JAR file that bundles all the required classes, libraries, and other resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T055735Z" creationid="xccui" creationdate="20190606T141549Z">
        <seg>该应用会包含一个所谓的JobGraph，一个逻辑Dataflow图（见"Dataflow编程介绍"），以及一个打包了全部所需类、库以及其他资源的JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application consists of a so-called JobGraph, a logical dataflow graph (see &lt;t2/&gt;Chapter 2&lt;t3/&gt;), and a JAR file that bundles all required classes, libraries, and other resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T034834Z" creationid="xccui" creationdate="20190418T034254Z">
        <seg>该应用会包含一个所谓的JobGraph，一个逻辑dataflow图（见第2章），还有一个打包了全部所需类、库以及其他资源的JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application consists of two source tasks that each consume a stream of increasing numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061931Z" creationid="xccui" creationdate="20190609T061931Z">
        <seg>应用包含了两个数据源任务，每个任务都会各自消费一条自增数字流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application has a single source task that consumes a stream of increasing num‐ bers—1, 2, 3, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T030703Z" creationid="xccui" creationdate="20190609T030545Z">
        <seg>该应用有一个数据源任务，负责从一个递增数字（1、2、3……）流中读取数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application is depicted in Figure 3-19.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062323Z" creationid="xccui" creationdate="20190609T062323Z">
        <seg>图3-19描绘了该应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application logic to read from and write to state is often straightforward.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055248Z" creationid="xccui" creationdate="20190607T055148Z">
        <seg>应用读写状态的逻辑通常都很简单，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application receives the stream of temperature sensor readings you have seen previously and an additional stream of smoke level measurements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T035958Z" creationid="xccui" creationdate="20190615T035958Z">
        <seg>该应用会接收一条包含之前所见全部温度传感器读数的数据流，以及另外一条烟雾水平测量值数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application we are going to run converts and aggregates randomly generated temperature sensor readings by time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122633Z" creationid="xccui" creationdate="20190605T122633Z">
        <seg>该应用会读取随机生成的温度传感器数值，并按时间对它们执行转换和聚合操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application will replay (and fast for‐ ward) the input events from the event log until it reaches the tail of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T211749Z" creationid="esouser" creationdate="20190603T211749Z">
        <seg>随后应用会从事件日志中读取并（快速）重放输入事件，直到数据流末尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The applications are usually connected to external services or face human users and continuously process incoming events such as orders, or mails, or clicks on a website.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T162118Z" creationid="xccui" creationdate="20190226T162118Z">
        <seg>此类应用通常会连接外部服务或真人用户，并持续处理诸如订单、邮件、网站点击等传入的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The applications in Figure 1-5 are connected by event logs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T055745Z" creationid="esouser" creationdate="20190603T213929Z">
        <seg>图1-5中不同应用之间通过事件日志进行连接，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The applications in our example architecture are connected by event logs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T073244Z" creationid="xccui" creationdate="20190307T152633Z">
        <seg>示例架构中的应用通过事件日志进行连接，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application’s restart strategy determines how often the JobManager restarts the application and how long it waits between restart attempts.1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145716Z" creationid="xccui" creationdate="20190606T145556Z">
        <seg>应用的重启策略决定了JobManager以何种频率重启应用以及重启尝试之间的等待间隔。1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application’s restart strategy&lt;t0/&gt;2&lt;t1/&gt; determines how often the JobManager tries to restart the application and how long it waits between restart attempts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T210615Z" creationid="xccui" creationdate="20190428T210355Z">
        <seg>应用的重启策略决定了JobManager以何种频率尝试重启应用以及重启尝试之间的等待间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The architecture is depicted in &lt;t0/&gt;Figure 1-3&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194650Z" creationid="xccui" creationdate="20190228T194528Z">
        <seg>图1-3详细描绘了其架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignTimestampsAndWater marks(new SensorTimeAssigner) method assigns the timestamps and watermarks that are required for event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052108Z" creationid="xccui" creationdate="20190612T052108Z">
        <seg>assignTimestampsAndWatermarks(new SensorTimeAssigner)方法负责分配事件时间所需的时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assigner determines to which windows the element needs to be routed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052038Z" creationid="xccui" creationdate="20190625T051958Z">
        <seg>该分配器决定了元素应该被路由至哪（几）个窗口中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The batch processor periodically processes the data in batch storage, writes the exact results into a batch table, and drops the corre‐ sponding inaccurate results from the speed table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052357Z" creationid="xccui" creationdate="20190605T052246Z">
        <seg>批处理引擎周期性地处理批量存储的数据，将精确结果写入批处理表，随后将"提速表"中对应的非精确结果删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012714Z" creationid="xccui" creationdate="20190606T012714Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The book examples are provided as a Maven project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040502Z" creationid="xccui" creationdate="20190611T040502Z">
        <seg>书中的示例都是以Maven项目的形式提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The boolean condition is implemented as a function either using the FilterFunction interface or a lambda function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052627Z" creationid="xccui" creationdate="20190613T052627Z">
        <seg>可以利用FilterFunction接口或lambda函数来实现定义布尔条件的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The boundaries of session windows are defined by gaps of inactivity, time intervals in which no record is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060946Z" creationid="xccui" creationdate="20190623T060946Z">
        <seg>会话窗口的边界由非活动间隔，即没有收到记录的时间间隔来定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The broadcast state is discussed in detail in “Using Connected Broadcast State” on page 160.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210044Z" creationid="xccui" creationdate="20190615T053447Z">
        <seg>我们会在第160页"使用联结的广播状态"一节详细讨论该功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The broadcast strategy sends every data item to all parallel tasks of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045141Z" creationid="xccui" creationdate="20190605T233431Z">
        <seg>广播策略（broadcast strategy）会把数据项发往下游算子的全部并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The broadcast() method replicates the input data stream so that all events are sent to all parallel tasks of the downstream operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045756Z" creationid="xccui" creationdate="20190616T045756Z">
        <seg>broadcast()方法会将输入流中的事件复制并发往所有下游算子的并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The business logic is constrained by how much it can control state and time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T061822Z" creationid="xccui" creationdate="20190313T051256Z">
        <seg>其业务逻辑受制于系统对状态和时间的把控能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The cashier receives your payment and passes your order to the barista who prepares your beverage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T152916Z" creationid="xccui" creationdate="20190401T152703Z">
        <seg>收银员收到你的付款后会把订单交给帮你准备饮品的咖啡师。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The central class in Flink’s type system is TypeInformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T050145Z" creationid="xccui" creationdate="20190617T050145Z">
        <seg>Flink类型系统的核心类是TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The challenges of end-to-end exactly-once applications and approaches to address them are dis‐ cussed in detail in “Application Consistency Guarantees” on page 184.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T054457Z" creationid="xccui" creationdate="20190609T054457Z">
        <seg>有关端到端精确一次应用所面临的挑战和解决方案会在184页"应用一致性保障"一节详细讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkpoint barriers emitted by the source tasks are shipped to the connected tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T155503Z" creationid="xccui" creationdate="20190609T155503Z">
        <seg>数据源任务发出的检查点分隔符会传输到与之相连的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkpoint is complete when all tasks have finished their copies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224148Z" creationid="xccui" creationdate="20190608T224148Z">
        <seg>在所有任务完成自己的拷贝工作后，检查点生成完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The checkpointing interval is an important parameter that affects the overhead of the checkpointing mechanism during regular processing and the time it takes to recover from a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T205252Z" creationid="xccui" creationdate="20190702T205252Z">
        <seg>检查点间隔是影响常规处理期间检查点机制的开销以及故障恢复所需时间的一个重要参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The choice also affects the performance of a function because each state backend provides its own implementations for these primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T041207Z" creationid="xccui" creationdate="20190630T041207Z">
        <seg>同时，由于每个状态后端都为这些原语提供了自己的实现，该选择还会影响函数的性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The choice of the right state primitive depends on how the function interacts with the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T040955Z" creationid="xccui" creationdate="20190630T040955Z">
        <seg>状态原语的选择取决于函数同状态的交互方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The choice of the state backend has implications on the robust‐ ness and performance of a stateful application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221454Z" creationid="xccui" creationdate="20190703T221454Z">
        <seg>状态后端的选择会影响状态化应用的鲁棒性及性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The clean-up time is computed by adding one hour to the timestamp of the current record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T212741Z" creationid="xccui" creationdate="20190704T212741Z">
        <seg>清理时间被设置为比当前记录时间晚一小时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The close() method is a finalization method for the function and it is called once per task after the last call of the transformation method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033120Z" creationid="xccui" creationdate="20190619T033120Z">
        <seg>close()作为函数的终止方法会在每个任务的转换方法调用结束后调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code examples of the book use Maven build manage‐ ment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T030150Z" creationid="xccui" creationdate="20190611T020420Z">
        <seg>书中示例代码都是使用Maven来构建管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code examples of this book are hosted on GitHub.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T035214Z" creationid="xccui" creationdate="20190611T035214Z">
        <seg>本书的示例代码托管在GitHub上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in Example 6-15 creates a cus‐ tom assigner for 30-second tumbling event-time windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042251Z" creationid="xccui" creationdate="20190626T042251Z">
        <seg>示例6-15中的代码为每30秒的滚动事件时间窗口创建了一个自定义分配器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in Example 6-2 shows how to use a timestamp assigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T033319Z" creationid="xccui" creationdate="20190620T033319Z">
        <seg>示例6-2中的代码展示了时间戳分配器的使用方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in Examples 6-13 and 6-14 shows how to solve the same use case as the code in Example 6-12 with a combination of a ReduceFunction and a Pro cessWindowFunction, emitting every 5 seconds the minimun and maximum temper‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045450Z" creationid="xccui" creationdate="20190625T043225Z">
        <seg>示例6-13和6-14中的代码展示了如何使用ReduceFunction和ProcessWindowFunction的组合来应对示例6-12中相同的用例——</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The completed checkpoint can be used to recover the appli‐ cation from a failure as described before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194512Z" creationid="xccui" creationdate="20190609T194447Z">
        <seg>如前所述，应用在发生故障时就可以利用这个生成好的检查点进行恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connect transformation and the cofunctions discussed in this section are more generic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045206Z" creationid="xccui" creationdate="20190615T045206Z">
        <seg>本节讨论的connect转换以及协处理函数通用性更强。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constructed plan is translated into a JobGraph and submitted to a JobManager for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T012200Z" creationid="xccui" creationdate="20190613T012055Z">
        <seg>构建完的计划会被转成JobGraph并提交至JobManager执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The content of the window is completely discarded and the window including all metadata is removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184909Z" creationid="xccui" creationdate="20190626T184757Z">
        <seg>完全清除窗口内容，并删除窗口自身及其元数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corre‐ sponding FlatMapFunction defines the flatMap() method, which may return zero, one, or more events as results by passing them to the Collector object:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T061011Z" creationid="xccui" creationdate="20190613T055004Z">
        <seg>对应的FlatMapFunction定义了flatMap()方法，可以通过向Collector对象中传递数据的方式返回零个、一个或多个事件作为结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data that is stored in the various transactional database systems of a company can provide valuable insights about a company’s business operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T024400Z" creationid="esouser" creationdate="20190603T201131Z">
        <seg>存储于不同事务型数据库系统中的数据，可以为公司提供业务运营相关的分析见解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data that is stored in the various transactional database systems of a company can provide valuable insights about various aspects of the company’s business.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T191929Z" creationid="xccui" creationdate="20190228T173220Z">
        <seg>存储于公司多个事务型数据库系统中的数据，可以为公司业务提供各个方面的宝贵见解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data type must be specified because</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T071400Z" creationid="xccui" creationdate="20190630T071033Z">
        <seg>由于Flink需要为状态创建合适的序列化器，因此数据类型指定是强制的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data types handled by the state are specified as Class or TypeInformation objects (see “Types” on page 97 for a discussion of Flink’s type handling).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T070936Z" creationid="xccui" creationdate="20190630T070936Z">
        <seg>状态处理的数据类型可以通过Class或TypeInformation对象指定（有关Flink类型处理的讨论请参见第97页的"类型"一节）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data written to the batch storage is periodically processed by a batch processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T045024Z" creationid="xccui" creationdate="20190322T045655Z">
        <seg>而批处理引擎会定期处理数据并将结果写入批量存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045718Z" creationid="xccui" creationdate="20190620T045718Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default maximum parallelism of an operator depends on the operator’s parallel‐ ism in the application’s first version:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025347Z" creationid="xccui" creationdate="20190703T025347Z">
        <seg>算子的默认最大并行度会取决于应用首个版本中算子的并行度：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default parallelism of an operator can be overridden by specifying it explicitly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060553Z" creationid="xccui" creationdate="20190616T060553Z">
        <seg>可以通过显式指定来覆盖算子的默认并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The descriptors for ReducingState and AggregatingState also need a ReduceFunction or AggregateFunction object to aggregate the added</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T065722Z" creationid="xccui" creationdate="20190630T065617Z">
        <seg>ReducingState和AggregatingState的描述符（descriptor）还需要接收一个ReduceFunction或AggregateFunction对象，以此来对加入的值进行聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dis&lt;t6/&gt;‐&lt;t7/&gt; patcher also runs a web dashboard to provide information about job executions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T024218Z" creationid="xccui" creationdate="20190423T024218Z">
        <seg>Dispatcher同时还会启动一个web仪表盘，用来提供有关作业执行的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dispatcher also runs a web dashboard to provide information about job executions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201540Z" creationid="xccui" creationdate="20190606T142935Z">
        <seg>Dispatcher同时还会启动一个Web UI，用来提供有关作业执行的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The easiest way to handle late events is to simply discard them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T153552Z" creationid="xingcan" creationdate="20190628T153520Z">
        <seg>处理迟到事件最简单的方式就是直接将其丢弃，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The embedded execution mode starts an application and the whole Flink system in a single JVM process, which can be used to run and debug Flink jobs within an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T200520Z" creationid="xccui" creationdate="20190605T121832Z">
        <seg>Flink的嵌入式执行模式可将应用自身连同整个Flink系统在单个JVM进程内启动，方便从IDE里运行和调试Flink作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end timestamp of GlobalWindows is Long.MAX_VALUE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044811Z" creationid="xccui" creationdate="20190626T044725Z">
        <seg>GlobalWindows的结束时间戳是Long.MAX_VALUE，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end-to- end consistency of the application depends on the integration of the chosen stream sinks with Flink’s checkpointing algorithm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005721Z" creationid="xccui" creationdate="20190613T005721Z">
        <seg>该一致性取决于所选数据汇和Flink检查点算法的集成情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event log decouples senders and receivers and provides asynchronous, non-blocking event transfer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T072837Z" creationid="xccui" creationdate="20190308T072837Z">
        <seg>事件日志将发送端和接收端解耦，并提供异步非阻塞的事件传输机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event log decouples senders and receivers and provides asynchro‐ nous, nonblocking event transfer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T214042Z" creationid="esouser" creationdate="20190603T214042Z">
        <seg>事件日志将发送端和接收端解耦，并提供异步非阻塞的事件传输机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event log pub&lt;t0/&gt;‐&lt;t1/&gt; lishes the changes to consumers that incorporate the updates into the affected data stores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062519Z" creationid="xccui" creationdate="20190314T072026Z">
        <seg>事件日志系统将改动发布给消费者，再由消费者将更新整合到相关数据存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The event-time clocks of a task with two input streams will corre‐ spond to the watermarks of the slower stream and usually the records or intermediate results of the faster stream are buffered in state until the event-time clock allows pro‐ cessing them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033418Z" creationid="xccui" creationdate="20190607T033418Z">
        <seg>对于一个有两个输入流的任务而言，其事件时间时钟会受制于那个相对较慢的流，而较快流的记录或中间结果会缓存在状态中，直到事件时间时钟到达允许处理它们的那个点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The events are merged in a FIFO fashion—the operator does not produce a specific order of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064745Z" creationid="xccui" creationdate="20190614T064449Z">
        <seg>执行过程中事件会以FIFO的方式合并，其顺序无法得到任何保证。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The events of the nonbroadcasted stream are simply forwarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T052035Z" creationid="xccui" creationdate="20190615T052015Z">
        <seg>而所有非广播流的事件只是会被简单地转发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The evictBefore() and evictAfter() methods are called before and after a window function is applied on the content of a window, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203253Z" creationid="xccui" creationdate="20190627T202249Z">
        <seg>evictBefore()和evictAfter()方法分别会在窗口函数作用于窗口内容之前和之后调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The evictor is an optional component that can be injected before or after a Process WindowFunction is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201552Z" creationid="xccui" creationdate="20190625T214328Z">
        <seg>移除器作为一个可选组件，允许在ProcessWindowFunction调用前或后注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact results are written into a batch table and the corresponding inaccurate results from the speed table are dropped.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032903Z" creationid="xccui" creationdate="20190322T051608Z">
        <seg>在精确结果写入批处理表后，"提速表"中对应的非精确结果就可以删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example application emits an alert event if the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061945Z" creationid="xccui" creationdate="20190630T061945Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execu&lt;t5/&gt;‐&lt;t6/&gt; tion of tasks and the concept of slots is discussed in more detail in a later section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062139Z" creationid="xccui" creationdate="20190418T052505Z">
        <seg>我们将在随后一节更详细讨论任务执行和处理槽的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051339Z" creationid="xccui" creationdate="20190612T051339Z">
        <seg>The execution</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execution environment determines whether the program is running on a local machine or on a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044916Z" creationid="xccui" creationdate="20190612T044916Z">
        <seg>执行环境决定了应用是在本地机器上还是集群上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execu‐ tion of tasks and the concept of slots is discussed in “Task Execution”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142745Z" creationid="xccui" creationdate="20190606T142726Z">
        <seg>我们将在"任务执行"一节进一步讨论任务执行和处理槽的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expressiveness of the API and the quality of state handling and event-time support determine the business logic that can be implemented and exe‐ cuted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T074408Z" creationid="xccui" creationdate="20190604T052839Z">
        <seg>API的表达能力以及对状态处理和事件时间的支持水平等诸多因素决定了可以实现和执行的业务逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The extracted timestamps are assigned to the respective record and the queried watermarks are ingested into the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T035457Z" creationid="xccui" creationdate="20190607T035446Z">
        <seg>提取出来的时间戳会附加到各自的记录上，查询得到的水位线会注入到数据流中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure shows four sender and four receiver tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T044155Z" creationid="xccui" creationdate="20190504T044155Z">
        <seg>其中包含了4个发送端和4个接收端任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filter transformation drops or forwards events of a stream by evaluating a boolean condition on each input event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T051901Z" creationid="xccui" creationdate="20190613T051252Z">
        <seg>Filter转换利用一个作用在每条输入事件上的布尔条件来决定流中事件的去存，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first field is a list of the flatMap results, and the second field is the new value of the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T035014Z" creationid="xccui" creationdate="20190701T035014Z">
        <seg>其中第一个字段是flatMap的结果列表，第二个字段是新的状态值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first field of the SensorReading is a sensorId, the second field is the time‐ stamp in milliseconds since 1970-01-01-00:00:00.000, and the third field is an average temperature computed over 5 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124114Z" creationid="xccui" creationdate="20190605T123948Z">
        <seg>SensorReading的第一个字段是sensorId，第二个字段是用自1970-01-01-00:00:00.000以来的毫秒数所表示的时间戳，第三个字段是每隔5秒计算出的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first field of the tuple holds the input record to flatMap, and the second field holds an Option of the retrieved state for the key of the processed record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T034047Z" creationid="xccui" creationdate="20190701T034040Z">
        <seg>参数元组的第一个字段是flatMap的输入记录；第二个字段是一个Option对象，其中保存了针对当前记录键值的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first generation of distributed open source stream processors (2011) focused on event processing with millisecond latencies and provided guarantees against loss of events in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T192923Z" creationid="xccui" creationdate="20190605T050830Z">
        <seg>第一代开源分布式流处理引擎（2011年）专注于以毫秒级延迟处理数据并保证系统故障时事件不会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first generation of distributed open source stream processors (2011) that got sub&lt;t0/&gt;‐&lt;t1/&gt; stantial adoption focused on event processing with millisecond latencies and pro&lt;t2/&gt;‐&lt;t3/&gt; vided guarantees that events would never be lost in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T050636Z" creationid="xccui" creationdate="20190322T040934Z">
        <seg>第一代开源分布式流处理引擎（2011年）专注于以毫秒级延迟处理数据并保证系统出错时事件不会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first interface defines assigners that emit watermarks periodically while the second injects watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045249Z" creationid="xccui" creationdate="20190620T045145Z">
        <seg>前者定义的分配器会周期性地发出水位线，而后者会根据输入事件的属性来引入水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first thing a Flink application needs to do is set up its execution environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044646Z" creationid="xccui" creationdate="20190612T044646Z">
        <seg>Flink应用要做的第一件事就是设置执行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first type are periodic report queries that compute business relevant statistics such as revenue, user growth, or production output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T193927Z" creationid="xccui" creationdate="20190228T193139Z">
        <seg>第一类是定期报告查询，用于计算业务相关的统计信息，如收入、用户增长、产出等，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flatMap transformation applies a function on each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T055027Z" creationid="xccui" creationdate="20190613T054855Z">
        <seg>flatMap转换会针对每个到来事件应用一个函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flatMap transformation is similar to map, but it can produce zero, one, or more output events for each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053414Z" creationid="xccui" creationdate="20190613T053414Z">
        <seg>flatMap转换类似于map，但它可以对每个到来事件产生零个、一个或多个输出事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flatMapWithState() method expects a function that accepts a Tuple2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T032420Z" creationid="xccui" creationdate="20190701T032420Z">
        <seg>调用flatMapWithState()方法时需要提供一个参数为Tuple2的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The folder contains a file flink-scala-project-0.1.jar, which is the JAR file of your Flink application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010603Z" creationid="xccui" creationdate="20190612T010603Z">
        <seg>该文件夹里会有一个flink-scala-project-0.1.jar文件，也就是你Flink应用的JAR包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code declares the id field as the key of a stream of SensorReading records:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051701Z" creationid="xccui" creationdate="20190614T051701Z">
        <seg>以下代码针对SensorReading记录流将其中的id字段声明为键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how to apply a KeyedProcessFunction to a KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T070648Z" creationid="xccui" creationdate="20190621T070648Z">
        <seg>以下代码展示了如何将KeyedProcessFunction用在一个KeyedStream上面：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how to define a window operator with a custom trigger and evictor:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014836Z" creationid="xccui" creationdate="20190626T014836Z">
        <seg>以下代码展示了如何使用自定义触发器和移除器来定义窗口算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how to define event-time and processing-time tumbling windows on a stream of sensor data measurements:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042900Z" creationid="xccui" creationdate="20190623T042900Z">
        <seg>以下代码展示了如何在一个传感数据测量流上定义事件时间和处理时间滚动窗口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how to group the sensor readings in sliding windows of 1 hour size with a 15-minute slide interval.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055645Z" creationid="xccui" creationdate="20190623T055634Z">
        <seg>以下代码展示了如何将传感器读数按照大小为1小时、滑动间隔为15分钟的滑动窗口进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how to specify a window assigner and a window function on a keyed or nonkeyed stream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041304Z" creationid="xccui" creationdate="20190622T041304Z">
        <seg>以下代码展示了如何在一个键值分区或非键值分区流上指定窗口分配器和窗口函数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows the interface of the ProcessWindowFunction:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010446Z" creationid="xccui" creationdate="20190624T010446Z">
        <seg>以下代码展示了ProcessWindowFunction接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows win‐ dows with an offset of 15 minutes that start at 00:15:00, 01:15:00, 02:15:00, and so on:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054422Z" creationid="xccui" creationdate="20190623T054422Z">
        <seg>以下代码展示了偏移量为15分钟的窗口，它们将从00:15:00、01:15:00、02:15:00……时间点开始：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example code shows how to use the methods of a RichFlat MapFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034214Z" creationid="xccui" creationdate="20190619T033912Z">
        <seg>示例5-3展示了如何使用RichFlatMapFunction中的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example fil‐ ters a DataStream of tuples with two fields:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070849Z" creationid="xccui" creationdate="20190616T070849Z">
        <seg>以下示例对于一个双字段元组的DataStream进行过滤处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example keys the input stream by the second field of the input tuple:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T041329Z" creationid="xccui" creationdate="20190618T033243Z">
        <seg>下方示例以输入元组的第2个字段作为输入流的键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example partitions a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050622Z" creationid="xccui" creationdate="20190616T050622Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example show a lambda function that filters tweets contain‐ ing the word “flink”:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055838Z" creationid="xccui" creationdate="20190618T055838Z">
        <seg>下面示例中的lambda函数会过滤出所有包含"flink"一词的推文：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows a MapFunction that provides its return type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061907Z" creationid="xccui" creationdate="20190617T061907Z">
        <seg>下面的例子展示了一个提供返回类型的MapFunction：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows a filter that drops all sensor measurements with tem‐ perature below 25°F:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053205Z" creationid="xccui" creationdate="20190613T053205Z">
        <seg>下方示例所展示的filter会丢弃所有温度低于25°F的传感器测量值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows how to update a field of a Java tuple:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040456Z" creationid="xccui" creationdate="20190617T040456Z">
        <seg>下面的例子展示了如何对Java元组的字段进行更新：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following examples show how to group the sensor readings into session windows where each session is defined by a 15-minute period of inactivity:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061426Z" creationid="xccui" creationdate="20190623T061426Z">
        <seg>以下示例展示了如何将传感器读数按照会话窗口进行分组，其中每个会话的非活动时间都设置为15分钟：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following expression accesses the field of a tuple nested in a POJO:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050556Z" creationid="xccui" creationdate="20190618T050556Z">
        <seg>下方表达式用于访问嵌套在POJO中某一元组的字段：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following is a simple mapper that extracts the first field (id) of each SensorRead ing in the input stream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050710Z" creationid="xccui" creationdate="20190613T050710Z">
        <seg>下面是一个简单的映射器，它会提取输入流中的每个SensorReading记录的第一个字段（id）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following shows how to generate watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051947Z" creationid="xccui" creationdate="20190620T051912Z">
        <seg>下方展示了如何对递增时间戳生成水位线：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following shows how to union three streams of type SensorReading into a single stream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064843Z" creationid="xccui" creationdate="20190614T064837Z">
        <seg>以下示例展示了如何将三条类型为SensorReading的数据流合并为一条：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following shows the WindowAssigner interface:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041550Z" creationid="xccui" creationdate="20190626T041550Z">
        <seg>以下就是WindowAssigner接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following state primitives are supported by Flink:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T041221Z" creationid="xccui" creationdate="20190630T041221Z">
        <seg>Flink目前支持以下状态原语：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following typographical conventions are used in this book:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210759Z" creationid="esouser" creationdate="20190603T210759Z">
        <seg>The following typographical conventions are used in this book:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The follow‐ ing code shows the interface of the AggregateFunction:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T003526Z" creationid="xccui" creationdate="20190624T003526Z">
        <seg>以下代码展示了AggregateFunction的接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fol‐ lowing code shows how to use this shortcut:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T053713Z" creationid="xccui" creationdate="20190623T053713Z">
        <seg>以下代码展示了如何使用这种简写：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fol‐ lowing steps show you how to start a local Flink cluster and submit an application for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201033Z" creationid="xccui" creationdate="20190605T123013Z">
        <seg>启动本地Flink集群并提交应用到上面执行的步骤如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forward and random strategies as key-based</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T140502Z" creationid="xccui" creationdate="20190401T140430Z">
        <seg>转发和随机策略同样基于键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forward strategy and the random strategy can also be viewed as variations of the key-based strategy, where the first preserves the key of the upstream tuple while the latter performs a random re-assignment of keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T142138Z" creationid="xccui" creationdate="20190401T140443Z">
        <seg>转发策略和随机策略也可以看做基于键值策略的变种，前者保留了上游元组的键值，后者会随机分配键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forward strategy sends data from a task to a receiving task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233408Z" creationid="xccui" creationdate="20190605T233408Z">
        <seg>转发策略（forward strategy）在发送端任务和接收端任务之间进行一对一的数据传输。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The framework style follows the traditional approach of submitting an application (or query) via a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T063832Z" creationid="xccui" creationdate="20190606T144133Z">
        <seg>基于框架的模式采用的是传统方式，即通过客户端提交应用（或查询）到正在运行的服务上；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The framework style is follows the traditional approach of submitting an application (or query) via a client to a running service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T040741Z" creationid="xccui" creationdate="20190423T040646Z">
        <seg>基于框架的模式遵循传统方式，即通过客户端提交应用（或查询）到正在运行的服务上；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function also returns a Tuple2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T034935Z" creationid="xccui" creationdate="20190701T034935Z">
        <seg>该函数同样会返回一个Tuple2对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function can be specified with a class that implements the ReduceFunction inter‐ face.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061729Z" creationid="xccui" creationdate="20190614T061729Z">
        <seg>reduce转换的函数可以通过一个实现了ReduceFunction接口的类来指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function in the above example counts per parallel instance how many tempera‐ ture measurements exceeded a configured threshold.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T053354Z" creationid="xccui" creationdate="20190701T053354Z">
        <seg>上述例子中的函数会统计每个并行实例中超过阈值的温度值数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function interface defines the transformation method that needs to be imple‐ mented by the user, such as the map() method in the example above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T021057Z" creationid="xccui" creationdate="20190613T020932Z">
        <seg>函数接口规定了用户需要实现的转换方法，例如上面例子中的map()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function is applied on a stream of sentences, splits each sentence by the space character, and emits each resulting word as an individual record:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T062259Z" creationid="xccui" creationdate="20190613T061921Z">
        <seg>这个函数会作用于一个语句流上，将每个句子按照空格字符分割，然后把分割得到的每个单词作为一条独立的记录发出去：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function is called for each record of the stream and returns zero, one, or more records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053136Z" creationid="xccui" creationdate="20190621T053136Z">
        <seg>该函数会针对流中的每条记录调用一次，并返回零个、一个或多个记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function monitors the temperatures of sensors and emits a warning if the tem‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T070743Z" creationid="xccui" creationdate="20190621T070743Z">
        <seg>该函数对传感器温度进行监测，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function that applies the rules ingests two input streams, the event stream and the rules stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T203028Z" creationid="xccui" creationdate="20190701T203028Z">
        <seg>规则应用函数需要同时接收这两条输入流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function uses operator state and has a single state variable for each parallel operator instance that is checkpointed</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T053909Z" creationid="xccui" creationdate="20190701T053909Z">
        <seg>它其中用到了算子状态，该状态会为每个并行算子实例保存一个状态变量并通过ListCheckpointed接口定义的方法创建检查点和进行恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions encapsulate the user application logic and define how the elements of the input stream are transformed into the elements of the output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T014237Z" creationid="xccui" creationdate="20190613T014237Z">
        <seg>这些函数封装了用户应用逻辑，定义了输入流的元素如何转换为输出流的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions of the operators are fused into a single task that is executed by a single thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T201014Z" creationid="xccui" creationdate="20190606T203546Z">
        <seg>多个算子的函数被"融合"到同一个任务中，在同一个线程内执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions of the&lt;t1/&gt; &lt;t2/&gt;operators are fused into a single task which is executed by a single thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T153708Z" creationid="esouser" creationdate="20190514T152833Z">
        <seg>算子里的函数被揉到同一个任务中，在一个线程里执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions that offer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T204318Z" creationid="xccui" creationdate="20190704T204318Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fundamental difference between rebalance() and rescale() lies in the way task connections are formed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T044140Z" creationid="xccui" creationdate="20190616T044140Z">
        <seg>rebalance()和rescale()的本质不同体现在生成任务连接的方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fundamental mode of operation - batch processing - is the same regardless whether the architecture is based on a data ware&lt;t2/&gt;‐&lt;t3/&gt; house or components of the Hadoop ecosystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T030601Z" creationid="xccui" creationdate="20190317T030601Z">
        <seg>基本操作模式（批处理）对基于数据仓库或Hadoop生态组件的架构，都是都是完全相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generated pom.xml file also contains instructions on how to add new dependencies to your project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010743Z" creationid="xccui" creationdate="20190612T010743Z">
        <seg>生成的pom.xml文件里还包含一些如何往项目中添加其他依赖的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The gen‐ erated folder contains a src/ folder and a pom.xml file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005659Z" creationid="xccui" creationdate="20190612T005652Z">
        <seg>生成的文件夹内包含了一个src/目录和一个pom.xml文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The getter and setter functions must follow the default naming scheme, which is Y getX() and setX(Y x) for a field x of type Y.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044510Z" creationid="xccui" creationdate="20190617T044510Z">
        <seg>这些方法需要遵循默认的命名模式，即对于Y类型的x字段方法头分别为Y getX()和setX(Y x)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The global() method sends all events of the input data stream to the first paral‐ lel task of the downstream operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045845Z" creationid="xccui" creationdate="20190616T045845Z">
        <seg>global()方法会将输入流中的所有事件发往下游算子的第一个并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The goal of this chapter is to introduce the fundamental concepts of stream process‐ ing and the requirements of its frameworks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T042658Z" creationid="xccui" creationdate="20190605T224706Z">
        <seg>通过本章，我们旨在介绍流处理的基础概念及其处理框架的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The handle does not hold the state itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T021003Z" creationid="xccui" creationdate="20190701T021003Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iden‐ tifiers are written into a savepoint as metadata with the actual state data of an opera‐ tor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015428Z" creationid="xccui" creationdate="20190703T015428Z">
        <seg>该标识会作为元数据和算子的实际状态一起写入保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The idle mechanism of sources can be used to address the problem of not advancing watermarks as discussed earlier.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T034838Z" creationid="xccui" creationdate="20190607T034838Z">
        <seg>数据源空闲声明机制可以用来解决上面提到的水位线不向前推进的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The image also includes the code to run a JobManager and ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T030328Z" creationid="xccui" creationdate="20190423T030328Z">
        <seg>映像中还包含着运行JobManager以及ResourceManager的代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation details of SensorTimeAssigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052836Z" creationid="xccui" creationdate="20190612T052147Z">
        <seg>现在无须关心SensorTimeAssigner的实现细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of a ReadingFilter function that dynamically filters a stream of sensor readings based on a stream of filter switches is shown in Example 6-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031929Z" creationid="xccui" creationdate="20190622T031929Z">
        <seg>示例6-9给出了ReadingFilter函数的实现，它基于过滤开关数据流对传感器读数流进行动态过滤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of the TempIncreaseAlterFunction is shown in Example 6-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071207Z" creationid="xccui" creationdate="20190621T071207Z">
        <seg>示例6-5给出了TempIncreaseAlterFunction的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The import steps are similar for most IDEs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040757Z" creationid="xccui" creationdate="20190611T040757Z">
        <seg>大多数IDE的导入步骤都很类似，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The importance of state becomes even more evident if we consider the case of using a batch processing system to analyze an unbounded data set.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053157Z" creationid="xccui" creationdate="20190414T053157Z">
        <seg>如果考虑使用批处理系统分析有限数据集的情况，那么状态的重要性就越发明显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The importance of state becomes even more evident if we consider the case of using a batch processing system to analyze an unbounded dataset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031746Z" creationid="xccui" creationdate="20190606T031623Z">
        <seg>在使用批处理系统分析有限数据集的情况下，状态的重要性会越发凸显。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ingestion time of an event is the time it entered the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T035807Z" creationid="xccui" creationdate="20190619T071759Z">
        <seg>事件的摄入时间是它进入流处理引擎的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializeState() method is called when a par‐ allel instance of CheckpointedFunction is created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T064300Z" creationid="xccui" creationdate="20190702T064300Z">
        <seg>initializeState()方法会在创建CheckpointedFunction的并行实例时调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interface defines an input type, IN, an accumulator of type ACC, and a result type OUT.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005027Z" creationid="xccui" creationdate="20190624T005027Z">
        <seg>该接口定义了输入类型IN，累加器类型ACC以及结果类型OUT。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interface pro‐ vides two methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T040549Z" creationid="xccui" creationdate="20190701T040549Z">
        <seg>ListCheckpointed接口提供了两个方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interval join currently only supports event time and operates with INNER JOIN</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025409Z" creationid="xccui" creationdate="20190628T025409Z">
        <seg>基于间隔的Join目前只支持事件时间以及INNER JOIN语义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interval join joins events from two streams that have a common key and that have timestamps not more than specified intervals apart from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T211758Z" creationid="xccui" creationdate="20190627T211758Z">
        <seg>基于间隔的Join会对两条流中拥有相同键值以及彼此之间时间戳不超过某一指定间隔的事件进行Join。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The introductory example actually uses a simple KeySelector function in the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051741Z" creationid="xccui" creationdate="20190618T051634Z">
        <seg>开篇示例其实就是在keyBy()方法中使用了一个简单的KeySelector函数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iterator returned by get() returns an Iterable with a single entry, which is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061108Z" creationid="xccui" creationdate="20190630T060432Z">
        <seg>ReducingState.get()方法返回的Iterable对象只有一个条目，即聚合后的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The join in Figure 6-7 stores all records with timestamps larger than the current watermark—15 minutes from stream A—and all records with timestamps larger than the current watermark—one hour from stream B. You should be aware that the storage requirements of the interval join may significantly increase if the event time of both input streams is not synchronized because the watermark is deter‐ mined by the “slower” stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T034102Z" creationid="xccui" creationdate="20190628T034102Z">
        <seg>图6-7中的Join需要存储数据流A中所有时间戳大于当前水位线减去15分钟的记录，以及数据流B中所有时间戳大于当前水位线减去1小时的记录。你应该明白，如果两条流的事件时间不同步，那么Join所需的存储就会显著增加，因为水位线总是由"较慢"的那条流来决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The join interval is symmetric, i.e., an event from B joins with all events from A that are no more than 15 minutes earlier and at most one hour later than the B event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025002Z" creationid="xccui" creationdate="20190627T214134Z">
        <seg>Join间隔具有对称性，因此上面的条件也可以表示为A中事件的时间戳相较B中事件的时间戳不早于15分钟且不晚于1小时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key and value of the map can be of arbitrary type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T221809Z" creationid="xccui" creationdate="20190607T221757Z">
        <seg>该映射的键和值可以是任意类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key does not necessarily have to be a field of the input event but can be derived using arbitrary computations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052030Z" creationid="xccui" creationdate="20190618T052030Z">
        <seg>这个键值不一定非要是输入事件中的一个字段，而是可以经由任意计算得来的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key-based strategy partitions data by a key attribute and guarantees that data items having the same key will be processed by the same task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T045240Z" creationid="xccui" creationdate="20190605T233508Z">
        <seg>基于键值的策略（key-based strategy）根据某一键值属性对数据分区，并保证键值相同的数据项会交由同一任务处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyBy transformation converts a DataStream into a KeyedStream by specifying a key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050208Z" creationid="xccui" creationdate="20190614T050208Z">
        <seg>keyBy转换通过指定键值的方式将一个DataStream转化为KeyedStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyBy() method receives an argument that specifies the key (or keys) to group by and returns a KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051446Z" creationid="xccui" creationdate="20190614T051446Z">
        <seg>keyBy()方法接收一个用来指定分区键值（可以是多个）的参数，返回一个KeyedStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyed state instances of a function are distributed across all parallel tasks of the function’s operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T035709Z">
        <seg>函数的键值分区状态实例会分布在函数算子的所有并行任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda architecture</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051834Z" creationid="xccui" creationdate="20190605T051834Z">
        <seg>Lambda架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda architecture augments the traditional periodic batch processing architec‐ ture with a speed layer that is powered by a low-latency stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193331Z" creationid="xccui" creationdate="20190605T051842Z">
        <seg>Lambda架构在传统周期性批处理架构的基础上添加了一个由低延迟流处理引擎所驱动的"提速层"（speed layer）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda architecture is no longer state of the art, but is still used in many places.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T052742Z" creationid="xccui" creationdate="20190605T052742Z">
        <seg>虽然Lambda架构已经算不上最先进，但仍在许多地方使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda function r =&gt; r.id extracts the id field of a sensor reading r.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051842Z" creationid="xccui" creationdate="20190614T051803Z">
        <seg>lambda函数r =&gt; r.id表示从传感器读数r中提取id字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lambda reduce function forwards the first tuple field (the key field) and concate‐ nates the List[String] values of the second tuple field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062552Z" creationid="xccui" creationdate="20190614T062552Z">
        <seg>用于reduce的lambda函数会直接转发第1个字段（键值字段），而将所有第2个字段中的List[String]值连接合并起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latter decision is based on a trigger condition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022846Z" creationid="xccui" creationdate="20190406T045549Z">
        <seg>其中参与计算的决策会根据触发条件判定，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list entries can be of arbitrary type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T220045Z" creationid="xccui" creationdate="20190607T220045Z">
        <seg>列表中的条目可以是任意类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The live updated results of a streaming analytics application can be used to power dashboard applications as shown in Figure 1-6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155543Z" creationid="xccui" creationdate="20190605T044552Z">
        <seg>如图1-6所示，流式分析应用实时更新的结果可用于支撑仪表盘应用的展示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The live updated results of a streaming analytics applications can be used to power dashboard applications as shown in &lt;t8/&gt;Figure 1-6&lt;t9/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062117Z" creationid="xccui" creationdate="20190317T061352Z">
        <seg>如图1-6所示，流式分析应用的实时更新结果可以支撑表盘应用的展示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The logic of an application is defined by chaining transformations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053100Z" creationid="xccui" creationdate="20190612T052904Z">
        <seg>应用的逻辑是通过一系列转换来定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lower and upper bounds are defined as negative and positive time intervals, for example, as between(Time.hour(-1), Time.minute(15)).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T030211Z" creationid="xccui" creationdate="20190628T030211Z">
        <seg>下界和上界分别由负时间间隔和正时间间隔来定义，例如between(Time.hour(-1), Time.minute(15))。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lower and upper bounds can be arbitrarily chosen as long as the lower bound is smaller than the upper bound; you</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T030743Z" creationid="xccui" creationdate="20190628T030705Z">
        <seg>在满足下界值小于上界值的前提下，你可以任意对它们赋值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main take-away here is that lowering latency actually increases throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T211801Z" creationid="xccui" creationdate="20190402T211645Z">
        <seg>这里的要点就是降低延迟实际上可以提高吞吐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main takeaway here is that lowering latency increases throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054722Z" creationid="xccui" creationdate="20190605T235620Z">
        <seg>此处的要点就是：降低延迟实际上可以提高吞吐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The map transformation is specified by calling the DataStream.map() method and produces a new DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T044734Z" creationid="xccui" creationdate="20190613T042736Z">
        <seg>通过调用DataStream.map()方法可以指定map转换产生一个新的DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum parallelism can be set for all operators of an applica‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024952Z" creationid="xccui" creationdate="20190703T024952Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum parallelism parameter of an operator defines the number of key groups into which the keyed state of the operator is split.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024348Z" creationid="xccui" creationdate="20190703T024348Z">
        <seg>算子的最大并行度参数定义了算子在对键值状态进行分割时所用到的键值组（key group）的数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mechanism is similar to buffering techniques used in networking or disk IO pro&lt;t2/&gt;‐&lt;t3/&gt; tocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041925Z" creationid="xccui" creationdate="20190504T041925Z">
        <seg>其机制和网络以及磁盘IO协议中的缓冲技术很像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mechanism is similar to the buffering techniques used in networking or disk I/O protocols.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T191311Z" creationid="xccui" creationdate="20190606T195538Z">
        <seg>它的机制类似于网络以及磁盘I/O协议中的缓冲技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The metadata of the window typically contains information that can be used</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023219Z" creationid="xccui" creationdate="20190624T011756Z">
        <seg>窗口的元数据通常包含了一些可用作窗口标识的信息，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method clears all state associated with the key, the last temperature and the last timer state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T213923Z" creationid="xccui" creationdate="20190704T213923Z">
        <seg>该回调方法会清除所有当前键值的状态，包括用于保存最近一次温度以及前一个计时器时间的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method distributes records randomly according to a uniform distribution to the parallel tasks of the following operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T071043Z" creationid="xccui" creationdate="20190615T071043Z">
        <seg>该方法会依照均匀分布随机地将记录发往后继算子的并行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method has to return</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T050302Z" creationid="xccui" creationdate="20190701T050302Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method has two parameters, checkpointId, which is a unique, monotonically increasing identifier for checkpoints, and timestamp, which is the wall-clock time when the master initiated the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023229Z" creationid="xccui" creationdate="20190701T050128Z">
        <seg>它接收两个参数：checkpointId是一个针对检查点的唯一且单调递增的标识，timestamp是JobManager开始创建检查点的机器时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method is called with a FunctionInitializationContext object that provides access to an Operator StateStore and a KeyedStateStore object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T064758Z" creationid="xccui" creationdate="20190702T064526Z">
        <seg>该方法在调用时会传入一个FunctionInitializationContext对象，我们可以利用它访问OperatorStateStore及KeyedStateStore对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method is called with a list of state objects and has to restore the state of the operator based on these objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T051344Z" creationid="xccui" creationdate="20190701T051344Z">
        <seg>该方法接收一个状态对象列表，并需要基于这些对象恢复算子状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The methods, processElement() and processBroadcastElement(), are called with different context objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T045919Z" creationid="xccui" creationdate="20190702T045919Z">
        <seg>processElement()和processBroadcastElement()两个方法在调用时会传入不同的上下文对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most trivial way would be to simply restart the job, but then we would have to replay all data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T044142Z" creationid="xccui" creationdate="20190415T044114Z">
        <seg>最傻的办法就是简单地重启作业，但这样的话我们必须重放全部数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most widely used types can be grouped into the following categories:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T064954Z" creationid="xccui" creationdate="20190616T064954Z">
        <seg>使用最多的可以分为以下几类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The naive approach to taking a checkpoint from a streaming application—to pause, checkpoint, and resume the application—is not practical for applications that have even moderate latency requirements due to its “stop-the-world” behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T055438Z" creationid="xccui" creationdate="20190609T054707Z">
        <seg>针对流式应用，生成检查点的朴素方法就是暂停执行，生成检查点，然后恢复应用。但这种"停止一切"的行为，即便对于那些具有中等延迟要求的应用也很不切实际。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060732Z" creationid="xccui" creationdate="20190618T060732Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The network</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041626Z" creationid="xccui" creationdate="20190504T041203Z">
        <seg>TaskManager的网络模块在传输记录前会将它们在缓冲区中收集起来，因此，记录并非逐个发送的，而是在缓冲区中以批次形式发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The network component of a TaskManager collects records in buffers before they are shipped, i.e., records are not shipped one by one but batched into buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T191248Z" creationid="xccui" creationdate="20190606T195414Z">
        <seg>它的网络模块在记录传输前会先将它们收集到缓冲区中。换言之，记录并非逐个发送的，而是在缓冲区中以批次形式发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next block of code shows the Trigger API:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185923Z" creationid="xccui" creationdate="20190626T185923Z">
        <seg>以下代码块展示了Trigger的API：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next example shows how to connect a (nonkeyed) DataStream with a broadcas‐ ted stream:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T205958Z" creationid="xccui" creationdate="20190615T051632Z">
        <seg>接下来的示例展示了如何联结一个（未按照键值分区的）DataStream和一个广播流：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of key groups limits the maximum number of parallel tasks to which keyed state can be scaled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024550Z" creationid="xccui" creationdate="20190703T024550Z">
        <seg>该数量限制了键值分区状态可以被扩展到的最大并行任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of parallel tasks of an operator is called the parallelism of the operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051400Z" creationid="xccui" creationdate="20190616T051400Z">
        <seg>算子并行化任务的数目称为该算子的并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of slots limits the number of tasks a TaskManager can execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T142537Z" creationid="xccui" creationdate="20190606T142537Z">
        <seg>处理槽的数目限制了一个TaskManager可执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of slots limits the number of tasks that a TaskMan&lt;t3/&gt;‐&lt;t4/&gt; ager can execute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062053Z" creationid="xccui" creationdate="20190418T051544Z">
        <seg>处理槽的数目限制了一个TaskManager可执行的任务数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The observation that data processing systems (at this point in time) could either provide fast or accurate results led to the design of the so-called Lambda architecture which is depicted in &lt;t6/&gt;Figure 1-7&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T043705Z" creationid="xccui" creationdate="20190322T043255Z">
        <seg>以当时的眼光看待流处理系统，快速计算和准确结果二者不可兼得，因此才有了所谓的Lambda架构，详见图1-7。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The observation that data processing systems (at this point in time) could either provide fast or accurate results led to the design of the so-called lambda architecture, which is depicted in Figure 1-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193153Z" creationid="xccui" creationdate="20190605T051725Z">
        <seg>以当时的眼光看待流处理系统，计算快速和结果准确二者不可兼得，因此才有了所谓的Lambda架构，见图1-7。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The obvious next step is to learn how to actually implement a DataStream program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T011435Z" creationid="xccui" creationdate="20190612T011435Z">
        <seg>而接下来将要学的自然就是如何实现DataStream程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The open() and close() methods of a RichFlatMapFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034240Z" creationid="xccui" creationdate="20190619T034231Z">
        <seg>RichFlatMapFunction中的open()和close()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The open() method is an initialization method for the rich function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060850Z" creationid="xccui" creationdate="20190618T060850Z">
        <seg>open()是富函数中的初始化方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator identifier and state name are required to be able to map the state data of a savepoint to the states of the operators of a starting application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023147Z" creationid="xccui" creationdate="20190609T215456Z">
        <seg>该算子标识和状态名需要能将保存点的状态数据映射到应用启动后的算子状态上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator keeps the current minimum value and accordingly updates it for each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061545Z" creationid="xccui" creationdate="20190606T011920Z">
        <seg>其算子会维护当前的最小值，并根据每个到来的事件去更新这个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator keeps the current value of the sum as its internal state and updates it every time it receives a new event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181721Z" creationid="xccui" creationdate="20190414T052338Z">
        <seg>该算子以内部状态形式存储当前的累加值，并会在每次收到新事件时对其进行更新。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator keeps the current&lt;t4/&gt; &lt;t5/&gt;minimum value and accordingly updates it for each incoming event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035839Z" creationid="xccui" creationdate="20190406T035703Z">
        <seg>其算子会维护当前的最小值，并根据每个到来的事件同步更新这个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator needs to store the “high temperature” event in its internal state until it sees the “smoke” event or the until 10-minute time period expires.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031605Z" creationid="xccui" creationdate="20190606T031527Z">
        <seg>这个算子需要将"高温"事件存为内部状态，直到接下来发现"烟雾"事件或超过10分钟的有效时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator needs to store the “high temperature” event in its internal state, until it sees the “smoke” event or the until 10-minute time period expires.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T052942Z" creationid="xccui" creationdate="20190414T052942Z">
        <seg>这个算子需要将"高温"事件存为内部状态，直到发现"烟雾"事件或超过10分钟的过期时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator pipeline</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152223Z" creationid="esouser" creationdate="20190514T152223Z">
        <seg>图3-5中的算子所组成的流水线就满足上述需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator pipeline shown in Figure 3-5 fulfills these requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T200313Z" creationid="xccui" creationdate="20190606T203341Z">
        <seg>图3-5中算子所组成的流水线就满足上述条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order in which the broadcasted events arrive at the different parallel tasks of the broadcast state operator might differ if the operator that emits the broadcasted messages runs with a parallel‐ ism larger than 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T055428Z" creationid="xccui" creationdate="20190702T055428Z">
        <seg>如果发出广播消息的算子并行度大于1，那么广播事件到达广播状态算子不同并行任务的顺序可能会不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original goals of this architecture were to improve the high result latency of the original batch analytics architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193729Z" creationid="xccui" creationdate="20190605T052749Z">
        <seg>它的最初目标是改善原始批量分析架构中结果的高延迟问题，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other common case of periodic watermark generation is when you know the maximum lateness that you will encounter in the input stream—the maximum differ‐ ence between an element’s timestamp and the largest timestamp of all perviously</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052720Z" creationid="xccui" creationdate="20190620T052720Z">
        <seg>另一个周期性生成水位线的常见情况是，你知道输入流中的延迟（任意新到元素和已到时间戳最大的元素之间的时间差）上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other operators have a parallelism of four.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T043456Z" creationid="xccui" creationdate="20190423T043437Z">
        <seg>其余算子的并行度为4。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other oper‐ ators have a parallelism of four.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144533Z" creationid="xccui" creationdate="20190606T144533Z">
        <seg>其余算子的并行度为4。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output can be read as follows: the first field of the SensorReading is a sen&lt;t0/&gt;‐&lt;t1/&gt; sorId, the second field is the timestamp as milliseconds since &lt;t2/&gt;1970-01-01-00:00:00.000&lt;t3/&gt;, and the third field is an average temperature compu&lt;t4/&gt;‐&lt;t5/&gt; &lt;t6/&gt;ted over five seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045333Z" creationid="xccui" creationdate="20190329T043115Z">
        <seg>输出说明如下：SensorReading的第一个字段是sensorId，第二个字段是以距1970-01-01-00:00:00.000的毫秒数表示的时间戳，第三个字段是每隔5秒计算出的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the example is (1,2,2) followed by (1,7,2) for the key “1” and (2,3,1) followed by (2,5,1) for the key “2.” The first</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T055333Z" creationid="xccui" creationdate="20190614T055254Z">
        <seg>示例对于键值"1"首先输出(1,2,2)，然后是(1,7,2)；对于键值"2"首先输出(2,3,1)然后是(2,5,1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the job is written to the standard out of Flink’s worker process which is by default redirected into a file in the &lt;t0/&gt;./log&lt;t1/&gt; folder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042518Z" creationid="xccui" creationdate="20190329T042238Z">
        <seg>作业的输出会写入Flink工作进程的标准输出，默认情况下它会重定向到./log目录下的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the job is written to the standard out of Flink’s worker process, which is redirected into a file in the ./log folder by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123802Z" creationid="xccui" creationdate="20190605T123802Z">
        <seg>作业的输出会写入Flink工作进程的标准输出，默认情况下它会重定向到./log目录下的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the program is written to the standard out (or console) window of your IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042955Z" creationid="xccui" creationdate="20190611T042955Z">
        <seg>程序的输出会写到你IDE的标准输出（或控制台）窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the source tasks is partitioned into streams of  even and odd numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T062132Z" creationid="xccui" creationdate="20190609T062059Z">
        <seg>数据源任务的输出会被分成奇数流和偶数流两个部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output starts with a few log statements about the states that parallel operator tasks go through, such as SCHED‐ ULING, DEPLOYING, and RUNNING.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043236Z" creationid="xccui" creationdate="20190611T043225Z">
        <seg>输出以几行日志语句开始，它们记录了并行算子所经过的一些状态，例如：SCHEDULING、DEPLOYING和RUNNING。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The overall logic is the same, but instead of calling a JoinFunction for every pair of events from both inputs, a CoGroupFunction is called once per window with iterators over the elements from both inputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T054429Z" creationid="xccui" creationdate="20190628T053655Z">
        <seg>Join和Cogroup的总体逻辑相同，二者的唯一区别是：Join会为两个输入中的每个事件对调用JoinFunction；而Gogroup中用到的GoGroupFunction会以两个输入的元素遍历器为参数，只在每个窗口中调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parallelism of an operator can be controlled at the level of the execution environ‐ ment or per individual operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051555Z" creationid="xccui" creationdate="20190616T051555Z">
        <seg>算子的并行度可以在执行环境级别或单个算子级别进行控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parallelism of the environment (and thus also the default parallelism of all operators) is automatically initialized based on the context in which the application is started.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T052803Z" creationid="xccui" creationdate="20190616T052730Z">
        <seg>环境的并行度（即所有算子的默认并行度）会根据应用启动时所处的上下文自动初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The performance of a stateful operator (built-in or user-defined) depends on several aspects, including the data types of the state, the state backend of the application, and the chosen state primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T030838Z" creationid="xccui" creationdate="20190704T030838Z">
        <seg>状态化算子（无论内置还是用户自定义）的性能取决于多个方面，包括状态的数据类型，应用的状态后端以及所选的状态原语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pom.xml file of a generated Maven project contains comments that explain how to add additional dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T043504Z" creationid="xccui" creationdate="20190619T043504Z">
        <seg>生成的Maven项目中的pom.xml文件包含了教你如何添加额外依赖的注释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The possible TriggerResult values enable you to implement sophisticated window‐ ing logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185344Z" creationid="xccui" creationdate="20190626T185344Z">
        <seg>多样化的TriggerResult返回值可以让你实现复杂的窗口逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous chapter discussed important concepts of distributed stream processing, such as parallelization, time, and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T053758Z" creationid="xccui" creationdate="20190416T053731Z">
        <seg>上一章主要讨论了分布式流处理中的一些重要概念，例如：并行、时间、状态等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous chapter introduced two concepts Flink leverages to provide event-time semantics: record timestamps and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204559Z" creationid="xccui" creationdate="20190606T204552Z">
        <seg>前一章介绍了Flink在提供处理时间语义时所采用的两个概念：记录时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous chapter introduced two concepts that Flink leverages to pro&lt;t2/&gt;‐&lt;t3/&gt; vide event-time semantics: record timestamps and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T034944Z" creationid="xccui" creationdate="20190523T034944Z">
        <seg>上一章介绍了Flink在提供处理时间语义时所采用的两个概念：记录时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that Alice lives in Berlin and she takes the subway to work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T152542Z" creationid="xccui" creationdate="20190411T150344Z">
        <seg>但问题在于，爱丽丝住在柏林，每天乘地铁上班，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that Alice lives in Berlin and takes the subway to work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154529Z" creationid="xccui" creationdate="20190606T014945Z">
        <seg>然而有个问题：爱丽丝住在柏林，每天乘地铁上班，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of copying data to the data warehouse is called extract-transform-load (ETL).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T192128Z" creationid="xccui" creationdate="20190228T190335Z">
        <seg>这个向数据仓库拷贝数据的过程被称为提取-转换-加载（Extract-Transform-Load，ETL）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of copying data to the data warehouse is called extract–transform–load (ETL).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T202730Z" creationid="esouser" creationdate="20190603T202730Z">
        <seg>这个向数据仓库拷贝数据的过程被称为提取-转换-加载（Extract-Transform-Load，ETL）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of waiting for all barriers to arrive is called barrier alignment, and it is depicted in Figure 3-22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T174938Z" creationid="xccui" creationdate="20190609T162722Z">
        <seg>这个等待所有分隔符到达的过程称为分隔符对齐，我们在图3-22中对它进行了阐述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process() method is called with the key of the window, an Iterable to access the elements of the window, and a Collector to emit results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011149Z" creationid="xccui" creationdate="20190624T011149Z">
        <seg>process()方法在调用时会传入窗口的键值、一个用于访问窗口内元素的Iterator以及一个用于发出结果的Collector。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The processElement() and onTimer() methods are synchronized to prevent concurrent access and manipu‐ lation of state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T061008Z" creationid="xccui" creationdate="20190621T061008Z">
        <seg>processElement()和onTimer()两方法是同步的，这样可以防止并发访问或操作状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program in Example 5-1 converts the temperatures from Fahrenheit to Celsius and computes the average temperature every 5 seconds for each sensor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053332Z" creationid="xccui" creationdate="20190612T035758Z">
        <seg>示例5-1中的程序将温度从华氏度转为摄氏度并计算每个传感器每5秒钟的平均温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program will continue to generate new events, process them, and emit new results every second until you terminate it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T043558Z" creationid="xccui" creationdate="20190611T043547Z">
        <seg>如果不手动终止，这个程序会一直生成新的事件、处理它们并每秒产生新的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The project contains two skeleton files, BatchJob.scala and StreamingJob.scala, as a starting point for your own programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010104Z" creationid="xccui" creationdate="20190612T010104Z">
        <seg>项目所包含的两个骨架文件，BatchJob.scala和StreamingJob.scala，可以作为你程序的起点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose of the snapshotState()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071540Z" creationid="xccui" creationdate="20190702T071540Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The random data exchange strategy is implemented by the DataStream.shuf fle() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043250Z" creationid="xccui" creationdate="20190615T070800Z">
        <seg>我们可以利用DataStream.shuffle()方法实现随机数据交换策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The random strategy uniformly distributes data items to operator tasks in order to evenly distribute the load across computing tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233607Z" creationid="xccui" creationdate="20190605T233549Z">
        <seg>随机策略（random strategy）会将数据均匀分配至算子的所有任务，以实现计算任务的负载均衡。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rapid digitalization and emergence of connected systems made it possible to collect much more data in real-time and immediately act on this data for example by adjusting to changing conditions or by personalizing user experiences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T052548Z" creationid="xccui" creationdate="20190317T051706Z">
        <seg>数字化的迅猛发展和互联系统的出现使得我们可以实时获取更多数据并立即根据它们采取行动，例如：适应状况的变化或个性化用户体验。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason for this is to keep the number of default dependencies low.4 Most connec‐ tors and libraries rely on one or more libraries, which typically have several addi‐ tional transitive dependencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T040303Z" creationid="xccui" creationdate="20190619T035840Z">
        <seg>之所以这么做是为了保持默认依赖的简洁性，4 因为大多数连接器或库还需要依赖其他库，而这些库通常又会级联引用更多的依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rebalance() method partitions the input stream so that events are evenly distributed to successor tasks in a round-robin fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031409Z" creationid="xccui" creationdate="20190616T043105Z">
        <seg>rebalance()方法会将输入流中的事件以轮流方式均匀分配给后继任务，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receiver processes the shipped data with the reserved buffers and uses the sender’s backlog size to prioritize the next credit grants for all its connected senders.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T195811Z" creationid="esouser" creationdate="20190514T143015Z">
        <seg>接收端使用保留的缓冲来处理收到的数据，同时依据各发送端的积压量信息来计算所有相连的发送端在下一轮的信用优先级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receiving task takes the buffer from the queue and deserializes the incoming records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T194041Z" creationid="esouser" creationdate="20190513T192253Z">
        <seg>接收任务会从这个队列里获取缓冲区并将其中的记录反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reduce transformation is a generalization of the rolling aggregation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061250Z" creationid="xccui" creationdate="20190614T061250Z">
        <seg>reduce转换是滚动聚合转换的泛化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remote storage for checkpointing could be a distributed filesystem or a database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053803Z" creationid="xccui" creationdate="20190608T053742Z">
        <seg>该远程存储可能是一个分布式文件系统，也可能是某个数据库系统。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rescale transformation is more efficient if the number of receiver tasks is a multitude of the number of sender tasks or vice versa.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T044029Z" creationid="xccui" creationdate="20190616T044029Z">
        <seg>当接收端任务远大于发送端任务的时候，该方法会更有效，反之亦然。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rescale() method also distributes events in a round-robin fashion, but only to a subset of successor tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T031526Z" creationid="xccui" creationdate="20190616T043552Z">
        <seg>rescale()也会以轮流方式对事件进行分发，但分发目标仅限于部分后继任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the Flink ecosystem</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030241Z" creationid="xccui" creationdate="20190225T030241Z">
        <seg>Flink生态的其他组成部分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The restoreState() method is always invoked when the state of a function needs to be initialized—when the job is started (from a savepoint or not) or in the case of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T051246Z" creationid="xccui" creationdate="20190701T051246Z">
        <seg>restoreState()方法会在初始化函数状态时调用，该过程可能发生在作业启动（无论是否从保存点）或故障恢复的情况下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result stream is written to the standard output by calling print():</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T022726Z" creationid="xccui" creationdate="20190612T054705Z">
        <seg>通过调用print()将写过写到标准输出：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results of the program are emitted to standard output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042541Z" creationid="xccui" creationdate="20190611T042541Z">
        <seg>程序的结果会写入标准输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rolling aggregate operator keeps a state for every key that is processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061006Z" creationid="xccui" creationdate="20190614T061006Z">
        <seg>滚动聚合算子会为每个处理过的键值维持一个状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rolling reduce operator keeps a state for every key that is pro‐ cessed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062936Z" creationid="xccui" creationdate="20190614T062936Z">
        <seg>滚动聚合算子会为每个处理过的键值维持一个状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second property is used to handle streams with out-of-order record timestamps, such as the records with timestamps 3 and 5 in &lt;t0/&gt;Figure 3-8&lt;t1/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T034143Z" creationid="xccui" creationdate="20190523T042812Z">
        <seg>第二个属性是用来应对那些记录时间戳乱序的数据流，例如图3-8中所示的时间戳3和5。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second property is used to handle streams with out-of-order record timestamps, such as the records with timestamps 3 and 5 in Figure 3-8.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205526Z" creationid="xccui" creationdate="20190606T205450Z">
        <seg>第二个属性是用来应对那些记录时间戳乱序的数据流，例如图3-8中的时间戳3和5。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second type are ad-hoc queries that aim to provide answers to specific questions and support business-critical deci&lt;t2/&gt;‐&lt;t3/&gt; sions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T030047Z" creationid="xccui" creationdate="20190228T193848Z">
        <seg>第二类是即席查询，其主要目的是通过解答特定问题来辅助商业决策。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second type are ad-hoc queries that aim to provide answers to specific questions and support business-critical decisions, for example a query to collect revenue numbers and spending on radio commercials to evaluate the effectiveness of a marketing cam‐ paign.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154650Z" creationid="esouser" creationdate="20190603T203150Z">
        <seg>第二类是即席查询（ad-hoc query）。其主要目的是通过解答特定问题来辅助关键性的商业决策，例如：通过查询来整合营收数字和电台广告中的投入，以评估市场营销的有效性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The serialization format of state is an important aspect when updating an application and is discussed later in this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023627Z" creationid="xccui" creationdate="20190701T023627Z">
        <seg>状态的序列化格式是在更新应用时需要重点考虑的一个方面，我们将在本章稍后对此进行讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service can be a Flink Dispatcher, a Flink JobManager, or YARN’s ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T025600Z" creationid="xccui" creationdate="20190423T025547Z">
        <seg>此处的服务可以是Flink Dispatcher，Flink JobManager或是YARN的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service can be a Flink Dispatcher, a Flink Job‐ Manager, or YARN’s ResourceManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143452Z" creationid="xccui" creationdate="20190606T143434Z">
        <seg>这里的服务可以是Flink Dispatcher，Flink JobManager或是YARN的ResourceManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service latency is the time you spend in the coffee shop, from the moment you enter until you have your first sip of coffee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T050924Z" creationid="xccui" creationdate="20190605T233933Z">
        <seg>所谓服务延迟就是你在店内买咖啡的时间，即从你进门的一刻到抿到第一口咖啡的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest thing to do when a task fails is to do nothing to recover lost state and replay lost events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034336Z" creationid="xccui" creationdate="20190415T051105Z">
        <seg>任务发生故障时最简单的措施就是既不恢复丢失的状态，也不重放丢失的事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The slide value defines the interval at which a new bucket is created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024245Z" creationid="xccui" creationdate="20190407T024134Z">
        <seg>滑动间隔决定每隔多久生成一个新的桶。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sliding count-based window of &lt;t5/&gt;Figure 2-8&lt;t6/&gt; has a length of 4 events and slide of 3 events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024330Z" creationid="xccui" creationdate="20190407T024330Z">
        <seg>在图2-8中，基于数量的滑动窗口的长度为4个事件，滑动间隔为3个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sliding count-based window of Figure 2-8 has a length of four events and slide of three events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013302Z" creationid="xccui" creationdate="20190606T013302Z">
        <seg>在图2-8中，基于数量的滑动窗口的长度为4个事件，滑动间隔为3个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sliding window assigner assigns elements to fixed-sized windows that are shifted by a specified slide interval, as shown in Figure 6-2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054743Z" creationid="xccui" creationdate="20190623T054743Z">
        <seg>如图6-2所示，滑动窗口分配器将元素分配给大小固定且按指定滑动间隔移动的窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The snapshot State() method splits the operator state into multiple parts and the restoreState()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T060605Z" creationid="xccui" creationdate="20190701T060430Z">
        <seg>snapshotState()方法能够将算子状态分为多个部分，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The snapshotState() method is called immediately before a checkpoint is taken and receives a FunctionSnapshotContext object as the parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071327Z" creationid="xccui" creationdate="20190702T071327Z">
        <seg>snapshotState()方法会在生成检查点之前调用，它需要接收一个FunctionSnapshotContext对象作为参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The snapshotState() method is invoked when Flink triggers a checkpoint of the stateful function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T045645Z" creationid="xccui" creationdate="20190701T045645Z">
        <seg>snapshotState()方法会在Flink触发有状态函数的检查点时调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The source task stores the current offset of its input stream as  state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T031659Z" creationid="xccui" creationdate="20190609T030952Z">
        <seg>数据源算子的任务会把输入流的当前偏移量存为状态；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The src/ folder has the follow‐ ing structure:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005710Z" creationid="xccui" creationdate="20190612T005710Z">
        <seg>src/目录的结构如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state backend is responsible for storing the local state of each task instance and persisting it to remote storage when a checkpoint is taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T213832Z" creationid="xccui" creationdate="20190703T213832Z">
        <seg>状态后端负责存储每个状态实例的本地状态，并在生成检查点时将它们写入远程持久化存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state backend notifies the task once its state checkpoint is complete and the task acknowledges the check‐ point at the JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T154433Z" creationid="xccui" creationdate="20190609T154111Z">
        <seg>状态后端会在状态存为检查点完成后通知任务，然后任务会给JobManager发送确认消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state copies in the savepoint are organized by an operator identifier and a state name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023143Z" creationid="xccui" creationdate="20190609T215249Z">
        <seg>保存点中的状态副本会按照算子标识和状态名称进行组织。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state elements can be accessed by calling List State.get(), which returns an Iterable[T] over all state elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T053907Z" creationid="xccui" creationdate="20190630T053907Z">
        <seg>还可以调用ListState.get()访问状态元素（它会返回一个所有元素上的Iterable[T]对象）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state handle object (lastTempState in Example 7-2) is a regular member variable of the function class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063849Z" creationid="xccui" creationdate="20190701T020612Z">
        <seg>我们一般会将状态句柄对象（示例7-2中的lastTempState）声明为函数类的常规成员变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state handle object only provides access to the state, which is stored an maintained in the state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T021127Z" creationid="xccui" creationdate="20190701T020932Z">
        <seg>状态句柄对象只提供用于访问状态的接口而不会存储状态本身，具体保存工作需要由状态后端（state backend）来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state name is scoped to the operator so that a function can have more</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T070147Z" creationid="xccui" creationdate="20190630T070107Z">
        <seg>状态名称的作用域是整个算子，因此你可以通过在函数中注册多个状态描述符的方式得到多个状态对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state of an application that was running for several weeks can be expensive or even impossible to recompute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T212148Z" creationid="xccui" creationdate="20190702T211747Z">
        <seg>在应用运行较长一段时间后，其状态就会变得成本十分昂贵，甚至无法重新计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state of the window is not changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184622Z" creationid="xccui" creationdate="20190626T184622Z">
        <seg>窗口状态不会发生任何变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state primitive offers many of the methods of a regular Java Map such as get(key: K), put(key: K, value:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T060032Z" creationid="xccui" creationdate="20190630T055837Z">
        <seg>该状态原语提供了很多常规Java Map中的方法，例如get(key: K)，put(key: K, value: V)，contains(key: K)，remove(key: K)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state stores are responsible for regis‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T064841Z" creationid="xccui" creationdate="20190702T064841Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state-cleaning mechanism implemented by the above KeyedProcessFunction works as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T211645Z" creationid="xccui" creationdate="20190704T211645Z">
        <seg>上述KeyedProcessFunction实现的状态清除策略的工作机制如下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The steps of this naive algorithm would be:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223351Z" creationid="xccui" creationdate="20190608T223351Z">
        <seg>朴素算法的步骤包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream of numbers is partitioned into a stream of even and odd numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T030857Z" creationid="xccui" creationdate="20190609T030659Z">
        <seg>数字流会被分成奇数流和偶数流，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream processor computes approximated results in near real time and writes them into a speed table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T193242Z" creationid="xccui" creationdate="20190605T052213Z">
        <seg>流处理引擎会近实时地计算出近似结果，并将其写入"提速表"中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stream processor computes possibly inaccurate results in near real-time and writes the results into a speed table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032857Z" creationid="xccui" creationdate="20190322T045515Z">
        <seg>流处理引擎会近实时地计算出一个可能并不精确的结果，随后将其写入"提速表"中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sum tasks persist the current sum value as state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T031626Z" creationid="xccui" creationdate="20190609T031626Z">
        <seg>求和算子的任务会把当前和值存为状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The system needs to efficiently manage the state and make sure it is protected from concurrent updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T183450Z" creationid="xccui" creationdate="20190606T032909Z">
        <seg>系统需要高效地管理状态并保证它们不受并发更新的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The system needs to efficiently manage the state and make&lt;t1/&gt; &lt;t2/&gt;sure it is protected from concurrent updates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T033323Z" creationid="xccui" creationdate="20190415T033225Z">
        <seg>系统需要高效地管理状态并保证它们在面对并发更新时不会出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task can then choose which entries to use and which to dis‐ card.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061346Z" creationid="xccui" creationdate="20190608T061317Z">
        <seg>随后由任务自己决定哪些条目该保留，哪些该丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task emits a watermark with the updated event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T012501Z" creationid="xccui" creationdate="20190606T213002Z">
        <seg>任务根据更新后的事件时间发出水位线记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task emits a watermark with the updated event-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042340Z" creationid="xccui" creationdate="20190529T042213Z">
        <seg>根据更新后的事件时间发出水位线记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task updates its internal event-time clock based on the watermark’s time&lt;t0/&gt;‐&lt;t1/&gt; stamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T041933Z" creationid="xccui" creationdate="20190529T041933Z">
        <seg>基于水位线记录的时间戳更新内部事件时间时钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task updates its internal event-time clock based on the watermark’s time‐ stamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T212920Z" creationid="xccui" creationdate="20190606T212920Z">
        <seg>基于水位线记录的时间戳更新内部事件时间时钟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tasks of a running application are continuously exchanging data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T190921Z" creationid="xccui" creationdate="20190504T040830Z">
        <seg>在运行状态下，应用的任务会持续进行数据交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tasks of operators with two or more input streams such as Union or CoFlatMap (see “Multistream Transformations”) also compute their event-time clock as the mini‐ mum of all partition watermarks—they do not distinguish between partition water‐ marks of different input streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024744Z" creationid="xccui" creationdate="20190607T025821Z">
        <seg>对于那些有着两条或多条输入数据流的算子，如Union或CoFlatMap（详见"多流转换"），它们的任务同样是利用全部分区水位线中的最小值来计算事件时间时钟而没有考虑分区是否来自不同的流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tasks of the operators with a parallelism of four are assigned to each slot.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062201Z" creationid="xccui" creationdate="20190423T164129Z">
        <seg>对于并行度为4的算子，其任务会每个处理槽分配一个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task’s time service identifies all timers with a time smaller than the updated event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190606T212936Z">
        <seg>任务的时间服务会找出所有触发时间小于更新后事件时间的计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The task’s time service identifies all timers with a time smaller than the updated event-time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042031Z" creationid="xccui" creationdate="20190529T042031Z">
        <seg>任务的时间服务会找出所有触发时间小于更新后事件时间的定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third and biggest challenge that comes with stateful operators is ensuring that state can be recovered and results will be correct even in the presence of fail‐ ures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T184111Z" creationid="xccui" creationdate="20190606T032958Z">
        <seg>最后一个也是最大的挑战在于，状态化算子需要保证状态可以恢复，并且即使出现故障也要确保结果正确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third generation of distributed open source stream processors (2015) addressed the dependency of results on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053334Z" creationid="xccui" creationdate="20190605T053320Z">
        <seg>第三代分布式流处理引擎（2015年）解决了结果对事件到来时间及顺序的依赖问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third generation of distributed open source stream processors (2015) fixed the dependency of results on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T050910Z" creationid="xccui" creationdate="20190327T050627Z">
        <seg>第三代分布式流处理引擎（2015年）修复了结果对事件到来时间及顺序的依赖问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The time characteristic is a property of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T064821Z" creationid="xccui" creationdate="20190619T064821Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The time interval can be set in milliseconds, seconds, minutes, hours, or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042758Z" creationid="xccui" creationdate="20190623T042741Z">
        <seg>时间间隔允许以毫秒、秒、分钟、小时或天数来表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timer will fire when the processing time of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060222Z">
        <seg>当执行机器的处理时间到达给定的时间戳时，该计时器就会触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timer will fire when the watermark is updated to a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060423Z">
        <seg>当更新候的水位线时间戳大于或等于计时器的时间戳时，它就会触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timestamp argument gives the timestamp of the firing timer and the Collec</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T054908Z" creationid="xccui" creationdate="20190621T054908Z">
        <seg>timestamp参数给出了所触发计时器的时间戳，Collector可用来发出记录。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timestamp associates a record with a specific point</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204839Z" creationid="xccui" creationdate="20190606T204839Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The timestamp associates an record with a specific point in time, usually the point in time at which the event that is represented by the record happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T035521Z" creationid="xccui" creationdate="20190523T035521Z">
        <seg>时间戳将记录和特定时间点进行关联，这些时间点通常是记录所表示事件的发生时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The traditional approach of a periodic ETL job to move data between storage systems is typically not able to propagate updates fast enough.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190314T070853Z" creationid="xccui" creationdate="20190314T070853Z">
        <seg>传统方式是通过定期执行ETL作业来转移数据，但这种更新传播方式往往不够迅速。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The traditional architecture that most businesses implement distinguishes two types of data process‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063923Z" creationid="esouser" creationdate="20190603T194352Z">
        <seg>绝大多数企业所实现的传统架构都会将数据处理分为两类：事务型处理和分析型处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transformation logic can be either integrated in the operator or provided by a user-defined function (UDF), as shown in &lt;t4/&gt;Figure 2-4&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T155218Z" creationid="xccui" creationdate="20190405T153643Z">
        <seg>如图2-4所示，具体转换逻辑可以是算子内置的，也可以由用户自定义函数（UDF）提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transformation logic can be either integrated in the operator or provided by a user-defined function, as shown in Figure 2-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060613Z" creationid="xccui" creationdate="20190606T011328Z">
        <seg>如图2-4所示，转换逻辑可以是算子内置的，也可以由用户自定义函数提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The trigger defines (fires) when a window is considered ready for evaluation and when a window is purged and its contents are cleared.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053029Z" creationid="xccui" creationdate="20190625T053029Z">
        <seg>触发器定义了窗口何时准备好执行计算（触发），何时需要清除自身及其内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The trigger fires at most every second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200209Z" creationid="xccui" creationdate="20190626T200209Z">
        <seg>触发周期不小于一秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The trigger registers a timer when the first event is assigned to a window, 1 second ahead of the current watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195833Z" creationid="xccui" creationdate="20190626T195833Z">
        <seg>它在第一个事件分配给窗口时注册了一个比当前水位线快1秒的计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The truth is, processing time can indeed be useful in some cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180456Z" creationid="xccui" creationdate="20190606T030701Z">
        <seg>事实上，处理时间的确有其特定的适用场景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tuple classes are strongly typed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T015557Z" creationid="xccui" creationdate="20190617T015557Z">
        <seg>这些元组类都是强类型的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two tasks of operators C and E are assigned to slots 1.1 and 2.1 and slots 1.2 and 2.2, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144657Z" creationid="xccui" creationdate="20190606T144651Z">
        <seg>其余两个算子C和E的任务会分别放到处理槽1.1、2.1和处理槽1.2、2.2中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two tasks of operators C and E are assigned to slots 1.1 and 2.1 and slots 1.2 and 2.2, respectively&lt;t4/&gt;1&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062232Z" creationid="xccui" creationdate="20190423T164232Z">
        <seg>其余两个算子C和E的任务会分别放到处理槽1.1、2.1和处理槽1.2、2.2中1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the output stream is the same as the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061617Z" creationid="xccui" creationdate="20190614T061549Z">
        <seg>因此输出流的类型永远和输入流保持一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The types of guarantees you have seen so far refer to the state of an application that is managed by the stream processor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035037Z" creationid="xccui" creationdate="20190606T035014Z">
        <seg>至今为止你看到的保障类型都仅限于流处理引擎自身的应用状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The types of guarantees you have seen so far refer to the stream processor component only.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045141Z" creationid="xccui" creationdate="20190416T045141Z">
        <seg>至今为止你看到的保障类型都仅限于流处理引擎组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ubiquitous problem of out-of-order data can also be solved with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160220Z" creationid="xccui" creationdate="20190606T024422Z">
        <seg>时常产生的无序问题也可以借此解决。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unique identifier and maximum parallelism of operators are baked into a savepoint and cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015228Z" creationid="xccui" creationdate="20190703T013858Z">
        <seg>算子的唯一标识和最大并行度会被固化到保存点中，不可更改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The updates are written to and distributed by the event log.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T040443Z" creationid="xccui" creationdate="20190605T040204Z">
        <seg>具体而言就是将更新写入事件日志系统，并由它进行分发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The views expressed in this work are those of the authors, and do not represent the publisher’s views.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210738Z" creationid="esouser" creationdate="20190603T210738Z">
        <seg>The views expressed in this work are those of the authors, and do not represent the publisher’s views.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The way operators interact with state has implications on the robustness and perfor‐ mance of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T210942Z" creationid="xccui" creationdate="20190703T210535Z">
        <seg>算子和状态的交互会对应用的鲁棒性及性能产生一定影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window content holds the elements that have been assigned to the window or the result of the incremental aggregation in case the window operator has a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033304Z" creationid="xccui" creationdate="20190626T033304Z">
        <seg>窗口内容包含了分配给窗口的元素或窗口算子配置了ReduceFunction或AggregateFunction时增量聚合得到的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window definition looked a bit different in our first DataStream API example, “Operations on Data Streams” on page 22.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T051241Z" creationid="xccui" creationdate="20190623T051241Z">
        <seg>在第22页"数据流上的操作"一节，我们第一个DataStream API示例中定义窗口的方式看上去有些不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window operator API provides a method to explicitly declare that you expect late elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164103Z" creationid="xingcan" creationdate="20190628T164103Z">
        <seg>窗口算子API提供了一个方法，可用来显式声明支持迟到的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window operator deletes a window when the end time of the window, defined by the end timestamp of the window object, is reached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T035514Z" creationid="xccui" creationdate="20190626T035514Z">
        <seg>窗口算子会在窗口结束时间（由窗口对象中的结束时间戳定义）到达时删除窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window operator groups elements based on the returned objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033717Z" creationid="xccui" creationdate="20190626T033717Z">
        <seg>窗口算子会根据返回的对象对元素进行分组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window result will not depend on how fast the stream is read or processed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071159Z" creationid="xccui" creationdate="20190619T071135Z">
        <seg>窗口结果不会取决于数据流的读取或处理速度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window’s state is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T001324Z" creationid="xccui" creationdate="20190624T001324Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The “Extract hashtags" and “Count" operators have two parallel operator tasks, each performing a computation on a subset of the input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T021422Z" creationid="xccui" creationdate="20190401T003521Z">
        <seg>"Extract hashtags"和"Count"算子都包含两个并行算子任务，每个任务负责计算一部分输入数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The&lt;t8/&gt; &lt;t9/&gt;behavior of windows is defined by a set of policies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T045355Z" creationid="xccui" creationdate="20190406T045224Z">
        <seg>窗口的行为是由一组策略定义的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then suddenly the train enters a tunnel and her phone gets dis‐ connected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154622Z" creationid="xccui" creationdate="20190606T015033Z">
        <seg>突然，地铁开进隧道，手机断网了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then suddenly, the train enters a tunnel and her phone gets dis&lt;t2/&gt;‐&lt;t3/&gt; connected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T151228Z" creationid="xccui" creationdate="20190411T150738Z">
        <seg>突然，地铁开进隧道，手机断网了，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then we introduced the idea of stateful stream processing and explained how it addresses a wide spectrum of use cases, rang‐ ing from business applications and microservices to ETL and data analytics.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T125220Z" creationid="xccui" creationdate="20190605T125200Z">
        <seg>随后我们介绍了状态化流处理的基本思想，解释了它如何处理从业务应用和微服务到ETL和数据分析的多种用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, can you somehow get both low latency and high throughput or is this a hope&lt;t0/&gt;‐&lt;t1/&gt; less endeavour?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210637Z" creationid="xccui" creationdate="20190402T210637Z">
        <seg>既然这样，可以通过某种方式同时获得低延迟和高吞吐吗？还是说根本不切实际？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, we use the keyBy() transformation to parti‐ tion the sensor readings by their sensor ID.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053453Z" creationid="xccui" creationdate="20190612T053453Z">
        <seg>然后我们使用keyBy()转换，将传感器读数按照传感器ID进行分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, we will cover the process functions, low-level transformations that provide access to timestamps and watermarks and can register timers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190619T052920Z">
        <seg>随后我们会介绍处理函数，它对应的低层转换可以访问时间戳和水位线，还能注册计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also applications that do not emit results but keep them internally to serve them via Flink’s queryable state feature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054456Z" creationid="xccui" creationdate="20190612T054456Z">
        <seg>还有一些应用不会发出结果，而是将它们保存在内部，利用Flink的可查询状态功能对外提供服务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are different types of transformations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052719Z" creationid="xccui" creationdate="20190612T052303Z">
        <seg>转换的类型多种多样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are different ways to specify keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051541Z" creationid="xccui" creationdate="20190614T051506Z">
        <seg>指定键值的方式多种多样，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are many popular libraries out there, such as Apache Commons or Google Guava, for various use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034840Z" creationid="xccui" creationdate="20190619T034840Z">
        <seg>很多流行库（例如：Apache Commons或Google Guava）会用于各种不同的用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are rich versions of all the DataStream API transformation functions, and you can use them in the same places you can use a regular function or lambda function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060440Z" creationid="xccui" creationdate="20190618T060440Z">
        <seg>DataStream API中的所有转换函数都有对应的富函数，它们能够的使用位置和普通函数以及lambda函数相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several aspects that affect the behavior of an appli‐ cation such as the choice of the state backend that locally maintains the state and performs checkpoints, the configuration of the checkpointing algorithm, and the size of the application’s state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T211607Z" creationid="xccui" creationdate="20190703T210934Z">
        <seg>这些影响的原因是多方面的，例如，对于用来维护本地状态和生成检查点的状态后端的选择，配置的检查点生成算法以及应用状态大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several event log sys&lt;t0/&gt;‐&lt;t1/&gt; tems available as open source software, Apache Kafka being the most popular, or as integrated services offered by cloud computing providers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T060116Z" creationid="xccui" creationdate="20190305T055922Z">
        <seg>有不少事件日志系统会以开源软件或云计算集成服务的形式出现，其中最流行的当属Apache Kafka。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several event log sys‐ tems available as open source software, Apache Kafka being the most popular, or as integrated services offered by cloud computing providers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T073413Z" creationid="esouser" creationdate="20190603T211119Z">
        <seg>有不少事件日志系统都是开源软件，其中最流行的当属Apache Kafka；也有部分系统会以云计算提供商集成服务的形式出现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two aspects of triggers that require special care: cleaning up state and merging triggers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193859Z" creationid="xccui" creationdate="20190626T193859Z">
        <seg>但有两类触发器需要格外小心：状态清理触发器及合并触发器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two types of functions that can be applied on a window:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T210034Z" creationid="xccui" creationdate="20190623T210034Z">
        <seg>可用于窗口的函数类型有两种：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two types of state, operator state and keyed state, that are accessible from different scopes and discussed in the following sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T023422Z">
        <seg>根据作用域的不同，状态可以分为两类：算子状态和键值分区状态，我们会在接下来的几节介绍它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two ways state can be modified:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043919Z" creationid="xccui" creationdate="20190705T043919Z">
        <seg>我们有两种办法可以对状态进行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two ways to ensure all dependencies are available to an application when it is executed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041104Z" creationid="xccui" creationdate="20190619T041054Z">
        <seg>有两种方法可以保证在执行应用时可以同时使用所有依赖：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two ways to provide TypeInformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061719Z" creationid="xccui" creationdate="20190617T061659Z">
        <seg>其方法有二。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There, we defined an event-time tumbling</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T051514Z" creationid="xccui" creationdate="20190623T051346Z">
        <seg>那里，我们使用timeWindow(size)方法定义了一个事件时间滚动窗口，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, a function can only access the state that belongs to the record it currently processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T063851Z" creationid="xccui" creationdate="20190630T063851Z">
        <seg>这样，函数每次只能访问属于当前处理记录的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, all configuration values are preserved after the object is deserialized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054924Z" creationid="xccui" creationdate="20190618T054924Z">
        <seg>这样在对象反序列化后，全部配置值都可以保留。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, it is important that application state can be migrated to a new version of the application or be redistributed to more or fewer operator tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T212646Z" creationid="xccui" creationdate="20190702T212646Z">
        <seg>所以说，能够将应用状态迁移到一个新版本的应用或重新分配到不同数量的算子任务上就变得十分重要。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, it is not necessary to define data types to hold keys and values, which avoids a lot of boilerplate code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T064100Z" creationid="xccui" creationdate="20190617T063903Z">
        <seg>因此，没必要为键和值再单独定义数据类型，这样省去了很多样板代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, such changes are not safepoint compatible even though they look unobtrusive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T041619Z" creationid="xccui" creationdate="20190705T041619Z">
        <seg>因此，这些看上去不惹眼的改动其实并非保存点兼容的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the operator emits a result that is incomplete or inaccurate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T160353Z" creationid="xingcan" creationdate="20190628T160353Z">
        <seg>这表示算子之前发出的结果可能是不完整或不准确的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the trigger fires, at most, every second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200010Z" creationid="xccui" creationdate="20190626T200010Z">
        <seg>因此该触发器最多每秒触发一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, we strongly recommend manually assign‐ ing unique identifiers to operators and not relying on Flink’s default assignment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T030745Z" creationid="xccui" creationdate="20190610T030737Z">
        <seg>所以我们强烈建议手工指定算子标识，而不要依赖Flink的默认分配机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These chapters guide you through setting up a development environment, cover the basics of the DataStream API, and go into the details of Flink’s time seman&lt;t2/&gt;‐&lt;t3/&gt; tics and window operators, its connectors to external systems, and the details of Flink’s fault-tolerant operator state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191557Z" creationid="xccui" creationdate="20190225T165712Z">
        <seg>这些章节将指导你完成开发环境设置，学习DataStream API的基础知识，深入了解Flink的时间语义、窗口算子、外部系统连接器以及Flink容错性operator state的细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These components are a JobManager, a ResourceManager, a TaskManager, and a Dispatcher.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T055541Z" creationid="xccui" creationdate="20190418T033541Z">
        <seg>这些组件是：JobManager、ResourceManager、TaskManager和Dispatcher。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These components need to be carefully orchestrated and especially error handling and failure recovery can become challenging.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T063117Z" creationid="xccui" creationdate="20190317T063117Z">
        <seg>这些组件需要仔细地协调，尤其是错误处理和故障恢复可能颇具挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions are typically very space-efficient and eventually emit the aggregated value as a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T210933Z" creationid="xccui" creationdate="20190623T210933Z">
        <seg>此类函数函数通常会十分节省空间且最终将聚合值作为单个结果发送出去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These metrics are assembled into reports that help the management to assess the business’s overall health.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T025100Z" creationid="esouser" creationdate="20190603T203141Z">
        <seg>将这些指标整合成报告，能够帮助管理层评估企业整体健康状况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These metrics are assembled into reports that help to assess the situation of the business.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T193934Z" creationid="xccui" creationdate="20190228T193457Z">
        <seg>在报告中汇总这些指标，有助于评估业务状况；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operations consume one event after the other and apply some trans&lt;t2/&gt;‐&lt;t3/&gt; formation to the event data, producing a new output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T034637Z" creationid="xccui" creationdate="20190405T153227Z">
        <seg>这些操作挨个读取事件，对其应用某些转换并产生一条新的输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operations consume one event after the other and apply some trans‐ formation to the event data, producing a new output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011319Z" creationid="xccui" creationdate="20190606T011303Z">
        <seg>这些操作逐个读取事件，对其应用某些转换并产生一条新的输出流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operations define how events are assigned to tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064903Z" creationid="xccui" creationdate="20190615T064903Z">
        <seg>这些操作定义了如何将事件分配给不同任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators can be combined into dataflow processing graphs to implement the logic of streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054922Z" creationid="xccui" creationdate="20190402T212738Z">
        <seg>这些算子可以组合生成Dataflow处理图，从而实现流式应用所需的逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These parameters are a unique operator identifier and the maximum parallelism (for opera‐ tors with keyed state).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015253Z" creationid="xccui" creationdate="20190703T012359Z">
        <seg>这两个参数是算子唯一标识和最大并行度（只针对具有键值分区状态的算子）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These systems are typically designed with separate tiers for data processing (the application itself) and data storage (a transactional database system) as shown in Figure 1-1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T071853Z" creationid="esouser" creationdate="20190603T195128Z">
        <seg>如图1-1所示，这些应用系统通常都会设置独立的数据处理层（应用程序本身）和数据存储层（事务型数据库系统）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These systems had rather low-level APIs and did not provide built-in support for accurate and con&lt;t4/&gt;‐&lt;t5/&gt; sistent results of streaming applications because the results depended on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T042817Z" creationid="xccui" creationdate="20190322T042044Z">
        <seg>它们的API非常底层，而且并未针对流式应用结果的准确性和一致性提供内置保障。其结果完全取决于事件到达的时间和顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These systems had rather low-level APIs and did not provide built-in support for accurate and consistent results of streaming applications because the results depended on the timing and order of arriving events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051546Z" creationid="xccui" creationdate="20190605T051546Z">
        <seg>它们的API非常底层，而且并未针对流式应用结果的准确性和一致性提供内置保障。其结果完全取决于事件到达的时间和顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These tasks can be of the same operator (data parallelism), a different operator (task parallelism), or even from a different application (job parallelism).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041312Z" creationid="xccui" creationdate="20190423T041251Z">
        <seg>这些任务可以属于同一个算子（数据并行），也可以是不同算子（任务并行），甚至还可以来自不同的应用（作业并行）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These tasks can be sub‐ tasks of the same operator (data parallelism), a different operator (task parallelism), or even from a different application (job parallelism).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144322Z" creationid="xccui" creationdate="20190606T144322Z">
        <seg>这些任务可以属于同一个算子（数据并行），也可以是不同算子（任务并行），甚至还可以来自不同的应用（作业并行）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These timers are maintained by the window operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T034804Z" creationid="xccui" creationdate="20190626T034804Z">
        <seg>这些计时器由窗口算子负责维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two interfaces extend the Time stampAssigner interface provided by the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044959Z" creationid="xccui" creationdate="20190620T044932Z">
        <seg>这两个接口都继承自DataStream API提供的TimestampAssigner接口，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They also support</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T041632Z" creationid="xccui" creationdate="20190618T041617Z">
        <seg>同时还支持选择嵌套字段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are called on a stream of elements and produce a new stream of timestamped elements and water‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T033231Z" creationid="xccui" creationdate="20190620T033231Z">
        <seg>它们会作用于数据流的元素之上，生成一条带有时间戳和水位线的新数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are discussed further in “Declaring Keyed State at RuntimeCon‐ text” on page 154.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T223752Z">
        <seg>更多相关内容请见154页"在RuntimeContext中声明键值分区状态"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are related to record timestamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205429Z" creationid="xccui" creationdate="20190606T205410Z">
        <seg>和记录的时间戳相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can also modify the structure of the dataflow graph by either splitting a stream into multi&lt;t0/&gt;‐&lt;t1/&gt; ple streams or merging streams into a single flow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T160048Z" creationid="xccui" creationdate="20190405T160023Z">
        <seg>也可以通过单流分割或合并多条流来改变dataflow图的结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can also modify the structure of the dataflow graph by either splitting a stream into multi‐ ple streams or merging streams into a single flow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060929Z" creationid="xccui" creationdate="20190606T011745Z">
        <seg>也可以通过单流分割或合并多条流来改变Dataflow图的结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can only be applied if the window collects all added events and does not</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203833Z" creationid="xccui" creationdate="20190627T203825Z">
        <seg>该操作的应用前提是窗口能够取得全部已加入的事件，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They communicate via event logs instead of REST calls and hold application data as local state instead of writing it to and reading it from an external data store, such as a transactional database or key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T152406Z" creationid="xccui" creationdate="20190307T152335Z">
        <seg>微服务通过REST调用进行通信，利用关系型数据库或键值存储等外部系统存储数据；而事件驱动型应用利用事件日志进行通信，而其数据会以本地状态形式存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They communicate via event logs instead of REST calls and hold application data as local state instead of writing it to and reading it from an external datastore, such as a relational database or key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T073910Z" creationid="esouser" creationdate="20190603T213740Z">
        <seg>微服务通过REST调用进行通信，利用事务型数据库或键值存储等外部系统存储数据；而事件驱动型应用利用事件日志进行通信，其数据则会以本地状态形式存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They consume data from inputs, perform a computation on them, and produce data to outputs for further processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T200240Z" creationid="xccui" creationdate="20190331T215135Z">
        <seg>它们从输入获取数据，对其进行计算，然后产生数据并发往输出以供后续处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They control how long to wait for data to arrive before performing a computation, such as finalizing a window computation and emitting the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T030937Z" creationid="xccui" creationdate="20190621T030937Z">
        <seg>它们控制在执行某些计算（例如完成窗口计算并发出结果）前需要等待数据到达的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They enable transfor‐ mations such as aggregations on bounded intervals of an unbounded stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T033021Z" creationid="xccui" creationdate="20190622T033021Z">
        <seg>它们可以在无限数据流上基于有界区间实现聚合等转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They follow the UNIX philoso&lt;t0/&gt;‐&lt;t1/&gt; phy of doing a single thing and doing it well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T171125Z" creationid="xccui" creationdate="20190227T233311Z">
        <seg>每个应用都遵循UNIX设计哲学：专注做好一件事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They follow the UNIX philosophy of doing a single thing and doing it well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T200630Z" creationid="esouser" creationdate="20190603T200630Z">
        <seg>每个应用都遵循UNIX设计哲学：专注做好一件事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They must be monotonically increasing to ensure the event-time clocks of tasks are progressing and not going backward.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205400Z" creationid="xccui" creationdate="20190606T205354Z">
        <seg>必须单调递增，这是为了确保任务中的事件时间时钟正确前进，不会倒退。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They need to be serialized and deserialized to ship them over the network or write them into or read them from state backends, checkpoints, and savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T063508Z" creationid="xccui" creationdate="20190616T063508Z">
        <seg>出于网络传输，读写状态、检查点和保存点等目的，需要对它们进行序列化和反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of user interac&lt;t0/&gt;‐&lt;t1/&gt; tions on websites or in mobile apps, placements of orders, server logs, or sensor measurements; all of these data are streams of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T035558Z" creationid="xccui" creationdate="20190301T035451Z">
        <seg>考虑一下，无论是网站或移动应用中的用户交互还是订单下达，无论是服务器日志还是传感器测量结果，这些数据本质上都是事件流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of user interac‐ tions on websites or in mobile apps, placements of orders, server logs, or sensor measurements; all of these are streams of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T065738Z" creationid="esouser" creationdate="20190603T204811Z">
        <seg>考虑一下，无论是网站或移动应用中的用户交互或订单下达，还是服务器日志或传感器测量结果，这些数据本质上都是事件流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Third, the Lambda architecture is hard to setup and maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T031328Z" creationid="xccui" creationdate="20190327T030936Z">
        <seg>最后，Lambda架构很难配置和维护，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Third, the lambda architecture is hard to set up and maintain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T053103Z" creationid="xccui" creationdate="20190605T053047Z">
        <seg>最后，Lambda架构很难配置和维护。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032416Z" creationid="xccui" creationdate="20190401T032416Z">
        <seg>这类并行性称作任务并行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to easily scale the application by adjusting its parallelism via the submission client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T054115Z" creationid="xccui" creationdate="20190616T054115Z">
        <seg>这样就可以通过提交客户端来轻易调整并行度，从而实现应用的扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to implement operators that are dynam‐ ically configured via a data stream (e.g., to add or remove filtering rules or update machine-learning models).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053341Z" creationid="xccui" creationdate="20190615T053341Z">
        <seg>你可以利用广播状态实现一个通过数据流进行动态配置的算子（例如：添加或删除规则或者更新机器学习模型）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to migrate an application to a newer Flink version or to a different cluster or data- center.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212841Z" creationid="xccui" creationdate="20190609T212841Z">
        <seg>这允许你把应用迁移到一个新的Flink版本，或是一个不同的集群或数据中心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This application design can cause problems when applications need to evolve or scale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="esouser" creationdate="20190603T195919Z">
        <seg>该设计在应用需要更新或扩容时，容易导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect depends on the APIs of the stream processor, what kinds of state primitives it provides, and on the quality of its support for event-time processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014629Z" creationid="xccui" creationdate="20190314T062102Z">
        <seg>具体一些，这种能力依赖于流处理引擎的API、提供的状态原语以及对事件时间处理的支持程度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aspect depends on the APIs of the stream processor, what kinds of state primitives it provides, and the quality of its support for event-time processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T074509Z" creationid="xccui" creationdate="20190604T053132Z">
        <seg>这方面要取决于流处理引擎的API、提供的状态原语以及对事件时间处理的支持程度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior can cause problems if the event times of the individual input streams of an application are not aligned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T031114Z" creationid="xccui" creationdate="20190607T031013Z">
        <seg>如果应用不同输入流的事件时间没有对齐，那么该行为会导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior yields nondeterministic results and is usually</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045745Z" creationid="xccui" creationdate="20190615T045745Z">
        <seg>该行为会产生不确定的结果，而这往往并不是我们想要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book couldn’t have been possible without the help and support of several amaz‐ ing people.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T160100Z" creationid="xccui" creationdate="20190605T131119Z">
        <seg>本书的付梓离不开众多能人志士的帮助和支持，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book covers the DataStream API and ProcessFunctions which provide primitives for common stream processing operations, such as windowing and asynchronous operations, and interfaces to precisely control state and time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T044508Z" creationid="xccui" creationdate="20190328T043432Z">
        <seg>本书涵盖了DataStream API和ProcessFunction的相关内容，它们提供了通用的流处理操作原语（如：窗口划分、异步操作）以及精确控制时间和状态的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book covers the DataStream API and process functions, which provide primitives for common stream processing operations, such as windowing and asynchronous operations, and interfaces to precisely control state and time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T195629Z" creationid="xccui" creationdate="20190605T060812Z">
        <seg>本书涵盖了DataStream API和处理函数（process function）的相关内容，它们提供了通用的流处理操作原语（如窗口划分和异步操作）以及精确控制时间和状态的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book is here to help you get your job done.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210815Z" creationid="esouser" creationdate="20190603T210815Z">
        <seg>This book is here to help you get your job done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book summarizes knowledge obtained through years of design, development, and testing performed by the Apache Flink community at large.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T062759Z" creationid="xccui" creationdate="20190605T131400Z">
        <seg>本书总结了Apache Flink社区多年来在设计、开发、测试等方面积累的知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book will teach you everything to know about stream processing with Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T042801Z" creationid="xccui" creationdate="20190225T042801Z">
        <seg>本书将教给你用Apache Flink进行流处理的一切知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book will teach you everything you need to know about stream processing with Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T031208Z" creationid="esouser" creationdate="20190603T152621Z">
        <seg>本书将教给你基于Apache Flink进行流处理的一切知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be a problem if you</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T063507Z" creationid="xccui" creationdate="20190701T063507Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be done by registering timers for a point of time in the future.4 Similar to state, timers are registered in the context of the currently active key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T203022Z" creationid="xccui" creationdate="20190704T202730Z">
        <seg>该工作可以通过注册针对未来某个时间点的计时器来完成。4 和状态类似，计时器也会注册在当前活跃键值的上下文中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be explained by looking at the steps of a naive algorithm that takes a consistent checkpoint of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223326Z" creationid="xccui" creationdate="20190608T223205Z">
        <seg>它可以通过用朴素算法对应用建立一致性检查点的步骤加以解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This case is shown in Figure 6-4.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053502Z" creationid="xccui" creationdate="20190625T053502Z">
        <seg>该情况如图6-4所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter focuses on the implementation of stateful user-defined functions and discusses the performance and robustness of stateful applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T033901Z" creationid="xccui" creationdate="20190630T033720Z">
        <seg>本章重点介绍如何实现有状态的用户自定义函数并对状态化应用的性能及健壮性加以讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter introduces the basics of Flink’s DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014914Z" creationid="xccui" creationdate="20190612T014914Z">
        <seg>本章主要介绍Flink DataStream API的基础知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter is still rather independent of Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T053557Z" creationid="xccui" creationdate="20190329T053557Z">
        <seg>本章节内容仍然独立于Flink。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter provides relevant background information to successfully implement and operate advanced streaming applications with Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T043453Z" creationid="xccui" creationdate="20190416T054356Z">
        <seg>本章会涉及使用Apache Flink实现并操纵高级流式应用的相关背景。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This check is necessary to ensure event time continuously increases; otherwise no watermark is produced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051451Z" creationid="xccui" creationdate="20190620T050454Z">
        <seg>这项检查对于保证事件时间持续增加十分必要，一旦失败将不会生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This checkpointing and recovery mechanism can provide exactly-once consistency for application state, given that all operators checkpoint and restore all of their states</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T043911Z" creationid="xccui" creationdate="20190609T040709Z">
        <seg>如果所有算子都将它们全部的状态写入检查点并从中恢复，并且所有输入流的消费位置都能重置到检查点生成那一刻，那么该检查点和恢复机制就能为整个应用的状态提供精确一次的一致性保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This deployment mode is common for microservice architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041101Z" creationid="xccui" creationdate="20190423T041101Z">
        <seg>该部署模式常用于微服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This deployment mode is common for microservices architectures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T063821Z" creationid="xccui" creationdate="20190606T144242Z">
        <seg>后者常用于微服务架构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This design can cause problems when applications need to evolve or scale.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T163248Z" creationid="xccui" creationdate="20190226T163132Z">
        <seg>该设计模式在应用需要升级或扩容时，容易导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This differs from batch processing where user-defined functions, such as GroupReduceFunction, are called when all data to be processed has been collected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T034350Z" creationid="xccui" creationdate="20190630T034350Z">
        <seg>这和批处理情况不同。在批处理中，只有在全部所需处理的数据都收集完后才会调用用户自定义函数（如GroupReduceFunction）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This element signifies a general note.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210810Z" creationid="esouser" creationdate="20190603T210810Z">
        <seg>This element signifies a general note.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This element signifies a tip or suggestion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210809Z" creationid="esouser" creationdate="20190603T210809Z">
        <seg>This element signifies a tip or suggestion.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This element signifies a warning or caution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210811Z" creationid="esouser" creationdate="20190603T210811Z">
        <seg>This element signifies a warning or caution.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example shows a flatMap transformation commonly found in data processing tutorials.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T061551Z" creationid="xccui" creationdate="20190613T061551Z">
        <seg>以下示例展示了数据处理教程中一个常见的flagMap转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This fea&lt;t0/&gt;‐&lt;t1/&gt; ture comes in handy when developing and testing Flink applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T053736Z" creationid="xccui" creationdate="20190328T053645Z">
        <seg>这在开发和调试Flink应用的时候非常好用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature comes in handy when developing and testing Flink appli‐ cations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T122111Z" creationid="xccui" creationdate="20190605T122111Z">
        <seg>这在开发和调试Flink应用的时候非常好用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function will be discussed in “Assigning Timestamps and Generating Watermarks” on page 111.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T035555Z" creationid="xccui" creationdate="20190607T035526Z">
        <seg>这个函数会在111页"分配时间戳和生成水位线"介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives the possibility to release cluster resources for higher-priority applications or when input data is not continuously produced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213217Z" creationid="xccui" creationdate="20190609T213202Z">
        <seg>这样可以为更高优先级的应用腾出集群资源，或者在输入数据不连续的情况下及时释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens when an application</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T064346Z" creationid="xccui" creationdate="20190702T064346Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes adding of stateful or stateless operators to the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035850Z" creationid="xccui" creationdate="20190705T035711Z">
        <seg>包括向应用中添加状态化或非状态化算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes handling of very large states, possibly exceeding memory, and ensuring that no state is lost in case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055510Z" creationid="xccui" creationdate="20190607T055446Z">
        <seg>这其中包括如何处理数量庞大、可能超出内存的状态，如何保证发生故障时状态不会丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes window operators and time-based joins as well as process functions that provide the most flexibility when dealing with time in streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151805Z" creationid="esouser" creationdate="20190603T161606Z">
        <seg>其中包含窗口算子、基于时间的Join以及一系列处理函数，它们将流式应用中的时间处理变得十分灵活。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This information will come in handy when designing advanced stream‐ ing applications, setting up and configuring clusters, and operating streaming appli‐ cations as well as reasoning about their performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T032507Z" creationid="xccui" creationdate="20190610T031959Z">
        <seg>在设计高级流式应用，设置并配置集群，控制流式应用并推断其性能时，这些内容都将派上用场。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interface provides the notifyCheckpointComplete(long chkpntId) method, which might be called when the JobManager registers a checkpoint as completed—when all operators successfully</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T202702Z" creationid="xccui" creationdate="20190702T202645Z">
        <seg>该接口提供的notifyCheckpointComplete(long chkpntId)方法，会在JobManager将检查点注册为完成时，即所有算子都成功将其状态复制到远程存储后，被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a common strat‐ egy to produce (incomplete) low-latency results despite using a conservative water‐ marking strategy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184214Z" creationid="xccui" creationdate="20190626T183949Z">
        <seg>这是一个在保守的水位线策略下依然可以产生（非完整的）低延迟结果的常用方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a safety mechanism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T051548Z" creationid="xccui" creationdate="20190702T051548Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also the case if the unique identifier of an operator or the name of a state was changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043141Z" creationid="xccui" creationdate="20190705T043141Z">
        <seg>如果算子的唯一标识或状态名称发生了改变，也会出现这种情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also the reason it is not a good idea to override existing timestamps and watermarks in the middle of a streaming application, although this is possible with user-defined functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T041209Z" creationid="xccui" creationdate="20190607T041148Z">
        <seg>这也是为什么不建议在流式应用中途覆盖已有的时间戳和水位线（虽然这可以通过用户自定义函数实现）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also true for processing-time timers that are persisted in a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T065436Z">
        <seg>存入保存点中的处理时间计时器也是如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is batch processing regardless of whether the architecture is based on a data warehouse or components of the Hadoop ecosystem.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T035223Z" creationid="xccui" creationdate="20190605T043413Z">
        <seg>无论它们的架构是基于数据仓库还是Hadoop生态系统组件，这都属于批处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is fine for some applications, but what if you are only interested in the most recent data?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043032Z" creationid="xccui" creationdate="20190406T042859Z">
        <seg>该操作对某些应用而言是可行的，但如果你只对最新的那部分数据感兴趣该怎么办？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to the maintenance techniques database sys‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155421Z" creationid="xccui" creationdate="20190605T044509Z">
        <seg>这有点类似于数据库系统为了更新物化视图而用到的维护技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to view maintenance techniques that database systems use to update materi&lt;t2/&gt;‐&lt;t3/&gt; alized views.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T060100Z" creationid="xccui" creationdate="20190317T060100Z">
        <seg>这有点类似于数据库系统为了更新物化视图而使用的视图维护技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the last call in our example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005918Z" creationid="xccui" creationdate="20190613T005918Z">
        <seg>这是我们示例中最后一个方法调用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the same use case as in the keyed state example before, but the KeyedProcessFunction also clears the state for keys (i.e., sensors) that have not pro‐ vided any new temperature measurements within one hour of event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205827Z" creationid="xccui" creationdate="20190704T205500Z">
        <seg>这和之前使用键值分区状态的用例相同，但此处的KeyedProcessFunction会在某一键值超过1小时（事件时间）都没有新到的温度测量数据时将其对应的状态清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the strictest and most challenging to achieve type of guarantee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T043916Z" creationid="xccui" creationdate="20190416T043916Z">
        <seg>这是最严格也是最难实现的一类保障。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very attractive especially in combination with Flink’s savepoint feature which can reset the state of an application to a previous consistent savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190313T005726Z" creationid="xccui" creationdate="20190312T214059Z">
        <seg>这在Flink保存点（savepoint）功能的加持下，尤为引人注目。所谓保存点功能是指在保证一致性的前提下，允许将应用状态重置到先前某个保存的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes development easier and sim‐ plifies cluster deployment, as you can run the exact same code in a cluster environ‐ ment without making any changes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T034912Z" creationid="xccui" creationdate="20190611T032127Z">
        <seg>这让开发过程变得更容易，也让集群部署变得更简单，因为你可以在不对代码进行任何修改的情况下直接切换到集群环境中运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes the JobManager a single point of failure for applications in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145839Z" creationid="xccui" creationdate="20190606T145818Z">
        <seg>这就导致JobManager成为Flink应用中的一个单点失效组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes the JobManager a single-point-of-failure for applications in Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T044559Z" creationid="xccui" creationdate="20190502T043400Z">
        <seg>这就导致JobManager成为Flink应用中一个单点失效组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means if the difference between an element’s event time and the maximum timestamp of all previous elements is greater than 10 seconds, the element might arrive for processing after its corresponding computation has completed and the result has been emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T053515Z" creationid="xccui" creationdate="20190620T053515Z">
        <seg>这意味着如果元素的事件时间和之前到达元素的最大时间戳相差超过10秒，那么当元素到达并开始处理时，它本应参与的计算可能已经完成，结果已经发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that all events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044724Z" creationid="xccui" creationdate="20190614T044724Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that all records processed by the same parallel task have access to the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T060848Z" creationid="xccui" creationdate="20190607T060836Z">
        <seg>这意味着所有在同一个并发任务之内的记录都能访问到相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you should take application requirements and the properties of its input data, such as key domain, into account when designing and implementing stateful operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T200130Z" creationid="xccui" creationdate="20190704T200130Z">
        <seg>这意味着你在设计和实现状态化算子的时候，需要把应用需求和输入数据的属性（如键值域）都考虑在内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means the time needed to prepare a single beverage will increase, causing each person to spend more time in the coffees hop, thus lowering the overall throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T054439Z" creationid="xccui" creationdate="20190605T235136Z">
        <seg>这意味着准备单杯咖啡的时间会延长，继而导致每位顾客在店里花费的时间增加，此时整体吞吐量将会下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method can decide to gen‐ erate a new watermark or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054317Z" creationid="xccui" creationdate="20190620T054317Z">
        <seg>它可以决定是否生成一个新的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method receives a Par titioner object that implements the partitioning logic and the field or key posi‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050335Z" creationid="xccui" creationdate="20190616T050245Z">
        <seg>该方法接收一个Partitioner对象，其中可以实现分区逻辑，定义分区需要参照的字段或键值位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method returns a local or remote environment, depending on the con‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045221Z" creationid="xccui" creationdate="20190612T045221Z">
        <seg>根据调用时所处上下文的不同，这个方法可能会返回一个本地或远程环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method stores every event in a buffer until its processing has been acknowledged by all tasks in the pipeline, at which point the event can be discarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T193901Z" creationid="xccui" creationdate="20190416T043634Z">
        <seg>该方法会将所有事件存在缓冲区中，直到处理管道中所有任务都确认某个事件已经处理完毕才会将事件丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method uses the current timestamp to generate watermarks, since no earlier timestamps can appear.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051836Z" creationid="xccui" creationdate="20190620T051801Z">
        <seg>基于时间戳不会回退，该方法使用当前时间戳生成水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This might happen if</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T021644Z" creationid="xccui" creationdate="20190701T021644Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mode is used to execute a Flink program within an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T052637Z" creationid="xccui" creationdate="20190611T052637Z">
        <seg>该模式可用于在IDE中执行Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This needs to be taken into</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T203026Z" creationid="xccui" creationdate="20190702T203026Z">
        <seg>你在实现接口时需要考虑到这点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This partitioning strategy must be used with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T045954Z" creationid="xccui" creationdate="20190616T045912Z">
        <seg>使用此分区策略时务必小心，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This problem does not only exist for custom stateful functions but also for some of the built-in operators of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T183059Z" creationid="xccui" creationdate="20190704T183059Z">
        <seg>该问题不但存在于自定义的有状态函数中，而且同样会影响DataStream API的内置算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This problem is commonly solved by delegating state management to an external system, such as a database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T054012Z" creationid="xccui" creationdate="20190414T053952Z">
        <seg>该问题通常的解决方案是将状态管理交由某个外部系统（如：数据库）完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This problem is commonly solved by delegating state manage‐ ment to an external system, such as a database.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032125Z" creationid="xccui" creationdate="20190606T032125Z">
        <seg>该问题通常的解决方案是将状态管理交由某个外部系统（如：数据库）完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property can be leveraged during checkpoints and when rescaling an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T185718Z" creationid="xccui" creationdate="20190607T185319Z">
        <seg>该特性可用于检查点保存或算子扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requires splitting or merging of state objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T055247Z" creationid="xccui" creationdate="20190701T055247Z">
        <seg>这就需要拆分或合并状态对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This setting offers very low latency because processing tasks do not have to wait for watermarks to advance the event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070153Z" creationid="xccui" creationdate="20190619T070153Z">
        <seg>在该配置下，由于处理任务无须等待水位线来驱动事件时间前进，所以可以提供极低的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This situation can be problematic for time-based operators that rely on an advancing clock to perform computations and clean up   their state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T032609Z" creationid="xccui" creationdate="20190607T032609Z">
        <seg>这种情形会给那些靠时钟前进来执行计算或清除状态的时间相关算子带来麻烦。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This situation is commonly known as &lt;t6/&gt;backpressure&lt;t7/&gt; and there exist different strategies to deal with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T202658Z" creationid="xccui" creationdate="20190402T202106Z">
        <seg>这种情形通常被称为背压（backpressure），可以通过多种策略来处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This situation is commonly known as backpressure and there are different strategies to deal with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T053732Z" creationid="xccui" creationdate="20190605T234829Z">
        <seg>这种情形通常被称为背压（backpressure），我们有多种可选策略来处理它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This state can be updated by incoming events and can be used in the processing logic of future events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T040548Z" creationid="xccui" creationdate="20190405T040313Z">
        <seg>它们的状态会根据传入的事件更新，并用于未来事件的处理逻辑中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This state can be upda‐ ted by incoming events and can be used in the processing logic of future events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235848Z" creationid="xccui" creationdate="20190605T235848Z">
        <seg>它们的状态会根据传入的事件更新，并用于未来事件的处理逻辑中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This state is completely controlled by the trigger and not maintained by the window operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T035220Z" creationid="xccui" creationdate="20190626T035125Z">
        <seg>该状态并非由窗口算子进行维护，而是完全由触发器来控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is fun&lt;t0/&gt;‐&lt;t1/&gt; damental to effectively utilize the networking resource and achieve high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041748Z" creationid="xccui" creationdate="20190504T041748Z">
        <seg>该技术是有效利用网络资源、实现高吞吐的基础。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is funda‐ mental to effectively using the networking resource and achieving high throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195459Z" creationid="xccui" creationdate="20190606T195459Z">
        <seg>该技术是有效利用网络资源、实现高吞吐的基础。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is used to recover from failures but can also be leveraged to update an</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T211855Z" creationid="esouser" creationdate="20190603T211855Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This technique is used to recover from failures but can also be leveraged to update an application, fix bugs and repair previously emitted results, migrate an application to a different cluster, or perform A/B tests with different application versions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T145302Z" creationid="xccui" creationdate="20190305T145014Z">
        <seg>该技术不但可用于失败恢复，还可用于应用更新、bug修复、结果修正、集群迁移或针对不同版本应用执行A/B测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of application is called a data pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154547Z" creationid="xccui" creationdate="20190605T042611Z">
        <seg>我们将此类应用称为数据管道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is also known as “no guar‐ antee” since even a system that drops every event can provide this guarantee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T192128Z" creationid="xccui" creationdate="20190606T034419Z">
        <seg>这类保障也被称作"没有保障"，因为即便系统丢掉所有事件也能满足其条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is also known as “no-guarantee” since even a system that drops every event can fulfil it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T184916Z" creationid="xccui" creationdate="20190415T184739Z">
        <seg>这类保障也被称作"没有保障"，因为即便系统丢掉所有事件也能满足。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is called at-least-once and it means that all events will def&lt;t0/&gt;‐&lt;t1/&gt; initely be processed, even though some of them might be processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T041957Z" creationid="xccui" creationdate="20190416T041845Z">
        <seg>这类保障称为至少一次。它意味着所有事件最终都会处理，即便有些可能会处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of guarantee is called at-least-once, and it means that all events will be pro‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T192900Z" creationid="xccui" creationdate="20190606T034604Z">
        <seg>这类保障称为至少一次。它意味着所有事件最终都会处理，虽然有些可能会处理多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of parallelism is called data parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044632Z" creationid="xccui" creationdate="20190401T030647Z">
        <seg>这种并行称为数据并行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of parallelism is called task parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T044813Z" creationid="xccui" creationdate="20190605T233305Z">
        <seg>这种并行称为任务并行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, open source communities are constantly improving the capabilities of their projects and are pushing the technical boundaries of stream processing further.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T041353Z" creationid="xccui" creationdate="20190322T035856Z">
        <seg>这样，开源社区不断增强它们项目的功能并在流处理领域开疆拓土。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, the time to prepare a sin&lt;t0/&gt;‐&lt;t1/&gt; gle beverage will increase, causing each person to spend more time in the coffee shop, thus lowering the overall throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190402T210136Z" creationid="xccui" creationdate="20190402T205924Z">
        <seg>这样的话，准备单杯咖啡的时间就会延长，继而导致每名顾客在店里花费的时间增加，整体吞吐量下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will generate a Maven project for Flink 1.7.1 in a folder called flink-scala-project.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005158Z" creationid="xccui" creationdate="20190612T005158Z">
        <seg>上述命令会为Flink 1.7.1版本生成一个Maven项目，放在flink-scala-project文件夹内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will initialize the state of the application to the state of the save‐ point and run the application from the point at which the savepoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211521Z" creationid="xccui" creationdate="20190609T211509Z">
        <seg>这样可以用保存点内的数据初始化状态并从生成保存点的那一刻继续运行应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This window type essentially represents a time interval between the two timestamps, where start is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041614Z" creationid="xccui" creationdate="20190623T041614Z">
        <seg>该窗口类型实际上表示两个时间戳之间的时间间隔（左闭右开）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This works because broadcasting state ensures that all tasks have the same state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T061853Z" creationid="xccui" creationdate="20190608T061836Z">
        <seg>这样做的原因是广播状态能确保所有任务的状态相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This yields a self- contained, yet typically quite large, application JAR file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T041513Z" creationid="xccui" creationdate="20190619T041513Z">
        <seg>这样会生成一个独立但通常很大的应用JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Threads are more lightweight than separate processes and have lower communication costs but do not strictly isolate tasks from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063219Z" creationid="xccui" creationdate="20190424T063109Z">
        <seg>和独立进程相比，线程更加轻量并且通信开销更低，但无法严格地将任务彼此隔离。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195249Z" creationid="xccui" creationdate="20190401T195249Z">
        <seg>吞吐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput is a measure of the system’s processing capacity, i.e. its &lt;t0/&gt;rate&lt;t1/&gt; of processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T195449Z" creationid="xccui" creationdate="20190401T195333Z">
        <seg>吞吐是用来衡量系统处理能力（处理速率）的指标，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput is a measure of the system’s processing capacity—its rate of processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234345Z" creationid="xccui" creationdate="20190605T234345Z">
        <seg>吞吐是用来衡量系统处理能力（处理速率）的指标，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughput is measured in events or operations per time unit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052333Z" creationid="xccui" creationdate="20190401T200345Z">
        <seg>吞吐的衡量方式是计算每个单位时间的事件或操作数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, an event might belong to multiple buckets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013221Z" creationid="xccui" creationdate="20190606T013145Z">
        <seg>这意味着每个事件可能会同时属于多个桶。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, an&lt;t1/&gt; &lt;t2/&gt;event might belong to multiple buckets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024049Z" creationid="xccui" creationdate="20190407T023736Z">
        <seg>这意味着每个事件可能会属于多个桶。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, for applications where speed is more important than accuracy, processing time comes handy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T043219Z" creationid="xccui" creationdate="20190414T041302Z">
        <seg>因此对于那些更重视处理速度而非准确度的应用而言，处理时间用起来很方便。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, for applications where speed is more important than accuracy, processing time comes in handy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T180646Z" creationid="xccui" creationdate="20190606T030938Z">
        <seg>因此针对那些更重视处理速度而非准确度的应用，处理时间就会派上用场。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, it is com‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045436Z" creationid="xccui" creationdate="20190619T045436Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the latency is bounded by the arrival time of the last event in each batch and naturally depends on the batch size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T200248Z" creationid="xccui" creationdate="20190401T193810Z">
        <seg>因此处理延迟受制于每个批次最迟事件的时间，且天然依赖批次大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, you wait in line and when it is your turn you make an order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T152842Z" creationid="xccui" creationdate="20190401T152507Z">
        <seg>这时候你就需要排队，等轮到你的时候再开始点单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, you wait in line and when it is your turn you place an order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233857Z" creationid="xccui" creationdate="20190605T233857Z">
        <seg>这时候你就需要排队，等轮到你的时候再开始点单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time Semantics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144012Z" creationid="esouser" creationdate="20190603T144012Z">
        <seg>时间语义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time Semantics | 27</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T041436Z" creationid="xccui" creationdate="20190606T041436Z">
        <seg>时间语义 | 27</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time is perhaps the most important aspect of stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064032Z" creationid="xccui" creationdate="20190409T200209Z">
        <seg>时间可能是流处理中最重要的一个方面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time semantics</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T015458Z" creationid="xccui" creationdate="20190225T015458Z">
        <seg>时间语义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time to get our hands dirty and start developing Flink applications!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190224T174724Z" creationid="xccui" creationdate="20190224T174724Z">
        <seg>是时候撸起袖子着手开发Flink应用了！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time windows have a start and an end timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T033207Z" creationid="xccui" creationdate="20190623T033207Z">
        <seg>每个时间窗口都有一个开始时间戳和一个结束时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time- based tumbling windows define a time interval during which events are buffered in the bucket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063432Z" creationid="xccui" creationdate="20190606T013049Z">
        <seg>基于时间的（time-based）滚动窗口定义了在桶中缓冲数据的时间间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-Based and Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045937Z" creationid="xccui" creationdate="20190619T045937Z">
        <seg>基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-Based and Window Operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145657Z" creationid="esouser" creationdate="20190603T145657Z">
        <seg>基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based and Window Operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022953Z" creationid="xccui" creationdate="20190225T022953Z">
        <seg>基于时间和窗口的算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based operators use this time to trigger computations and make progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T041707Z" creationid="xccui" creationdate="20190523T041707Z">
        <seg>基于时间的算子会使用这个时间来触发计算并向前推进。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based tumbling window</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013123Z" creationid="xccui" creationdate="20190606T013122Z">
        <seg>基于时间的滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based tumbling window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023609Z" creationid="xccui" creationdate="20190407T023609Z">
        <seg>基于时间的滚动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based tumbling windows define a time interval during which events are buffered in the bucket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T023258Z" creationid="xccui" creationdate="20190407T023053Z">
        <seg>基于时间的（time-based）滚动窗口定义在桶中缓冲数据的时间间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-based window assigners assign an element based on its event-time timestamp or the current processing time to windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T033135Z" creationid="xccui" creationdate="20190623T033135Z">
        <seg>基于时间的窗口分配器会根据元素的事件时间戳或当前处理时间将其分配到一个或多个窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time-related operators such as window operators and other specialized trans‐ formations are described in later chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T013239Z" creationid="xccui" creationdate="20190613T013033Z">
        <seg>基于时间的算子（例如窗口算子）以及其他一些特殊转换会在后面章节介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TimeCharacteristic.ProcessingTime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T014054Z" creationid="xccui" creationdate="20190620T014054Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TimerService and Timers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="esouser" creationdate="20190603T145847Z">
        <seg>时间服务和计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers are always asynchronously checkpointed, with one exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T065600Z">
        <seg>计时器通常会以异步方式存入检查点，但有一个例外。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers are checkpointed along with any other state of the function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T065223Z">
        <seg>这些计时器会和其他状态一起写入检查点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers can be based on event time or processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205850Z" creationid="xccui" creationdate="20190704T205850Z">
        <seg>计时器可以基于事件时间或处理时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers can only be registered on keyed streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T061215Z">
        <seg>计时器只允许在按键值分区的数据流上注册。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers of a trigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040431Z" creationid="xccui" creationdate="20190626T034200Z">
        <seg>触发器计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers on Nonkeyed Streams</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T061036Z">
        <seg>在非键值流上设置计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timers that are registered for a timestamp in the past are not silently dropped but processed as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T070407Z">
        <seg>以过去的时间戳注册的计时器不会被静默删除，而同样会被处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamp Assignment and Watermark Generation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144538Z" creationid="xccui" creationdate="20190225T021938Z">
        <seg>时间戳分配和水位线生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamp assigners behave like other transformation operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T032959Z" creationid="xccui" creationdate="20190620T032959Z">
        <seg>时间戳分配器和工作原理和其他转换算子类似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamp assigners do not change the data type of a DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T033249Z" creationid="xccui" creationdate="20190620T033249Z">
        <seg>时间戳分配器不会改变DataStream的数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T155747Z" creationid="xccui" creationdate="20190225T021851Z">
        <seg>时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and watermarks are specified in milliseconds since the epoch of 1970-01-01T00:00:00Z.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T020306Z" creationid="xccui" creationdate="20190620T020306Z">
        <seg>时间戳和水位线都是利用自1970-01-01 00:00:00以来的毫秒数指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and watermarks are usually assigned and generated when a stream is ingested by a streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T033706Z" creationid="xccui" creationdate="20190607T033653Z">
        <seg>时间戳和水位线通常都是在数据流刚刚进入流处理应用的时候分配和生成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and watermarks for event-time applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023039Z" creationid="xccui" creationdate="20190225T023039Z">
        <seg>事件时间应用中的时间戳和watermark</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps and water‐ marks can be either assigned and generated by a SourceFunction or using an explicit user-defined timestamp assigner and watermark generator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T020916Z" creationid="xccui" creationdate="20190620T020916Z">
        <seg>时间戳分配和水位线生成既可以通过SourceFunction，也可以使用一个显式的用户自定义时间戳分配和水位线生成器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps usually exist inside the event data before they enter the processing pipeline (e.g. event cre&lt;t2/&gt;‐&lt;t3/&gt; ation time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T150102Z" creationid="xccui" creationdate="20190412T150102Z">
        <seg>这些时间戳通常在事件数据进入流处理管道之前就存在（例如：事件生成时间）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timestamps usually exist inside the event data before they enter the processing pipeline (e.g., the event creation time).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155915Z" creationid="xccui" creationdate="20190606T024140Z">
        <seg>这些时间戳通常在事件数据进入流处理管道之前就存在（例如事件的创建时间）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To access the createTypeInformation macro function, make sure to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054745Z" creationid="xccui" creationdate="20190617T054731Z">
        <seg>为了使用createTypeInformation宏函数，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To assess end-to-end guarantees, one has to consider all the components of an application pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045840Z" creationid="xccui" creationdate="20190416T045830Z">
        <seg>为了评估它，需要考虑应用处理管道上的所有组件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To better understand the con&lt;t4/&gt;‐&lt;t5/&gt; cept of peak throughput, let us consider that system resources are completely unused.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T204336Z" creationid="xccui" creationdate="20190401T204219Z">
        <seg>为了更好地理解峰值吞吐的概念，我们假设系统资源完全空闲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To better understand the con‐ cept of peak throughput, let’s consider a stream processing application that does not receive any incoming data and thus does not consume any system resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052628Z" creationid="xccui" creationdate="20190605T234611Z">
        <seg>为了更好地理解峰值吞吐的概念，我们先假设某个流处理应用没有在接收任何数据，也因此无需占用任何系统资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To comment or ask technical questions about this book, send email to bookques‐ tions@oreilly.com.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210844Z" creationid="esouser" creationdate="20190603T210844Z">
        <seg>To comment or ask technical questions about this book, send email to bookques‐ tions@oreilly.com.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a state object, we have to register a StateDescriptor with Flink’s runtime via the RuntimeContext, which is exposed by RichFunction (see “Implementing Functions” on page 105 for a discussion of the RichFunction interface).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T065152Z" creationid="xccui" creationdate="20190630T064840Z">
        <seg>为了创建一个状态对象，我们需要利用RichFunction（有关该接口的内容请参照105页"实现函数"）中的RuntimeContext在Flink运行时中注册一个StateDescriptor。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a window operator, you need to specify two window components:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T035330Z" creationid="xccui" creationdate="20190622T035330Z">
        <seg>为了新建一个窗口算子需要指定两个窗口组件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To date, more than five hundred individu‐ als have contributed to Flink, and it has evolved into one of the most sophisticated open source stream processing engines as proven by its widespread adoption.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T051658Z" creationid="esouser" creationdate="20190603T162900Z">
        <seg>截至目前，该项目已经有超过500名贡献者，并在不断普及的过程中逐渐发展为开源界最为先进的流处理引擎之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define time operations in a distributed stream processing application, it is impor‐ tant to understand the meaning of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T054852Z" creationid="xccui" creationdate="20190619T054843Z">
        <seg>为了在分布式流处理应用中定义时间操作，准确理解时间的含义非常关键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ensure that event-time operations behave as expected, the assigner should be called before any event-time dependent transformation (e.g., before the first event- time window).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T033058Z" creationid="xccui" creationdate="20190620T032816Z">
        <seg>为了保证事件时间操作能够正常工作，必须将分配器放在任何依赖事件时间的转换之前（例如，在第一个事件时间窗口之前）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To key the stream by sensor ID we can pass the field name id to the keyBy() func‐ tion:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T042634Z" creationid="xccui" creationdate="20190618T042634Z">
        <seg>为了将传感器ID设为数据流的键值，我们可以把字段名称id传给keyBy()函数：，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To limit the state size, operators usually maintain some kind of summary or &lt;t0/&gt;synopsis&lt;t1/&gt; of the events seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055014Z" creationid="xccui" creationdate="20190414T054943Z">
        <seg>为了限制状态大小，算子通常都会只保留到目前为止所见事件的摘要或概览。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To limit the state size, operators usually maintain some kind of summary or synopsis of the events seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T032413Z" creationid="xccui" creationdate="20190606T032413Z">
        <seg>为了限制状态大小，算子通常都会只保留到目前为止所见事件的摘要或概览。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To overcome this problem, Flink supports a high-availability mode that migrates the responsibility and metadata for a job to another JobManager in case that the original JobManager disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T044628Z" creationid="xccui" creationdate="20190502T044050Z">
        <seg>为了解决该问题，Flink提供了高可用模式，支持在原JobManager消失的情况下将作业的管理职责及元数据迁移到另一个JobManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To over‐ come this problem, Flink supports a high-availability mode that migrates the respon‐ sibility and metadata for a job to another JobManager in case the original JobManager disappears.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145905Z" creationid="xccui" creationdate="20190606T145905Z">
        <seg>为了解决该问题，Flink提供了高可用模式，支持在原JobManager消失的情况下将作业的管理职责及元数据迁移到另一个JobManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To produce a result, a UDF accumulates state over a period or number of events, e.g. to compute an aggregation or detect a pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T051900Z" creationid="xccui" creationdate="20190414T051733Z">
        <seg>为了生成结果，UDF会在一段时间或基于一定个数的事件来累积状态，如：计算聚合或检测某个模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To produce a result, a function accumulates state over a period of time or number of events (e.g., to compute an aggregation or detect a pattern).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181304Z" creationid="xccui" creationdate="20190606T031435Z">
        <seg>为了生成结果，函数会在一段时间或基于一定个数的事件来累积状态（例如计算聚合或检测某个模式）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prop&lt;t0/&gt;‐&lt;t1/&gt; erly define window operator semantics, we need to answer two main questions: “&lt;t2/&gt;how&lt;t3/&gt; &lt;t4/&gt;are events assigned to buckets?&lt;t5/&gt;” and “&lt;t6/&gt;how often does the window produce a result?&lt;t7/&gt;”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022727Z" creationid="xccui" creationdate="20190406T045045Z">
        <seg>为了准确定义窗口算子语义，我们需要回答两个核心问题："事件如何分配到桶中"以及"窗口以什么频率产生结果"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prop‐ erly define window operator semantics we need to determine both how events are assigned to buckets and how often the window produces a result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012636Z" creationid="xccui" creationdate="20190606T012334Z">
        <seg>为了准确定义窗口算子语义，我们需要决定事件如何分配到桶中以及窗口以怎样的频率产生结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recap, processing time offers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031242Z" creationid="xccui" creationdate="20190606T031242Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recap, processing time offers low latency but results depend on the speed of processing and are not deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050354Z" creationid="xccui" creationdate="20190414T045432Z">
        <seg>总之，虽然处理时间提供了很低的延迟，但它的结果依赖处理速度，具有不确定性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recover from fail&lt;t0/&gt;‐&lt;t1/&gt; ures, the system needs to deal with two aspects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205059Z" creationid="xccui" creationdate="20190428T204311Z">
        <seg>为了从故障中恢复，系统需要做两手处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To recover from fail‐ ures, the system first needs to restart failed processes, and second, restart the applica‐ tion and recover its state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T072106Z" creationid="xccui" creationdate="20190606T145331Z">
        <seg>为了从故障中恢复，系统首先要重启故障进程，随后需要重启应用并恢复其状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To some extent, the latency can be reduced by importing data into the data store with data pipeline applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032021Z" creationid="xccui" creationdate="20190317T032021Z">
        <seg>在某种程度上，使用数据管道应用来导入数据可以降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To some extent, the latency can be reduced by importing data into the datastore with a data pipeline application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T043556Z" creationid="xccui" creationdate="20190605T043556Z">
        <seg>在某种程度上，使用数据管道应用来导入数据可以降低延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To start the application, run the main() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T042857Z" creationid="xccui" creationdate="20190611T042842Z">
        <seg>直接运行它就能启动应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To structure a typical Flink streaming application:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043456Z" creationid="xccui" creationdate="20190612T043456Z">
        <seg>构建一个典型的Flink流式应用需要以下步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To understand latency intuitively, consider your daily visit to your favorite coffee shop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233829Z" creationid="xccui" creationdate="20190401T152125Z">
        <seg>为了直观地理解延迟，想一下你每天都会光顾自己喜欢的咖啡店。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use timers on a nonkeyed stream, you can create a keyed stream by</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T062029Z">
        <seg>为了在一条非键值分区的数据流上使用计时器，你可以通过在KeySelector中返回一个假的常数键值来创建一条键值分区数据流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, components of the Apache Hadoop ecosystem are integral parts in the IT infrastructures of many enterprises and companies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T032150Z" creationid="xccui" creationdate="20190228T210817Z">
        <seg>时至今日，Apache Hadoop生态组件已经成为很多公司和企业IT基础架构中举足轻重的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, components of the Apache Hadoop ecosystem are integral parts in the IT infrastructures of many enterprises.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T204436Z" creationid="esouser" creationdate="20190603T203736Z">
        <seg>时至今日，Apache Hadoop生态组件已经成为很多公司和企业IT基础设施中举足轻重的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, distributed open source stream processors power business-critical applications in many enterprises across dif&lt;t2/&gt;‐&lt;t3/&gt; ferent industries such as (online) retail, social media, telecommunication, gaming, and banking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T014807Z" creationid="xccui" creationdate="20190319T041711Z">
        <seg>如今，开源分布式流处理引擎已经支撑起包括（在线）零售、社交媒体、移动通信、游戏、银行等很多不同行业的核心业务应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today, dis‐ tributed open source stream processors power business-critical applications in many</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050251Z" creationid="xccui" creationdate="20190605T050251Z">
        <seg>如今，开源分布式流处理引擎已经支撑起包括（在线）零售、社交媒体、移动通信、游戏、银行等很多不同行业的核心业务应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today’s IT architectures include many different data stores, such as relational and special-purpose database systems, event logs, distributed file systems, in-memory caches, and search indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T013908Z" creationid="xccui" creationdate="20190314T064734Z">
        <seg>今日的IT架构通常会涵盖多种不同的数据存储，例如：关系型或专用数据库系统、事件日志系统、分布式文件系统、内存缓存、搜索索引等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Today’s IT architectures include many different datastores, such as relational and special-purpose database systems, event logs, distributed filesystems, in-memory caches, and search indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T153510Z" creationid="xccui" creationdate="20190604T053748Z">
        <seg>如今的IT架构通常会包含多种不同的数据存储，例如：关系型或专用数据库系统、事件日志系统、分布式文件系统、内存缓存及搜索索引等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tokyo</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210643Z" creationid="esouser" creationdate="20190603T210643Z">
        <seg>Tokyo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional Data Infrastructures</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T014533Z" creationid="xccui" creationdate="20190225T014533Z">
        <seg>传统数据处理架构</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional Data Infrastructures   | 3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T203023Z" creationid="esouser" creationdate="20190603T203023Z">
        <seg>传统数据处理架构 | 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional analytics pipelines consist of several individual components such as an ETL process, a storage system, and in case of a Hadoop-based environment also a data processor and scheduler to trigger jobs or queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T062950Z" creationid="xccui" creationdate="20190317T062820Z">
        <seg>传统分析流水线包含了很多独立组件，例如：ETL进程、存储系统等。即便是基于Hadoop的环境，也需要有数据处理器和用来触发作业或查询的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional analytics pipelines consist of several individual components such as an ETL process, a storage system, and in the case of a Hadoop-based environment, a data processor and scheduler to trigger jobs or queries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155638Z" creationid="xccui" creationdate="20190605T044756Z">
        <seg>传统分析流水线包含了很多独立组件，例如ETL进程、存储系统等。即便是基于Hadoop的环境，也需要有数据处理器和用来触发作业或查询的调度器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional batch oriented architectures are not able to address such use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T054141Z" creationid="xccui" creationdate="20190317T054141Z">
        <seg>面向批次的传统架构根本无力应对它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traditional design of transactional applications that store data in a remote database system</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T195357Z" creationid="esouser" creationdate="20190603T195332Z">
        <seg>将数据存储在远程数据库系统内的传统事务型应用设计</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional Processing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142849Z" creationid="esouser" creationdate="20190603T142849Z">
        <seg>事务型处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional Sink Connectors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T025317Z" creationid="xccui" creationdate="20190225T025317Z">
        <seg>事务性汇连接器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional Writes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T055932Z" creationid="esouser" creationdate="20190603T151955Z">
        <seg>事务性写</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T061953Z" creationid="xccui" creationdate="20190226T161728Z">
        <seg>事务型应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional updates are one way to achieve this result, but they can incur substantial performance overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034940Z" creationid="xccui" creationdate="20190606T034907Z">
        <seg>事务性更新是实现该目标的一个方法，但它可能会带来极大的性能开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transactional updates is one way to achieve this result, however, it can incur substantial performance over&lt;t0/&gt;‐&lt;t1/&gt; head.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T044921Z" creationid="xccui" creationdate="20190416T044551Z">
        <seg>事务性更新是达到该结果的一个方法，但它可能会带来极大的性能开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformation operations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T152748Z" creationid="xccui" creationdate="20190405T152748Z">
        <seg>转换操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformation operations are single-pass operations that process each event inde&lt;t0/&gt;‐&lt;t1/&gt; pendently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T153157Z" creationid="xccui" creationdate="20190405T152939Z">
        <seg>转换操作是一种"单向"操作，会独立处理每个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformation operations are single-pass operations that process each event inde‐ pendently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T060526Z" creationid="xccui" creationdate="20190606T010742Z">
        <seg>转换操作是一类"单向"操作，它们会独立处理每个事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T022706Z" creationid="xccui" creationdate="20190225T022706Z">
        <seg>转换操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations and rolling aggregations process one event at a time to produce out&lt;t0/&gt;‐&lt;t1/&gt; put events and potentially update state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T041821Z" creationid="xccui" creationdate="20190406T035950Z">
        <seg>转换操作和滚动聚合每次处理一个事件来产生输出并（可能）更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations and rolling aggregations process one event at a time to produce out‐ put events and potentially update state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011956Z" creationid="xccui" creationdate="20190606T011956Z">
        <seg>转换操作和滚动聚合每次处理一个事件来产生输出并（可能）更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transformations | 85</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045238Z" creationid="xccui" creationdate="20190619T045238Z">
        <seg>转换操作 | 85</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TriggerResult can take one of the following values:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T184354Z" creationid="xccui" creationdate="20190626T184354Z">
        <seg>TriggerResult允许是以下值之一：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TriggerResult onElement(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190001Z" creationid="xccui" creationdate="20190626T190001Z">
        <seg>TriggerResult onElement(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TriggerResult.CONTINUE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200648Z" creationid="xccui" creationdate="20190626T200648Z">
        <seg>TriggerResult.CONTINUE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TriggerResult.FIRE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200902Z" creationid="xccui" creationdate="20190626T200902Z">
        <seg>TriggerResult.FIRE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TriggerResult.FIRE_AND_PURGE</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200740Z" creationid="xccui" creationdate="20190626T200740Z">
        <seg>TriggerResult.FIRE_AND_PURGE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Triggers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T213643Z" creationid="xccui" creationdate="20190625T213643Z">
        <seg>触发器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Triggers define when a window is evaluated and its results are emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T181313Z" creationid="xccui" creationdate="20190626T181313Z">
        <seg>触发器用于定义何时对窗口进行计算并发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Triggers have access to time properties and timers, and can work with state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T182331Z" creationid="xccui" creationdate="20190626T182243Z">
        <seg>触发器不仅能够访问时间属性和计时器，还可以使用状态，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True stream processing does not introduce such artificial delays and therefore can achieve really low latencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T194716Z" creationid="xccui" creationdate="20190401T194107Z">
        <seg>真正的流处理不会引入人为推迟等要素，因此才能实现极低的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True stream processing does not intro‐ duce such artificial delays and thus can achieve really low latencies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051857Z" creationid="xccui" creationdate="20190605T234321Z">
        <seg>真正的流处理不会引入人为延迟等要素，只有这样才能将延迟将至极低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tumbling &lt;t0/&gt;windows assign events into non-overlapping buckets of fixed size.&lt;t1/&gt; &lt;t2/&gt;When the window border is passed, all the events are sent to an evaluation func&lt;t3/&gt;‐&lt;t4/&gt; tion for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022909Z" creationid="xccui" creationdate="20190406T050614Z">
        <seg>滚动窗口（tumbling window）将事件分配到长度固定且互不重叠的桶中。在窗口边界通过后，所有事件会发送给计算函数处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tumbling windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041957Z" creationid="xccui" creationdate="20190623T041957Z">
        <seg>滚动窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tumbling windows assign events into nonoverlapping buckets of fixed size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013019Z" creationid="xccui" creationdate="20190606T013011Z">
        <seg>滚动窗口（tumbling window）将事件分配到长度固定且互不重叠的桶中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuning Checkpointing and Recovery</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025948Z" creationid="xccui" creationdate="20190225T030028Z">
        <seg>调整检查点及恢复</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple fields are referenced either by their field name (1-offset for Scala tuples, 0-offset for Java tuples) or by their 0-offset field index:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T043248Z" creationid="xccui" creationdate="20190618T043248Z">
        <seg>元组字段的引用既可以利用字段名称（Scala元组编号从1开始，Java元组编号从0开始）也可以利用从0开始的字段索引：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple fields can be accessed by the name of their public fields—f0, f1, f2, etc., as shown earlier—or by position using the getField(int pos) method, where indexes start at 0:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035616Z" creationid="xccui" creationdate="20190617T035415Z">
        <seg>元组中的各个字段可以向上面那样通过公有字段名称（f0、f1、f2等）访问，也可以使用getField(int pos)方法通过位置访问，位置下标从0开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple2.of("Sarah", 23));</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035201Z" creationid="xccui" creationdate="20190617T035201Z">
        <seg>Tuple2.of("Sarah", 23));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple2&lt;String, Integer&gt; personTuple = Tuple2.of("Alex", "42"); Integer age = personTuple.getField(1); // age = 42</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035820Z" creationid="xccui" creationdate="20190617T035820Z">
        <seg>Tuple2&lt;String, Integer&gt; personTuple = Tuple2.of("Alex", "42"); Integer age = personTuple.getField(1); // age = 42</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples are composite data types that consist of a fixed number of typed fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070645Z" creationid="xccui" creationdate="20190616T070645Z">
        <seg>元组是由固定数量的类型字段所组成的复合数据类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two tasks of a sum operator compute the running sums of all even and odd numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T030906Z" creationid="xccui" creationdate="20190609T030813Z">
        <seg>求和算子的两个任务会分别对它们求和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Information in the Scala API</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054635Z" creationid="xccui" creationdate="20190617T054635Z">
        <seg>Scala API中的类型信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TypeInformation&lt;Integer&gt; intType = Types.INT;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053613Z" creationid="xccui" creationdate="20190617T053613Z">
        <seg>TypeInformation&lt;Integer&gt; intType = Types.INT;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TypeInformation&lt;Person&gt; personType = Types.POJO(Person.class);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053659Z" creationid="xccui" creationdate="20190617T053659Z">
        <seg>TypeInformation&lt;Person&gt; personType = Types.POJO(Person.class);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TypeInformation’s helper class is org.apache.flink.api.scala.typeutils.Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053810Z" creationid="xccui" creationdate="20190617T053746Z">
        <seg>Scala API中有关TypeInformation的辅助类是org.apache.flink.api.scala.typeutils.Types，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T055128Z" creationid="xccui" creationdate="20190225T022759Z">
        <seg>类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types that are not specially handled are treated as generic types and serialized using the Kryo serialization framework.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T065415Z" creationid="xccui" creationdate="20190616T065247Z">
        <seg>那些无法特别处理的类型会被当做泛型类型交给Kryo序列化框架进行序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types | 101</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045301Z" creationid="xccui" creationdate="20190619T045301Z">
        <seg>类型系统 | 101</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical real-world setups can easily have hundreds of such tasks running in parallel on many physical machines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T185655Z" creationid="xccui" creationdate="20190415T041636Z">
        <seg>不少实际系统设置都可以轻松做到在很多物理机器上并行运行数以百计的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical use cases for event-driven applications include</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190307T024821Z" creationid="xccui" creationdate="20190307T024821Z">
        <seg>事件驱动型应用的典型应用场景有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical use cases for event-driven applications include:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T213603Z" creationid="esouser" creationdate="20190603T213603Z">
        <seg>事件驱动型应用的典型应用场景有：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical use cases for streaming analytics applications are</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T033324Z" creationid="xccui" creationdate="20190319T033305Z">
        <seg>典型的流式分析用例包括：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, a database system serves multiple applications which often even access the same databases or tables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T184437Z" creationid="xccui" creationdate="20190226T163003Z">
        <seg>通常情况下，多个应用会共用一个数据库系统，更有甚者，这些应用会访问相同的数据库或表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, an external resource manager such as Kubernetes takes care of starting the images and ensures that containers are restarted in case of a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T063504Z" creationid="xccui" creationdate="20190606T143951Z">
        <seg>通常情况下，外部资源管理器（如：Kubernetes）负责启动映像，并确保在发生故障时可以重启容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, an external resource manager such as Kubernetes takes care of starting the images and ensuring that of each type a certain number of containers is running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T040551Z" creationid="xccui" creationdate="20190423T040305Z">
        <seg>通常情况下，是由外部资源管理器（如：Kubernetes）负责启动映像，并各类型容器都以指定数量运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, streaming applications store their result in an external data store that supports efficient updates, such as a database or key-value store.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T155507Z" creationid="xccui" creationdate="20190317T060355Z">
        <seg>通常情况下，流式应用会把它们的结果保存在某种支持高效更新的外部数据存储中，例如数据库或键值存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, the state handle object is created in the open() method of RichFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T020654Z" creationid="xccui" creationdate="20190630T035356Z">
        <seg>通常情况下，状态句柄对象要在RichFunction的open()方法中创建。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, the timestamp assigner is called right after the source function because most assigners make assumptions about the order of elements with respect to their timestamps when generating watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T030818Z" creationid="xccui" creationdate="20190620T030818Z">
        <seg>通常情况下，应该在数据源函数后面立即调用时间戳分配器，因为大多数分配器在生成水位线的时候都会做出一些元素顺序相对时间戳的假设。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, there are multiple TaskManagers running in a Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061024Z" creationid="xccui" creationdate="20190606T142319Z">
        <seg>通常在Flink搭建过程中要启动多个TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, there are multiple&lt;t1/&gt; &lt;t2/&gt;TaskManager running in a Flink setup.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T051413Z" creationid="xccui" creationdate="20190418T051413Z">
        <seg>通常在Flink设置过程中要启动多个TaskManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, there are two classes of queries executed on a data warehouse.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T024914Z" creationid="xccui" creationdate="20190228T192320Z">
        <seg>通常数据仓库中的查询可以分为两类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typi‐ cally, these intervals are defined using time-based logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T033117Z" creationid="xccui" creationdate="20190622T033117Z">
        <seg>通常情况下，这些区间都是使用时间逻辑定义的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UDFs are written by the application programmer and implement custom computation logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T155205Z" creationid="xccui" creationdate="20190405T155205Z">
        <seg>UDF由应用开发人员编写，实现某些自定义的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Union</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T063514Z" creationid="xccui" creationdate="20190614T063514Z">
        <seg>Union</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Union list state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T035905Z" creationid="xccui" creationdate="20190607T184319Z">
        <seg>联合列表状态（union list state）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unique identifiers should be specified for every operator of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T015328Z" creationid="xccui" creationdate="20190703T015220Z">
        <seg>你应该为应用中的每个算子指定唯一标识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless you opt for a very conservative watermark strategy that guarantees that all relevant records will be included at the cost of high latency, your application will most likely have to handle late elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T151659Z" creationid="xingcan" creationdate="20190628T145930Z">
        <seg>除非你选择一种非常保守的水位线生成策略，以高延迟为代价确保涵盖全部相关记录，否则你的应用将很有可能需要处理迟到的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless you specify a parallelism, a program is executed by as many threads as the number of CPU threads of your development machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T053929Z" creationid="xccui" creationdate="20190611T053929Z">
        <seg>除非手工指定并行度，否则程序的线程数会和你开发机器的CPU线程数一样多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike batch applications, which are built around the premise that all data is avail‐ able, the latency/completeness tradeoff is a fundamental characteristic of stream pro‐ cessing applications, which process unbounded data as it arrives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T042217Z" creationid="xccui" creationdate="20190621T042217Z">
        <seg>批处理应用构建的前提是所有数据都处于随时可用状态。而流处理应用需要处理随时到来的无限数据，因此延迟和完整性之间的取舍是它的一项基本特征。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until the rise of Apache Hadoop, specialized analytical database systems and data warehouses were the predominant solutions for data analytics workloads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T203754Z" creationid="xccui" creationdate="20190228T194848Z">
        <seg>在Apache Hadoop出现前，专业分析型数据库系统和数据仓库共同占据着数据分析的江山。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until today, more than 470 individuals have contributed to Flink and it has evolved into one of the most sophisticated open source stream processing engines as proven by its widespread adoption.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T222146Z" creationid="xccui" creationdate="20190225T220444Z">
        <seg>时至今日，它已经有超过470名贡献者，并在不断普及的过程中逐渐演变为开源界最为复杂的流处理引擎之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Up to this point, we have considered streaming concepts independently of Apache Flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T195220Z" creationid="xccui" creationdate="20190416T051823Z">
        <seg>到目前为止，我们考虑的流处理相关概念都还是独立于Apache Flink的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating Results by Including Late Events</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T150802Z" creationid="xccui" creationdate="20190225T023500Z">
        <seg>基于迟到事件更新结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating an Application without Modifying Existing State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="xccui" creationdate="20190225T024908Z">
        <seg>保持现有状态更新应用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating or extending the logic of an application without changing or removing an existing state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T040022Z" creationid="xccui" creationdate="20190705T035553Z">
        <seg>在不对已有状态进行更改或删除的前提下更新或扩展应用逻辑，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating the event time of a task with watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T025639Z" creationid="xccui" creationdate="20190607T025639Z">
        <seg>利用水位线更新任务的事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon completion of a check‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T150247Z" creationid="xccui" creationdate="20190606T150247Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon the completion of a checkpoint, i.e., when all tasks have successfully written their state into the remote storage, the JobManager writes the state handles to the remote storage and a pointer to this location to ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T051010Z" creationid="xccui" creationdate="20190502T050555Z">
        <seg>在checkpoint即将完成之际，如果所有任务已经将各自状态成功写入远程存储，JobManager就会将状态句柄写入远程存储，并将远程位置的指针写入ZooKeeper。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the information and instructions contained in this work is at your own risk.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210741Z" creationid="esouser" creationdate="20190603T210741Z">
        <seg>Use of the information and instructions contained in this work is at your own risk.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Used for program listings, as well as within paragraphs to refer to program ele‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210803Z" creationid="esouser" creationdate="20190603T210803Z">
        <seg>Used for program listings, as well as within paragraphs to refer to program ele‐</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User functions can employ keyed state to store and access state in the context of a key attribute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190630T035526Z">
        <seg>用户函数可以使用键值分区状态来存储和访问当前键值上下文中的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-defined timestamp assignment functions are usually applied as close to a source operator as possible because it can be very difficult to reason about the order of records and their timestamps after they have been processed by an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T041030Z" creationid="xccui" creationdate="20190607T040633Z">
        <seg>用户自定义的时间戳分配函数通常都会尽可能地靠近数据源算子，因为在经过其他算子处理后，记录顺序和它们的时间戳会变得难以推断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users are organized in teams and the application collects a team’s activity and provides rewards in the game, such as extra lives and level-ups, based on how fast the team’s members meet the game’s goals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154428Z" creationid="xccui" creationdate="20190411T144758Z">
        <seg>该应用将用户组织成不同团队，并会收集每个团队的活动信息，这样就能基于团队成员完成游戏目标的速度，提供诸如额外生命或等级提升的游戏奖励</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users have reported applications with state sizes of multiple terabytes leveraging RocksDBStateBackend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025108Z" creationid="xccui" creationdate="20190704T025108Z">
        <seg>已经有用户介绍使用RocksDBStateBackend支撑起了状态大小为数个TB的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Code Examples</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210812Z" creationid="esouser" creationdate="20190603T210812Z">
        <seg>Using Code Examples</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Connected Broadcast State</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T205903Z" creationid="xccui" creationdate="20190225T024605Z">
        <seg>使用联结的广播状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a timestamp assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044614Z" creationid="xccui" creationdate="20190620T044614Z">
        <seg>使用时间戳分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using savepoints</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210933Z" creationid="xccui" creationdate="20190609T063118Z">
        <seg>保存点的使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using task parallelism you can better uti&lt;t0/&gt;‐&lt;t1/&gt; lize the computing resources of a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T034154Z" creationid="xccui" creationdate="20190401T032431Z">
        <seg>通过任务并行，可以更好地利用集群的计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using task parallelism, you can better utilize the computing resources of a cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233318Z" creationid="xccui" creationdate="20190605T233318Z">
        <seg>通过任务并行，可以更好地利用集群的计算资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the CheckpointedFunction Interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T024618Z" creationid="xccui" creationdate="20190225T024618Z">
        <seg>使用CheckpointedFunction接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the interval join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025827Z" creationid="xccui" creationdate="20190628T025827Z">
        <seg>使用基于间隔的Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using these exam‐ ples, we will show how Flink applications are executed and debugged in an IDE.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T040616Z" creationid="xccui" creationdate="20190610T040506Z">
        <seg>这些示例将向你展示如何在IDE中执行和调试Flink应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually, the program’s</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T051407Z" creationid="xccui" creationdate="20190611T051407Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>V), contains(key: K), remove(key: K), and iterators over the contained entries, keys, and values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T060004Z" creationid="xccui" creationdate="20190630T060004Z">
        <seg>以及用于遍历所含条目（entry）、键和值的遍历器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value state</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T215622Z" creationid="xccui" creationdate="20190607T192625Z">
        <seg>单值状态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ValueState[T] holds a single value of type T. The value can be read using Value State.value() and updated with ValueState.update(value: T).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T054334Z" creationid="xccui" creationdate="20190630T041507Z">
        <seg>ValueState[T]用于保存类型为T的单个值。你可以利用State.value()来读取该值并通过ValueState.update(value: T)来更新它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Virtually all data is created as continuous streams of events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T034956Z" creationid="xccui" creationdate="20190301T034927Z">
        <seg>几乎所有数据都是以连续事件流的形式产生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>W window,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201906Z" creationid="xccui" creationdate="20190627T201906Z">
        <seg>W window,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wait for all in-flight data to be completely processed, meaning all tasks have pro‐ cessed all their input data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T223921Z" creationid="xccui" creationdate="20190608T223647Z">
        <seg>等待已经流入系统的数据被完全处理，即所有任务已经处理完所有的输入数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watch us on YouTube: http://www.youtube.com/oreillymedia</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210847Z" creationid="esouser" creationdate="20190603T210847Z">
        <seg>Watch us on YouTube: http://www.youtube.com/oreillymedia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermark Propagation and Event Time</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T144528Z" creationid="xccui" creationdate="20190225T021907Z">
        <seg>水位线传播和事件时间</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155415Z" creationid="xccui" creationdate="20190412T155415Z">
        <seg>水位线</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are a powerful way to control the behavior of an application with respect to time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T042448Z" creationid="xccui" creationdate="20190621T042448Z">
        <seg>水位线是一种控制应用时间处理行为的强大方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are essential for both event-time win‐ dows and operators handling out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025515Z" creationid="xccui" creationdate="20190606T025515Z">
        <seg>水位线无论对于事件时间窗口还是处理乱序事件的算子都很关键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are essential to both event-time windows and operators handling out-of-order events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205616Z" creationid="xccui" creationdate="20190412T205616Z">
        <seg>水位线无论对于事件时间窗口还是处理乱序事件的算子都很关键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are related to record timestamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042558Z" creationid="xccui" creationdate="20190523T042558Z">
        <seg>水位线和记录的时间戳紧密相关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are used to balance latency and result completeness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T024055Z" creationid="xccui" creationdate="20190620T055329Z">
        <seg>水位线可用于平衡延迟和结果的完整性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are used to derive the current event time at each task in an event-time application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205105Z" creationid="xccui" creationdate="20190606T205105Z">
        <seg>水位线用于推断事件时间应用中每个任务当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks are used to derive the current event-time at each task in an event-time application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T041537Z" creationid="xccui" creationdate="20190523T040931Z">
        <seg>水位线用于推断事件时间应用中每个任务当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks flow in a stream of regular records with annotated timestamps as &lt;t0/&gt;Figure 3-8&lt;t1/&gt; shows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042250Z" creationid="xccui" creationdate="20190523T042250Z">
        <seg>如图3-8所示，它像带有注释时间戳的常规记录一样在数据流中移动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks flow in a stream of regular records with annotated time‐ stamps as Figure 3-8 shows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205307Z" creationid="xccui" creationdate="20190606T205307Z">
        <seg>如图3-8所示，它像带有注释时间戳的常规记录一样在数据流中移动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks have two basic properties.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042342Z" creationid="xccui" creationdate="20190523T042339Z">
        <seg>水位线拥有两个基本属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks have two basic properties:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205349Z" creationid="xccui" creationdate="20190606T205348Z">
        <seg>水位线拥有两个基本属性：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks must be monotonically increasing in order to ensure that the event-time clocks of tasks are progressing and not going backwards.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T042533Z" creationid="xccui" creationdate="20190523T042505Z">
        <seg>水位线必须单调递增，这是为了确保任务中的事件时间时钟正确前进，不会倒退。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks provide a configurable trade-off between results confidence and latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T210429Z" creationid="xccui" creationdate="20190412T210154Z">
        <seg>水位线允许我们在结果的准确性和延迟之间调整取舍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks provide a configurable tradeoff between results confidence and latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025633Z" creationid="xccui" creationdate="20190606T025603Z">
        <seg>水位线允许我们在结果的准确性和延迟之间做出取舍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks that are very tight, i.e., close to the record timestamps, result in low processing latency because a task will only briefly wait for more records to arrive before finalizing a computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T040459Z" creationid="xccui" creationdate="20190529T040214Z">
        <seg>如果水位线很紧密（靠近记录时间戳），得到结果的处理延迟就会很低，因为任务无须等待多少记录到来就可以触发最终计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks that are very tight—close to the record timestamps—result in low processing latency because a task will only briefly wait for more records to arrive before finalizing a computation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T210129Z" creationid="xccui" creationdate="20190606T205826Z">
        <seg>如果水位线很紧（靠近记录时间戳），得到结果的处理延迟就会很低，因为任务无须等待多少记录到来就可以触发最终计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Watermarks, Latency, and Completeness</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190604T030551Z" creationid="xccui" creationdate="20190225T023059Z">
        <seg>水位线、延迟及完整性问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We already discussed some of the features of the Context object when introducing the process functions, such as access to the current processing and event-time and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011641Z" creationid="xccui" creationdate="20190624T011641Z">
        <seg>在介绍处理函数的时候，我们已经讨论过Context对象的一些功能，例如访问当前处理时间和事件时间，访问副输出等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also assume per&lt;t2/&gt;‐&lt;t3/&gt; fect failure detectors and that no task will intentionally act maliciously; that is, all non-failed tasks follow the above steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043852Z" creationid="xccui" creationdate="20190415T043600Z">
        <seg>我们还假设任何故障都会被检测到，没有任务故意捣乱。换言之，所有正常运行的任务都会遵循上述步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also assume perfect failure detectors and that no task will intentionally act mali‐ ciously, meaning all nonfailed tasks follow the above steps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T200047Z" creationid="xccui" creationdate="20190606T033718Z">
        <seg>我们还假设任何故障都会被检测到，没有任务故意捣乱。换言之，所有正常运行的任务都会遵循上面提到的步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also discuss Flink’s unique savepoint feature, a “Swiss Army knife”-like tool that addresses many challenges of operating streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T154419Z" creationid="xccui" creationdate="20190608T154131Z">
        <seg>此外我们还会讨论Flink所独有的保存点机制，它就像一把瑞士军刀，解决了运行流式应用中的诸多挑战。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also discuss performance aspects and how to control the size of function</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T034111Z" creationid="xccui" creationdate="20190630T034111Z">
        <seg>此外，还将讨论性能方面的问题以及如何控制函数状态的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also discussed the semantics of watermarks, how to trade off result com‐ pleteness and result latency, and strategies for handling late events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041816Z" creationid="xccui" creationdate="20190629T041816Z">
        <seg>我们还讨论了水位线的语义，如何在结果的完成性和延迟之间进行取舍，以及应对迟到事件的相关策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also looked into supported data types and different ways to specify keys and user-defined functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T044237Z" creationid="xccui" creationdate="20190619T044237Z">
        <seg>我们还了解了Flink支持的数据类型以及用于指定键值和用户自定义函数的多种方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also provide complete example applications implemented in Java and Scala in our GitHub repositories.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T034647Z" creationid="xccui" creationdate="20190612T034647Z">
        <seg>我们在Github仓库中同时提供了用Java和Scala实现的完整示例程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also show how to jointly apply incremental aggregation and full window functions in a window operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211919Z" creationid="xccui" creationdate="20190623T211919Z">
        <seg>此外我们还将展示如何在窗口算子上联合应用增量聚合及全量窗口函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We appreciate, but do not require, attribution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210822Z" creationid="esouser" creationdate="20190603T210822Z">
        <seg>We appreciate, but do not require, attribution.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We are grateful to everyone who has contributed to Flink through code, documentation, reviews, bug reports, feature requests, mailing list discussions, trainings, conference talks, meetup organization, and other activities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T143647Z" creationid="xccui" creationdate="20190605T131706Z">
        <seg>感谢所有通过代码、文档、评论、Bug报告、功能需求、邮件列表讨论、培训、会议演讲、聚会组织等一切活动为Flink做出过贡献的人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume reliable network connections, and that no records are dropped or duplicated and all events are eventually delivered to their destination in FIFO order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T190803Z" creationid="xccui" creationdate="20190606T033648Z">
        <seg>我们假设网络连接是可靠的，不存在记录丢失或重复，且所有事件最终都会以先进先出的顺序到达各自终点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume reliable network connections, such that no records are dropped or duplicated and all events are eventually delivered to their destination in FIFO order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T043327Z" creationid="xccui" creationdate="20190415T043245Z">
        <seg>我们假设网络连接是可靠的，即不存在记录丢失或重复，所有事件最终都会以先进先出的顺序到达其终点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We assume the following software is installed as well, although it is not strictly required to develop Flink applications:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T020130Z" creationid="xccui" creationdate="20190611T020130Z">
        <seg>此外虽不强制，但我们假设以下软件也已装好：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We call this type of applications data pipelines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T014229Z" creationid="xccui" creationdate="20190317T014229Z">
        <seg>我们将此类应用称为数据管道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can key the input stream by the second and third fields as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T041320Z" creationid="xccui" creationdate="20190618T041209Z">
        <seg>我们可以像下面这样利用第2、3字段作为输入流的键值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can parametrize the above example and pass the String "flink" as a parameter to the KeywordFilter constructor as shown below:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054636Z" creationid="xccui" creationdate="20190618T054636Z">
        <seg>我们为上述示例添加参数并将"flink"字符串以参数形式传给KeywordFilter：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can rewrite the filtering example in the Java DataStream API as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035150Z" creationid="xccui" creationdate="20190617T015621Z">
        <seg>可以像下面这样利用Java DataStream API重写过滤示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We cover</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053544Z" creationid="xccui" creationdate="20190615T053544Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We covered basic streaming operations and how to compute meaningful results on unbounded input data using windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T040418Z" creationid="xccui" creationdate="20190606T040418Z">
        <seg>章节还涵盖了基本的流式操作以及如何利用窗口在无限输入上计算出有意义的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We define sliding windows by providing their length and their &lt;t3/&gt;slide&lt;t4/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T024113Z" creationid="xccui" creationdate="20190407T024113Z">
        <seg>我们通过指定长度和滑动间隔来定义滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We define sliding windows by providing their length and their slide.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T013255Z" creationid="xccui" creationdate="20190606T013255Z">
        <seg>我们通过指定长度和滑动间隔来定义滑动窗口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe both interfaces in detail next.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045315Z" creationid="xccui" creationdate="20190620T045315Z">
        <seg>接下来我们详细讨论一下它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe both notions in the fol&lt;t0/&gt;‐&lt;t1/&gt; lowing sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T143746Z" creationid="xccui" creationdate="20190412T143518Z">
        <seg>接下来的几节我们来介绍一下它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe both notions in the fol‐ lowing sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T155531Z" creationid="xccui" creationdate="20190606T023752Z">
        <seg>我们将在接下来的几节对它们进行介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe how to assign operator identifiers in detail in “Specifying Unique Operator Identifiers” on page 168.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T030854Z" creationid="xccui" creationdate="20190610T030851Z">
        <seg>有关分配算子标识的详细内容会在168页"指定唯一算子标识"中介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the classes of applications as distinct patterns to emphasize the versatility of stateful stream processing, but most real-world applications share the properties of more than one class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T033527Z" creationid="esouser" creationdate="20190603T212509Z">
        <seg>为了突出状态化流处理的用途之多，我们将不同的应用类别区分地很明显，而事实上大多数真实应用都会同时具有多种类别的特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the classes of applications as distinct patterns to emphasize the versatility of stateful stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190308T072714Z" creationid="xccui" creationdate="20190305T155234Z">
        <seg>为了突出状态化流处理的不同用途，我们假设每种应用类别模式单一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the steps for a UNIX environment, but if you are running Windows, we recommend setting up a virtual machine with Linux, Cygwin (a Linux environment for Win‐ dows), or the Windows Subsystem for Linux, introduced with Windows 10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T065236Z" creationid="xccui" creationdate="20190605T122711Z">
        <seg>我们假设以下步骤都是针对UNIX环境，如果你用Windows，我们建议你配置一个Linux虚拟机，也可以安装Cygwin（一个Windows下的Linux环境）或配置WSL（Windows Subsystem for Linux，Windows 10中新加的功能）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe the steps for a UNIX environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190328T060116Z" creationid="xccui" creationdate="20190328T055241Z">
        <seg>我们将以类UNIX环境为例介绍操作步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss CoProcessFunction in Chapter 6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045349Z" creationid="xccui" creationdate="20190615T045349Z">
        <seg>有关CoProcessFunction的内容会在第6章讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss Flink’s fault-tolerance algorithm in &lt;t2/&gt;Chapter 3&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T045041Z" creationid="xccui" creationdate="20190416T045041Z">
        <seg>我们会在第3章讨论Flink的容错算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss Flink’s fault-tolerance algorithm in “Checkpoints, Save‐ points, and State Recovery” on page 58.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T194306Z" creationid="xccui" creationdate="20190606T035001Z">
        <seg>我们会在第58页"检查点、保存点和状态恢复"一节讨论Flink的容错算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss all these matters in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042314Z" creationid="xccui" creationdate="20190415T042227Z">
        <seg>我们将在本节一一讨论这些问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss how a stream processor can provide accurate results with out-of-order events and how you can perform historical event processing and time travel with streaming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T152709Z" creationid="xccui" creationdate="20190409T210351Z">
        <seg>我们将讨论流处理引擎如何基于乱序事件产生精确结果，以及如何基于历史事件和不同历史区间的数据进行分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss in &lt;t8/&gt;Chapter 10&lt;t9/&gt; how to control the scheduling of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062903Z" creationid="xccui" creationdate="20190424T062903Z">
        <seg>我们将在第10章讨论如何控制任务调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss in “Tuning Checkpointing and Recovery” on page 263 how to use and configure state backends in your application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T030104Z" creationid="xccui" creationdate="20190704T025917Z">
        <seg>我们会在第263页"调整检查点及恢复"一节讨论具体如何在应用中使用和配置状态后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the implementation of a user-defined function in a later sec‐ tion of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054002Z" creationid="xccui" creationdate="20190612T032346Z">
        <seg>有关用户自定义函数的实现会在本章后面部分讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the importance of unique operator identifiers and the mapping of savepoint state in more detail in “Savepoints” on page 66.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T023837Z" creationid="xccui" creationdate="20190703T023432Z">
        <seg>有关唯一算子标识的重要性及保存点状态的映射规则已经在第66页"保存点"一节详细讨论过了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the responsibilities of each component and how it interacts with the other components in the following.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033707Z" creationid="xccui" creationdate="20190418T033707Z">
        <seg>我们接下来讨论各组件的职责以及它们之间是如何交互的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the semantics of all operators available in Flink in &lt;t2/&gt;Chapter 5&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T160141Z" creationid="xccui" creationdate="20190405T160124Z">
        <seg>我们将在第5章讨论Flink中各算子的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the semantics of all operators available in Flink in Chapter 5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T061013Z" creationid="xccui" creationdate="20190606T011752Z">
        <seg>我们将在第5章讨论Flink中每个算子的语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss the topic of application deployment in more detail in &lt;t2/&gt;Chap&lt;t3/&gt;‐&lt;t4/&gt; &lt;t5/&gt;ter 10&lt;t6/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T041129Z" creationid="xccui" creationdate="20190423T041129Z">
        <seg>我们会在第10章节详细讨论应用部署的相关内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss these options in more detail in “Tuning Checkpointing and Recovery” on page 263.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T211306Z" creationid="xccui" creationdate="20190702T211306Z">
        <seg>我们会在第263页"调节检查点和恢复"一节详细讨论这些选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss this difference later in this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T184754Z" creationid="xccui" creationdate="20190607T184716Z">
        <seg>详细内容将在本章稍后讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss this function in  detail in “Assigning Timestamps and Generating Watermarks” as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T040454Z" creationid="xccui" creationdate="20190607T040402Z">
        <seg>我们同样会在"分配时间戳和生成水位线"一节详细讨论它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discuss two different styles of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T141158Z" creationid="xccui" creationdate="20190606T141158Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We discussed Flink’s strategies to scale stateful operators earlier in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T220025Z" creationid="xccui" creationdate="20190609T220025Z">
        <seg>我们已经在本章前面讨论过Flink对于状态化算子的扩缩容策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We dis‐ cuss the topic of application deployment in more detail in “Running and Managing Streaming Applications” on page 245.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T144314Z" creationid="xccui" creationdate="20190606T144314Z">
        <seg>我们会在245页的"运行和管理流式应用"一节详细讨论应用部署的相关内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We dis‐ cussed how open source stream processing systems have evolved since their inception in the early 2010s and how stream processing became a viable solution for many use cases of today’s businesses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T202100Z" creationid="xccui" creationdate="20190605T125312Z">
        <seg>我们讨论了开源流处理系统如何从二十世纪初逐步进化，成为针对目前很多企业用例的可行解决方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We don't use processing time timers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200921Z" creationid="xccui" creationdate="20190626T200921Z">
        <seg>我们使用处理时间计时器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We examined the structure of Flink programs and learned how to combine data and partitioning trans‐ formations to build streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T044025Z" creationid="xccui" creationdate="20190619T044025Z">
        <seg>我们研究了Flink程序的结构，学习了如何将数据和分区转换结合来构建流式应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explain how state is stored and maintained by state backends and how stateful applications can be scaled by redistributing state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T053705Z" creationid="xccui" creationdate="20190607T053446Z">
        <seg>我们将解释如何利用状态后端对状态进行存储和维护，以及状态化应用如何通过状态再分配实现扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explain their semantics and show code examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T025327Z" creationid="xccui" creationdate="20190613T025327Z">
        <seg>我们将结合代码示例对它们的语义进行解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We explained how to configure the time characteristics of a streaming applica‐ tion and how to assign timestamps and watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041548Z" creationid="xccui" creationdate="20190629T041449Z">
        <seg>我们解释了如何为流式应用配置时间特征以及如何分配时间戳和水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We express these performance requirements in terms of &lt;t4/&gt;latency &lt;t5/&gt;and&lt;t6/&gt; throughput&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T151521Z" creationid="xccui" creationdate="20190401T151311Z">
        <seg>我们用延迟和吞吐来表示这两方面的性能需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We express these performance requirements in terms of latency and throughput.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233804Z" creationid="xccui" creationdate="20190605T233804Z">
        <seg>我们用延迟和吞吐来表示这两方面的性能需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We first show the keyBy() case:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050002Z" creationid="xccui" creationdate="20190615T050002Z">
        <seg>我们首先来看一下keyBy()的情况：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have a web page for this book, where we list errata, examples, and any additional information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210842Z" creationid="esouser" creationdate="20190603T210842Z">
        <seg>We have a web page for this book, where we list errata, examples, and any additional information.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have to point out that Flink’s checkpointing and recovery mechanism only resets the internal state of a streaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T053624Z" creationid="xccui" creationdate="20190609T053610Z">
        <seg>我们必须指出，Flink的检查点和恢复机制仅能重置流式应用内部的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We hope that after reading this chapter, you will be able to evaluate the features of modern stream processing systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T042948Z" creationid="xccui" creationdate="20190605T224722Z">
        <seg>希望阅读过后，你能对时下不同流处理系统的功能进行评估。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We hope that after reading this chapter, you will have gained a better understanding of stream applications requirements and you will be able to evaluate the features of modern stream processing systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T054105Z" creationid="xccui" creationdate="20190329T053836Z">
        <seg>我们希望你在读完本章后能对流处理应用的需求有一个更深刻的理解并可以对当下不同的流处理系统进行功能评估。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We know of a company that decided to built the backend of a social network based on an event log and event-driven applications because of these features.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190313T010445Z" creationid="xccui" creationdate="20190313T010445Z">
        <seg>据我们所知，正是因为上述功能，有公司决定基于事件日志和事件驱动型应用来构建社交网络后端。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We looked at the dataflow programming model and learned how streaming applications can be expressed as distributed dataflow graphs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T035532Z" creationid="xccui" creationdate="20190606T035500Z">
        <seg>我们介绍了Dataflow编程模型以及如何将一个流式应用表示为分布式Dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We need to specify the key by calling keyBy() on the input stream before we apply the function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062633Z" creationid="xccui" creationdate="20190630T062633Z">
        <seg>即在应用函数之前需要在输入流上调用keyBy()方法来指定键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We now look at these parts in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044534Z" creationid="xccui" creationdate="20190612T044457Z">
        <seg>接下来我们详细介绍一下这些步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We now turn to another extremely important aspect of stream processing—state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T031403Z" creationid="xccui" creationdate="20190606T031350Z">
        <seg>我们现在要转向流处理中另一个十分重要的方面——状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We now turn to examine another extremely important aspect of stream processing, state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T050456Z" creationid="xccui" creationdate="20190414T050456Z">
        <seg>我们现在要转而研究流处理中另一个十分重要的方面——状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We present the transformations of the DataStream API in four categories:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T024132Z" creationid="xccui" creationdate="20190613T024132Z">
        <seg>我们将DataStream API的转换分为四类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We present two different styles of deploying Flink applications and dis&lt;t0/&gt;‐&lt;t1/&gt; cuss how tasks are distributed and executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T033310Z" creationid="xccui" creationdate="20190418T033020Z">
        <seg>随后，我们会给出部署Flink应用的两种类型，并讨论如何分配和执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We recommend using IntelliJ IDEA.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T030642Z" creationid="xccui" creationdate="20190611T030642Z">
        <seg>本书建议使用IntelliJ IDEA。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We show the structure and components of a typical Flink streaming application, discuss Flink’s type systems and the supported data types, and present data and partitioning transformations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T032259Z" creationid="xccui" creationdate="20190612T032259Z">
        <seg>我们会介绍典型Flink流式应用的结构及组件，讨论Flink的类型系统和支持的数据类型，并展示数据转换和分区转换操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We start by reviewing conventional data application architectures and point out their limitations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T023001Z" creationid="esouser" creationdate="20190603T163025Z">
        <seg>我们首先将回顾传统数据处理应用架构并指出其局限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We start reviewing conventional data processing application architectures and point out their limitations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T040526Z" creationid="xccui" creationdate="20190225T222520Z">
        <seg>我们首先将回顾传统数据处理应用架构并指出其局限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We started with a recap of traditional data infrastruc‐ tures, how business applications are commonly designed, and how data is collected and analyzed in most companies today.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T041116Z" creationid="xccui" creationdate="20190605T124846Z">
        <seg>我们首先回顾了传统的数据基础架构，业务应用的常规设计以及当今大多数公司如何收集和分析数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We strongly recommend assigning unique identifiers to every operator of an applica‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024044Z" creationid="xccui" creationdate="20190703T023809Z">
        <seg>我们强烈建议你为应用中的每个算子都分配唯一标识，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We use an example of a simple streaming application to explain the algorithm step by step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061814Z" creationid="xccui" creationdate="20190609T061814Z">
        <seg>我们通过一个简单流式应用的示例来一步一步解释这个算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will be assuming a UNIX-based setup in the rest of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T014324Z" creationid="xccui" creationdate="20190610T054905Z">
        <seg>本章剩余部分假设设置都是基于类UNIX系统来完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will be using the Scala repository for the setup, but you should be able to follow the same instructions if you prefer Java.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T035926Z" creationid="xccui" creationdate="20190611T035846Z">
        <seg>我们将选用Scala仓库进行设置，但如果你想用Java，也可以遵循相同的说明。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will briefly discuss the most common keyed state primitives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T192620Z">
        <seg>我们接下来简要讨论一下键值分区状态最常用的几个原语。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will continue dis‐ cussing these common features by looking in detail at the KeyedProcessFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T052436Z" creationid="xccui" creationdate="20190621T052436Z">
        <seg>接下来我们会以KeyedProcessFunction为例来讨论这些通用的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the con&lt;t4/&gt;‐&lt;t5/&gt; figuration and setup of Flink clusters in detail in &lt;t6/&gt;Chapter 9&lt;t7/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T063849Z" creationid="xccui" creationdate="20190424T063840Z">
        <seg>我们会在第9章讨论搭建和配置Flink集群的详细内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the configuration and setup of Flink clusters in detail in Chapter 9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T145157Z" creationid="xccui" creationdate="20190606T145157Z">
        <seg>我们会在第9章讨论搭建和配置Flink集群的详细内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the configuration of highly available Flink setups later in &lt;t4/&gt;Chapter 9&lt;t5/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T040756Z" creationid="xccui" creationdate="20190504T040756Z">
        <seg>我们稍后会在第9章节讨论Flink高可用相关配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the configuration of highly available Flink setups later in “Highly Available Setups”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T074314Z" creationid="xccui" creationdate="20190606T195259Z">
        <seg>我们稍后会在"高可用性设置"一节讨论Flink高可用相关配置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss the different state backends and their advantages and disadvantages in more detail in “Choosing a State Backend” on page 169.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T054246Z" creationid="xccui" creationdate="20190608T054230Z">
        <seg>我们会在169页"选择状态后端"一节详细讨论不同状态后端的区别以及它们各自的优劣。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss this topic in more detail in “Application Consistency Guarantees” on page 184.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005758Z" creationid="xccui" creationdate="20190613T005758Z">
        <seg>我们会在184页"应用一致性保障"一节详细讨论这一话题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will present Flink’s more sophisticated checkpointing algorithm later in this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T224913Z" creationid="xccui" creationdate="20190608T224902Z">
        <seg>而是使用了一种更加复杂的检查点算法，我们会在本节后面介绍该算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will start by discussing the required software and where you can get the code examples of this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T014744Z" creationid="xccui" creationdate="20190610T040332Z">
        <seg>我们会从所需软件以及怎样获取书中示例代码开始讲起。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will take a brief look into the past to see where open source stream processing came from and where it is today.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190322T040653Z" creationid="xccui" creationdate="20190322T040653Z">
        <seg>我们将通过简要地历史回顾来探索一下开源流处理技术的前世今生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will take a brief look into the past to see where open source stream pro‐ cessing came from and where it is today.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T192839Z" creationid="xccui" creationdate="20190605T050803Z">
        <seg>在此，我们将通过简要的历史回顾来探索一下开源流处理技术的前世今生。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will use this example to show‐ case the basic structure of a Flink program and introduce some important features of the DataStream API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035413Z" creationid="xccui" creationdate="20190612T035257Z">
        <seg>通过该示例，我们将展示Flink程序的基本结构并引出DataStream API中的几个重要特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We would like to thank and acknowledge some of them here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T160115Z" creationid="xccui" creationdate="20190605T131312Z">
        <seg>在此由衷地感谢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We’ve also like to thank our technical reviewers who made countless valuable sugges‐ tions helping us to improve the presentation of the content.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T063028Z" creationid="xccui" creationdate="20190605T133326Z">
        <seg>我们还要感谢那些给予我们无数宝贵建议的技术评审员们：Adam Kawa、Aljoscha Krettek、Kenneth Knowles、Lea Giordano、Matthias J. Sax、Stephan Ewen、Ted Malaska以及Tyler Akidau，感谢你们为改善内容所做的帮助。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What Does One Minute Mean in Stream Processing?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T153019Z" creationid="esouser" creationdate="20190603T144036Z">
        <seg>流处理场景下一分钟的含义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What You Will Learn in This Book</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T042821Z" creationid="xccui" creationdate="20190225T042455Z">
        <seg>你能从本书学到什么</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What happens when a trigger fires depends on the configured functions of the win‐ dow operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T053324Z" creationid="xccui" creationdate="20190625T053324Z">
        <seg>触发器成功触发后的行为取决于窗口算子所配置的函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is a task failure?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042327Z" creationid="xccui" creationdate="20190415T042327Z">
        <seg>什么是任务故障？</seg>
      </tuv>
    </tu>
    <tu>
      <note>每分钟还是一分钟？</note>
      <tuv lang="EN-US">
        <seg>What is the meaning of one minute?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T205925Z" creationid="xccui" creationdate="20190225T015542Z">
        <seg>分钟的含义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What should the application do?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154810Z" creationid="xccui" creationdate="20190411T152000Z">
        <seg>此时应用该怎么办？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What we have not discussed yet is the effect that watermarks have on your streaming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T055305Z" creationid="xccui" creationdate="20190620T055232Z">
        <seg>但并没有涉及水位线对于流式应用的影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What would &lt;t0/&gt;one minute&lt;t1/&gt; really mean in the context of our streaming application?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190411T144519Z" creationid="xccui" creationdate="20190409T211131Z">
        <seg>那么一分钟在流式应用的环境下到底是什么含义？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What would one minute really mean in the context of our streaming application?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T153519Z" creationid="xccui" creationdate="20190606T014710Z">
        <seg>那么一分钟在流式应用环境中的含义到底是什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, by reducing the stream history to a single aggre&lt;t0/&gt;‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043806Z" creationid="xccui" creationdate="20190406T043701Z">
        <seg>此外，将整条历史流合并为单个聚合值会丢失数据随时间变化的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, by reducing the stream history to a single aggre‐ gate, you lose the information about how your data varies over time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012316Z" creationid="xccui" creationdate="20190606T012316Z">
        <seg>此外，将整条历史流合并为单个聚合值会丢失数据随时间变化的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, streaming applications that process events as they are produced should also be able to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052607Z" creationid="xccui" creationdate="20190409T202149Z">
        <seg>此外，处理实时事件的流处理应用还应以相同的方式处理历史事件，这样才能支持离线分析、甚至那些比较不同历史区间的分析。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, streaming applica‐ tions that process events as they are produced should also be able to process historical events in the same way, thus enabling offline analytics or even time travel analyses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T064258Z" creationid="xccui" creationdate="20190606T014415Z">
        <seg>此外，处理实时事件的流处理应用还应以相同的方式处理历史事件，这样才能支持离线分析，甚至那些比较不同历史区间数据的分析（time travel analyse）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, when combined with re-playable streams, the determinism of time&lt;t0/&gt;‐&lt;t1/&gt; stamps gives you the ability to &lt;t2/&gt;fast-forward&lt;t3/&gt; the past.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T154731Z" creationid="xccui" creationdate="20190412T154437Z">
        <seg>而且结合可重放的数据流，时间戳的确定性允许你对历史数据"快进"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s more, when combined with replayable streams, the determinism of timestamps gives you the ability to fast forward the past.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T160545Z" creationid="xccui" creationdate="20190606T025045Z">
        <seg>而且结合可重放的数据流，时间戳所带来的确定性允许你对历史数据"快进"。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What’s the meaning of one minute in this case?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T142442Z" creationid="xccui" creationdate="20190411T152030Z">
        <seg>在上述示例中一分钟的含义又是什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Flink processes a data stream in event-time mode, it evaluates time-based operators based on the timestamps of records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190523T040225Z" creationid="xccui" creationdate="20190523T040149Z">
        <seg>当Flink以事件时间模式处理数据流时，会根据记录的时间戳触发时间相关算子的行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a DataStream program is submitted to the JobManager for execution, the system creates a dataflow graph and prepares the operators for execu‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T051014Z" creationid="xccui" creationdate="20190616T051014Z">
        <seg>当提交一个DataStream程序到JobManager上执行时，系统会生成一个dataflow图并将用于执行的算子准备好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a JobManager fails, all tasks that belong to its application are automatically  cancelled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195013Z" creationid="xccui" creationdate="20190606T194908Z">
        <seg>当JobManager发生故障时，其下应用的所有任务都会自动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a JobManager fails, all tasks that belong to its application are automatically cancelled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T052256Z" creationid="xccui" creationdate="20190502T052211Z">
        <seg>当JobManager发生故障，所有隶属其应用的任务都会自动取消。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a JobManager requests TaskManager slots, the ResourceManager instructs a TaskManager with idle slots to offer them to the JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T060731Z" creationid="xccui" creationdate="20190418T050502Z">
        <seg>当JobManager申请TaskManager处理槽时，ResourceManager会指示一个拥有空闲处理槽的TaskManager将其处理槽提供给JobManager。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a checkpoint is triggered, the state backend creates a local copy of the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T202934Z" creationid="xccui" creationdate="20190609T202934Z">
        <seg>当检查点生成过程触发时，状态后端会为当前状态创建一个本地拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a check‐ point is taken, MemoryStateBackend sends the state to the JobManager, which stores it in its heap memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T020339Z" creationid="xccui" creationdate="20190704T020339Z">
        <seg>在生成检查点时，MemoryStateBackend会将状态发送至JobManager并保存到它的堆内存中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a container is started from the image, it automatically launches the ResourceManager and JobManager and submits the bundled job for execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T143744Z" creationid="xccui" creationdate="20190606T143716Z">
        <seg>当容器从映像启动后会自动加载ResourceManager和JobManager，并将绑定的作业提交执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a container is started from this image, it automatically starts a TaskManager, which connects to the ResourceManager and registers its slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T042604Z" creationid="xccui" creationdate="20190423T040144Z">
        <seg>当容器启动后会自动运行TaskManager，它负责连接ResourceManager并注册处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a data source task receives the message, it pauses emitting records, triggers a checkpoint of its local state at the state backend, and broadcasts checkpoint barriers with the checkpoint ID via all outgoing stream partitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T063446Z" creationid="xccui" creationdate="20190609T063201Z">
        <seg>当一个数据源任务收到消息后，会暂停发出记录，利用状态后端触发生成本地状态的检查点，随后把该检查点分隔符连同检查点编号广播至所有传出的数据流分区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function registers a StateDescriptor, Flink checks if the state backend has data for the function and a state with the given name and type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T021434Z" creationid="xccui" creationdate="20190701T021106Z">
        <seg>当函数注册StateDescriptor时，Flink会检查状态后端是否包含了函数的数据以及与给定名称、类型相同的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function registers state, the state store tries</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T065110Z" creationid="xccui" creationdate="20190702T065047Z">
        <seg>在函数进行状态注册时，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a job fin&lt;t0/&gt;‐&lt;t1/&gt; ishes, the result is written to persistent storage, and all operator state is lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T053639Z" creationid="xccui" creationdate="20190414T053558Z">
        <seg>当一个作业结束，其结果就会写入持久化存储中，同时所有算子的状态将不复存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a job finishes, the result is written to persistent storage, and all operator state is lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T182140Z" creationid="xccui" creationdate="20190606T032106Z">
        <seg>每当一个作业结束，其结果都会写入持久化存储中，同时所有算子的状态将不复存在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a late element arrives within the allowed lateness period it is handled like an on-time element and handed to the trigger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164831Z" creationid="xingcan" creationdate="20190628T164831Z">
        <seg>在这段额外时间内到达的迟到元素会像按时到达的元素一样交给触发器处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a new element is received, the ReduceFunction is called with the new element and the current value that is read from the window’s state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T001105Z" creationid="xccui" creationdate="20190624T001105Z">
        <seg>每当收到一个新元素，都会以该元素和从窗口状态取出的当前聚合值为参数调用ReduceFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a program is submitted for execution, all function objects are serialized using Java serialization and shipped to all parallel tasks of their corresponding operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055206Z" creationid="xccui" creationdate="20190618T054831Z">
        <seg>当程序提交执行时，所有参数对象都会利用Java自身的序列化机制进行序列化，然后传发送对应算子的所有并行任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a savepoint is taken, the states of all tasks are copied to a persistent storage location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215054Z" creationid="xccui" creationdate="20190609T214950Z">
        <seg>在生成保存点的时候，所有任务的状态都会拷贝到某个持久化存储位置上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a sender task and a receiver task run in the same TaskManager process, the sender task serializes the outgoing records into a byte buffer and puts the buffer into a queue once it is filled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193926Z" creationid="esouser" creationdate="20190513T191646Z">
        <seg>当发送任务和接收任务处于同一个TaskManager进程时，发送任务会将要发送的记录序列化到一个字节缓冲区中，一旦该缓冲区占满就会被放到一个队列里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a sink task receives a barrier, it performs a barrier alignment, checkpoints its own state, and acknowledges the reception of the barrier to the JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T194118Z" creationid="xccui" creationdate="20190609T194118Z">
        <seg>数据汇任务在收到分隔符后会依次执行分隔符对齐，将自身状态写入检查点，向JobManager确认已接收分隔符等一系列动作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task processes a record, it automatically scopes the state access to the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191343Z" creationid="xccui" creationdate="20190607T190932Z">
        <seg>当任务在处理一个记录时，会自动把状态的访问范围限制为当前记录的键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a barrier for a new checkpoint, it waits for the arrival of barriers from all its input partitions for the checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162050Z" creationid="xccui" creationdate="20190609T161207Z">
        <seg>当任务收到一个新检查点的分隔符时，会继续等待所有其它输入分区也发来这个检查点的分隔符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a record that violates the watermark property and has smaller time&lt;t4/&gt;‐&lt;t5/&gt; stamps than a previously received watermark, it might be the case that the computa&lt;t6/&gt;‐&lt;t7/&gt; tion it would belong to has already been completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T035531Z" creationid="xccui" creationdate="20190529T035229Z">
        <seg>当任务接收到一个违反水位线属性、时间戳小于前一个水位线的记录时，该记录本应参与的计算可能已经完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a record that violates the watermark property and has smaller time‐ stamps than a previously received watermark, it may be that the computation it belongs to has already been completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205709Z" creationid="xccui" creationdate="20190606T205651Z">
        <seg>当任务接收到一个违反水位线属性，时间戳小于前一个水位线的记录时，该记录本应参与的计算可能已经完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a watermark, the following actions take place.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190529T042423Z" creationid="xccui" creationdate="20190529T041904Z">
        <seg>当任务接收到一条水位线记录时会执行以下操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a task receives a watermark, the following actions take place:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T212916Z" creationid="xccui" creationdate="20190606T212913Z">
        <seg>当任务接收到一条水位线记录时会执行以下操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a timer fires, the onTimer() callback function is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060732Z">
        <seg>计时器触发时会调用onTimer()回调函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a window is deleted, the window operator automatically clears the window content and discards the window object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040254Z" creationid="xccui" creationdate="20190626T040254Z">
        <seg>当窗口需要删除时，窗口算子会自动清除窗口内容并丢掉窗口对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is executed, all of its dependencies must be available to the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T035540Z" creationid="xccui" creationdate="20190619T035540Z">
        <seg>应用在执行时，必须能够访问到所有依赖。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is started from a savepoint, Flink redistributes the savepoint data to the tasks of the corresponding operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T215608Z" creationid="xccui" creationdate="20190609T215601Z">
        <seg>当应用从保存点启动时，Flink会将保存点的数据分发到对应算子的任务上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is started from a savepoint, the identifiers are used to map a state in the savepoint to the corresponding operator of the started application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T022753Z" creationid="xccui" creationdate="20190703T022449Z">
        <seg>当应用从保存点启动时，会利用这些标识将保存点中的状态映射到目标应用对应的算子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is started from a savepoint, the operators of the started applica‐ tion are initialized by looking up the corresponding states from the savepoint using operator identifiers and state names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035026Z" creationid="xccui" creationdate="20190705T034847Z">
        <seg>当应用从保存点启动时，它的算子会使用算子标识和状态名称从保存点中查找对应的状态进行初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application is submitted for execution, Flink’s type system tries to automati‐ cally derive the TypeInformation for every data type that is processed by the frame‐ work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T051220Z" creationid="xccui" creationdate="20190617T051220Z">
        <seg>当应用提交执行时，Flink的类型系统会为框架所需处理的每种类型自动推断TypeInformation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application receives an event, it can perform arbitrary computations that involve reading data from or writing data to the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T030804Z" creationid="xccui" creationdate="20190305T030739Z">
        <seg>应用收到事件后可以执行包括读写状态在内的任意计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an application receives an event, it can perform arbi‐ trary computations that involve reading data from or writing data to the state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T205844Z" creationid="esouser" creationdate="20190603T205844Z">
        <seg>应用收到事件后可以执行包括读写状态在内的任意计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an container is started from the image, it automatically launches the ResourceManager and the JobMan&lt;t1/&gt;‐&lt;t2/&gt; ager and hands over the bundled job.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190423T035802Z" creationid="xccui" creationdate="20190423T032325Z">
        <seg>当容器从映像启动后会自动加载ResourceManager和JobManager，并提交绑定的作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an element arrives at a window operator, it is handed to the WindowAssigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T051534Z" creationid="xccui" creationdate="20190625T051534Z">
        <seg>当一个元素进入窗口算子时会被移交给WindowAssigner。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an event is processed, an application reads its state or updates it by running transac‐ tions against the remote database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T064048Z" creationid="esouser" creationdate="20190603T195529Z">
        <seg>期间每处理一条事件，应用都会通过执行远程数据库系统的事务来读取或更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an event is processed, an application reads its state or updates its state by run&lt;t0/&gt;‐&lt;t1/&gt; ning transactions against the remote database system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T162610Z" creationid="xccui" creationdate="20190226T162548Z">
        <seg>期间每处理一条事件，应用都会通过远程数据库系统的事务来读取或更新状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an operator receives a watermark with time T, it can assume that no further events with timestamp less than T will be received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T205925Z" creationid="xccui" creationdate="20190412T205544Z">
        <seg>当一个算子接收到时间为T的水位线，就可以认为不会再收到任何时间戳小于或等于T的事件了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an operator receives a watermark with time T, it can assume that no further events with time‐ stamp less than T will be received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025434Z" creationid="xccui" creationdate="20190606T025434Z">
        <seg>当一个算子接收到时间为T的水位线，就可以认为不会再收到任何时间戳小于或等于T的事件了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When applied on a KeyedStream with an evolving key space, Global Windows will maintain some state for each key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045046Z" creationid="xccui" creationdate="20190626T045046Z">
        <seg>当把GlobalWindows应用于一个键值空间不断变化的KeyedStream时，它会为每个键值维持一些状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When applied on a windowed stream, ReduceFunction incrementally aggregates the elements that are assigned to a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T225051Z" creationid="xccui" creationdate="20190623T224934Z">
        <seg>当应用于窗口化数据流时，ReduceFunction会对分配给窗口的元素进行增量聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When asked for a new watermark, the assigner returns a watermark with the maximum timestamp minus a 1-minute tolerance interval.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051015Z" creationid="xccui" creationdate="20190620T051015Z">
        <seg>当收到新水位线请求时，该分配器会返回一个时间戳等于最大时间戳减去1分钟容忍间隔的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When building applications with the DataStream API the sys‐ tem automatically chooses data partitioning strategies and routes data to the correct destination depending on the operation semantics and the configured parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T065209Z" creationid="xccui" creationdate="20190615T065209Z">
        <seg>在使用DataStream API构建程序时，系统会根据操作语义和配置的并行度自动选择数据分区策略并将数据转发到正确的目标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When dealing with a potentially unbounded stream of continuously arriving events, time becomes a central aspect of applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T153413Z" creationid="xccui" creationdate="20190409T210522Z">
        <seg>当处理一个持续到达且可能无穷的事件流时，时间便成了应用中最为核心的要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When instructed by the ResourceManager, the TaskManager offers one or more of its slots to a JobManager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190424T062127Z" creationid="xccui" creationdate="20190418T051847Z">
        <seg>当接收到ResourceManager的指示时，TaskManager会向JobManager提供一个或多个处理槽。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it receives a watermark from a partition, it updates the respective partition watermark to be the maximum of the received value and the current value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T024528Z" creationid="xccui" creationdate="20190607T024528Z">
        <seg>当收到某个分区传来的水位线后，它会以接收值和当前值中较大的那个作为对应分区水位线更新后的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When iterating over the entry set of MapState, the seri‐ alized entries are prefetched from RocksDB and only deserialized when a key or value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T034033Z" creationid="xccui" creationdate="20190704T033458Z">
        <seg>在遍历MapState的条目集（entry set）时，状态后端会从RocksDB中预取出序列化好的所有条目，并只有在实际访问某个键或数据值的时候才会将其反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When merging windows, you need to ensure that the state of all merging windows and their triggers is also appropriately merged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045948Z" creationid="xccui" creationdate="20190626T045948Z">
        <seg>在合并窗口时，需要保证所有目标窗口的状态以及它们的触发器也能够正确合并。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When none of the predefined partitioning strategies is suitable, you can define your own by using the partitionCustom() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050123Z" creationid="xccui" creationdate="20190616T050123Z">
        <seg>如果所有预定义的分区策略都不合适，你可以利用partitionCustom()方法自己定义分区策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When operating in high- availability mode, the JobManager writes the JobGraph and all required metadata,  such as the application’s JAR file, into a remote persistent storage system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073026Z" creationid="xccui" creationdate="20190606T150048Z">
        <seg>JobManager在高可用模式下工作时，会将JobGraph以及所有所需的元数据（例如应用的JAR文件）写入一个远程持久化存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When operating in high-availability mode, the JobManager writes the JobGraph and all required metadata, such as the application’s JAR file, into a remote persistent storage system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190502T045712Z" creationid="xccui" creationdate="20190502T045505Z">
        <seg>JobManager在高可用模式下工作时，会将JobGraph以及所有所需的元数据（例如应用的JAR文件）写入到一个远程持久化存储系统中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When presenting the transformations of the DataStream API, we show the interfaces for all function classes, but mostly use lambda functions instead of function classes in code examples for brevity.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T022839Z" creationid="xccui" creationdate="20190613T022648Z">
        <seg>在介绍DataStream API的转换时，我们会展示所有函数类的接口。但出于简洁考虑，在绝大多数示例代码中我们会使用lambda函数而不是函数类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running an application as a library deployment in a container environment, such as Kubernetes, failed JobManager or TaskManager containers are usually auto&lt;t0/&gt;‐&lt;t1/&gt; matically restarted by the container orchestration service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T035643Z" creationid="xccui" creationdate="20190504T035046Z">
        <seg>当在容器环境（如：Kubernetes）中将应用作为库部署运行时，容器编排服务通常会自动重启故障的JobManager或TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running an application as a library deployment in a container environment, such as Kubernetes, failed JobManager or TaskManager containers are usually auto‐ matically restarted by the container orchestration service.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T190745Z" creationid="xccui" creationdate="20190606T195057Z">
        <seg>如果是在容器环境（如Kubernetes）中以库模式部署运行应用，容器编排服务（orchestration service）通常会自动重启故障的JobManager或TaskManager容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running on YARN   or on Mesos, Flink’s remaining processes trigger the restart of JobManager or Task‐ Manager processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T195152Z" creationid="xccui" creationdate="20190606T195108Z">
        <seg>当运行在YARN或Mesos上面时，Flink的其余进程会触发JobManager或TaskManager进程重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When running on YARN or on Mesos, Flink’s remaining processes trigger the restart of JobManager or Task&lt;t2/&gt;‐&lt;t3/&gt; Manager processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T035754Z" creationid="xccui" creationdate="20190504T035708Z">
        <seg>当运行在YARN或Mesos上面时，Flink的剩余进程会触发JobManager或TaskManager进程重启。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When submitting an application to a running Flink cluster, the environment parallelism is set to the default parallelism of the cluster unless it is explicitly specified via the submission client (see “Running and Managing Streaming Applications” on page 245 for more details).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T053312Z" creationid="xccui" creationdate="20190616T053312Z">
        <seg>如果应用是提交到Flink集群运行，那么除非提交客户端明确指定（详情请参阅第245页"运行和管理流式应用"），否则环境并行度将设置为集群默认并行度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the application has been completely defined, it can be executed by call‐ ing StreamExecutionEnvironment.execute().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005845Z" creationid="xccui" creationdate="20190613T005845Z">
        <seg>当应用定义完成后就可以通过调用StreamExecutionEnvironment.execute()来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the first event comes in, it will be immediately processed with the minimum latency possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T052653Z" creationid="xccui" creationdate="20190605T234653Z">
        <seg>当首个事件进入时，系统会立刻以尽可能低的延迟进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the local copy is finished, the task continues its regular processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T203350Z" creationid="xccui" creationdate="20190609T203350Z">
        <seg>在本地拷贝创建完成后，任务就可以继续它的常规处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the new version of the application is started from a save‐ point of the previous version, the savepoint contains state that cannot be mapped to the restarted application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043048Z" creationid="xccui" creationdate="20190705T043048Z">
        <seg>当新版本的应用从一个旧版本的保存点启动时，保存点中的部分状态将无法映射到重启的应用中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the processing method of a function with keyed input is called, Flink’s runtime auto‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064956Z" creationid="xccui" creationdate="20190630T062841Z">
        <seg>对于一个作用在键值分区输入上的函数而言，Flink运行时会在调用它的处理方法时，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the slide interval is smaller than the window size, the windows overlap and elements can be assigned to more than one window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T055232Z" creationid="xccui" creationdate="20190623T055127Z">
        <seg>如果滑动间隔小于窗口大小，则窗口会出现重叠，此时元素会被分配给多个窗口；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the state of a</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061208Z" creationid="xccui" creationdate="20190701T061208Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the task receives a new record, it accesses the state to get the current count, increments the count, updates the state, and emits the new count.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T055111Z" creationid="xccui" creationdate="20190607T054625Z">
        <seg>当任务收到一个新的记录后，首先会访问状态获取当前统计的记录数目，然后把数目增加并更新状态，最后将更新后的数目发送出去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the temperature is over a given threshold and the smoke level is high, the application emits a fire alert.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040129Z" creationid="xccui" creationdate="20190615T040129Z">
        <seg>当温度超过给定阈值且烟雾水平很高时，应用就会发出火灾警报。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the timer fires, a call‐ back method is called and the context of timer’s key is loaded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T203711Z" creationid="xccui" creationdate="20190704T203711Z">
        <seg>当计时器触发时，会调用回调方法并加载计时器键值的上下文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the timer fires, a new timer is regis‐ tered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195937Z" creationid="xccui" creationdate="20190626T195937Z">
        <seg>当一个计时器触发时又会注册一个新计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the timer of a window fires, the JoinFunction is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T052644Z" creationid="xccui" creationdate="20190628T052644Z">
        <seg>当窗口的计时器触发时，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the train exits the tunnel, she comes back online, and pending events are sent to the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T154758Z" creationid="xccui" creationdate="20190411T151545Z">
        <seg>在地铁离开隧道，爱丽丝重新上线后，之前缓存的事件才会发送给应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the trigger condition is met, the bucket contents are sent to an evaluation func&lt;t12/&gt;‐&lt;t13/&gt; tion that applies the computation logic on the bucket elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T045744Z" creationid="xccui" creationdate="20190406T045620Z">
        <seg>当触发条件满足时，桶中的内容会发送给一个计算函数（evaluation function），由它来对桶内元素应用计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the trigger condition is met, the bucket contents are sent to an evaluation function that applies the computation logic on the bucket elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012858Z" creationid="xccui" creationdate="20190606T012803Z">
        <seg>当触发条件满足时，桶内数据会发送给一个计算函数（evaluation function），由它来对桶中的元素应用计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the watermark passes the window’s end timestamp plus the lateness interval, the window is finally deleted and all subsequent late elements are discarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165028Z" creationid="xingcan" creationdate="20190628T165028Z">
        <seg>当水位线超过了窗口结束时间加延迟容忍度间隔，窗口才会被最终删除，此后所有的迟到元素都将直接丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the window border is passed, all the events are sent to an evaluation func‐ tion for processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T063350Z" creationid="xccui" creationdate="20190606T013021Z">
        <seg>在窗口边界通过后，所有事件会发送给计算函数进行处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When triggers are merged, all descriptors of custom states must be provided to the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195340Z" creationid="xccui" creationdate="20190626T195318Z">
        <seg>在合并触发器时，需要把所有自定义状态的描述符传给OnMergeContext对象的mergePartitionedState()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using a rich function, you can implement two additional methods to the func‐ tion’s lifecycle:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060824Z" creationid="xccui" creationdate="20190618T060824Z">
        <seg>在使用富函数的时候，你可以针对函数生命周期实现两个额外的方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using event-time windows, you can specify an additional time period called allowed lateness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T164252Z" creationid="xingcan" creationdate="20190628T164252Z">
        <seg>在使用事件时间窗口时，你可以指定一个名为延迟容忍度（allowed lateness）的额外时间段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using per-window state in a trigger, you need to ensure that this state is prop‐ erly deleted when the window is deleted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194100Z" creationid="xccui" creationdate="20190626T194100Z">
        <seg>当在触发器中使用了单个窗口状态时，你需要保证它们会随着窗口删除而正确删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using the Scala API or Java 8, the mapper can also be expressed as a lambda function:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T051123Z" creationid="xccui" creationdate="20190613T051123Z">
        <seg>如果使用Scala API或Java 8，还可以通过lambda函数来表示映射器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you enter the coffee shop, there might be other customers inside already.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T152836Z" creationid="xccui" creationdate="20190401T152347Z">
        <seg>当你进门的时候，可能已经有别的顾客在里面了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you specify a window to collect events in one-minute buckets, which events exactly will each bucket contain?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T055110Z" creationid="xccui" creationdate="20190619T055110Z">
        <seg>当你指定一个窗口来收集每分钟的桶内事件时，每个存储桶中需要包含哪些事件？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you submit the application via a submission client and specify the parallelism to be 16, the source will run with a parallelism of 16, the mapper will run with 32 tasks, and the sink will run with 2 tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061928Z" creationid="xccui" creationdate="20190616T061928Z">
        <seg>当你通过提交客户端提交应用且将并行度设置为16时，数据源会以16的并行度运行，map将运行32个任务，数据汇将运行2个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where to Go from Here?.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T152414Z" creationid="esouser" creationdate="20190603T152414Z">
        <seg>还有什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where to go from here?.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T030219Z" creationid="xccui" creationdate="20190225T030219Z">
        <seg>还有什么？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether a data source can reset its input stream depends on its implementation and the external system or interface from which the stream is consumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044432Z" creationid="xccui" creationdate="20190609T044221Z">
        <seg>数据源能否重置其输入流取决于它的具体实现以及所消费外部系统是否提供相关接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether this happens with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T035851Z" creationid="xccui" creationdate="20190626T035851Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Alice’s phone loses connection when inside the tunnel, Bob’s phone remains connected and delivers events to the gaming application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T152314Z" creationid="xccui" creationdate="20190412T152302Z">
        <seg>当爱丽丝的手机在隧道里没信号的时候，鲍勃的手机依然能联网向后端游戏应用发送事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While a task checkpoints its state, it is blocked and its input is buffered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T200059Z" creationid="xccui" creationdate="20190609T200005Z">
        <seg>任务在将其状态存入检查点的过程中，会出于阻塞状态，此时的输入会放入缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While adding or removing state from an application is rather easy and does not affect savepoint compatibility, modifying the state of an existing operator is more involved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043936Z" creationid="xccui" creationdate="20190705T043840Z">
        <seg>虽然从应用中增删状态非常容易，也不会影响保存点兼容性，但一旦涉及改变已有算子的状态，问题就会变得十分复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While evictors are optional components, each window operator needs a trigger to decide when to evaluate its windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T015004Z" creationid="xccui" creationdate="20190626T015004Z">
        <seg>虽然移除器是可选组件，但每个窗口算子都需要一个触发器来决定何时对窗口进行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While in the logical dataflow graph the nodes represent operators, in the physical dataflow, the nodes are tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233139Z" creationid="xccui" creationdate="20190401T003341Z">
        <seg>在逻辑Dataflow图中，顶点代表算子；而在物理Dataflow图中，顶点代表任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it is waiting, it continues pro‐ cessing records from stream partitions that did not provide a barrier yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T162506Z" creationid="xccui" creationdate="20190609T162226Z">
        <seg>在等待过程中，它会继续处理那些从还未提供分隔符的分区发来的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While period‐ ically loading data into a data analysis system has been the state of the art for many years, it adds considerable latency to the analytics pipeline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T154852Z" creationid="xccui" creationdate="20190605T043429Z">
        <seg>虽然周期性地将数据导入分析系统在多年来一直是最先进的方法，但它会给分析管道带来相当大的延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While previous stream processors only provided either high throughput or low latency, systems of the third generation are able to serve both ends of the spectrum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T134922Z" creationid="xccui" creationdate="20190327T134531Z">
        <seg>前几代的流处理引擎只能在高吞吐和低延迟之中取其一，而第三代的系统可以兼顾两者，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While previous stream processors only pro‐ vide either high throughput or low latency, systems of the third generation are able to serve both ends of the spectrum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T194617Z" creationid="xccui" creationdate="20190605T053538Z">
        <seg>前几代的流处理引擎只能在高吞吐和低延迟之间二选其一，而第三代的系统可以兼顾两者，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While processing the data, the task can read and update its state and compute its result based on its input data and state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054433Z" creationid="xccui" creationdate="20190607T054433Z">
        <seg>在处理这些数据的过程中，任务可以读取更新其状态，并根据状态和输入数据计算结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While processing time is easy to understand because it is based on the local time of the processing machine, it produces somewhat arbitrary, incon‐ sistent, and nonreproducible results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204212Z" creationid="xccui" creationdate="20190606T204212Z">
        <seg>虽然处理时间是基于处理机器的本地时间，相对容易理解，但它会产生一些较为随意、不一致且无法重现的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While processing-time is easy to understand because it is based on the local time of the processing machine, it produces somewhat arbitrary, inconsistent, and non-reproducible results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T160158Z" creationid="esouser" creationdate="20190514T160158Z">
        <seg>虽然处理时间是基于处理机器的本地时间，相对容易理解，但它会产生一些较为随意、不一致且无法重现的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While rebalance() will create communication channels between all sending tasks to all receiving tasks, rescale() will only cre‐ ate channels from each task to some of the tasks of the downstream operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T044438Z" creationid="xccui" creationdate="20190616T044438Z">
        <seg>rebalance()会在所有发送任务和接收任务之间建立通信通道；而rescale()中每个发送任务只会和下游算子的部分任务建立通道。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While scaling stateless opera‐ tors is trivial, changing the parallelism of stateful operators is much more challenging because their state needs to be repartitioned and assigned to more or fewer parallel tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T054759Z" creationid="xccui" creationdate="20190608T054626Z">
        <seg>对于无状态的算子，扩缩容很容易。但对于有状态的算子，改变并发度就会复杂很多，因为我们需要把状态重新分组，分配到与之前数量不等的并行任务之上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While some chapters are descriptive and aim to introduce concepts and high-level design, others are more hands-on and contain many code examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T191213Z" creationid="xccui" creationdate="20190225T161953Z">
        <seg>书中部分章节会侧重描述概念或高层次的设计理念，而其余章节会更加侧重实践并包含很多示例代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While some chapters are descriptive and aim to introduce high-level design concepts, others are more hands-on and contain many code examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T153029Z" creationid="esouser" creationdate="20190603T152715Z">
        <seg>书中部分章节会侧重描述高层次的设计理念，而其余章节会更加注重实践并包含了很多示例代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the approach of periodically loading data into data analysis systems has been the state-of-the-art for many years, it suffers from a notable drawback.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T031044Z" creationid="xccui" creationdate="20190317T030912Z">
        <seg>虽然周期性地将数据导入分析系统多年来一直是最先进的方法，但它有个明显的缺点，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the first option gives very fast state access, it is limited by the size of the memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T053100Z" creationid="xccui" creationdate="20190608T052828Z">
        <seg>前者状态访问会更快一些，但会受到内存大小的限制；</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the interface of the AggregateFunction is much more flexible, it is also more complex to implement compared to the interface of the ReduceFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T003513Z" creationid="xccui" creationdate="20190624T003513Z">
        <seg>虽然AggregateFunction和ReduceFunction相比接口更加灵活，但同时实现也更为复杂。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While the publisher and the authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210740Z" creationid="esouser" creationdate="20190603T210740Z">
        <seg>While the publisher and the authors have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the authors disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this approach provides very low latencies to read or write state, it has</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T222108Z" creationid="xccui" creationdate="20190703T222108Z">
        <seg>虽然这种方法读写状态的延迟会很低，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this behavior seems to be exactly the same as recovering an application from a failure using a checkpoint, failure recovery is actually just a special case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T211834Z" creationid="xccui" creationdate="20190609T211646Z">
        <seg>这个行为看上去和利用检查点将应用从故障中恢复完全一致，但其实故障恢复只是一种特殊情况，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this kind of delay may have been acceptable in the past, applications today must be able to collect data in real-time and immediately act on it (e.g., by adjusting to changing con‐ ditions in a mobile game or by personalizing user experiences for an online retailer).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044455Z" creationid="xccui" creationdate="20190605T043748Z">
        <seg>虽然从过去视角来看，这种延迟可以接受，但当今的应用必须能够实时收集数据并迅速响应（例如调整手游中的某个可变条件或使用户在网购过程中获得个性化体验）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this might yield incomplete or inaccurate results, the results are produced in a timely fashion with lower latency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T040711Z" creationid="xccui" creationdate="20190621T040711Z">
        <seg>虽然这会导致结果不完整或不准确，但能够做到以较低延迟及时地生成结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we intended for the book to be read in chapter order when we were writing it, readers familiar with a chapter’s content might want to skip it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T041545Z" creationid="esouser" creationdate="20190603T153220Z">
        <seg>尽管我们在写书的时候是按照预期阅读顺序进行的章节编排，但如果你已经对某些章节的内容很熟悉，仍可以选择跳过。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While you might get annoyed by this delay, most other customers will still be happy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T051338Z" creationid="xccui" creationdate="20190401T160314Z">
        <seg>虽然你可能因为这次耽搁而不高兴，但这丝毫不会影响其余大多数顾客的心情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While you want latency to be as low as possible, you generally want throughput to be as high as possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234525Z" creationid="xccui" creationdate="20190401T195813Z">
        <seg>通常情况下延迟是越低越好，而显然吞吐则是越高越好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Join</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151644Z" creationid="esouser" creationdate="20190603T150722Z">
        <seg>基于窗口的Join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190225T023138Z" creationid="xccui" creationdate="20190225T023138Z">
        <seg>窗口算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators | 123</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042004Z" creationid="xccui" creationdate="20190629T042004Z">
        <seg>窗口算子 | 123</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators | 131</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042053Z" creationid="xccui" creationdate="20190629T042053Z">
        <seg>窗口算子 | 131</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators | 133</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042100Z" creationid="xccui" creationdate="20190629T042100Z">
        <seg>窗口算子 | 133</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators | 141</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042104Z" creationid="xccui" creationdate="20190629T042104Z">
        <seg>窗口算子 | 141</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Operators | 143</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T042109Z" creationid="xccui" creationdate="20190629T042109Z">
        <seg>窗口算子| 143</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window assigners</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040902Z" creationid="xccui" creationdate="20190626T040902Z">
        <seg>窗口分配器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window content</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033002Z" creationid="xccui" creationdate="20190626T033002Z">
        <seg>窗口内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window functions define the computation that is performed on the elements of a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T205944Z" creationid="xccui" creationdate="20190623T205944Z">
        <seg>窗口函数定义了针对窗口内每一个元素的计算逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window lifecycle</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T030130Z" creationid="xccui" creationdate="20190626T030130Z">
        <seg>窗口的生命周期</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window object</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033421Z" creationid="xccui" creationdate="20190626T033421Z">
        <seg>窗口对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011951Z" creationid="xccui" creationdate="20190606T011951Z">
        <seg>窗口操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations are closely related to two dominant concepts in stream process&lt;t0/&gt;‐&lt;t1/&gt; ing: time semantics and state management.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T200140Z" creationid="xccui" creationdate="20190409T200114Z">
        <seg>窗口操作与流处理中两个核心概念密切相关：时间语义（time semantics）和状态管理（state management）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations are closely related to two dominant concepts in stream process‐ ing: time semantics and state management.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014214Z" creationid="xccui" creationdate="20190606T014214Z">
        <seg>窗口操作与流处理中两个核心概念密切相关：时间语义（time semantics）和状态管理（state management）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operations continuously create finite sets of events called buckets from an unbounded event stream and let us perform computations on these finite sets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022718Z" creationid="xccui" creationdate="20190406T044746Z">
        <seg>窗口操作会持续创建一些称为桶（bucket）的有限事件集合，并允许我们基于这些有限集进行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operators can be applied on a keyed or a nonkeyed stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T034136Z" creationid="xccui" creationdate="20190622T034136Z">
        <seg>窗口算子可用于键值分区或非键值分区的数据流上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operators defined using Flink’s built-in window assigners can address many common use cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045320Z" creationid="xccui" creationdate="20190625T045320Z">
        <seg>使用Flink内置窗口分配器定义的窗口算子可以应对许多常见用例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operators provide a way to group events in buckets of finite size and apply computations on the bounded contents of these buckets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T033431Z" creationid="xccui" creationdate="20190622T033431Z">
        <seg>窗口算子提供了一种基于有限大小的存储桶对事件进行分组，并对这些桶中的有限内容应用计算的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window operators, time-based transformations, stateful operators, and connectors are discussed in the next chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T032830Z" creationid="xccui" creationdate="20190612T032454Z">
        <seg>有关窗口算子、基于时间的转换、状态化算子和连接器的内容将在接下来的几章讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window opera‐ tors on keyed windows are evaluated in parallel, and nonkeyed windows are processed in a single thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T035249Z" creationid="xccui" creationdate="20190622T035249Z">
        <seg>用于键值分区窗口的窗口算子可以并行计算，而非键值分区窗口只能单线程处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window policies decide when new buckets are created, which events are assigned to which buckets, and when the con&lt;t10/&gt;‐&lt;t11/&gt; tents of a bucket get evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190407T022740Z" creationid="xccui" creationdate="20190406T045304Z">
        <seg>这些窗口策略决定了什么时间创建桶，事件如何分配到桶中以及桶中的内容什么时间参与计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window policies decide when new buckets are created, which events are assigned to which buckets, and when the contents of a bucket get evaluated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012831Z" creationid="xccui" creationdate="20190606T012724Z">
        <seg>这些窗口策略决定了什么时间创建桶，事件如何分配到桶中以及桶内数据什么时间参与计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window transformations are described in detail in “Window Operators” on page 122.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053825Z" creationid="xccui" creationdate="20190612T053825Z">
        <seg>有关窗口转换的详细内容会在122页"窗口算子"一节介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>WindowFunction has been superseded by ProcessWindow Function and will not be discussed here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010332Z" creationid="xccui" creationdate="20190624T010332Z">
        <seg>但该接口已经被ProcessWindowFunction取代，所以此处我们不再讨论。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Windows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T035926Z" creationid="xccui" creationdate="20190406T035926Z">
        <seg>窗口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Windows are common operations in streaming applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032841Z" creationid="xccui" creationdate="20190622T032841Z">
        <seg>窗口时流式应用中一类十分常见的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Windows with time-based trig‐ gers (both processing time and event time) are not affected by this because they trig‐ ger and purge their state based on time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T195942Z" creationid="xccui" creationdate="20190704T195942Z">
        <seg>基于时间（无论是处理时间还是事件时间）触发的窗口则不受该问题的影响，因为它们会根据不断前进的时间触发计算并清除状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a shuffle or broadcast connection, each sending task needs a buffer for each receiving task; the number of required buffers is quadratic to the number of tasks of the involved operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T193617Z" creationid="xccui" creationdate="20190606T201749Z">
        <seg>在Shuffle或广播连接的情况下，每个发送任务都需要为每个接收任务提供一个缓冲区，因此所需的缓冲区数量可达到相关算子任务数的平方级别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this book, we hope to reach developers, engineers, and streaming enthusiasts around the world and grow the Flink community even larger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T062952Z" creationid="xccui" creationdate="20190605T132916Z">
        <seg>通过本书，我们期待能够吸引世界各地的开发者、工程师以及流处理爱好者加入，进一步扩大Flink社区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this in mind, you can use watermarks to balance result latency and result completeness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T033758Z" creationid="xccui" creationdate="20190621T033758Z">
        <seg>知道这点，你就可以使用水位线来平衡结果的延迟和完成整。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing a Data‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T013925Z" creationid="xccui" creationdate="20190613T013925Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also know a little bit about the evolution of the open source stream processing space and what a Flink streaming application looks like.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T042338Z" creationid="xccui" creationdate="20190605T224647Z">
        <seg>还了解了开源流处理领域的发展过程以及Flink流式应用的模样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You apply a function on the connected streams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040931Z" creationid="xccui" creationdate="20190702T040931Z">
        <seg>在联结后的数据流上应用一个函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are probably not surprised that stateful stream processing is the right technology to build low-latency analytics pipelines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T054805Z" creationid="xccui" creationdate="20190317T054517Z">
        <seg>你应该会理所当然地想到状态化流处理就是构建低延迟分析流水线的恰当技术。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access the default paral‐ lelism of the environment as shown in the following example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T054220Z" creationid="xccui" creationdate="20190616T054220Z">
        <seg>你可以按照下面的示例来访问环境的默认并行度：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access this page at http://bit.ly/stream-proc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210843Z" creationid="esouser" creationdate="20190603T210843Z">
        <seg>You can access this page at http://bit.ly/stream-proc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also apply a CoProcessFunction to ConnectedStreams.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045325Z" creationid="xccui" creationdate="20190615T045325Z">
        <seg>你也可以对ConnectedStreams应用CoProcessFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also build the JAR file yourself by following the steps in the repository’s README file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123551Z" creationid="xccui" creationdate="20190605T123533Z">
        <seg>你也可以根据代码库中README文件的指示自行构建JAR文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also delete them if you do not need them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010448Z" creationid="xccui" creationdate="20190612T010135Z">
        <seg>如果不需要，也可以删除它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also download the source code of the examples as a zip-archive from GitHub:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040419Z" creationid="xccui" creationdate="20190611T040419Z">
        <seg>你也可以把示例代码以zip压缩包的形式从GitHub上下载下来：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also just take a savepoint to version and archive the state of an applica‐ tion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T213419Z" creationid="xccui" creationdate="20190609T213419Z">
        <seg>你还可以为保存点设置不同版本并将应用状态归档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also override the default parallelism of the environment, but you will no longer be able to control the parallelism of your application via the submission client:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060440Z" creationid="xccui" creationdate="20190616T060440Z">
        <seg>你也可以覆盖环境的默认并行度，然而一旦如此，将再无法通过提交客户端控制应用并行度：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can change the Flink version, group and artifact IDs, version, and generated package by changing the respective parameters of the above mvn command.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005618Z" creationid="xccui" creationdate="20190612T005349Z">
        <seg>你可以通过改变上述mvn命令的相应参数来更改Flink版本，Maven的组标识符和项目标识符，项目版本以及生成的包。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define breakpoints in the code and debug your application as you would normally do.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T053653Z" creationid="xccui" creationdate="20190611T053048Z">
        <seg>就如同往常一般，在代码里设置断点，开启调试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can develop and execute Flink applications on Linux, macOS, and Windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T054036Z" creationid="xccui" creationdate="20190610T040911Z">
        <seg>你可以在Linux、maxOS以及Windows等常见操作系统上开发和运行Flink应用，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do this by selecting the job in the web dashboard and clicking on the CANCEL button on the top of the page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T045547Z" creationid="xccui" creationdate="20190329T045547Z">
        <seg>取消的方式是在Web仪表盘中选定作业，然后点击页面上方的CANCEL按钮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do this by selecting the job in the web dashboard and clicking the Cancel button at the top of the page.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T201525Z" creationid="xccui" creationdate="20190605T124408Z">
        <seg>取消的方式是在Web UI中选定作业，然后点击页面上方的Cancel按钮。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can exploit parallelism in dataflow graphs in different ways.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T233216Z" creationid="xccui" creationdate="20190401T022711Z">
        <seg>Dataflow图的并行性可以通过多种方式加以利用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can follow the instruc‐ tions at the IntelliJ IDEA website to download and install it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T030717Z" creationid="xccui" creationdate="20190611T030717Z">
        <seg>你可以按照IntelliJ IDEA官网的说明下载并安装它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can import the project in your IDE following the steps we described in the previ‐ ous section or you can execute the following command to build a JAR file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T010443Z" creationid="xccui" creationdate="20190612T010248Z">
        <seg>此时，你可以按照我们在上一节所介绍的步骤把项目导入IDE，也可以执行以下命令来构建一个JAR文件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can monitor the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130301Z" creationid="xccui" creationdate="20190605T130301Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can monitor the constantly produced output using the tail command for example as follows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042619Z" creationid="xccui" creationdate="20190329T042619Z">
        <seg>如下所示，你可以使用tail命令监控持续产生的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set the identifier with the uid() method as shown in Example 7-10.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024110Z" creationid="xccui" creationdate="20190703T023949Z">
        <seg>具体方式可以像示例7-10中那样利用uid()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can start a different but compatible application from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212000Z" creationid="xccui" creationdate="20190609T212000Z">
        <seg>你可以从保存点启动一个不同但相互兼容的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can start the same application on a different cluster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212732Z" creationid="xccui" creationdate="20190609T212716Z">
        <seg>你可以在另一个集群上启动相同的应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can start the same application with a different parallelism and scale the appli‐ cation out or in.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212646Z" creationid="xccui" creationdate="20190609T212609Z">
        <seg>你可以用不同的并发度启动原应用，从而实现应用的扩缩容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of keyed state as a key-value map that is partitioned (or sharded) on  the key across all parallel tasks of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041533Z" creationid="xccui" creationdate="20190607T192001Z">
        <seg>你可以把键值分区状态想象成一个在算子所有并行任务上进行分区（或分片）的键值映射。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of state as a local or instance variable that is accessed by a task’s business logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T054049Z" creationid="xccui" creationdate="20190607T054049Z">
        <seg>你可以把状态想象成任务的业务逻辑所需要访问的本地或实例变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a savepoint to pause an application and resume it later.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T212928Z" creationid="xccui" creationdate="20190609T212928Z">
        <seg>你可以利用保存点暂停某个应用，稍后再把它启动起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use broadcast state to connect a keyed and a broadcast stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T210016Z" creationid="xccui" creationdate="20190615T052419Z">
        <seg>你可以使用广播状态来联结一个按键值分好区流和一个广播流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You connect the BroadcastStream with a DataStream or KeyedStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040613Z" creationid="xccui" creationdate="20190702T040613Z">
        <seg>将BroadcastStream和一个DataStream或KeyedStream联结起来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You create a BroadcastStream by calling DataStream.broadcast() and provid‐ ing one or more MapStateDescriptor objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T040524Z" creationid="xccui" creationdate="20190702T040524Z">
        <seg>调用DataStream.broadcast()方法创建一个BroadcastStream并提供一个以上MapStateDescriptor对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not need to contact us for permission unless you’re reproducing a significant portion of the code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210817Z" creationid="esouser" creationdate="20190603T210817Z">
        <seg>You do not need to contact us for permission unless you’re reproducing a significant portion of the code.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have become familiar with the evolution of the open-source stream processing space and you have got a brief taste of what a Flink streaming application looks like.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T052906Z" creationid="xccui" creationdate="20190329T052313Z">
        <seg>你已经熟悉了开源流处理领域的发展过程，且对Flink流式应用有一个粗略的认识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have learned basic streaming operations and how you can compute meaningful results on unbounded input data using windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051247Z" creationid="xccui" creationdate="20190416T051207Z">
        <seg>你学习了基本的流式操作，并掌握了如何利用窗口在无限输入上计算出有意义的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have probably already noticed that Flink programs are defined and submitted for execution in regular Scala or Java methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043401Z" creationid="xccui" creationdate="20190612T043039Z">
        <seg>你可能已经注意到了，用日常的Scala或Java方法就可以定义并提交Flink程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have seen how rolling aggregations encode the history of the whole stream in an aggregate value and provide us with a low-latency result for every event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T062530Z" creationid="xccui" creationdate="20190406T042607Z">
        <seg>你已经了解滚动聚合是如何将整条历史流压缩成一个聚合值，以及如何针对每个事件在极低延迟内产生结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have seen the dataflow programming model and learned how streaming applications can be expressed as distributed dataflow graphs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050548Z" creationid="xccui" creationdate="20190416T050539Z">
        <seg>你了解了dataflow编程模型以及如何将一个流式应用表示为分布式dataflow图。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have wondered about the meaning of time in stream processing and you have compared the notions of event time and processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T051413Z" creationid="xccui" creationdate="20190416T051333Z">
        <seg>你思考了流式应用中时间的含义，并比较了事件时间和处理时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You just installed and started your first local Flink cluster and ran your first Flink DataStream API program!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T124508Z" creationid="xccui" creationdate="20190605T124440Z">
        <seg>恭喜你首次成功安装启动了Flink本地集群并运行了你的首个Flink DataStream程序！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You just installed and started your first local Flink cluster and ran your first Flink DataStream program!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T050049Z" creationid="xccui" creationdate="20190328T062213Z">
        <seg>恭喜你首次成功安装启动了Flink本地集群并运行了你第一个Flink DataStream程序！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You learned about time-based operators, including Flink’s process functions, built-in windows, and custom win‐ dows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T041643Z" creationid="xccui" creationdate="20190629T041533Z">
        <seg>你对Flink中基于时间的算子（包括处理函数、内置窗口以及自定义窗口等）已经有所了解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You learned the mean‐ ing of time in stream processing and compared the notions of event time and pro‐ cessing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T040431Z" creationid="xccui" creationdate="20190606T040431Z">
        <seg>你学习了流式应用中时间的含义，并比较了事件时间和处理时间的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may be able to lower the latency in our coffee shop example by hiring a more skilled barista—one that prepares coffees faster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T235353Z" creationid="xccui" creationdate="20190605T235258Z">
        <seg>为了降低延迟，可以雇佣更娴熟的咖啡师，他们制作咖啡会更快一些。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have been able to generate a result earlier but you had to wait for the water‐ mark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T034128Z" creationid="xccui" creationdate="20190621T034128Z">
        <seg>换言之，可能你早就能够生成结果，但必须等待水位线来触发。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need to use whatever information you have about the sources, the network, and the partitions to estimate progress and an upper bound for the lateness of your input records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T033709Z" creationid="xccui" creationdate="20190621T032302Z">
        <seg>你需要尽可能地了解有关数据源、网络以及分区等一切信息，以此来估计进度和输入记录的延迟上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should now be able to browse and inspect the code of the book exam‐ ples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T041822Z" creationid="xccui" creationdate="20190611T041759Z">
        <seg>你现在应该就能浏览和研究书中示例的源码了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see a job listed under “Running Jobs.” If you click on that job, you will see the dataflow and live metrics about the opera‐ tors of the running job similar to the screenshot in Figure 1-9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123742Z" creationid="xccui" creationdate="20190605T123657Z">
        <seg>你应该能看到"Running Jobs"列表中有一个作业。点击那个作业，你会看到和图1-9中的截图相类似的数据流程及运行作业中算子的实时指标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see a job listed under “Running Jobs”.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T040122Z" creationid="xccui" creationdate="20190329T040122Z">
        <seg>你会发现"Running Jobs"列表中有一个作业。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see lines as the following ones being written to the file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190329T042932Z" creationid="xccui" creationdate="20190329T042825Z">
        <seg>你会看到文件中写入了以下文本行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should see lines like this being written to the file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123930Z" creationid="xccui" creationdate="20190605T123849Z">
        <seg>你会看到文件中写入了和下面类似的文本行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will also get an introduction to custom, user-defined window operations and core windowing constructs, such as assigners, triggers, and evictors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T053336Z" creationid="xccui" creationdate="20190619T053336Z">
        <seg>此外你还将了解用户自定义窗口操作以及窗口中的核心结构，例如：分配器、触发器和移除器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will find the source code in the src/ directory, grouped by chapter:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040535Z" creationid="xccui" creationdate="20190611T040535Z">
        <seg>你可以在src/目录中找到按照章节分好的源代码：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will learn how to implement a DataStream application and which stream transforma‐ tions, functions, and data types are supported.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T061616Z" creationid="esouser" creationdate="20190603T161436Z">
        <seg>你将从中学到如何实现DataStream应用以及Flink所支持的流式转换、函数、数据类型等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will learn more about stateful stream processing, failure scenarios, and consistency at the end of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T005148Z" creationid="xccui" creationdate="20190606T005148Z">
        <seg>在本章末尾，你将了解更多有关状态化流处理、错误场景和一致性的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will learn more about stateful stream processing, failure scenarios, and consistency in the end of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190405T151708Z" creationid="xccui" creationdate="20190405T151603Z">
        <seg>在本章末尾，你将了解更多有关状态化流处理、错误场景和一致性的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your service latency is the time you spend in the coffee shop, from the moment you enter until you have the first sip of coffee.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T154418Z" creationid="xccui" creationdate="20190401T154008Z">
        <seg>你的服务延迟就是在店内买咖啡的时间，即从你进门的一刻到抿到第一口咖啡的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You’ve seen user-defined functions in action in the code examples of this chapter so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052928Z" creationid="xccui" creationdate="20190618T052830Z">
        <seg>目前位置，你已经在本章的代码示例中见到过如何使用用户自定义函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[(String, Double), (String, Double, Int), (String, Double)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005603Z" creationid="xccui" creationdate="20190624T005603Z">
        <seg>[(String, Double), (String, Double, Int), (String, Double)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[.evictor(...)]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014909Z" creationid="xccui" creationdate="20190626T014909Z">
        <seg>[.evictor(...)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[.trigger(...)]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T014838Z" creationid="xccui" creationdate="20190626T014838Z">
        <seg>[.trigger(...)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[String, SensorReading, (String, Double, Double)]#Context, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210448Z" creationid="xccui" creationdate="20190704T210448Z">
        <seg>[String, SensorReading, (String, Double, Double)]#Context, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[String, SensorReading, (String, Double, Double)]#OnTimerContext, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210700Z" creationid="xccui" creationdate="20190704T210700Z">
        <seg>[String, SensorReading, (String, Double, Double)]#OnTimerContext, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[String, SensorReading, ThresholdUpdate, (String, Double, Double)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041333Z" creationid="xccui" creationdate="20190702T041333Z">
        <seg>[String, SensorReading, ThresholdUpdate, (String, Double, Double)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[String, SensorReading, ThresholdUpdate, (String, Double, Double)]#Context, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042536Z" creationid="xccui" creationdate="20190702T042536Z">
        <seg>[String, SensorReading, ThresholdUpdate, (String, Double, Double)]#Context, out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>\</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T004818Z" creationid="xccui" creationdate="20190612T004818Z">
        <seg>\</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a ProcessWindowFunction or the result of applying a ReduceFunction, a Process Function memorizes scheduled timers, and some sink functions maintain state about transactions to provide exactly-once functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T031718Z" creationid="xccui" creationdate="20190630T031718Z">
        <seg>举例而言：窗口算子会为ProcessWindowFunction收集输入记录或保存ReduceFunction所产生的结果；ProcessFunction需要记住设定的计时器；一些数据汇函数为了提供精确一次语义需要维护事务相关状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a WindowAssigner, a trigger decides when to evalute a window, and a window func‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T031548Z" creationid="xccui" creationdate="20190626T031548Z">
        <seg>触发器决定何时对窗口执行计算，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a broadcasted stream and storing the broadcasted events in man‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053023Z" creationid="xccui" creationdate="20190615T053023Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a filter operation that only preserves white squares.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052257Z" creationid="xccui" creationdate="20190613T052257Z">
        <seg>图5-2展示的filter操作仅保留了白色方块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a trigger needs to remove all custom per-window state and delete all processing-time and event-time timers using the TriggerContext object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194543Z" creationid="xccui" creationdate="20190626T194404Z">
        <seg>触发器的clear()方法需要删除全部自定义的单个窗口状态并使用TriggerContext对象删除所有处理时间和事件时间计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a window—when it is created, what information it consists of, and when it is deleted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032507Z" creationid="xccui" creationdate="20190626T032507Z">
        <seg>即它何时创建，包含了哪些信息以及何时删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>able field in the open() method or override the Java serialization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055447Z" creationid="xccui" creationdate="20190618T055342Z">
        <seg>或者覆盖Java的序列化反序列化方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>acceptable because a prompt reaction to new results or insights did not yield a signifi&lt;t0/&gt;‐&lt;t1/&gt; cant advantage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190317T032923Z" creationid="xccui" creationdate="20190317T032923Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>access a keyed value and will throw an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054227Z" creationid="xccui" creationdate="20190702T054227Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>access intermediate data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T205838Z" creationid="esouser" creationdate="20190603T205838Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>accesses and fault tolerance in the case of failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T022639Z" creationid="xccui" creationdate="20190704T022425Z">
        <seg>又可以支持故障容错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>account when implementing the interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T203051Z" creationid="xccui" creationdate="20190702T203051Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>address: Address)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050018Z" creationid="xccui" creationdate="20190618T050018Z">
        <seg>address: Address)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aged state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053027Z" creationid="xccui" creationdate="20190615T053027Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aggregate the window content.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203840Z" creationid="xccui" creationdate="20190627T203840Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>aggregates on a KeyedStream, either with the built-in aggregations functions such as min, max, sum, minBy, or maxBy or with a custom ReduceFunction or AggregateFunc tion, keeps the state for each key and never discards it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T183348Z" creationid="xccui" creationdate="20190704T183348Z">
        <seg>例如，当我们在一个KeyedStream上计算聚合时，无论采用的是内置聚合函数（例如min、max、sum、minBy或maxBy）还是自定义的ReduceFunction或AggregateFunction，都会为每个键值保存状态并且永不丢弃。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>allows reading and writing values per key—only those keys and values are de/serial‐ ized that are read or written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T033400Z" creationid="xccui" creationdate="20190704T033038Z">
        <seg>RocksDBStateBackend的MapState允许按照每个键对其数据值进行读写，并且只有那些读写的键和数据值才需要进行（反）序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>always add the following import statement to your Scala applica‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054830Z" creationid="xccui" creationdate="20190617T054830Z">
        <seg>请确保将以下导入语句添加到你的Scala应用中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an OutOfMemoryError.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T222743Z" creationid="xccui" creationdate="20190703T222743Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and deserialization methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055451Z" creationid="xccui" creationdate="20190618T055451Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and is the only interface that gives access to operator list union state—the operator state that is fully replicated in the case of a recovery or savepoint restart.3</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T063827Z" creationid="xccui" creationdate="20190702T063515Z">
        <seg>并且是唯一可以访问算子联合列表状态（在进行恢复或从保存点启动的情况下需要被完整复制的算子状态）的接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and processes the elements that are assigned to a window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T040102Z" creationid="xccui" creationdate="20190622T040102Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and provided sources and sinks, Flink’s DataStream API exposes interfaces to register, maintain, and access state in user-defined functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T032018Z" creationid="xccui" creationdate="20190630T032018Z">
        <seg>除了内置算子和提供的数据源及数据汇之外，Flink DataStream API也在用户自定义函数里暴露了状态的注册、维护及访问接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and restored using the methods of the ListCheckpointed interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T053912Z" creationid="xccui" creationdate="20190701T053912Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and that all input streams are reset to the position up to which they were consumed when the checkpoint was taken.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T044017Z" creationid="xccui" creationdate="20190609T044017Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and the onMerge() method needs to implement the logic to perform the merge.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195055Z" creationid="xccui" creationdate="20190626T195023Z">
        <seg>而相应地需要在onMerge()方法中实现合并逻辑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and video from O’Reilly and 200+ other publishers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210833Z" creationid="esouser" creationdate="20190603T210833Z">
        <seg>and video from O’Reilly and 200+ other publishers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and when the trigger of the window fires, the aggregated result will be handed to ProcessWindowFunction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T035851Z" creationid="xccui" creationdate="20190625T035656Z">
        <seg>随后当窗口触发器触发时，再将聚合后的结果传给ProcessWindowFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and write data from and to RocksDB, it needs to be de/serialized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T023950Z" creationid="xccui" creationdate="20190704T023657Z">
        <seg>为了从RocksDB中读写数据，需要对数据进行序列化和反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application is represented by the StreamExecutionEnvironment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T044952Z" creationid="xccui" creationdate="20190612T044952Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application, fix bugs and repair previously emitted results, migrate an application to a different cluster, or perform A/B tests with different application versions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190625T143904Z" creationid="esouser" creationdate="20190603T211838Z">
        <seg>该技术不但可用于失败恢复，还可用于应用更新、Bug修复、结果修正、集群迁移或针对不同版本应用执行A/B测试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T032948Z" creationid="xccui" creationdate="20190418T032948Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>apply a ReduceFunction or AggregateFunction to incrementally</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203838Z" creationid="xccui" creationdate="20190627T203838Z">
        <seg>且没有对窗口内容使用ReduceFunction或AggregateFunction进行增量聚合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as an identifier for a window, such as the start and end timestamps in the case of a time window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011918Z" creationid="xccui" creationdate="20190624T011845Z">
        <seg>例如时间窗口中的开始和结束时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>assignTimestampsAndWatermarks() method where we define the timestamp assigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044558Z" creationid="xccui" creationdate="20190620T044558Z">
        <seg>然后调用assignTimestampsAndWatermarks()方法传入时间戳分配器MyAssigner()。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>assigning timestamps if such operations do not induce a redistribution of elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T031947Z" creationid="xccui" creationdate="20190620T031947Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ated with the windows.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T050619Z" creationid="xccui" creationdate="20190626T050619Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ator does not have an incremental aggregation function, the new element is appended to a ListState that holds all assigned elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052516Z" creationid="xccui" creationdate="20190625T052516Z">
        <seg>如果窗口算子没有配置增量聚合函数，新加入的元素会附加到一个用于存储所有窗口分配元素的ListState上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ature per sensor and the end timestamp of each window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043445Z" creationid="xccui" creationdate="20190625T043304Z">
        <seg>为每个传感器每5秒发出一次最高和最低温度以及窗口的结束时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>avgTemp.print()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042827Z" creationid="xccui" creationdate="20190612T042827Z">
        <seg>avgTemp.print()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>based on a property of the input events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045149Z" creationid="xccui" creationdate="20190620T045149Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>batch storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T051915Z" creationid="xccui" creationdate="20190605T051915Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because the contents of the windows depend on the speed at which the elements arrive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T065849Z" creationid="xccui" creationdate="20190619T065849Z">
        <seg>这是因为窗口内容取决于元素到达的速率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>between the events of both streams so events of both streams are randomly assigned to operator instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045555Z" creationid="xccui" creationdate="20190615T045451Z">
        <seg>默认情况下，connect()方法不会在两个输入流的事件之间建立关联，因此所有事件都会随机分配给算子实例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>birthday: (Int, Int, Int), // year, month, day</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050008Z" creationid="xccui" creationdate="20190618T050008Z">
        <seg>birthday: (Int, Int, Int), // 年、月、日</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ble.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T041101Z" creationid="xccui" creationdate="20190414T041101Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>broadcast input does not specify a key, the state backend cannot</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T054224Z" creationid="xccui" creationdate="20190702T054224Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>broadcasted stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024120Z" creationid="xccui" creationdate="20190702T024120Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>buffer channels and serialization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204046Z" creationid="xccui" creationdate="20190606T204046Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by Fabian Hueske and Vasiliki Kalavri</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210709Z" creationid="esouser" creationdate="20190603T210709Z">
        <seg>by Fabian Hueske and Vasiliki Kalavri</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>by a session gap</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061314Z" creationid="xccui" creationdate="20190623T061314Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>called for each combination of elements from the first and the second input—the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T053148Z" creationid="xccui" creationdate="20190628T052848Z">
        <seg>会遍历两个输入中元素的每种组合（叉乘积）去调用JoinFunction。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can join all A events with all B events that have timestamps between one and two hours more than the A event.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T031015Z" creationid="xccui" creationdate="20190628T031015Z">
        <seg>例如：允许出现B中事件的时间戳相较A中事件的时间戳早1到2个小时这样的条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>canMerge() declares that a trigger supports merging</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194948Z" creationid="xccui" creationdate="20190626T194948Z">
        <seg>canMerge()声明了某个触发器支持合并，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>care, as routing all events to the same task might impact application perfor‐ mance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050002Z" creationid="xccui" creationdate="20190616T045949Z">
        <seg>因为将所有事件发往同一任务可能会影响程序性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case (in: SensorReading, None) =&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023022Z" creationid="xccui" creationdate="20190701T023022Z">
        <seg>case (in: SensorReading, None) =&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case (r: SensorReading, lastTemp: Some[Double]) =&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T023141Z" creationid="xccui" creationdate="20190701T023141Z">
        <seg>case (r: SensorReading, lastTemp: Some[Double]) =&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class Address( address: String, zip: String country: String)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T045954Z" creationid="xccui" creationdate="20190618T045954Z">
        <seg>case class Address( address: String, zip: String country: String)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class MinMaxTemp(id: String, min: Double, max:Double, endTs: Long)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030650Z" creationid="xccui" creationdate="20190625T030650Z">
        <seg>case class MinMaxTemp(id: String, min: Double, max:Double, endTs: Long)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class MinMaxTemp(id: String, min: Double, max:Double, endTs: Long) val minMaxTempPerWindow2: DataStream[MinMaxTemp] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043552Z" creationid="xccui" creationdate="20190625T043552Z">
        <seg>case class MinMaxTemp(id: String, min: Double, max:Double, endTs: Long) val minMaxTempPerWindow2: DataStream[MinMaxTemp] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class Person( name: String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T045958Z" creationid="xccui" creationdate="20190618T045958Z">
        <seg>case class Person( name: String,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class Person(name: String, age: Int)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041136Z" creationid="xccui" creationdate="20190617T041136Z">
        <seg>case class Person(name: String, age: Int)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>case class SensorReading( id: String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035705Z" creationid="xccui" creationdate="20190612T035705Z">
        <seg>case class SensorReading( id: String,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190319T055509Z" creationid="xccui" creationdate="20190319T055509Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cations run continuously and the input is potentially unbounded, there is no notion of total execution time in data stream processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T150815Z" creationid="xccui" creationdate="20190401T150815Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cations” on page 245.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T043512Z" creationid="xccui" creationdate="20190705T043512Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cessed, and there is a chance that some of them are processed more than once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T034626Z" creationid="xccui" creationdate="20190606T034626Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cessing time and watermark, state stores to manage per-window and per-key global</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024305Z" creationid="xccui" creationdate="20190624T011407Z">
        <seg>当前处理时间和水位线，用于管理单个窗口和每个键值全局状态的状态存储</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cessor, a speed store, a batch store, and tools to ingest data for the batch processor and scheduling batch jobs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190327T032758Z" creationid="xccui" creationdate="20190327T032758Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>choose the TypeInformation that generates the most efficient serializers and deserial‐ izers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061119Z" creationid="xccui" creationdate="20190617T061119Z">
        <seg>此外，某些情况下Flink选择的TypeInformation可能无法生成最高效的序列化和反序列化器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class AssignWindowEndProcessFunction extends</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045134Z" creationid="xccui" creationdate="20190625T045134Z">
        <seg>class AssignWindowEndProcessFunction extends</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class AvgTempFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005551Z" creationid="xccui" creationdate="20190624T005551Z">
        <seg>class AvgTempFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class FlinkFilter extends FilterFunction[String] { override def filter(value: String): Boolean = { value.contains("flink")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054002Z" creationid="xccui" creationdate="20190618T054002Z">
        <seg>class FlinkFilter extends FilterFunction[String] { override def filter(value: String): Boolean = { value.contains("flink")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class FreezingMonitor extends ProcessFunction[SensorReading, SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023913Z" creationid="xccui" creationdate="20190622T023913Z">
        <seg>class FreezingMonitor extends ProcessFunction[SensorReading, SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class HighAndLowTempProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031907Z" creationid="xccui" creationdate="20190625T031907Z">
        <seg>class HighAndLowTempProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class HighTempCounter(val threshold: Double)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052316Z" creationid="xccui" creationdate="20190701T052316Z">
        <seg>class HighTempCounter(val threshold: Double)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class KeywordFilter(keyWord: String) extends FilterFunction[String] { override def filter(value: String): Boolean = { value.contains(keyWord)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054645Z" creationid="xccui" creationdate="20190618T054645Z">
        <seg>class KeywordFilter(keyWord: String) extends FilterFunction[String] { override def filter(value: String): Boolean = { value.contains(keyWord)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class LateReadingsFilter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155830Z" creationid="xingcan" creationdate="20190628T155830Z">
        <seg>class LateReadingsFilter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class MyFlatMap extends RichFlatMapFunction[Int, (Int, Int)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034245Z" creationid="xccui" creationdate="20190619T034245Z">
        <seg>class MyFlatMap extends RichFlatMapFunction[Int, (Int, Int)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class MyMapFunction extends MapFunction[Int, Int] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020905Z" creationid="xccui" creationdate="20190613T020905Z">
        <seg>class MyMapFunction extends MapFunction[Int, Int] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class MyMapFunction extends MapFunction[SensorReading, String] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050721Z" creationid="xccui" creationdate="20190613T050721Z">
        <seg>class MyMapFunction extends MapFunction[SensorReading, String] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class OneSecondIntervalTrigger</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200215Z" creationid="xccui" creationdate="20190626T200215Z">
        <seg>class OneSecondIntervalTrigger</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class PeriodicAssigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051033Z" creationid="xccui" creationdate="20190620T051033Z">
        <seg>class PeriodicAssigner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class PunctuatedAssigner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054750Z" creationid="xccui" creationdate="20190620T054750Z">
        <seg>class PunctuatedAssigner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class ReadingFilter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032024Z" creationid="xccui" creationdate="20190622T032024Z">
        <seg>class ReadingFilter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class SelfCleaningTemperatureAlertFunction(val threshold: Double)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205615Z" creationid="xccui" creationdate="20190704T205615Z">
        <seg>class SelfCleaningTemperatureAlertFunction(val threshold: Double)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class TempIncreaseAlertFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071337Z" creationid="xccui" creationdate="20190621T071337Z">
        <seg>class TempIncreaseAlertFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class TemperatureAlertFunction(val threshold: Double)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064204Z" creationid="xccui" creationdate="20190630T064204Z">
        <seg>class TemperatureAlertFunction(val threshold: Double)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class ThirtySecondsWindows</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042647Z" creationid="xccui" creationdate="20190626T042647Z">
        <seg>class ThirtySecondsWindows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class Tuple2ToPersonMapper extends MapFunction[(String, Int), Person] with ResultTypeQueryable[Person] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061912Z" creationid="xccui" creationdate="20190617T061912Z">
        <seg>class Tuple2ToPersonMapper extends MapFunction[(String, Int), Person] with ResultTypeQueryable[Person] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class UpdatableTemperatureAlertFunction() extends KeyedBroadcastProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T041330Z" creationid="xccui" creationdate="20190702T041330Z">
        <seg>class UpdatableTemperatureAlertFunction() extends KeyedBroadcastProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>class UpdatingWindowCountFunction extends ProcessWindowFunction[</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T033939Z" creationid="xccui" creationdate="20190629T033939Z">
        <seg>class UpdatingWindowCountFunction extends ProcessWindowFunction[</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>clearly define its behavior in a failure scenario.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190415T042849Z" creationid="xccui" creationdate="20190415T042849Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>collects all events can become significantly larger than the state of a window whose</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034336Z" creationid="xccui" creationdate="20190625T034336Z">
        <seg>收集全部事件的窗口其状态要大得多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>compared to event time as it does not provide deterministic results and has simi‐ lar performance as event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071915Z" creationid="xccui" creationdate="20190619T071915Z">
        <seg>和事件时间相比，它的实际价值不大，因为无法提供确定的结果且性能还和事件时间类似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>component of a TaskManager collect records in buffers before they are shipped, i.e., records are not shipped one-by-one but batched into buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T041706Z" creationid="xccui" creationdate="20190504T041706Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>connection pattern of the rescale distribution transformation is shown in Figure 5-7.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T044847Z" creationid="xccui" creationdate="20190616T044847Z">
        <seg>图5-7展示了重调分发转换的连接模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>constantly produced output using the tail command as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T123837Z" creationid="xccui" creationdate="20190605T123837Z">
        <seg>你可以使用tail命令监控持续产生的结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>copied their state to the remote storage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T202707Z" creationid="xccui" creationdate="20190702T202707Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cross-product.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T053144Z" creationid="xccui" creationdate="20190628T053144Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx.output(freezingAlarmOutput, s"Freezing Alarm for ${r.id}")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T024020Z" creationid="xccui" creationdate="20190622T024020Z">
        <seg>ctx.output(freezingAlarmOutput, s"Freezing Alarm for ${r.id}")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx.output(lateReadingsOut, r)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155937Z" creationid="xingcan" creationdate="20190628T155937Z">
        <seg>ctx.output(lateReadingsOut, r)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032604Z" creationid="xccui" creationdate="20190622T032604Z">
        <seg>ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]#Context, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032238Z" creationid="xccui" creationdate="20190622T032238Z">
        <seg>ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]#Context, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: Context,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031921Z" creationid="xccui" creationdate="20190625T031921Z">
        <seg>ctx: Context,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: KeyedBroadcastProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042531Z" creationid="xccui" creationdate="20190702T042531Z">
        <seg>ctx: KeyedBroadcastProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: KeyedProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210654Z" creationid="xccui" creationdate="20190704T210654Z">
        <seg>ctx: KeyedProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: KeyedProcessFunction[String, SensorReading, String]#Context, out: Collector[String]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071416Z" creationid="xccui" creationdate="20190621T071416Z">
        <seg>ctx: KeyedProcessFunction[String, SensorReading, String]#Context, out: Collector[String]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: KeyedProcessFunction[String, SensorReading, String]#OnTimerContext, out: Collector[String]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071739Z" creationid="xccui" creationdate="20190621T071739Z">
        <seg>ctx: KeyedProcessFunction[String, SensorReading, String]#OnTimerContext, out: Collector[String]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: ProcessFunction[SensorReading, SensorReading]#Context, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023936Z" creationid="xccui" creationdate="20190622T023936Z">
        <seg>ctx: ProcessFunction[SensorReading, SensorReading]#Context, out: Collector[SensorReading]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: Trigger.TriggerContext): TriggerResult = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200238Z" creationid="xccui" creationdate="20190626T200238Z">
        <seg>ctx: Trigger.TriggerContext): TriggerResult = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: Trigger.TriggerContext): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200930Z" creationid="xccui" creationdate="20190626T200930Z">
        <seg>ctx: Trigger.TriggerContext): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ctx: WindowAssigner.WindowAssignerContext): java.util.List[TimeWindow] = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042723Z" creationid="xccui" creationdate="20190626T042723Z">
        <seg>ctx: WindowAssigner.WindowAssignerContext): java.util.List[TimeWindow] = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>currentProcessingTime(): Long returns the current processing time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060006Z" creationid="xccui" creationdate="20190621T060006Z">
        <seg>currentProcessingTime(): Long返回当前的处理时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>currentTimer.update(timerTs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071727Z" creationid="xccui" creationdate="20190621T071727Z">
        <seg>currentTimer.update(timerTs)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>currentWatermark(): Long returns the timestamp of the current watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060023Z" creationid="xccui" creationdate="20190621T060023Z">
        <seg>currentWatermark(): Long返回当前水位线的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>data with other TaskManagers that run tasks of the same application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T061343Z" creationid="xccui" creationdate="20190606T142702Z">
        <seg>在执行期间，运行同一应用不同任务的TaskManager之间会产生数据交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>days.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042801Z" creationid="xccui" creationdate="20190623T042801Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>def main(args: Array[String]) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041920Z" creationid="xccui" creationdate="20190612T041920Z">
        <seg>def main(args: Array[String]) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>define their own.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070302Z" creationid="xccui" creationdate="20190615T070302Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deleteEventTimeTimer(timestamp: Long): Unit deletes an event-time timer that was previously registered for the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060658Z">
        <seg>deleteEventTimeTimer(timestamp: Long): Unit针对当前键值删除一个过去注册的事件时间计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deleteProcessingTimeTimer(timestamp: Long): Unit deletes a processing- time timer that was previously registered for the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060504Z">
        <seg>deleteProcessingTimeTimer(timestamp: Long): Unit针对当前键值删除一个过去注册的处理时间计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deleted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194741Z" creationid="xccui" creationdate="20190626T194741Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deploying Flink applications and the way each distributes and executes tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T045209Z" creationid="xccui" creationdate="20190606T141058Z">
        <seg>我们主要讨论两类部署Flink应用的方式以及它们如何分配和执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>different contexts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T052026Z" creationid="xccui" creationdate="20190621T052026Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>different pieces of state as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032948Z" creationid="xccui" creationdate="20190626T032948Z">
        <seg>窗口包含的不同状态如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>distribution behavior when the HighTempCounter function is rescaled, we can imple‐ ment the snapshotState() method so that it splits its count into multiple partial counts as shown in Example 7-5.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062416Z" creationid="xccui" creationdate="20190701T062256Z">
        <seg>为了让状态在HighTempCounter函数扩缩容时分布地更好，我们可以像示例7-5中那样，在实现snapshotState()方法时将计数值分成多个子部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do not concern us right now.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T052907Z" creationid="xccui" creationdate="20190612T052907Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does not automatically clean up savepoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T210957Z" creationid="xccui" creationdate="20190609T210957Z">
        <seg>同时，Flink也不会自动清理保存点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dow does not exist yet, it is created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T052115Z" creationid="xccui" creationdate="20190625T052115Z">
        <seg>如何目标窗口不存在，则会创建它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dows afterward.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045849Z" creationid="xccui" creationdate="20190626T045849Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>duces a new DataStream of the same type as the input DataStream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T052158Z" creationid="xccui" creationdate="20190613T052158Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>effectively executed with a parallelism of 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T064006Z" creationid="xccui" creationdate="20190621T064006Z">
        <seg>强制算子以并行度1来执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elements are incrementally aggregated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T034355Z" creationid="xccui" creationdate="20190625T034355Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elements: Iterable[SensorReading],</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034006Z" creationid="xccui" creationdate="20190629T034006Z">
        <seg>elements: Iterable[SensorReading],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>end timestamp of the window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030912Z" creationid="xccui" creationdate="20190625T030912Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>enterprises across different industries such as (online) retail, social media, telecom‐ munication, gaming, and banking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T050311Z" creationid="xccui" creationdate="20190605T050311Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.addSource(new SensorSource)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051430Z" creationid="xccui" creationdate="20190612T051430Z">
        <seg>env.addSource(new SensorSource)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.enableCheckpointing(10000L)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T204850Z" creationid="xccui" creationdate="20190702T204850Z">
        <seg>env.enableCheckpointing(10000L)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.execute("Compute average sensor temperature")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042809Z" creationid="xccui" creationdate="20190612T042809Z">
        <seg>env.execute("Compute average sensor temperature")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.getConfig.setAutoWatermarkInterval(5000)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045802Z" creationid="xccui" creationdate="20190620T045802Z">
        <seg>env.getConfig.setAutoWatermarkInterval(5000)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.setMaxParallelism(512)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T025105Z" creationid="xccui" creationdate="20190703T025105Z">
        <seg>env.setMaxParallelism(512)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.setParallelism(32)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060510Z" creationid="xccui" creationdate="20190616T060510Z">
        <seg>env.setParallelism(32)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.setStateBackend(backend)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025736Z" creationid="xccui" creationdate="20190704T025736Z">
        <seg>env.setStateBackend(backend)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041940Z" creationid="xccui" creationdate="20190612T041940Z">
        <seg>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>env: environment.StreamExecutionEnvironment): Trigger[Object, TimeWindow] = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044154Z" creationid="xccui" creationdate="20190626T044154Z">
        <seg>env: environment.StreamExecutionEnvironment): Trigger[Object, TimeWindow] = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>environment offers more configuration options, such as setting the program parallel‐ ism and enabling fault tolerance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T050029Z" creationid="xccui" creationdate="20190612T045857Z">
        <seg>执行环境还提供了很多配置选项，例如设置程序并行度，启用容错等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>event, the operator updates the corresponding aggregate value and emits an event with the updated value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052402Z" creationid="xccui" creationdate="20190614T052132Z">
        <seg>每到来一个事件，该算子都会更新相应的聚合结果，并将它以事件形式发送出去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>events with the same key are processed by the same task of the subsequent operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050540Z" creationid="xccui" creationdate="20190614T050540Z">
        <seg>这样一来有着相同键值的事件一定会在后续算子的同一个任务上处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>example is a stream of rules and a stream of events on which the rules are applied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T202923Z" creationid="xccui" creationdate="20190701T202923Z">
        <seg>一个典型的例子是有一条规则流和一条需要应用这些规则的事件流。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>examples are windows with count-based triggers, which process and clean their state when a certain number of records has been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T184154Z" creationid="xccui" creationdate="20190704T184154Z">
        <seg>其他例子还有像基于数量触发的窗口，它们只有在收到一定数量的记录时才会进行处理并清除状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>examples of finite, complete data sets that are generated all at once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190301T035813Z" creationid="xccui" creationdate="20190301T035813Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>executing machine reaches the provided timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060229Z" creationid="xccui" creationdate="20190621T060229Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>executionConfig: ExecutionConfig): TypeSerializer[TimeWindow] = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044229Z" creationid="xccui" creationdate="20190626T044229Z">
        <seg>executionConfig: ExecutionConfig): TypeSerializer[TimeWindow] = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exists, the method has no effect.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060540Z">
        <seg>如果该计时器不存在，则方法不会有任何作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>explicitly specified via the submission client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060228Z" creationid="xccui" creationdate="20190616T060228Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends AbstractRichFunction {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010452Z" creationid="xccui" creationdate="20190624T010452Z">
        <seg>extends AbstractRichFunction {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends AggregateFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005559Z" creationid="xccui" creationdate="20190624T005559Z">
        <seg>extends AggregateFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends AssignerWithPeriodicWatermarks[SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051037Z" creationid="xccui" creationdate="20190620T051037Z">
        <seg>extends AssignerWithPeriodicWatermarks[SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends AssignerWithPunctuatedWatermarks[SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054753Z" creationid="xccui" creationdate="20190620T054753Z">
        <seg>extends AssignerWithPunctuatedWatermarks[SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends CoProcessFunction[SensorReading, (String, Long), SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032027Z" creationid="xccui" creationdate="20190622T032027Z">
        <seg>extends CoProcessFunction[SensorReading, (String, Long), SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends FlatMapFunction[SensorReading, (String, Long, Long)] with CheckpointedFunction {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T154751Z" creationid="xccui" creationdate="20190702T154751Z">
        <seg>extends FlatMapFunction[SensorReading, (String, Long, Long)] with CheckpointedFunction {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends KeyedProcessFunction[String, SensorReading, (String, Double, Double)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T205618Z" creationid="xccui" creationdate="20190704T205618Z">
        <seg>extends KeyedProcessFunction[String, SensorReading, (String, Double, Double)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends KeyedProcessFunction[String, SensorReading, String] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071301Z" creationid="xccui" creationdate="20190621T071301Z">
        <seg>extends KeyedProcessFunction[String, SensorReading, String] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends ProcessFunction[SensorReading, SensorReading] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155850Z" creationid="xingcan" creationdate="20190628T155850Z">
        <seg>extends ProcessFunction[SensorReading, SensorReading] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends ProcessWindowFunction[SensorReading, MinMaxTemp, String, TimeWindow] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031913Z" creationid="xccui" creationdate="20190625T031913Z">
        <seg>extends ProcessWindowFunction[SensorReading, MinMaxTemp, String, TimeWindow] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends RichFlatMapFunction[SensorReading, (Int, Long)]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052319Z" creationid="xccui" creationdate="20190701T052319Z">
        <seg>extends RichFlatMapFunction[SensorReading, (Int, Long)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends RichFlatMapFunction[SensorReading, (String, Double, Double)] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064210Z" creationid="xccui" creationdate="20190630T064210Z">
        <seg>extends RichFlatMapFunction[SensorReading, (String, Double, Double)] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends Trigger[SensorReading, TimeWindow] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200227Z" creationid="xccui" creationdate="20190626T200227Z">
        <seg>extends Trigger[SensorReading, TimeWindow] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extends WindowAssigner[Object, TimeWindow] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042650Z" creationid="xccui" creationdate="20190626T042650Z">
        <seg>extends WindowAssigner[Object, TimeWindow] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extractedTS: Long): Watermark = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054810Z" creationid="xccui" creationdate="20190620T054810Z">
        <seg>extractedTS: Long): Watermark = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T051249Z" creationid="xccui" creationdate="20190701T051249Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fashion, i.e., the data input of a query is fully available and the query terminates after it returned the computed result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190228T194449Z" creationid="xccui" creationdate="20190228T194449Z">
        <seg>即，可以全量获取查询输入且查询会在返回结果后终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>fers might become unavailable and data might get lost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234823Z" creationid="xccui" creationdate="20190605T234823Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>field is the common key, the second field is the sum, and the third field is not defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T060228Z" creationid="xccui" creationdate="20190614T060228Z">
        <seg>结果中的第1个字段是键值，第2个字段是总和，第3个字段没有定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first type are periodic report queries that compute business-relevant statistics such as revenue, user growth, or production output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T025119Z" creationid="esouser" creationdate="20190603T203039Z">
        <seg>第一类是定期报告查询。它可用于计算业务相关的统计数据，如收入、用户增长、产出等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for (cnt &lt;- state.asScala) { highTempCnt += cnt</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052902Z" creationid="xccui" creationdate="20190701T052902Z">
        <seg>for (cnt &lt;- state.asScala) { highTempCnt += cnt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for ascending timestamps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051915Z" creationid="xccui" creationdate="20190620T051915Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for the Scala API, and it is used as shown in the following:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053814Z" creationid="xccui" creationdate="20190617T053801Z">
        <seg>它的用法如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>forwardingEnabled.clear() disableTimer.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032656Z" creationid="xccui" creationdate="20190622T032656Z">
        <seg>forwardingEnabled.clear() disableTimer.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>forwardingEnabled.update(true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032320Z" creationid="xccui" creationdate="20190622T032320Z">
        <seg>forwardingEnabled.update(true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>from a window by calling the remove() method on the Iterator that can be obtained from the Iterable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T203426Z" creationid="xccui" creationdate="20190627T203426Z">
        <seg>从Iterable中可以取得Iterator对象，调用后者的remove()方法就能删除元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function is restored, the parts of the state are distributed among all parallel instances of the function and handed to the restoreState() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061204Z" creationid="xccui" creationdate="20190701T061204Z">
        <seg>在函数进行状态恢复时，Flink会将状态的各个部分分配到函数的所有并行实例上，并将每个实例上的状态传递给restoreState()方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033454Z" creationid="xccui" creationdate="20190619T033454Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>function: ProcessWindowFunction[IN, OUT, K, W])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040344Z" creationid="xccui" creationdate="20190625T040344Z">
        <seg>function: ProcessWindowFunction[IN, OUT, K, W])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>functionality.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T035616Z" creationid="xccui" creationdate="20190625T035616Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211002Z" creationid="xccui" creationdate="20190623T211002Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gate, you lose the information about how your data varies over time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190406T043721Z" creationid="xccui" creationdate="20190406T043721Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ger the execution of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011950Z" creationid="xccui" creationdate="20190613T011950Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>get stronger semantics with weaker guarantees.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T050116Z" creationid="xccui" creationdate="20190416T050116Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>git clone https://github.com/streaming-with-flink/examples-scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040428Z" creationid="xccui" creationdate="20190611T040428Z">
        <seg>git clone https://github.com/streaming-with-flink/examples-scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gives access to the element or timer timestamp, a TimerService, and side outputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190622T031158Z">
        <seg>在被调用时都会传入一个Context对象，可用于访问当前元素或计时器时间戳，TimerService，以及副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>heap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T064256Z" creationid="xccui" creationdate="20190621T064256Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>highTempCnt += 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052533Z" creationid="xccui" creationdate="20190701T052533Z">
        <seg>highTempCnt += 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>holds the information used to distinguish windows from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T033853Z" creationid="xccui" creationdate="20190626T033853Z">
        <seg>因此窗口对象中保存着用于区分窗口的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>https://github.com/streaming-with-flink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210814Z" creationid="esouser" creationdate="20190603T210814Z">
        <seg>https://github.com/streaming-with-flink.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ices as the Context object of the processElement() method and also returns the time domain (processing time or event time) of the firing trigger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T055201Z">
        <seg>此外，它还会返回触发计时器的时间域（处理时间还是事件时间）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>identified by an OutputTag[X] object, where X is the type of the resulting side output</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T015021Z" creationid="xccui" creationdate="20190622T014937Z">
        <seg>每个副输出都由一个OutputTag[X]对象标识，其中X是副输出结果流的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!firstSeen.value()) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200415Z" creationid="xccui" creationdate="20190626T200415Z">
        <seg>if (!firstSeen.value()) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (!isUpdate.value()) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034338Z" creationid="xccui" creationdate="20190629T034338Z">
        <seg>if (!isUpdate.value()) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (in.temperature &gt; threshold) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052459Z" creationid="xccui" creationdate="20190701T052459Z">
        <seg>if (in.temperature &gt; threshold) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (key &lt; 0) 0 else r.nextInt(numPartitions)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050644Z" creationid="xccui" creationdate="20190616T050644Z">
        <seg>if (key &lt; 0) 0 else r.nextInt(numPartitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (prevTemp == 0.0 || r.temperature &lt; prevTemp) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071522Z" creationid="xccui" creationdate="20190621T071522Z">
        <seg>if (prevTemp == 0.0 || r.temperature &lt; prevTemp) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (r.id == "sensor_1") {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054813Z" creationid="xccui" creationdate="20190620T054813Z">
        <seg>if (r.id == "sensor_1") {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (r.temperature &lt; 32.0) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T024017Z" creationid="xccui" creationdate="20190622T024017Z">
        <seg>if (r.temperature &lt; 32.0) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (r.timestamp &lt; ctx.timerService().currentWatermark()) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155909Z" creationid="xingcan" creationdate="20190628T155909Z">
        <seg>if (r.timestamp &lt; ctx.timerService().currentWatermark()) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (t &lt; window.getEnd) { ctx.registerEventTimeTimer(t)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200827Z" creationid="xccui" creationdate="20190626T200827Z">
        <seg>if (t &lt; window.getEnd) { ctx.registerEventTimeTimer(t)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (tempDiff &gt; sensorThreshold) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042750Z" creationid="xccui" creationdate="20190702T042750Z">
        <seg>if (tempDiff &gt; sensorThreshold) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (tempDiff &gt; threshold) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064454Z" creationid="xccui" creationdate="20190630T064454Z">
        <seg>if (tempDiff &gt; threshold) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (thresholds.contains(reading.id)) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042743Z" creationid="xccui" creationdate="20190702T042743Z">
        <seg>if (thresholds.contains(reading.id)) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (timerTimestamp &gt; curTimerTimestamp) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032344Z" creationid="xccui" creationdate="20190622T032344Z">
        <seg>if (timerTimestamp &gt; curTimerTimestamp) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (timestamp == window.getEnd) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200703Z" creationid="xccui" creationdate="20190626T200703Z">
        <seg>if (timestamp == window.getEnd) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (update.threshold != 0.0d) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042556Z" creationid="xccui" creationdate="20190702T042556Z">
        <seg>if (update.threshold != 0.0d) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (v.temperature &gt; threshold) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162303Z" creationid="xccui" creationdate="20190702T162303Z">
        <seg>if (v.temperature &gt; threshold) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if you need to ensure a function’s operator state can be evolved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035314Z" creationid="xccui" creationdate="20190701T063328Z">
        <seg>如果想确保函数的算子状态日后支持更新，请使用CheckpointedFunction接口替代ListCheckpointed。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if(in % 2 == subTaskIndex) { out.collect((subTaskIndex, in))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034505Z" creationid="xccui" creationdate="20190619T034505Z">
        <seg>if(in % 2 == subTaskIndex) { out.collect((subTaskIndex, in))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ify an offset as a second parameter in the assigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T054244Z" creationid="xccui" creationdate="20190623T054157Z">
        <seg>或者你也可以通过第二个参数指定一个偏移量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035452Z" creationid="xccui" creationdate="20190418T035452Z">
        <seg>iii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>implement your own streaming sinks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054219Z" creationid="xccui" creationdate="20190612T054219Z">
        <seg>你也可以实现自己的流式数据汇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>implements Serializable {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041558Z" creationid="xccui" creationdate="20190626T041558Z">
        <seg>implements Serializable {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>implications on the robustness of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T222144Z" creationid="xccui" creationdate="20190703T222144Z">
        <seg>但它会影响应用的鲁棒性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>import org.apache.flink.streaming.api.scala._</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054850Z" creationid="xccui" creationdate="20190617T054850Z">
        <seg>import org.apache.flink.streaming.api.scala._</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in time, usually the point in time at which the event that is represented by the record happened.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T204807Z" creationid="xccui" creationdate="20190606T204807Z">
        <seg>时间戳将记录和特定时间点进行关联，这些时间点通常是记录所表示事件的发生时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>inclusive and end is exclusive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T041615Z" creationid="xccui" creationdate="20190623T041615Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>incrAggregator: AggregateFunction[IN, ACC, V], windowFunction: ProcessWindowFunction[V, OUT, K, W])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040523Z" creationid="xccui" creationdate="20190625T040523Z">
        <seg>incrAggregator: AggregateFunction[IN, ACC, V], windowFunction: ProcessWindowFunction[V, OUT, K, W])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>incrAggregator: ReduceFunction[IN],</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040341Z" creationid="xccui" creationdate="20190625T040341Z">
        <seg>incrAggregator: ReduceFunction[IN],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>increase the processing latency of an application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T195732Z" creationid="xccui" creationdate="20190609T195732Z">
        <seg>但它仍会增加应用处理延迟。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>increased the parallelism of this operator, some of the new subtasks would be initial‐ ized with an empty state, and start counting from zero.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T061840Z" creationid="xccui" creationdate="20190701T061840Z">
        <seg>如果我们增加算子的并行度，那么部分新的子任务就只能得到空的状态，从而需要从零开始计数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>incremental aggregation function is specified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T201556Z" creationid="xccui" creationdate="20190626T201556Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>information between multiple windows on the same key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024913Z" creationid="xccui" creationdate="20190624T024913Z">
        <seg>全局状态可用于在键值相同的多个窗口之间共享信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ing: transactional processing and analytical processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T194515Z" creationid="esouser" creationdate="20190603T194515Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ingested elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052722Z" creationid="xccui" creationdate="20190620T052722Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040331Z" creationid="xccui" creationdate="20190625T040331Z">
        <seg>input</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input and redirects them to a side-output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155514Z" creationid="xingcan" creationdate="20190628T155514Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025831Z" creationid="xccui" creationdate="20190628T025831Z">
        <seg>input1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>input1.join(input2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T035951Z" creationid="xccui" creationdate="20190628T035951Z">
        <seg>input1.join(input2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instance of an operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T044645Z" creationid="xccui" creationdate="20190615T044645Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instance, ValueState is completely deserialized when it is accessed and serialized when it is updated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T031904Z" creationid="xccui" creationdate="20190704T031904Z">
        <seg>例如，ValueState需要在更新和访问时分别进行完整的序列化和反序列化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instance, when you join or group by some key, TypeInformation allows Flink to per‐ form the semantic check of whether the fields used as keys are valid.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T151948Z" creationid="xccui" creationdate="20190617T050559Z">
        <seg>例如：如果需要通过某个键值进行Join或分组，TypeInformation允许Flink对能否使用某字段作为键值进行语义检测。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>interface EvictorContext {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202127Z" creationid="xccui" creationdate="20190627T202127Z">
        <seg>interface EvictorContext {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>interface that extends WindowAssigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045237Z" creationid="xccui" creationdate="20190626T045237Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>internal state, will it update it again after it recovers?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T033635Z" creationid="xccui" creationdate="20190606T033635Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>interval is set to two hundred milliseconds, but it can be configured using the Execu tionConfig.setAutoWatermarkInterval() method:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045716Z" creationid="xccui" creationdate="20190620T045716Z">
        <seg>默认的时间间隔为200毫秒，但可以利用ExecutionConfig.setAutoWatermarkInterval()方法来配置：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is actually accessed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T034039Z" creationid="xccui" creationdate="20190704T034039Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T024915Z" creationid="xccui" creationdate="20190626T024915Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is forwarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T050306Z" creationid="xccui" creationdate="20190620T050306Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is started or when a task is restarted due to a failure.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T064344Z" creationid="xccui" creationdate="20190702T064344Z">
        <seg>它的触发时机是应用启动或由于故障而重启任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>its preceding operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190610T023212Z" creationid="xccui" creationdate="20190610T023212Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iv</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T035723Z" creationid="xccui" creationdate="20190418T035723Z">
        <seg>iv</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>iv | Table of Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130312Z" creationid="xccui" creationdate="20190605T130312Z">
        <seg>iv | 目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ix</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040613Z" creationid="xccui" creationdate="20190418T040613Z">
        <seg>ix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ix 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T145402Z" creationid="esouser" creationdate="20190603T145402Z">
        <seg>ix 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>java.util.Collections.singletonList(highTempCnt)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T053238Z" creationid="xccui" creationdate="20190701T053238Z">
        <seg>java.util.Collections.singletonList(highTempCnt)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>join is defined as shown in Example 6-18.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025803Z" creationid="xccui" creationdate="20190628T025803Z">
        <seg>示例6-18中定义了一个基于间隔的Join。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>key of the current record.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190607T191732Z" creationid="xccui" creationdate="20190607T191732Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keyBy</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050132Z" creationid="xccui" creationdate="20190614T050132Z">
        <seg>keyBy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keyBy() method:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051732Z" creationid="xccui" creationdate="20190618T051732Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T141438Z" creationid="xccui" creationdate="20190704T141438Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lastTemp.update(r.temperature)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071516Z" creationid="xccui" creationdate="20190621T071516Z">
        <seg>lastTemp.update(r.temperature)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lastTempState = getRuntimeContext.getState[Double](lastTempDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064327Z" creationid="xccui" creationdate="20190630T064327Z">
        <seg>lastTempState = getRuntimeContext.getState[Double](lastTempDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lastTimerState.update(newTimer)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210645Z" creationid="xccui" creationdate="20190704T210645Z">
        <seg>lastTimerState.update(newTimer)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lazy val currentTimer: ValueState[Long] = getRuntimeContext.getState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071405Z" creationid="xccui" creationdate="20190621T071405Z">
        <seg>lazy val currentTimer: ValueState[Long] = getRuntimeContext.getState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lazy val disableTimer: ValueState[Long] = getRuntimeContext.getState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032228Z" creationid="xccui" creationdate="20190622T032228Z">
        <seg>lazy val disableTimer: ValueState[Long] = getRuntimeContext.getState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lazy val forwardingEnabled: ValueState[Boolean] = getRuntimeContext.getState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032058Z" creationid="xccui" creationdate="20190622T032058Z">
        <seg>lazy val forwardingEnabled: ValueState[Boolean] = getRuntimeContext.getState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lazy val freezingAlarmOutput: OutputTag[String] = new OutputTag[String]("freezing-alarms")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T023931Z" creationid="xccui" creationdate="20190622T023931Z">
        <seg>lazy val freezingAlarmOutput: OutputTag[String] = new OutputTag[String]("freezing-alarms")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lazy val lastTemp: ValueState[Double] = getRuntimeContext.getState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071341Z" creationid="xccui" creationdate="20190621T071341Z">
        <seg>lazy val lastTemp: ValueState[Double] = getRuntimeContext.getState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>leaking state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T040854Z" creationid="xccui" creationdate="20190626T040854Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long getCurrentProcessingTime();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192555Z" creationid="xccui" creationdate="20190626T192555Z">
        <seg>long getCurrentProcessingTime();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long getCurrentWatermark();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192617Z" creationid="xccui" creationdate="20190626T192617Z">
        <seg>long getCurrentWatermark();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190130Z" creationid="xccui" creationdate="20190626T190130Z">
        <seg>long timestamp, W window, TriggerContext ctx);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>long timestamp, WindowAssignerContext context);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041651Z" creationid="xccui" creationdate="20190626T041651Z">
        <seg>long timestamp, WindowAssignerContext context);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>low latency but results depend on the speed of processing and are not deterministic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T181105Z" creationid="xccui" creationdate="20190606T031232Z">
        <seg>总而言之，虽然处理时间提供了很低的延迟，但它的结果依赖处理速度，具有不确定性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lowing:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T062207Z" creationid="xccui" creationdate="20190617T062207Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>main method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T043220Z" creationid="xccui" creationdate="20190612T043220Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>main() method assembles the dataflow and submits it to a remote JobManager when the StreamExecutionEnvironment.execute() method is called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T051801Z" creationid="xccui" creationdate="20190611T051412Z">
        <seg>通常情况下程序的main()方法会把dataflow组装好，然后在StreamExecutionEnvironment.execute()方法被调用时将其提交到远程的JobManager上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>maintain information that should be shared between multiple invocations of the pro cess() method on the same window, which can happen due to configuring allowed lateness or using a custom trigger.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024428Z" creationid="xccui" creationdate="20190624T023815Z">
        <seg>单个窗口状态用于维护同一窗口内多次调用process()方法所需共享的信息，这种多次调用可能是由于配置了允许数据迟到或使用了自定义触发器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>many sensor readings exceed a specified threshold.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T154652Z" creationid="xccui" creationdate="20190702T154652Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>map1() and flatMap1() are called to process an event of the first input and map2() and flat Map2() are invoked to process an event of the second input:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T042740Z" creationid="xccui" creationdate="20190615T041435Z">
        <seg>map1()和flatMap()用来处理第一个输入流的事件；map2()和flatMap2()用来处理第二个输入流的事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>marks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T033233Z" creationid="xccui" creationdate="20190620T033233Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>matically puts all keyed state objects of the function into the context of the key of the record that is passed by the function call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T063820Z" creationid="xccui" creationdate="20190630T063103Z">
        <seg>自动将函数中的全部键值分区状态对象放入当前处理记录的键值上下文中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>max()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053408Z" creationid="xccui" creationdate="20190614T053408Z">
        <seg>max()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>maxBy()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053818Z" creationid="xccui" creationdate="20190614T053818Z">
        <seg>maxBy()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>maxTs = maxTs.max(r.timestamp)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051144Z" creationid="xccui" creationdate="20190620T051144Z">
        <seg>maxTs = maxTs.max(r.timestamp)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mentations for the different state primitives, such as ValueState, ListState, and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T221556Z" creationid="xccui" creationdate="20190703T221556Z">
        <seg>每一种状态后端都为不同的状态原语（如ValueState、ListState和MapState）提供了不同的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ments such as variable or function names, databases, data types, environment variables, statements, and keywords.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210805Z" creationid="esouser" creationdate="20190603T210805Z">
        <seg>ments such as variable or function names, databases, data types, environment variables, statements, and keywords.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mergePartitionedState() method of the OnMergeContext object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195325Z" creationid="xccui" creationdate="20190626T195325Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>merges black and gray events into a single output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T065114Z" creationid="xccui" creationdate="20190614T065114Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method assembles the operator state from possibly multiple parts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T060711Z" creationid="xccui" creationdate="20190701T060517Z">
        <seg>而restoreState()方法也可以利用（一个或）多个部分对算子状态进行组装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method has no effect.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060718Z" creationid="xccui" creationdate="20190621T060718Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method is to ensure all state objects are updated before the checkpoint is done.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T071731Z" creationid="xccui" creationdate="20190702T071538Z">
        <seg>snapshotState()方法的目的是确保检查点开始之前所有状态对象都已更新完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method provides read-only access to the broadcast state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T051407Z" creationid="xccui" creationdate="20190702T051407Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method will replace existing values with the given list of values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T055530Z" creationid="xccui" creationdate="20190630T055530Z">
        <seg>该方法将使用给定列表的值替换已有值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>microservices are strictly decoupled from each other and only communicate over well-defined interfaces, each microservice can be implemented with a different tech‐ nology stack including a programming language, libraries, and datastores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T023410Z" creationid="esouser" creationdate="20190603T200753Z">
        <seg>由于微服务彼此间严格解耦且仅通过定义良好的接口通信，所以在实现微服务时可以选用不同的技术栈，包括编程语言、类库和数据存储等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>min()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052719Z" creationid="xccui" creationdate="20190614T052719Z">
        <seg>min()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>minBy()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053534Z" creationid="xccui" creationdate="20190614T053534Z">
        <seg>minBy()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>minMaxIt: Iterable[(String, Double, Double)], out: Collector[MinMaxTemp]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045141Z" creationid="xccui" creationdate="20190625T045141Z">
        <seg>minMaxIt: Iterable[(String, Double, Double)], out: Collector[MinMaxTemp]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>monitoredReadings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022911Z" creationid="xccui" creationdate="20190622T022911Z">
        <seg>monitoredReadings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>monly used for cleanup and releasing resources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033155Z" creationid="xccui" creationdate="20190619T033155Z">
        <seg>因而它通常用于清理和释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>monotonically increasing, you can use the shortcut method assignAscending TimeStamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051808Z" creationid="xccui" creationdate="20190620T051620Z">
        <seg>则可以使用一个简便方法assignAscendingTimeStamps。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>more processing slots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190428T205902Z" creationid="xccui" creationdate="20190428T205902Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mvn archetype:generate</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T064642Z" creationid="xccui" creationdate="20190613T064642Z">
        <seg>mvn archetype:generate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mvn clean package -Pbuild-jar</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T064647Z" creationid="xccui" creationdate="20190613T064647Z">
        <seg>mvn clean package -Pbuild-jar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>need to update your application because Java serialization does not allow for migrating or configuring a custom serializer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190705T035415Z" creationid="xccui" creationdate="20190701T063504Z">
        <seg>由于该序列化机制不支持目标迁移或配置自定义序列化器，所以可能会在你需要更新应用时导致问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>neither the ReduceFunction nor the AggregateFunction are suitable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010013Z" creationid="xccui" creationdate="20190624T010013Z">
        <seg>对于此类应用，ReduceFunction和AggregateFunction都不合适。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new AssignWindowEndProcessFunction()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043637Z" creationid="xccui" creationdate="20190625T043637Z">
        <seg>new AssignWindowEndProcessFunction()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new BoundedOutOfOrdernessTimestampExtractor[SensorReading]( Time.seconds(10))(e =&gt;.timestamp)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052900Z" creationid="xccui" creationdate="20190620T052900Z">
        <seg>new BoundedOutOfOrdernessTimestampExtractor[SensorReading]( Time.seconds(10))(e =&gt;.timestamp)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new MapStateDescriptor[String, Double]( "thresholds", classOf[String], classOf[Double])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024332Z" creationid="xccui" creationdate="20190702T024332Z">
        <seg>new MapStateDescriptor[String, Double]( "thresholds", classOf[String], classOf[Double])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new Person("Alex", 42),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044923Z" creationid="xccui" creationdate="20190617T044923Z">
        <seg>new Person("Alex", 42),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new Person("Wendy", 23));</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044926Z" creationid="xccui" creationdate="20190617T044926Z">
        <seg>new Person("Wendy", 23));</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new RichFilterFunction[String] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054235Z" creationid="xccui" creationdate="20190618T054235Z">
        <seg>new RichFilterFunction[String] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new TimeWindow.Serializer</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044232Z" creationid="xccui" creationdate="20190626T044232Z">
        <seg>new TimeWindow.Serializer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Boolean]("filterSwitch", Types.of[Boolean]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032102Z" creationid="xccui" creationdate="20190622T032102Z">
        <seg>new ValueStateDescriptor[Boolean]("filterSwitch", Types.of[Boolean]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Boolean]("firstSeen", classOf[Boolean]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200338Z" creationid="xccui" creationdate="20190626T200338Z">
        <seg>new ValueStateDescriptor[Boolean]("firstSeen", classOf[Boolean]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Boolean]("firstSeen", classOf[Boolean])) firstSeen.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200944Z" creationid="xccui" creationdate="20190626T200944Z">
        <seg>new ValueStateDescriptor[Boolean]("firstSeen", classOf[Boolean])) firstSeen.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Boolean]("isUpdate", Types.of[Boolean]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034335Z" creationid="xccui" creationdate="20190629T034335Z">
        <seg>new ValueStateDescriptor[Boolean]("isUpdate", Types.of[Boolean]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Double]("lastTemp", Types.of[Double]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071345Z" creationid="xccui" creationdate="20190621T071345Z">
        <seg>new ValueStateDescriptor[Double]("lastTemp", Types.of[Double]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Double]("lastTemp", classOf[Double])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064315Z" creationid="xccui" creationdate="20190630T064315Z">
        <seg>new ValueStateDescriptor[Double]("lastTemp", classOf[Double])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new ValueStateDescriptor[Long]("timer", Types.of[Long]))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071409Z" creationid="xccui" creationdate="20190621T071409Z">
        <seg>new ValueStateDescriptor[Long]("timer", Types.of[Long]))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new Watermark(extractedTS - bound)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054840Z" creationid="xccui" creationdate="20190620T054840Z">
        <seg>new Watermark(extractedTS - bound)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>new Watermark(maxTs - bound)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051129Z" creationid="xccui" creationdate="20190620T051129Z">
        <seg>new Watermark(maxTs - bound)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nonnull watermark that is larger than the latest emitted watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054519Z" creationid="xccui" creationdate="20190620T054519Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not change the type of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061521Z" creationid="xccui" creationdate="20190614T061521Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>not have access to timestamps or the current event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T043253Z" creationid="xccui" creationdate="20190621T043253Z">
        <seg>MapFunction无法访问时间戳或当前的事件时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>null</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054858Z" creationid="xccui" creationdate="20190620T054858Z">
        <seg>null</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>object AverageSensorReadings {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041830Z" creationid="xccui" creationdate="20190612T041830Z">
        <seg>object AverageSensorReadings {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>object myPartitioner extends Partitioner[Int] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050633Z" creationid="xccui" creationdate="20190616T050633Z">
        <seg>object myPartitioner extends Partitioner[Int] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of Streaming Applications</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T142522Z" creationid="esouser" creationdate="20190603T142522Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of elements in the window (size), the window object, and an EvictorContext that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202748Z" creationid="xccui" creationdate="20190627T202748Z">
        <seg>窗口内的元素数量、窗口对象以及一个用于访问当前处理时间和水位线的EvictorContext。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of its key definition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T040710Z" creationid="xccui" creationdate="20190630T040710Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of state is custom for every stateful function, this cannot be automatically done for arbitrary types of state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T060122Z" creationid="xccui" creationdate="20190701T060035Z">
        <seg>由于每个函数都有自己的状态拆分及合并逻辑，所以这两个过程无法针对任意状态类型都自动完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of the parallel partitions of a DataStream is skewed, we might want to rebalance the data to evenly distribute the computation load of subsequent operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T065820Z" creationid="xccui" creationdate="20190615T065415Z">
        <seg>举例而言，如果我们知道DataStream的并行分区存在倾斜现象，那么可能就希望通过重新平衡数据来均匀分配后续算子的负载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT]) is a callback function that is invoked when a previously registered timer triggers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T054245Z">
        <seg>onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT])是一个回调函数，会在之前注册的计时器触发时被调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>one data source and one data sink.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T000316Z" creationid="xccui" creationdate="20190401T000316Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opHighTempCnt += 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162503Z" creationid="xccui" creationdate="20190702T162503Z">
        <seg>opHighTempCnt += 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opHighTempCnt = opCntState.get().asScala.sum</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163340Z" creationid="xccui" creationdate="20190702T163340Z">
        <seg>opHighTempCnt = opCntState.get().asScala.sum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open() is called before any processing methods, such as flatMap() in the case of a FlatMapFunction, are called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T020455Z" creationid="xccui" creationdate="20190701T020327Z">
        <seg>该方法会在任意处理方法（例如FlatMapFunction中的flatMap()）之前调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>open() is typically used for setup work that needs to be done only once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T061103Z" creationid="xccui" creationdate="20190618T061103Z">
        <seg>open()通常用于那些只需进行一次的设置工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or broadcast connection, each sending task needs a buffer for each receiving task, i.e, the number of required buffers is quadratic to the parallelism of the involved opera&lt;t0/&gt;‐&lt;t1/&gt; tors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190504T045238Z" creationid="xccui" creationdate="20190504T045238Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or purging a window without emitting a result if a certain condition is fulfilled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185710Z" creationid="xccui" creationdate="20190626T185710Z">
        <seg>还能够在某个条件满足时只清除窗口而不发出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect("Temperature of sensor '" + ctx.getCurrentKey + "' monotonically increased for 1 second.") currentTimer.clear()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071743Z" creationid="xccui" creationdate="20190621T071743Z">
        <seg>out.collect("Temperature of sensor '" + ctx.getCurrentKey + "' monotonically increased for 1 second.") currentTimer.clear()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect((id, ctx.window.getEnd, cnt, "update"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034448Z" creationid="xccui" creationdate="20190629T034448Z">
        <seg>out.collect((id, ctx.window.getEnd, cnt, "update"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect((reading.id, reading.temperature, tempDiff))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064511Z" creationid="xccui" creationdate="20190630T064511Z">
        <seg>out.collect((reading.id, reading.temperature, tempDiff))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect((subtaskIdx, highTempCnt))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052700Z" creationid="xccui" creationdate="20190701T052700Z">
        <seg>out.collect((subtaskIdx, highTempCnt))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect((v.id, keyHighTempCnt, opHighTempCnt))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162607Z" creationid="xccui" creationdate="20190702T162607Z">
        <seg>out.collect((v.id, keyHighTempCnt, opHighTempCnt))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect(MinMaxTemp(key, minMax._2, minMax._3, windowEnd))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045147Z" creationid="xccui" creationdate="20190625T045147Z">
        <seg>out.collect(MinMaxTemp(key, minMax._2, minMax._3, windowEnd))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect(MinMaxTemp(key, temps.min, temps.max, windowEnd))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031941Z" creationid="xccui" creationdate="20190625T031941Z">
        <seg>out.collect(MinMaxTemp(key, temps.min, temps.max, windowEnd))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out.collect(r)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T024049Z" creationid="xccui" creationdate="20190622T024049Z">
        <seg>out.collect(r)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out: Collector[(Int, Long)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052446Z" creationid="xccui" creationdate="20190701T052446Z">
        <seg>out: Collector[(Int, Long)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064334Z" creationid="xccui" creationdate="20190630T064334Z">
        <seg>out: Collector[(String, Double, Double)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out: Collector[(String, Long, Int, String)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034010Z" creationid="xccui" creationdate="20190629T034010Z">
        <seg>out: Collector[(String, Long, Int, String)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out: Collector[(String, Long, Long)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162245Z" creationid="xccui" creationdate="20190702T162245Z">
        <seg>out: Collector[(String, Long, Long)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>out: Collector[MinMaxTemp]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031927Z" creationid="xccui" creationdate="20190625T031927Z">
        <seg>out: Collector[MinMaxTemp]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def add(in: (String, Double), acc: (String, Double, Int)) = { (in._1, in._2 + acc._2, 1 + acc._3)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005610Z" creationid="xccui" creationdate="20190624T005610Z">
        <seg>override def add(in: (String, Double), acc: (String, Double, Int)) = { (in._1, in._2 + acc._2, 1 + acc._3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def assignWindows( o: Object,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042656Z" creationid="xccui" creationdate="20190626T042656Z">
        <seg>override def assignWindows( o: Object,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def checkAndGetNextWatermark( r: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054807Z" creationid="xccui" creationdate="20190620T054807Z">
        <seg>override def checkAndGetNextWatermark( r: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def clear( window: TimeWindow,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200926Z" creationid="xccui" creationdate="20190626T200926Z">
        <seg>override def clear( window: TimeWindow,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def close(): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034524Z" creationid="xccui" creationdate="20190619T034524Z">
        <seg>override def close(): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def createAccumulator() = { ("", 0.0, 0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005607Z" creationid="xccui" creationdate="20190624T005607Z">
        <seg>override def createAccumulator() = { ("", 0.0, 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def extractTimestamp( r: SensorReading, previousTS: Long): Long = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051133Z" creationid="xccui" creationdate="20190620T051133Z">
        <seg>override def extractTimestamp( r: SensorReading, previousTS: Long): Long = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def filter(value: String): Boolean = { value.contains("flink")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054238Z" creationid="xccui" creationdate="20190618T054238Z">
        <seg>override def filter(value: String): Boolean = { value.contains("flink")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def flatMap( in: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052443Z" creationid="xccui" creationdate="20190701T052443Z">
        <seg>override def flatMap( in: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def flatMap( reading: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064331Z" creationid="xccui" creationdate="20190630T064331Z">
        <seg>override def flatMap( reading: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def flatMap( v: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162241Z" creationid="xccui" creationdate="20190702T162241Z">
        <seg>override def flatMap( v: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def flatMap(in: Int, out: Collector[(Int, Int)]): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034402Z" creationid="xccui" creationdate="20190619T034402Z">
        <seg>override def flatMap(in: Int, out: Collector[(Int, Int)]): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def getCurrentWatermark: Watermark = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051107Z" creationid="xccui" creationdate="20190620T051107Z">
        <seg>override def getCurrentWatermark: Watermark = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def getDefaultTrigger(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044150Z" creationid="xccui" creationdate="20190626T044150Z">
        <seg>override def getDefaultTrigger(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def getProducedType: TypeInformation[Person] = Types.CASE_CLASS[Person]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061940Z" creationid="xccui" creationdate="20190617T061940Z">
        <seg>override def getProducedType: TypeInformation[Person] = Types.CASE_CLASS[Person]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def getResult(acc: (String, Double, Int)) = { (acc._1, acc._2 / acc._3)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005613Z" creationid="xccui" creationdate="20190624T005613Z">
        <seg>override def getResult(acc: (String, Double, Int)) = { (acc._1, acc._2 / acc._3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def getWindowSerializer(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044223Z" creationid="xccui" creationdate="20190626T044223Z">
        <seg>override def getWindowSerializer(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def initializeState(initContext: FunctionInitializationContext): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162946Z" creationid="xccui" creationdate="20190702T162946Z">
        <seg>override def initializeState(initContext: FunctionInitializationContext): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def isEventTime = true</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044236Z" creationid="xccui" creationdate="20190626T044236Z">
        <seg>override def isEventTime = true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def map(r: SensorReading): String = r.id</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050726Z" creationid="xccui" creationdate="20190613T050726Z">
        <seg>override def map(r: SensorReading): String = r.id</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def map(v: (String, Int)): Person = Person(v._1, v._2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T061916Z" creationid="xccui" creationdate="20190617T061916Z">
        <seg>override def map(v: (String, Int)): Person = Person(v._1, v._2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def map(value: Int): Int = value + 1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020909Z" creationid="xccui" creationdate="20190613T020909Z">
        <seg>override def map(value: Int): Int = value + 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def merge(acc1: (String, Double, Int), acc2: (String, Double, Int)) = { (acc1._1, acc1._2 + acc2._2, acc1._3 + acc2._3)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005617Z" creationid="xccui" creationdate="20190624T005617Z">
        <seg>override def merge(acc1: (String, Double, Int), acc2: (String, Double, Int)) = { (acc1._1, acc1._2 + acc2._2, acc1._3 + acc2._3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def onElement( r: SensorReading, timestamp: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200230Z" creationid="xccui" creationdate="20190626T200230Z">
        <seg>override def onElement( r: SensorReading, timestamp: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def onEventTime( timestamp: Long, window: TimeWindow,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200658Z" creationid="xccui" creationdate="20190626T200658Z">
        <seg>override def onEventTime( timestamp: Long, window: TimeWindow,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def onProcessingTime( timestamp: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200907Z" creationid="xccui" creationdate="20190626T200907Z">
        <seg>override def onProcessingTime( timestamp: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def onTimer( timestamp: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210651Z" creationid="xccui" creationdate="20190704T210651Z">
        <seg>override def onTimer( timestamp: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def onTimer( ts: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071736Z" creationid="xccui" creationdate="20190621T071736Z">
        <seg>override def onTimer( ts: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def open(configuration: Configuration): Unit = { subTaskIndex = getRuntimeContext.getIndexOfThisSubtask</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034254Z" creationid="xccui" creationdate="20190619T034254Z">
        <seg>override def open(configuration: Configuration): Unit = { subTaskIndex = getRuntimeContext.getIndexOfThisSubtask</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def open(parameters: Configuration): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064229Z" creationid="xccui" creationdate="20190630T064229Z">
        <seg>override def open(parameters: Configuration): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def partition(key: Int, numPartitions: Int): Int = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050641Z" creationid="xccui" creationdate="20190616T050641Z">
        <seg>override def partition(key: Int, numPartitions: Int): Int = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def process( id: String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034002Z" creationid="xccui" creationdate="20190629T034002Z">
        <seg>override def process( id: String,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def process( key: String,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031916Z" creationid="xccui" creationdate="20190625T031916Z">
        <seg>override def process( key: String,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processBroadcastElement( update: ThresholdUpdate,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042524Z" creationid="xccui" creationdate="20190702T042524Z">
        <seg>override def processBroadcastElement( update: ThresholdUpdate,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processElement( r: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071412Z" creationid="xccui" creationdate="20190621T071412Z">
        <seg>override def processElement( r: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processElement( reading: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042650Z" creationid="xccui" creationdate="20190702T042650Z">
        <seg>override def processElement( reading: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processElement( reading: SensorReading, ctx: KeyedProcessFunction</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210444Z" creationid="xccui" creationdate="20190704T210444Z">
        <seg>override def processElement( reading: SensorReading, ctx: KeyedProcessFunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processElement1( reading: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032232Z" creationid="xccui" creationdate="20190622T032232Z">
        <seg>override def processElement1( reading: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def processElement2( switch: (String, Long),</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032304Z" creationid="xccui" creationdate="20190622T032304Z">
        <seg>override def processElement2( switch: (String, Long),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def restoreState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052705Z" creationid="xccui" creationdate="20190701T052705Z">
        <seg>override def restoreState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def snapshotState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163344Z" creationid="xccui" creationdate="20190702T163344Z">
        <seg>override def snapshotState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>override def snapshotState( chkpntId: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052938Z" creationid="xccui" creationdate="20190701T052938Z">
        <seg>override def snapshotState( chkpntId: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>own types and tell Flink how to handle them efficiently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053222Z" creationid="xccui" creationdate="20190617T053009Z">
        <seg>或者你可能需要定义自己的类型并告知Flink该如何高效地处理它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>own window with the element’s timestamp as the start time and the session gap as the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T062104Z" creationid="xccui" creationdate="20190623T062037Z">
        <seg>该窗口的起始时间是元素的时间戳，大小为会话间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>page 154.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T033816Z" creationid="xccui" creationdate="20190619T033816Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>parallel instance of the function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052214Z" creationid="xccui" creationdate="20190701T052214Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>pared to maintaining state on the heap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025408Z" creationid="xccui" creationdate="20190704T025408Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>perature of a sensor monotonically increases for a period of 1 second in processing time:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T070859Z" creationid="xccui" creationdate="20190621T070845Z">
        <seg>如果某个传感器的温度在1秒的处理时间内持续上升则发出警告：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>personTuple.f1 = 42;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T064531Z" creationid="xccui" creationdate="20190617T064531Z">
        <seg>personTuple.f1 = 42;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>personTuple.setField(43, 1); // set the 2nd field to 43</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T040535Z" creationid="xccui" creationdate="20190617T040535Z">
        <seg>personTuple.setField(43, 1); // 将第二个字段设为43</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>persons.filter(p -&gt; p.f1 &gt; 18);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T035205Z" creationid="xccui" creationdate="20190617T035205Z">
        <seg>persons.filter(p -&gt; p.f1 &gt; 18);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>persons.filter(p =&gt; p._2 &gt; 18)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T071131Z" creationid="xccui" creationdate="20190616T071131Z">
        <seg>persons.filter(p =&gt; p._2 &gt; 18)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>persons.filter(p =&gt; p.age &gt; 18)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041213Z" creationid="xccui" creationdate="20190617T041213Z">
        <seg>persons.filter(p =&gt; p.age &gt; 18)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>persons.keyBy("birthday._") // key by all fields of nested tuple</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050802Z" creationid="xccui" creationdate="20190618T050802Z">
        <seg>persons.keyBy("birthday._") // 以元组中的全部字段为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>persons.keyBy("birthday._1") // key by field of nested tuple</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050632Z" creationid="xccui" creationdate="20190618T050632Z">
        <seg>persons.keyBy("birthday._1") // 以嵌套元组的字段为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T194324Z" creationid="xccui" creationdate="20190626T194324Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>points can implement the CheckpointListener interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T202327Z" creationid="xccui" creationdate="20190702T202327Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>point—when all tasks have successfully written their state into the remote storage— the JobManager writes the state handles to the remote storage and a pointer to this location to ZooKeeper.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T073305Z" creationid="xccui" creationdate="20190606T150217Z">
        <seg>在检查点即将完成的时候，如果所有任务已经将各自状态成功写入远程存储，JobManager就会将状态句柄写入远程存储，并将远程位置的路径地址写入ZooKeeper。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>precede a barrier are included in the barrier’s checkpoint and all modifications due to records that follow the barrier are included in a later checkpoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190609T061733Z" creationid="xccui" creationdate="20190609T061206Z">
        <seg>所有先于分隔符的记录所导致的状态更改都会被包含在分隔符所对应的检查点之中；而所有晚于分隔符的记录所导致的状态更改都会被纳入随后的检查点中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>present DataStream methods that enable users to control partitioning strategies or</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070257Z" creationid="xccui" creationdate="20190615T070257Z">
        <seg>本节我们会介绍DataStream中用于控制分区策略或自定义分区策略的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private lazy val subtaskIdx = getRuntimeContext</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052352Z" creationid="xccui" creationdate="20190701T052352Z">
        <seg>private lazy val subtaskIdx = getRuntimeContext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private var highTempCnt = 0L</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052439Z" creationid="xccui" creationdate="20190701T052439Z">
        <seg>private var highTempCnt = 0L</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private var lastTempState: ValueState[Double] = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064226Z" creationid="xccui" creationdate="20190630T064226Z">
        <seg>private var lastTempState: ValueState[Double] = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>private var lastTimerState: ValueState[Long] = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210225Z" creationid="xccui" creationdate="20190704T210225Z">
        <seg>private var lastTimerState: ValueState[Long] = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>process historical events in the same way, thus enabling offline analytics or even time travel analyses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190409T203458Z" creationid="xccui" creationdate="20190409T203458Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>processElement(v: IN, ctx: Context, out: Collector[OUT]) is called for each record of the stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T053527Z" creationid="xccui" creationdate="20190621T053527Z">
        <seg>processElement(v: IN, ctx: Context, out: Collector[OUT])会针对流中的每条记录都调用一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>processing-time or event-time semantics depends on the value returned by the Win dowAssigner.isEventTime() method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T035849Z" creationid="xccui" creationdate="20190626T035751Z">
        <seg>该时间是处理时间还是事件时间语义取决于WindowAssigner.isEventTime()方法的返回值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>provides access to the current processing time and watermark.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T202838Z" creationid="xccui" creationdate="20190627T202838Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public Person() {}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044844Z" creationid="xccui" creationdate="20190617T044844Z">
        <seg>public Person() {}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public Person(String name, int age) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044851Z" creationid="xccui" creationdate="20190617T044851Z">
        <seg>public Person(String name, int age) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract &lt;X&gt; void output(OutputTag&lt;X&gt; outputTag, X value);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010951Z" creationid="xccui" creationdate="20190624T010951Z">
        <seg>public abstract &lt;X&gt; void output(OutputTag&lt;X&gt; outputTag, X value);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract Collection&lt;W&gt; assignWindows( T element,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041647Z" creationid="xccui" creationdate="20190626T041647Z">
        <seg>public abstract Collection&lt;W&gt; assignWindows( T element,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract KeyedStateStore globalState();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010916Z" creationid="xccui" creationdate="20190624T010916Z">
        <seg>public abstract KeyedStateStore globalState();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract KeyedStateStore windowState();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010840Z" creationid="xccui" creationdate="20190624T010840Z">
        <seg>public abstract KeyedStateStore windowState();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract TriggerResult onEventTime(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190127Z" creationid="xccui" creationdate="20190626T190127Z">
        <seg>public abstract TriggerResult onEventTime(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract W window();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010724Z" creationid="xccui" creationdate="20190624T010724Z">
        <seg>public abstract W window();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract boolean isEventTime();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041919Z" creationid="xccui" creationdate="20190626T041919Z">
        <seg>public abstract boolean isEventTime();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract class Context implements Serializable {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010714Z" creationid="xccui" creationdate="20190624T010714Z">
        <seg>public abstract class Context implements Serializable {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract class ProcessWindowFunction&lt;IN, OUT, KEY, W extends Window&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010449Z" creationid="xccui" creationdate="20190624T010449Z">
        <seg>public abstract class ProcessWindowFunction&lt;IN, OUT, KEY, W extends Window&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract class Trigger&lt;T, W extends Window&gt; implements Serializable {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T185925Z" creationid="xccui" creationdate="20190626T185925Z">
        <seg>public abstract class Trigger&lt;T, W extends Window&gt; implements Serializable {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract class WindowAssigner&lt;T, W extends Window&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041554Z" creationid="xccui" creationdate="20190626T041554Z">
        <seg>public abstract class WindowAssigner&lt;T, W extends Window&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract long currentProcessingTime();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010735Z" creationid="xccui" creationdate="20190624T010735Z">
        <seg>public abstract long currentProcessingTime();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract long currentWatermark();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010752Z" creationid="xccui" creationdate="20190624T010752Z">
        <seg>public abstract long currentWatermark();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract long getCurrentProcessingTime();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041947Z" creationid="xccui" creationdate="20190626T041947Z">
        <seg>public abstract long getCurrentProcessingTime();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract static class WindowAssignerContext {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T041943Z" creationid="xccui" creationdate="20190626T041943Z">
        <seg>public abstract static class WindowAssignerContext {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public abstract void clear(W window, TriggerContext ctx);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192334Z" creationid="xccui" creationdate="20190626T192334Z">
        <seg>public abstract void clear(W window, TriggerContext ctx);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public boolean canMerge();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190153Z" creationid="xccui" creationdate="20190626T190153Z">
        <seg>public boolean canMerge();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public class Person {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044803Z" creationid="xccui" creationdate="20190617T044803Z">
        <seg>public class Person {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public interface AggregateFunction&lt;IN, ACC, OUT&gt; extends Function, Serializable {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T003529Z" creationid="xccui" creationdate="20190624T003529Z">
        <seg>public interface AggregateFunction&lt;IN, ACC, OUT&gt; extends Function, Serializable {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public interface Evictor&lt;T, W extends Window&gt; extends Serializable {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201547Z" creationid="xccui" creationdate="20190627T201547Z">
        <seg>public interface Evictor&lt;T, W extends Window&gt; extends Serializable {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public interface OnMergeContext extends TriggerContext {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193026Z" creationid="xccui" creationdate="20190626T193026Z">
        <seg>public interface OnMergeContext extends TriggerContext {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public interface TriggerContext {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192552Z" creationid="xccui" creationdate="20190626T192552Z">
        <seg>public interface TriggerContext {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public void clear(Context ctx) throws Exception {}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010622Z" creationid="xccui" creationdate="20190624T010622Z">
        <seg>public void clear(Context ctx) throws Exception {}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>public void onMerge(W window, OnMergeContext ctx);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T190951Z" creationid="xccui" creationdate="20190626T190951Z">
        <seg>public void onMerge(W window, OnMergeContext ctx);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>r.timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051158Z" creationid="xccui" creationdate="20190620T051158Z">
        <seg>r.timestamp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>r: SensorReading,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155839Z" creationid="xingcan" creationdate="20190628T155839Z">
        <seg>r: SensorReading,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>readOnlyCtx: KeyedBroadcastProcessFunction [String, SensorReading, ThresholdUpdate, (String, Double, Double)]#ReadOnlyContext,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042654Z" creationid="xccui" creationdate="20190702T042654Z">
        <seg>readOnlyCtx: KeyedBroadcastProcessFunction [String, SensorReading, ThresholdUpdate, (String, Double, Double)]#ReadOnlyContext,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reading per window and emits them together with the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031901Z" creationid="xccui" creationdate="20190625T030902Z">
        <seg>它会将读数连同窗口结束时间戳一起发出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>readings.print()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022929Z" creationid="xccui" creationdate="20190622T022929Z">
        <seg>readings.print()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rect answers to these questions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T025245Z" creationid="xccui" creationdate="20190606T025245Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>refer to the same class of entities, just like a join predicate in a SQL query.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T051155Z" creationid="xccui" creationdate="20190615T051155Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>registerEventTimeTimer(timestamp: Long): Unit registers an event-time timer for the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060320Z">
        <seg>registerEventTimeTimer(timestamp: Long): Unit针对当前键值注册一个事件时间计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>registerProcessingTimeTimer(timestamp: Long): Unit registers a processing time timer for the current key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032553Z" creationid="xccui" creationdate="20190621T060056Z">
        <seg>registerProcessingTimeTimer(timestamp: Long): Unit针对当前键值注册一个处理时间计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>remove elements from the window state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044708Z" creationid="xccui" creationdate="20190626T044708Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>replaced by the ReduceFunction’s result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T001322Z" creationid="xccui" creationdate="20190624T001322Z">
        <seg>随后会用ReduceFunction的结果替换窗口状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>repository to your local machine:1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040104Z" creationid="xccui" creationdate="20190611T040104Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>restoreState(java.util.List[T] state): Unit</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T045523Z" creationid="xccui" creationdate="20190701T045523Z">
        <seg>restoreState(java.util.List[T] state): Unit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T210937Z" creationid="xccui" creationdate="20190623T210937Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>results continuously, maybe every minute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T014703Z" creationid="xccui" creationdate="20190606T014703Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rich function starts with Rich followed by the transformation name—RichMapFunc tion, RichFlatMapFunction, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T060729Z" creationid="xccui" creationdate="20190618T060721Z">
        <seg>它的命名规则是以Rich开头，后面跟着普通转换函数的名字，例如：RichMapFunction、RichFlatMapFunction等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>round-robin distribution transformation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043417Z" creationid="xccui" creationdate="20190616T043417Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>semantics (events that have no matching event will not be forwarded).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T025655Z" creationid="xccui" creationdate="20190628T025655Z">
        <seg>（不会发出未匹配成功的事件）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>separate tiers for data processing (the application itself) and data storage (a transac&lt;t0/&gt;‐&lt;t1/&gt; tional database system) as shown in &lt;t2/&gt;Figure 1-1&lt;t3/&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190226T155712Z" creationid="xccui" creationdate="20190226T155712Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>shown in &lt;t0/&gt;Figure 3-5&lt;t1/&gt; fulfills the requirements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190514T152232Z" creationid="esouser" creationdate="20190514T152232Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>side outputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011643Z" creationid="xccui" creationdate="20190624T011643Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sitively applied to these sources.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T011815Z" creationid="xccui" creationdate="20190613T011815Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>size in time units; this can be specified using the of(Time size) method of the assigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042707Z" creationid="xccui" creationdate="20190623T042501Z">
        <seg>以时间单元表示的窗口大小。它可以利用分配器的of(Time size)方法指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>size of the TaskManager memory and might suffer from garbage collection pau‐ ses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T022948Z" creationid="xccui" creationdate="20190704T022923Z">
        <seg>但它同样会受到TaskManager内存大小的限制，并且也可能导致垃圾回收停顿问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>snapshotContext: FunctionSnapshotContext): Unit = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163347Z" creationid="xccui" creationdate="20190702T163347Z">
        <seg>snapshotContext: FunctionSnapshotContext): Unit = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>snapshotState(checkpointId: Long, timestamp: Long): java.util.List[T]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T045509Z" creationid="xccui" creationdate="20190701T045509Z">
        <seg>snapshotState(checkpointId: Long, timestamp: Long): java.util.List[T]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specific state before the window is purged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T024801Z" creationid="xccui" creationdate="20190624T024801Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specifies that operators determine the current time by using information from</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070249Z" creationid="xccui" creationdate="20190619T070212Z">
        <seg>指定算子根据数据自身的信息决定当前时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specifies that operators determine the current time of the data stream according</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070216Z" creationid="xccui" creationdate="20190619T065107Z">
        <seg>指定算子根据处理机器的系统时钟决定数据流当前的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specifies the processing time of the source operator as an event time timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071539Z" creationid="xccui" creationdate="20190619T071451Z">
        <seg>指定每个接收的记录都把在数据源算子的处理时间作为事件时间戳并且自动生成水位线，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>specify a TypeSerializer to control how state is written into a state backend, check‐ point, and savepoint.2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T071605Z" creationid="xccui" creationdate="20190630T071605Z">
        <seg>或者，你也可以显式指定一个TypeSerializer来控制状态如何写入状态后端、检查点及保存点。2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sponding input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T043715Z" creationid="xccui" creationdate="20190615T043715Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>src/</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005738Z" creationid="xccui" creationdate="20190612T005738Z">
        <seg>src/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T034403Z" creationid="xccui" creationdate="20190630T034400Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>state: util.List[java.lang.Long]): Unit = { highTempCnt = 0</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052709Z" creationid="xccui" creationdate="20190701T052709Z">
        <seg>state: util.List[java.lang.Long]): Unit = { highTempCnt = 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>states, and side outputs to emit records.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T011523Z" creationid="xccui" creationdate="20190624T011523Z">
        <seg>以及用于发出数据的副输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T041331Z" creationid="xccui" creationdate="20190622T041331Z">
        <seg>stream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream of integers so that all negative numbers are sent to the first task and all other numbers are sent to a random task:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050616Z" creationid="xccui" creationdate="20190616T050616Z">
        <seg>以下示例对一个整数数据流进行了分区，所有负数会定向发往第一个任务，而其他数字会随机选择一个任务发送：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream partitions, such as parallelism changes, keyBy(), or other explicit redistribu‐</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T031345Z" creationid="xccui" creationdate="20190620T031345Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T015026Z" creationid="xccui" creationdate="20190622T015026Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>streams can be ingested from sources such as message queues or files, or also be gen‐ erated on the fly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051324Z" creationid="xccui" creationdate="20190612T051324Z">
        <seg>这些数据流的来源可以是消息队列或文件，也可以实时生成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>streams to which the record is routed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T061022Z" creationid="xccui" creationdate="20190615T061022Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>substreams of events that share the same key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T043958Z" creationid="xccui" creationdate="20190614T043958Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>succeed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="esouser" changedate="20190603T210830Z" creationid="esouser" creationdate="20190603T210830Z">
        <seg>succeed.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sum()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T052601Z" creationid="xccui" creationdate="20190614T052601Z">
        <seg>sum()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>summary can be a count, a sum, a sample of the events seen so far, a window buffer, or a custom data structure that preserves some property interesting to the running application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190414T055808Z" creationid="xccui" creationdate="20190414T055808Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>support to register timers are the Trigger interface for windows and the process function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T204246Z" creationid="xccui" creationdate="20190704T204246Z">
        <seg>只有窗口的Trigger接口以及处理函数才支持注册计时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tain information about the events they have received before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T055209Z" creationid="xccui" creationdate="20190605T235835Z">
        <seg>相反，状态化算子可能需要维护之前接收的事件信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ted result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T040025Z" creationid="xccui" creationdate="20190625T040025Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>temperature measured by a sensor changes by more than a threshold since the last measurement.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T061940Z" creationid="xccui" creationdate="20190630T061940Z">
        <seg>该示例应用会在传感器测量的温度和前一个测量值相比变化超出一定阈值时发出警报。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tems use to update materialized views.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T044542Z" creationid="xccui" creationdate="20190605T044542Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tering function state with Flink’s runtime and returning the state objects, such as ValueState, ListState, or BroadcastState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T064920Z" creationid="xccui" creationdate="20190702T064742Z">
        <seg>这两个状态存储（state store）对象能够使用Flink运行时来注册函数状态并返回状态对象（例如ValueState、ListState或BroadcastState）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>text in which the method is invoked.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045223Z" creationid="xccui" creationdate="20190612T045223Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>than one state object by registering multiple state descriptors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T070214Z" creationid="xccui" creationdate="20190630T070214Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is called a state backend.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190608T051432Z" creationid="xccui" creationdate="20190608T051432Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is used if no explicit trigger is specified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042149Z" creationid="xccui" creationdate="20190626T042149Z">
        <seg>用于未显式指定触发器的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that returns exactly one output event, possibly of a different type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T045224Z" creationid="xccui" creationdate="20190613T045224Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that, the method compares the temperatures, possibly emits an alert, and updates its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T213216Z" creationid="xccui" creationdate="20190704T213038Z">
        <seg>随后，方法就会比较两个相邻的温度值，依照逻辑决定是否发出警报，并更新最近一次温度的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the JobManager’s memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T020537Z" creationid="xccui" creationdate="20190704T020537Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the aggregation—a single value of the ReduceFunction’s input (and output) type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T225146Z" creationid="xccui" creationdate="20190623T225146Z">
        <seg>一个和ReduceFunction的输入及输出类型都相同的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the application logic might require that all tasks of an operation receive the same data or that events be distributed following a custom strategy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T070115Z" creationid="xccui" creationdate="20190615T070115Z">
        <seg>亦或是可能应用逻辑要求某操作的所有任务接收相同的数据或按照自定义策略分发事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the data itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T070251Z" creationid="xccui" creationdate="20190619T070251Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the events of both inputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190628T052629Z" creationid="xccui" creationdate="20190628T052629Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the input elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054026Z" creationid="xccui" creationdate="20190620T054026Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the method updates the clean-up timer by deleting the previous timer and registering a new one.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T212649Z" creationid="xccui" creationdate="20190704T212546Z">
        <seg>该方法会通过删除已有计时器并注册新计时器的方法达到"延期清理"的目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the operator state as a list of serializable state objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T050259Z" creationid="xccui" creationdate="20190701T050259Z">
        <seg>该方法需要以可序列化状态对象列表的形式返回算子状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the reduced value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T060434Z" creationid="xccui" creationdate="20190630T060434Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the selection of nested fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T041634Z" creationid="xccui" creationdate="20190618T041634Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the stateful function is restarted to recover from a failure or when an application is started from a savepoint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T021731Z" creationid="xccui" creationdate="20190701T021555Z">
        <seg>这有可能在有状态函数进行故障恢复或应用从保存点开始执行的情况下出现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>them in “Defining Keys and Referencing Fields” on page 102.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T051537Z" creationid="xccui" creationdate="20190614T051537Z">
        <seg>我们会在102页"定义键值和引用字段中"介绍它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.age = age;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044901Z" creationid="xccui" creationdate="20190617T044901Z">
        <seg>this.age = age;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.lastTempState.update(reading.temperature)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064715Z" creationid="xccui" creationdate="20190630T064715Z">
        <seg>this.lastTempState.update(reading.temperature)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this.name = name;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T044856Z" creationid="xccui" creationdate="20190617T044856Z">
        <seg>this.name = name;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>threshold.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T204926Z" creationid="xccui" creationdate="20190704T204926Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>thresholds.put(update.id, update.threshold)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042642Z" creationid="xccui" creationdate="20190702T042642Z">
        <seg>thresholds.put(update.id, update.threshold)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>thresholds.remove(update.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042645Z" creationid="xccui" creationdate="20190702T042645Z">
        <seg>thresholds.remove(update.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timestamp is stored in an additional ValueState[Long] called lastTimerState.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T212953Z" creationid="xccui" creationdate="20190704T212953Z">
        <seg>KeyedProcessFunction会使用一个名为lastTimerState的ValueState[Long]来记录它的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timestamp larger than the timestamp of the previous watermark, the new watermark</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T050324Z" creationid="xccui" creationdate="20190620T050302Z">
        <seg>且它的时间戳大于上一个水位线的时间戳，则算子就会发出一个新的水位线。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timestamp that is equal to or larger than the timer’s timestamp.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T060426Z" creationid="xccui" creationdate="20190621T060426Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>timestamp: Long, temperature: Double)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T035709Z" creationid="xccui" creationdate="20190612T035709Z">
        <seg>timestamp: Long, temperature: Double)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T211423Z" creationid="xccui" creationdate="20190623T211423Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion must be Serializable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055235Z" creationid="xccui" creationdate="20190618T055235Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion on which the stream is to be partitioned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050340Z" creationid="xccui" creationdate="20190616T050340Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion pauses because it puts many long-lived objects on the heap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T020001Z" creationid="xccui" creationdate="20190704T020001Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion performs the actual window evaluation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T032323Z" creationid="xccui" creationdate="20190626T031606Z">
        <seg>而实际的计算逻辑是由窗口函数决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion via the StreamExecutionEnvironment or per operator using the setMaxParallel ism() method as shown in Example 7-11.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024950Z" creationid="xccui" creationdate="20190703T024950Z">
        <seg>如示例7-11所示，我们可以通过StreamExecutionEnvironment为应用的所有算子设置最大并行度或利用算子的setMaxParallelism()方法为每个算子单独设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tion:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T054847Z" creationid="xccui" creationdate="20190617T054847Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tions and reduce.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T050128Z" creationid="xccui" creationdate="20190614T050128Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tions, mixes up the timestamp order of the elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T031401Z" creationid="xccui" creationdate="20190620T031401Z">
        <seg>都会使元素的时间戳顺序产生混乱。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to connect to the source of the sensor measurements and create an initial DataStream of type SensorReading.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051601Z" creationid="xccui" creationdate="20190612T051601Z">
        <seg>来连接传感器测量源，并创建出SensorReading类型的初始DataStream。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to each ingested record and automatically generates watermarks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T071459Z" creationid="xccui" creationdate="20190619T071459Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to ensure the broadcast state holds the same information in all parallel instances.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T053159Z" creationid="xccui" creationdate="20190702T051544Z">
        <seg>这其实是一种安全机制，用于确保所有并行实例中广播状态所保存的信息完全相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to initialize the state by checking if the state backend holds state for the function reg‐ istered under the given name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T070144Z" creationid="xccui" creationdate="20190702T065114Z">
        <seg>状态存储首先会利用给定名称检查状态后端中是否存在一个为当前函数注册过的同名状态，并尝试用它对状态进行初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to instruct our program to interpret time semantics using event time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T045900Z" creationid="xccui" creationdate="20190612T045805Z">
        <seg>来指定程序使用事件时间作为其时间语义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to the system clock of the machine where they are being executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T065121Z" creationid="xccui" creationdate="20190619T065121Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tor allows records to be emitted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T054911Z" creationid="xccui" creationdate="20190621T054911Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tors collect and process records with possibly unordered timestamps and finalize a computation when their event-time clock, which is advanced by the received water‐ marks, indicates that no more records with relevant timestamps are expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T205535Z" creationid="xccui" creationdate="20190606T205535Z">
        <seg>对基于时间算子的任务而言，其收集和处理的记录可能会包含乱序的时间戳。只有当它们的事件时间时钟（由接收的水位线驱动）指示不必再等那些包含相关时间戳的记录时，才会最终触发计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>transformation-specific function interface:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T020901Z" creationid="xccui" creationdate="20190613T020901Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>trigger does not support merging it cannot be used in combination with a Merging WindowAssigner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T195200Z" creationid="xccui" creationdate="20190626T195135Z">
        <seg>如果一个触发器不支持合并，则无法与MergingWindowAssigner组合使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>truth because it persists the input events and can replay them in an deterministic order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190305T144509Z" creationid="xccui" creationdate="20190305T061121Z">
        <seg>这缘于于它可以持久化输入事件并以确定顺序将其重放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ts: Long): java.util.List[java.lang.Long] = {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052942Z" creationid="xccui" creationdate="20190701T052942Z">
        <seg>ts: Long): java.util.List[java.lang.Long] = {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ts: Long,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042700Z" creationid="xccui" creationdate="20190626T042700Z">
        <seg>ts: Long,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type information to represent data types and generate specific serializers, deserializ‐ ers, and comparators for every data type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T064111Z" creationid="xccui" creationdate="20190616T063841Z">
        <seg>Flink利用类型信息的概念来表示数据类型，并且对于每种类型，都会为其生成特定的序列化器、反序列化器以及比较器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type of parallelism is called task parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190401T032421Z" creationid="xccui" creationdate="20190401T032421Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type of the input stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T061554Z" creationid="xccui" creationdate="20190614T061554Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T052653Z" creationid="xccui" creationdate="20190617T052653Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>undesirable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T045748Z" creationid="xccui" creationdate="20190615T045748Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>unzip master.zip</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040435Z" creationid="xccui" creationdate="20190611T040435Z">
        <seg>unzip master.zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>up with the events happening now, it can continue as a real-time application using exactly the same program logic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190412T155347Z" creationid="xccui" creationdate="20190412T155347Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>used with care.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T045146Z" creationid="xccui" creationdate="20190626T045108Z">
        <seg>因此使用时要格外小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>user-defined function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T025350Z" creationid="xccui" creationdate="20190620T025350Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>using a KeySelector with a constant dummy key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T062031Z" creationid="xccui" creationdate="20190621T062031Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>v</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040010Z" creationid="xccui" creationdate="20190418T040010Z">
        <seg>v</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val alerts: DataStream[(String, Double, Double)] = keyedData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062427Z" creationid="xccui" creationdate="20190630T062427Z">
        <seg>val alerts: DataStream[(String, Double, Double)] = keyedData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val alerts: DataStream[(String, Double, Double)] = keyedSensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024505Z" creationid="xccui" creationdate="20190702T024505Z">
        <seg>val alerts: DataStream[(String, Double, Double)] = keyedSensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val all: DataStream[(Int, String)] = splitted.select("small", "large")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064116Z" creationid="xccui" creationdate="20190615T064116Z">
        <seg>val all: DataStream[(Int, String)] = splitted.select("small", "large")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val allCities: DataStream[SensorReading] = parisStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064852Z" creationid="xccui" creationdate="20190614T064852Z">
        <seg>val allCities: DataStream[SensorReading] = parisStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val avgTemp = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T042905Z" creationid="xccui" creationdate="20190623T042905Z">
        <seg>val avgTemp = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val avgTemp: DataStream[SensorReading] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042225Z" creationid="xccui" creationdate="20190612T042225Z">
        <seg>val avgTemp: DataStream[SensorReading] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val avgTempPerWindow: DataStream[(String, Double)] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005450Z" creationid="xccui" creationdate="20190624T005450Z">
        <seg>val avgTempPerWindow: DataStream[(String, Double)] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val backend = new RocksDBStateBackend(checkpointPath)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025725Z" creationid="xccui" creationdate="20190704T025725Z">
        <seg>val backend = new RocksDBStateBackend(checkpointPath)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val bound: Long = 60 * 1000</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051040Z" creationid="xccui" creationdate="20190620T051040Z">
        <seg>val bound: Long = 60 * 1000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val bound: Long = 60 * 1000 // 1 min in ms</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054805Z" creationid="xccui" creationdate="20190620T054805Z">
        <seg>val bound: Long = 60 * 1000 // 1分钟的毫秒数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val broadcastStateDescriptor =</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024327Z" creationid="xccui" creationdate="20190702T024327Z">
        <seg>val broadcastStateDescriptor =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val broadcastThresholds: BroadcastStream[ThresholdUpdate] = thresholds</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024336Z" creationid="xccui" creationdate="20190702T024336Z">
        <seg>val broadcastThresholds: BroadcastStream[ThresholdUpdate] = thresholds</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val byId: KeyedStream[SensorReading, String] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051748Z" creationid="xccui" creationdate="20190618T051748Z">
        <seg>val byId: KeyedStream[SensorReading, String] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val caseClassType: TypeInformation[Person] = Types.CASE_CLASS[Person]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053917Z" creationid="xccui" creationdate="20190617T053917Z">
        <seg>val caseClassType: TypeInformation[Person] = Types.CASE_CLASS[Person]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val celsius = (r.temperature - 32) * (5.0 / 9.0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042259Z" creationid="xccui" creationdate="20190612T042259Z">
        <seg>val celsius = (r.temperature - 32) * (5.0 / 9.0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val cnt = elements.count(_ =&gt; true)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034120Z" creationid="xccui" creationdate="20190629T034120Z">
        <seg>val cnt = elements.count(_ =&gt; true)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val connected: ConnectedStreams[Int, String] = first.connect(second)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040824Z" creationid="xccui" creationdate="20190615T040824Z">
        <seg>val connected: ConnectedStreams[Int, String] = first.connect(second)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val countPer10Secs: DataStream[(String, Long, Int)] = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154933Z" creationid="xingcan" creationdate="20190628T154933Z">
        <seg>val countPer10Secs: DataStream[(String, Long, Int)] = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val countPer10Secs: DataStream[(String, Long, Int, String)] = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T165206Z" creationid="xingcan" creationdate="20190628T165206Z">
        <seg>val countPer10Secs: DataStream[(String, Long, Int, String)] = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val curTimer = lastTimerState.value()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210609Z" creationid="xccui" creationdate="20190704T210609Z">
        <seg>val curTimer = lastTimerState.value()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val curTimerTimestamp = currentTimer.value();</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071518Z" creationid="xccui" creationdate="20190621T071518Z">
        <seg>val curTimerTimestamp = currentTimer.value();</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val curTimerTimestamp = disableTimer.value()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032340Z" creationid="xccui" creationdate="20190622T032340Z">
        <seg>val curTimerTimestamp = disableTimer.value()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val defaultP = env.env.getParallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T060244Z" creationid="xccui" creationdate="20190616T060244Z">
        <seg>val defaultP = env.env.getParallelism</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val defaultP = env.getParallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061615Z" creationid="xccui" creationdate="20190616T061615Z">
        <seg>val defaultP = env.getParallelism</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val div = highTempCnt / 10</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062728Z" creationid="xccui" creationdate="20190701T062728Z">
        <seg>val div = highTempCnt / 10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val endTime = startTime + windowSize</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044106Z" creationid="xccui" creationdate="20190626T044106Z">
        <seg>val endTime = startTime + windowSize</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T041917Z" creationid="xccui" creationdate="20190612T041917Z">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T045734Z" creationid="xccui" creationdate="20190620T045734Z">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment val checkpointPath: String = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T025646Z" creationid="xccui" creationdate="20190704T025646Z">
        <seg>val env = StreamExecutionEnvironment.getExecutionEnvironment val checkpointPath: String = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val env: StreamExecutionEnvironment.getExecutionEnvironment</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T054818Z" creationid="xccui" creationdate="20190616T054818Z">
        <seg>val env: StreamExecutionEnvironment.getExecutionEnvironment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val filterSwitches: DataStream[(String, Long)] = env</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031604Z" creationid="xccui" creationdate="20190622T031604Z">
        <seg>val filterSwitches: DataStream[(String, Long)] = env</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val filteredReadings: DataStream[SensorReading] = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155621Z" creationid="xingcan" creationdate="20190628T155621Z">
        <seg>val filteredReadings: DataStream[SensorReading] = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val filteredSensors = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053212Z" creationid="xccui" creationdate="20190613T053212Z">
        <seg>val filteredSensors = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val first: DataStream[(Int, Long)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T051655Z" creationid="xccui" creationdate="20190615T051655Z">
        <seg>val first: DataStream[(Int, Long)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val first: DataStream[Int] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040722Z" creationid="xccui" creationdate="20190615T040722Z">
        <seg>val first: DataStream[Int] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val firstSeen: ValueState[Boolean] = ctx.getPartitionedState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200332Z" creationid="xccui" creationdate="20190626T200332Z">
        <seg>val firstSeen: ValueState[Boolean] = ctx.getPartitionedState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val flinkTweets = tweets.filter(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054233Z" creationid="xccui" creationdate="20190618T054233Z">
        <seg>val flinkTweets = tweets.filter(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val flinkTweets = tweets.filter(_.contains("flink"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055915Z" creationid="xccui" creationdate="20190618T055915Z">
        <seg>val flinkTweets = tweets.filter(_.contains("flink"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val flinkTweets = tweets.filter(new FlinkFilter)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054129Z" creationid="xccui" creationdate="20190618T054129Z">
        <seg>val flinkTweets = tweets.filter(new FlinkFilter)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val flinkTweets = tweets.filter(new KeywordFilter("flink"))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054642Z" creationid="xccui" creationdate="20190618T054642Z">
        <seg>val flinkTweets = tweets.filter(new KeywordFilter("flink"))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val forwardedReadings = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T031647Z" creationid="xccui" creationdate="20190622T031647Z">
        <seg>val forwardedReadings = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val input : DataStream[(Int, Int)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052152Z" creationid="xccui" creationdate="20190618T052152Z">
        <seg>val input : DataStream[(Int, Int)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val input: DataStream[(Int, String, Long)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T033254Z" creationid="xccui" creationdate="20190618T033254Z">
        <seg>val input: DataStream[(Int, String, Long)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val input: DataStream[(Int, String, Long)] = ... val keyed1 = input.keyBy("2") // key by 3rd field val keyed2 = input.keyBy("_1") // key by 1st field</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T043349Z" creationid="xccui" creationdate="20190618T043341Z">
        <seg>val input: DataStream[(Int, String, Long)] = ... val keyed1 = input.keyBy("2") // 以第3个字段为键值 val keyed2 = input.keyBy("_1") // 以第1个字段为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val inputStream: DataStream[(Int, Int, Int)] = env.fromElements( (1, 2, 2), (2, 3, 1), (2, 2, 4), (1, 5, 3))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054427Z" creationid="xccui" creationdate="20190614T054427Z">
        <seg>val inputStream: DataStream[(Int, Int, Int)] = env.fromElements( (1, 2, 2), (2, 3, 1), (2, 2, 4), (1, 5, 3))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val inputStream: DataStream[(Int, String)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064057Z" creationid="xccui" creationdate="20190615T064057Z">
        <seg>val inputStream: DataStream[(Int, String)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val inputStream: DataStream[(String, List[String])] = env.fromElements( ("en", List("tea")), ("fr", List("vin")), ("en", List("cake")))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062232Z" creationid="xccui" creationdate="20190614T062232Z">
        <seg>val inputStream: DataStream[(String, List[String])] = env.fromElements( ("en", List("tea")), ("fr", List("vin")), ("en", List("cake")))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val isUpdate = ctx.windowState.getState(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190629T034323Z" creationid="xccui" creationdate="20190629T034323Z">
        <seg>val isUpdate = ctx.windowState.getState(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyCntDescriptor = new ValueStateDescriptor[Long]("keyedCnt", classOf[Long]) keyedCntState = initContext.getKeyedStateStore.getState(keyCntDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163315Z" creationid="xccui" creationdate="20190702T163315Z">
        <seg>val keyCntDescriptor = new ValueStateDescriptor[Long]("keyedCnt", classOf[Long]) keyedCntState = initContext.getKeyedStateStore.getState(keyCntDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyHighTempCnt = keyedCntState.value() + 1 keyedCntState.update(keyHighTempCnt)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162539Z" creationid="xccui" creationdate="20190702T162539Z">
        <seg>val keyHighTempCnt = keyedCntState.value() + 1 keyedCntState.update(keyHighTempCnt)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyed = input.keyBy(1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T033251Z" creationid="xccui" creationdate="20190618T033251Z">
        <seg>val keyed = input.keyBy(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyed2 = input.keyBy(1, 2)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T041306Z" creationid="xccui" creationdate="20190618T041306Z">
        <seg>val keyed2 = input.keyBy(1, 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyed: KeyedStream[SensorReading, String] = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053550Z" creationid="xccui" creationdate="20190615T053550Z">
        <seg>val keyed: KeyedStream[SensorReading, String] = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedConnect1: ConnectedStreams[(Int, Long), (Int, String)] = one</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050145Z" creationid="xccui" creationdate="20190615T050145Z">
        <seg>val keyedConnect1: ConnectedStreams[(Int, Long), (Int, String)] = one</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedConnect2: ConnectedStreams[(Int, Long), (Int, String)] = one.keyBy(0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050432Z" creationid="xccui" creationdate="20190615T050432Z">
        <seg>val keyedConnect2: ConnectedStreams[(Int, Long), (Int, String)] = one.keyBy(0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedConnect: ConnectedStreams[(Int, Long), (Int, String)] = first</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053608Z" creationid="xccui" creationdate="20190615T053608Z">
        <seg>val keyedConnect: ConnectedStreams[(Int, Long), (Int, String)] = first</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedData: KeyedStream[SensorReading, String] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062059Z" creationid="xccui" creationdate="20190630T062059Z">
        <seg>val keyedData: KeyedStream[SensorReading, String] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedSensorData: KeyedStream[SensorReading, String] = sensorData.keyBy(_.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024311Z" creationid="xccui" creationdate="20190702T024311Z">
        <seg>val keyedSensorData: KeyedStream[SensorReading, String] = sensorData.keyBy(_.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedSensors = sensorStream.keyBy("id")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T042640Z" creationid="xccui" creationdate="20190618T042640Z">
        <seg>val keyedSensors = sensorStream.keyBy("id")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val keyedStream = input.keyBy(value =&gt; math.max(value._1, value._2))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T052156Z" creationid="xccui" creationdate="20190618T052156Z">
        <seg>val keyedStream = input.keyBy(value =&gt; math.max(value._1, value._2))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val large: DataStream[(Int, String)] = splitted.select("large")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064109Z" creationid="xccui" creationdate="20190615T064109Z">
        <seg>val large: DataStream[(Int, String)] = splitted.select("large")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lastTemp = lastTempState.value()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064433Z" creationid="xccui" creationdate="20190630T064433Z">
        <seg>val lastTemp = lastTempState.value()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lastTempDesc = new ValueStateDescriptor[Double]("lastTemp", classOf[Double]) lastTempState = getRuntimeContext.getState[Double](lastTempDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210329Z" creationid="xccui" creationdate="20190704T210329Z">
        <seg>val lastTempDesc = new ValueStateDescriptor[Double]("lastTemp", classOf[Double]) lastTempState = getRuntimeContext.getState[Double](lastTempDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lastTempDescriptor =</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064311Z" creationid="xccui" creationdate="20190630T064311Z">
        <seg>val lastTempDescriptor =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lastTempDescriptor = new ValueStateDescriptor[Double]( "lastTemp", classOf[Double])</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042520Z" creationid="xccui" creationdate="20190702T042520Z">
        <seg>val lastTempDescriptor = new ValueStateDescriptor[Double]( "lastTemp", classOf[Double])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lastTimerDesc = new ValueStateDescriptor[Long]("lastTimer", classOf[Long]) lastTimerState = getRuntimeContext.getState(timestampDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210440Z" creationid="xccui" creationdate="20190704T210440Z">
        <seg>val lastTimerDesc = new ValueStateDescriptor[Long]("lastTimer", classOf[Long]) lastTimerState = getRuntimeContext.getState(timestampDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lateReadings: DataStream[SensorReading] = filteredReadings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155643Z" creationid="xingcan" creationdate="20190628T155643Z">
        <seg>val lateReadings: DataStream[SensorReading] = filteredReadings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lateReadingsOut = new OutputTag[SensorReading]("late-readings") override def processElement(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155835Z" creationid="xingcan" creationdate="20190628T155835Z">
        <seg>val lateReadingsOut = new OutputTag[SensorReading]("late-readings") override def processElement(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val lateStream: DataStream[SensorReading] = countPer10Secs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155125Z" creationid="xingcan" creationdate="20190628T155125Z">
        <seg>val lateStream: DataStream[SensorReading] = countPer10Secs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val localEnv: StreamExecutionEnvironment.createLocalEnvironment()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T044907Z" creationid="xccui" creationdate="20190612T045612Z">
        <seg>val localEnv = StreamExecutionEnvironment.createLocalEnvironment()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val minMax = minMaxIt.head</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T045144Z" creationid="xccui" creationdate="20190625T045144Z">
        <seg>val minMax = minMaxIt.head</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val minMaxTempPerWindow: DataStream[MinMaxTemp] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030643Z" creationid="xccui" creationdate="20190625T030643Z">
        <seg>val minMaxTempPerWindow: DataStream[MinMaxTemp] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val minTempPerWindow: DataStream[(String, Double)] = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T002443Z" creationid="xccui" creationdate="20190624T002443Z">
        <seg>val minTempPerWindow: DataStream[(String, Double)] = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val mod = (highTempCnt % 10).toInt</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T062731Z" creationid="xccui" creationdate="20190701T062731Z">
        <seg>val mod = (highTempCnt % 10).toInt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val monitoredReadings: DataStream[SensorReading] = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T022715Z" creationid="xccui" creationdate="20190622T022715Z">
        <seg>val monitoredReadings: DataStream[SensorReading] = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val newTimer = ctx.timestamp() + (3600 * 1000)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190704T210548Z" creationid="xccui" creationdate="20190704T210548Z">
        <seg>val newTimer = ctx.timestamp() + (3600 * 1000)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val numbers: DataStream[(Int)] = ... numbers.partitionCustom(myPartitioner, 0)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050629Z" creationid="xccui" creationdate="20190616T050629Z">
        <seg>val numbers: DataStream[(Int)] = ... numbers.partitionCustom(myPartitioner, 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val numbers: DataStream[Long] = env.fromElements(1L, 2L, 3L, 4L) numbers.map( n =&gt; n + 1)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T070457Z" creationid="xccui" creationdate="20190616T070457Z">
        <seg>val numbers: DataStream[Long] = env.fromElements(1L, 2L, 3L, 4L) numbers.map( n =&gt; n + 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val one: DataStream[(Int, Long)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T053600Z" creationid="xccui" creationdate="20190615T053600Z">
        <seg>val one: DataStream[(Int, Long)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val opCntDescriptor = new ListStateDescriptor[Long]("opCnt", classOf[Long]) opCntState = initContext.getOperatorStateStore.getListState(opCntDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T163320Z" creationid="xccui" creationdate="20190702T163320Z">
        <seg>val opCntDescriptor = new ListStateDescriptor[Long]("opCnt", classOf[Long]) opCntState = initContext.getOperatorStateStore.getListState(opCntDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val output = stream.assignTimestampsAndWatermarks(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052857Z" creationid="xccui" creationdate="20190620T052857Z">
        <seg>val output = stream.assignTimestampsAndWatermarks(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val parisStream: DataStream[SensorReading] = ... val tokyoStream: DataStream[SensorReading] = ... val rioStream: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T064847Z" creationid="xccui" creationdate="20190614T064847Z">
        <seg>val parisStream: DataStream[SensorReading] = ... val tokyoStream: DataStream[SensorReading] = ... val rioStream: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val persons: DataStream[Person] = ... persons.keyBy("address.zip") // key by nested POJO field</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T050133Z" creationid="xccui" creationdate="20190618T050133Z">
        <seg>val persons: DataStream[Person] = ... persons.keyBy("address.zip") // 以嵌套的POJO字段为键值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val persons: DataStream[Person] = env.fromElements(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T041128Z" creationid="xccui" creationdate="20190617T041128Z">
        <seg>val persons: DataStream[Person] = env.fromElements(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val prevTemp = lastTemp.value()</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071431Z" creationid="xccui" creationdate="20190621T071431Z">
        <seg>val prevTemp = lastTemp.value()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val r = scala.util.Random</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T050636Z" creationid="xccui" creationdate="20190616T050636Z">
        <seg>val r = scala.util.Random</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050713Z" creationid="xccui" creationdate="20190613T050713Z">
        <seg>val readings: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[SensorReading] = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T154914Z" creationid="xingcan" creationdate="20190628T154914Z">
        <seg>val readings: DataStream[SensorReading] = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[SensorReading] = env</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T044638Z" creationid="xccui" creationdate="20190620T044638Z">
        <seg>val readings: DataStream[SensorReading] = env</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val readings: DataStream[SensorReadings] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T053208Z" creationid="xccui" creationdate="20190613T053208Z">
        <seg>val readings: DataStream[SensorReadings] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val remoteEnv = StreamExecutionEnvironment.createRemoteEnvironment( "host",</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T051333Z" creationid="xccui" creationdate="20190612T051333Z">
        <seg>val remoteEnv = StreamExecutionEnvironment.createRemoteEnvironment( "host",</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val result: = env.addSource(new CustomSource)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T061619Z" creationid="xccui" creationdate="20190616T061619Z">
        <seg>val result: = env.addSource(new CustomSource)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val resultStream: DataStream[(Int, Int, Int)] = inputStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T054459Z" creationid="xccui" creationdate="20190614T054459Z">
        <seg>val resultStream: DataStream[(Int, Int, Int)] = inputStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val resultStream: DataStream[(String, List[String])] = inputStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T062227Z" creationid="xccui" creationdate="20190614T062227Z">
        <seg>val resultStream: DataStream[(String, List[String])] = inputStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val second: DataStream[(Int, String)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T051658Z" creationid="xccui" creationdate="20190615T051658Z">
        <seg>val second: DataStream[(Int, String)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val second: DataStream[String] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T040832Z" creationid="xccui" creationdate="20190615T040832Z">
        <seg>val second: DataStream[String] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] =</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T054743Z" creationid="xccui" creationdate="20190612T054743Z">
        <seg>val sensorData: DataStream[SensorReading] =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T051745Z" creationid="xccui" creationdate="20190618T051745Z">
        <seg>val sensorData: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T062019Z" creationid="xccui" creationdate="20190630T062019Z">
        <seg>val sensorData: DataStream[SensorReading] = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] = env</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042047Z" creationid="xccui" creationdate="20190612T042047Z">
        <seg>val sensorData: DataStream[SensorReading] = env</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorData: DataStream[SensorReading] = env.addSource(...)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T072817Z" creationid="xccui" creationdate="20190619T072817Z">
        <seg>val sensorData: DataStream[SensorReading] = env.addSource(...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorIds: DataStream[String] = readings.map(new MyMapFunction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T050717Z" creationid="xccui" creationdate="20190613T050717Z">
        <seg>val sensorIds: DataStream[String] = readings.map(new MyMapFunction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorIds: DataStream[String] = readings.map(r =&gt; r.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T051126Z" creationid="xccui" creationdate="20190613T051126Z">
        <seg>val sensorIds: DataStream[String] = readings.map(r =&gt; r.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorStream: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T042637Z" creationid="xccui" creationdate="20190618T042637Z">
        <seg>val sensorStream: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sensorThreshold: Double = thresholds.get(reading.id)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042746Z" creationid="xccui" creationdate="20190702T042746Z">
        <seg>val sensorThreshold: Double = thresholds.get(reading.id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sentences: DataStream[String] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005237Z" creationid="xccui" creationdate="20190613T005237Z">
        <seg>val sentences: DataStream[String] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val sessionWindows = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T061438Z" creationid="xccui" creationdate="20190623T061438Z">
        <seg>val sessionWindows = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val slidingAvgTemp = sensorData</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T060024Z" creationid="xccui" creationdate="20190623T060024Z">
        <seg>val slidingAvgTemp = sensorData</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val small: DataStream[(Int, String)] = splitted.select("small")</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064112Z" creationid="xccui" creationdate="20190615T064112Z">
        <seg>val small: DataStream[(Int, String)] = splitted.select("small")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val splitted: SplitStream[(Int, String)] = inputStream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T064101Z" creationid="xccui" creationdate="20190615T064101Z">
        <seg>val splitted: SplitStream[(Int, String)] = inputStream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val startTime = ts - (ts % windowSize)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T044101Z" creationid="xccui" creationdate="20190626T044101Z">
        <seg>val startTime = ts - (ts % windowSize)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val stream: DataStream[SensorReading] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051957Z" creationid="xccui" creationdate="20190620T051957Z">
        <seg>val stream: DataStream[SensorReading] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val stringType: TypeInformation[String] = Types.STRING</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053818Z" creationid="xccui" creationdate="20190617T053818Z">
        <seg>val stringType: TypeInformation[String] = Types.STRING</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 1000))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200824Z" creationid="xccui" creationdate="20190626T200824Z">
        <seg>val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 1000))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 1000)) ctx.registerEventTimeTimer(t)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200552Z" creationid="xccui" creationdate="20190626T200552Z">
        <seg>val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 1000)) ctx.registerEventTimeTimer(t)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tempDiff = (reading.temperature - lastTemp).abs</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T064449Z" creationid="xccui" creationdate="20190630T064449Z">
        <seg>val tempDiff = (reading.temperature - lastTemp).abs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val temps = vals.map(_.temperature)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031930Z" creationid="xccui" creationdate="20190625T031930Z">
        <seg>val temps = vals.map(_.temperature)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val thresholds = ctx.getBroadcastState(thresholdStateDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042554Z" creationid="xccui" creationdate="20190702T042554Z">
        <seg>val thresholds = ctx.getBroadcastState(thresholdStateDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val thresholds = readOnlyCtx.getBroadcastState(thresholdStateDescriptor)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T042707Z" creationid="xccui" creationdate="20190702T042707Z">
        <seg>val thresholds = readOnlyCtx.getBroadcastState(thresholdStateDescriptor)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val thresholds: DataStream[ThresholdUpdate] = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T024307Z" creationid="xccui" creationdate="20190702T024307Z">
        <seg>val thresholds: DataStream[ThresholdUpdate] = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val timerTimestamp = ctx.timerService().currentProcessingTime() + switch._2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190622T032337Z" creationid="xccui" creationdate="20190622T032337Z">
        <seg>val timerTimestamp = ctx.timerService().currentProcessingTime() + switch._2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val timerTs = ctx.timerService().currentProcessingTime() + 1000 ctx.timerService().registerProcessingTimeTimer(timerTs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071711Z" creationid="xccui" creationdate="20190621T071711Z">
        <seg>val timerTs = ctx.timerService().currentProcessingTime() + 1000 ctx.timerService().registerProcessingTimeTimer(timerTs)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tupleType: TypeInformation[(Int, Long)] = Types.TUPLE[(Int, Long)]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190617T053851Z" creationid="xccui" creationdate="20190617T053851Z">
        <seg>val tupleType: TypeInformation[(Int, Long)] = Types.TUPLE[(Int, Long)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tweets: DataStream[String] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T055841Z" creationid="xccui" creationdate="20190618T055841Z">
        <seg>val tweets: DataStream[String] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val tweets: DataStream[String] = ???</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054638Z" creationid="xccui" creationdate="20190618T054638Z">
        <seg>val tweets: DataStream[String] = ???</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val two: DataStream[(Int, String)] = ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190615T050041Z" creationid="xccui" creationdate="20190615T050041Z">
        <seg>val two: DataStream[(Int, String)] = ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val warnings = readings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T070901Z" creationid="xccui" creationdate="20190621T070901Z">
        <seg>val warnings = readings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val windowEnd = ctx.window.getEnd</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031934Z" creationid="xccui" creationdate="20190625T031934Z">
        <seg>val windowEnd = ctx.window.getEnd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val windowSize: Long = 30 * 1000L</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T042653Z" creationid="xccui" creationdate="20190626T042653Z">
        <seg>val windowSize: Long = 30 * 1000L</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val withTimestampsAndWatermarks = stream</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T052001Z" creationid="xccui" creationdate="20190620T052001Z">
        <seg>val withTimestampsAndWatermarks = stream</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>val words: DataStream[String] = sentences</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190613T005233Z" creationid="xccui" creationdate="20190613T005233Z">
        <seg>val words: DataStream[String] = sentences</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vals: Iterable[SensorReading],</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T031924Z" creationid="xccui" creationdate="20190625T031924Z">
        <seg>vals: Iterable[SensorReading],</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>value observed so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T053815Z" creationid="xccui" creationdate="20190614T053815Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T011820Z" creationid="xccui" creationdate="20190606T011820Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190630T065725Z" creationid="xccui" creationdate="20190630T065725Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var keyedCntState: ValueState[Long] = _ var opCntState: ListState[Long] = _</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162238Z" creationid="xccui" creationdate="20190702T162238Z">
        <seg>var keyedCntState: ValueState[Long] = _ var opCntState: ListState[Long] = _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var maxTs: Long = Long.MinValue // the maximum observed timestamp</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T051105Z" creationid="xccui" creationdate="20190620T051105Z">
        <seg>var maxTs: Long = Long.MinValue // 观察到的最大时间戳</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var opHighTempCnt: Long = 0</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T162235Z" creationid="xccui" creationdate="20190702T162235Z">
        <seg>var opHighTempCnt: Long = 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>var subTaskIndex = 0</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T034249Z" creationid="xccui" creationdate="20190619T034249Z">
        <seg>var subTaskIndex = 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vi</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040256Z" creationid="xccui" creationdate="20190418T040256Z">
        <seg>vi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040515Z" creationid="xccui" creationdate="20190418T040515Z">
        <seg>vii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>viii</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190418T040559Z" creationid="xccui" creationdate="20190418T040559Z">
        <seg>viii</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>viii | Table of Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130320Z" creationid="xccui" creationdate="20190605T130320Z">
        <seg>viii | 目录</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void deleteEventTimeTimer(long time);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192721Z" creationid="xccui" creationdate="20190626T192721Z">
        <seg>void deleteEventTimeTimer(long time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void deleteProcessingTimeTimer(long time);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192708Z" creationid="xccui" creationdate="20190626T192708Z">
        <seg>void deleteProcessingTimeTimer(long time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void evictAfter( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201926Z" creationid="xccui" creationdate="20190627T201926Z">
        <seg>void evictAfter( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void evictBefore( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190627T201903Z" creationid="xccui" creationdate="20190627T201903Z">
        <seg>void evictBefore( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void mergePartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T193115Z" creationid="xccui" creationdate="20190626T193115Z">
        <seg>void mergePartitionedState(StateDescriptor&lt;S, ?&gt; stateDescriptor);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void process(</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T010515Z" creationid="xccui" creationdate="20190624T010515Z">
        <seg>void process(</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void registerEventTimeTimer(long time);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192652Z" creationid="xccui" creationdate="20190626T192652Z">
        <seg>void registerEventTimeTimer(long time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>void registerProcessingTimeTimer(long time);</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T192631Z" creationid="xccui" creationdate="20190626T192631Z">
        <seg>void registerProcessingTimeTimer(long time);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wait until they bring some from the supply room.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T234106Z" creationid="xccui" creationdate="20190605T234106Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>way to perform a lightweight load rebalance when the number of sender and receiver tasks is not the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190616T043851Z" creationid="xccui" creationdate="20190616T043851Z">
        <seg>本质上看，重调分区策略为发送端和接收端任务不等的情况提供了一种轻量级的负载平衡方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>wget https://github.com/streaming-with-flink/examples-scala/archive/master.zip</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040424Z" creationid="xccui" creationdate="20190611T040424Z">
        <seg>wget https://github.com/streaming-with-flink/examples-scala/archive/master.zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will move all data to a single task such that the operator would be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T062540Z" creationid="xccui" creationdate="20190621T062117Z">
        <seg>注意，这样操作会使所有数据发到单个任务上，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>window size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T062149Z" creationid="xccui" creationdate="20190623T062149Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>window to perform more complex computations, such as computing the median of values in a window or the most frequently occurring value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190624T005940Z" creationid="xccui" creationdate="20190624T005940Z">
        <seg>但有些时候我们需要访问窗口内的所有元素来执行一些更加复杂的计算，例如计算窗口内数据的中值或出现频率最高的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>window using the timeWindow(size) method, which is a shortcut for either window.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190623T053640Z" creationid="xccui" creationdate="20190623T051438Z">
        <seg>该方法是对window.(TumblingEventTimeWindows.of(size))或window.(TumblingProcessing TimeWindows.of(size))的简写，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>window: TimeWindow,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190626T200233Z" creationid="xccui" creationdate="20190626T200233Z">
        <seg>window: TimeWindow,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>windows is defined by a set of policies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190606T012709Z" creationid="xccui" creationdate="20190606T012709Z">
        <seg>窗口的行为是由一系列策略定义的，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>windows of 5 seconds:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T053745Z" creationid="xccui" creationdate="20190612T053745Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>window’s start and end timestamp and the minimum and maximum temperature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T030535Z" creationid="xccui" creationdate="20190625T030535Z">
        <seg>其中包含了窗口的开始、结束时间以及窗口内的最低、最高温度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with Flink’s checkpoints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190702T072256Z" creationid="xccui" creationdate="20190702T072256Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with ListCheckpointed[java.lang.Long] {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190701T052323Z" creationid="xccui" creationdate="20190701T052323Z">
        <seg>with ListCheckpointed[java.lang.Long] {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with the same key access the same state and thus can be processed together.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190614T044717Z" creationid="xccui" creationdate="20190614T044414Z">
        <seg>这意味着所有键值相同的事件可以访问相同的状态，因此可以一并处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x | Preface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130336Z" creationid="xccui" creationdate="20190605T130328Z">
        <seg>x | 序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>xii | Preface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190605T130350Z" creationid="xccui" creationdate="20190605T130350Z">
        <seg>xii | 序言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190416T052353Z" creationid="xccui" creationdate="20190416T052353Z">
        <seg>|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>| 81</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190619T045202Z" creationid="xccui" creationdate="20190619T045202Z">
        <seg>| 81</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042813Z" creationid="xccui" creationdate="20190612T042813Z">
        <seg>}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} )</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T042307Z" creationid="xccui" creationdate="20190612T042307Z">
        <seg>} )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else if (r.temperature &gt; prevTemp &amp;&amp; curTimerTimestamp == 0) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190621T071627Z" creationid="xccui" creationdate="20190621T071627Z">
        <seg>} else if (r.temperature &gt; prevTemp &amp;&amp; curTimerTimestamp == 0) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190620T054844Z" creationid="xccui" creationdate="20190620T054844Z">
        <seg>} else {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>} else { out.collect(r)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xingcan" changedate="20190628T155940Z" creationid="xingcan" creationdate="20190628T155940Z">
        <seg>} else { out.collect(r)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>})</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190618T054242Z" creationid="xccui" creationdate="20190618T054242Z">
        <seg>})</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>},</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190625T043616Z" creationid="xccui" creationdate="20190625T043616Z">
        <seg>},</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Scaling Stateful Operators” on page 56 discusses key groups and how keyed state is scaled out and in.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190703T024744Z" creationid="xccui" creationdate="20190703T024744Z">
        <seg>第56页"状态化算子扩容"一节已经对键值组和键值状态的伸缩规则进行了介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>│</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040608Z" creationid="xccui" creationdate="20190611T040608Z">
        <seg>│</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040619Z" creationid="xccui" creationdate="20190611T040619Z">
        <seg>└── ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── AverageSensorReadings.scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040611Z" creationid="xccui" creationdate="20190611T040611Z">
        <seg>└── AverageSensorReadings.scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── StreamingJob.scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005810Z" creationid="xccui" creationdate="20190612T005810Z">
        <seg>└── StreamingJob.scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── apache</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005751Z" creationid="xccui" creationdate="20190612T005751Z">
        <seg>└── apache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── flink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005756Z" creationid="xccui" creationdate="20190612T005756Z">
        <seg>└── flink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── github</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040556Z" creationid="xccui" creationdate="20190611T040556Z">
        <seg>└── github</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── io</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040552Z" creationid="xccui" creationdate="20190611T040552Z">
        <seg>└── io</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── log4j.properties</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005730Z" creationid="xccui" creationdate="20190612T005730Z">
        <seg>└── log4j.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── main</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040540Z" creationid="xccui" creationdate="20190611T040540Z">
        <seg>└── main</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── org</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005748Z" creationid="xccui" creationdate="20190612T005748Z">
        <seg>└── org</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── quickstart</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005800Z" creationid="xccui" creationdate="20190612T005800Z">
        <seg>└── quickstart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040543Z" creationid="xccui" creationdate="20190611T040543Z">
        <seg>└── scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── streamingwithflink</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040559Z" creationid="xccui" creationdate="20190611T040559Z">
        <seg>└── streamingwithflink</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>└── util</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040628Z" creationid="xccui" creationdate="20190611T040628Z">
        <seg>└── util</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040621Z" creationid="xccui" creationdate="20190611T040621Z">
        <seg>├── ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── BatchJob.scala</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005806Z" creationid="xccui" creationdate="20190612T005806Z">
        <seg>├── BatchJob.scala</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── chapter1</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040604Z" creationid="xccui" creationdate="20190611T040604Z">
        <seg>├── chapter1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── chapter5</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190611T040614Z" creationid="xccui" creationdate="20190611T040614Z">
        <seg>├── chapter5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>├── resources</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="xccui" changedate="20190612T005721Z" creationid="xccui" creationdate="20190612T005721Z">
        <seg>├── resources</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
